/*!
 * bns-plus@0.15.2 - DNS bike-shed
 * Copyright (c) 2022, Christopher Jeffrey (MIT)
 * https://github.com/chjj/bns
 *
 * License for bns-plus@0.15.2:
 *
 * This software is licensed under the MIT License.
 *
 * Copyright (c) 2018, Christopher Jeffrey (https://github.com/chjj)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Parts of this software are based on miekg/dns and golang/go:
 * https://github.com/miekg/dns https://github.com/golang/go
 *
 * Extensions of the original work are copyright (c) 2011 Miek Gieben
 *
 * As this is fork of the official Go code the same license applies:
 *
 * Copyright (c) 2009 The Go Authors. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer. * Redistributions in binary
 * form must reproduce the above copyright notice, this list of conditions and
 * the following disclaimer in the documentation and/or other materials provided
 * with the distribution. * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Parts of this software are based on solvere:
 * https://github.com/rolandshoemaker/solvere
 *
 * MIT License
 *
 * Copyright (c) 2016 Roland Bracewell Shoemaker
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * License for bsert@0.0.10:
 *
 * This software is licensed under the MIT License.
 *
 * Copyright (c) 2018, Christopher Jeffrey (https://github.com/chjj)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * License for binet@0.3.7:
 *
 * This software is licensed under the MIT License.
 *
 * Copyright (c) 2017, Christopher Jeffrey (https://github.com/chjj)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * License for bs32@0.1.6:
 *
 * This software is licensed under the MIT License.
 *
 * Copyright (c) 2017, Christopher Jeffrey (https://github.com/chjj)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * License for bufio@1.0.7:
 *
 * This software is licensed under the MIT License.
 *
 * Copyright (c) 2017, Christopher Jeffrey (https://github.com/chjj)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * License for bcrypto@5.4.0:
 *
 * This software is licensed under the MIT License.
 *
 * Copyright (c) 2017-2019, Christopher Jeffrey (https://github.com/chjj)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * ---
 *
 * Parts of this software are based on indutny/elliptic:
 *
 * https://github.com/indutny/elliptic
 *
 * This software is licensed under the MIT License.
 *
 * Copyright Fedor Indutny, 2014.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * ---
 *
 * Parts of this software are based on indutny/hash.js:
 *
 * https://github.com/indutny/hash.js
 *
 * This software is licensed under the MIT License.
 *
 * Copyright Fedor Indutny, 2014.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * ---
 *
 * Parts of this software are based on indutny/bn.js:
 *
 * https://github.com/indutny/bn.js
 *
 * This software is licensed under the MIT License.
 *
 * Copyright Fedor Indutny, 2015.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * ---
 *
 * Parts of this software are based on indutny/hmac-drbg:
 *
 * https://github.com/indutny/hmac-drbg
 *
 * This software is licensed under the MIT License.
 *
 * Copyright Fedor Indutny, 2017.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * ---
 *
 * Parts of this software are based on indutny/minimalistic-crypto-utils:
 *
 * https://github.com/indutny/minimalistic-crypto-utils
 *
 * This software is licensed under the MIT License.
 *
 * Copyright Fedor Indutny, 2017.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * ---
 *
 * Parts of this software are based on isaacs/inherits:
 *
 * https://github.com/isaacs/inherits
 *
 * The ISC License
 *
 * Copyright (c) Isaac Z. Schlueter
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 * ---
 *
 * Parts of this software are based on cryptocoinjs/secp256k1-node:
 *
 * https://github.com/cryptocoinjs/secp256k1-node
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014-2016 secp256k1-node contributors
 *
 * Parts of this software are based on bn.js, elliptic, hash.js Copyright (c)
 * 2014-2016 Fedor Indutny
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * ---
 *
 * Parts of this software are based on bitcoin-core/secp256k1:
 *
 * https://github.com/bitcoin-core/secp256k1
 *
 * Copyright (c) 2013 Pieter Wuille
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * ---
 *
 * Parts of this software are based on BLAKE2/BLAKE2:
 *
 * https://github.com/BLAKE2/BLAKE2
 *
 * Creative Commons Legal Code
 *
 * CC0 1.0 Universal
 *
 * CREATIVE COMMONS CORPORATION IS NOT A LAW FIRM AND DOES NOT PROVIDE LEGAL
 * SERVICES. DISTRIBUTION OF THIS DOCUMENT DOES NOT CREATE AN ATTORNEY-CLIENT
 * RELATIONSHIP. CREATIVE COMMONS PROVIDES THIS INFORMATION ON AN "AS-IS" BASIS.
 * CREATIVE COMMONS MAKES NO WARRANTIES REGARDING THE USE OF THIS DOCUMENT OR
 * THE INFORMATION OR WORKS PROVIDED HEREUNDER, AND DISCLAIMS LIABILITY FOR
 * DAMAGES RESULTING FROM THE USE OF THIS DOCUMENT OR THE INFORMATION OR WORKS
 * PROVIDED HEREUNDER.
 *
 * Statement of Purpose
 *
 * The laws of most jurisdictions throughout the world automatically confer
 * exclusive Copyright and Related Rights (defined below) upon the creator and
 * subsequent owner(s) (each and all, an "owner") of an original work of
 * authorship and/or a database (each, a "Work").
 *
 * Certain owners wish to permanently relinquish those rights to a Work for the
 * purpose of contributing to a commons of creative, cultural and scientific
 * works ("Commons") that the public can reliably and without fear of later
 * claims of infringement build upon, modify, incorporate in other works, reuse
 * and redistribute as freely as possible in any form whatsoever and for any
 * purposes, including without limitation commercial purposes. These owners may
 * contribute to the Commons to promote the ideal of a free culture and the
 * further production of creative, cultural and scientific works, or to gain
 * reputation or greater distribution for their Work in part through the use and
 * efforts of others.
 *
 * For these and/or other purposes and motivations, and without any expectation
 * of additional consideration or compensation, the person associating CC0 with
 * a Work (the "Affirmer"), to the extent that he or she is an owner of
 * Copyright and Related Rights in the Work, voluntarily elects to apply CC0 to
 * the Work and publicly distribute the Work under its terms, with knowledge of
 * his or her Copyright and Related Rights in the Work and the meaning and
 * intended legal effect of CC0 on those rights.
 *
 * 1. Copyright and Related Rights. A Work made available under CC0 may be
 * protected by copyright and related or neighboring rights ("Copyright and
 * Related Rights"). Copyright and Related Rights include, but are not limited
 * to, the following:
 *
 * i. the right to reproduce, adapt, distribute, perform, display, communicate,
 * and translate a Work; ii. moral rights retained by the original author(s)
 * and/or performer(s); iii. publicity and privacy rights pertaining to a
 * person's image or likeness depicted in a Work; iv. rights protecting against
 * unfair competition in regards to a Work, subject to the limitations in
 * paragraph 4(a), below; v. rights protecting the extraction, dissemination,
 * use and reuse of data in a Work; vi. database rights (such as those arising
 * under Directive 96/9/EC of the European Parliament and of the Council of 11
 * March 1996 on the legal protection of databases, and under any national
 * implementation thereof, including any amended or successor version of such
 * directive); and vii. other similar, equivalent or corresponding rights
 * throughout the world based on applicable law or treaty, and any national
 * implementations thereof.
 *
 * 2. Waiver. To the greatest extent permitted by, but not in contravention of,
 * applicable law, Affirmer hereby overtly, fully, permanently, irrevocably and
 * unconditionally waives, abandons, and surrenders all of Affirmer's Copyright
 * and Related Rights and associated claims and causes of action, whether now
 * known or unknown (including existing as well as future claims and causes of
 * action), in the Work (i) in all territories worldwide, (ii) for the maximum
 * duration provided by applicable law or treaty (including future time
 * extensions), (iii) in any current or future medium and for any number of
 * copies, and (iv) for any purpose whatsoever, including without limitation
 * commercial, advertising or promotional purposes (the "Waiver"). Affirmer
 * makes the Waiver for the benefit of each member of the public at large and to
 * the detriment of Affirmer's heirs and successors, fully intending that such
 * Waiver shall not be subject to revocation, rescission, cancellation,
 * termination, or any other legal or equitable action to disrupt the quiet
 * enjoyment of the Work by the public as contemplated by Affirmer's express
 * Statement of Purpose.
 *
 * 3. Public License Fallback. Should any part of the Waiver for any reason be
 * judged legally invalid or ineffective under applicable law, then the Waiver
 * shall be preserved to the maximum extent permitted taking into account
 * Affirmer's express Statement of Purpose. In addition, to the extent the
 * Waiver is so judged Affirmer hereby grants to each affected person a
 * royalty-free, non transferable, non sublicensable, non exclusive, irrevocable
 * and unconditional license to exercise Affirmer's Copyright and Related Rights
 * in the Work (i) in all territories worldwide, (ii) for the maximum duration
 * provided by applicable law or treaty (including future time extensions),
 * (iii) in any current or future medium and for any number of copies, and (iv)
 * for any purpose whatsoever, including without limitation commercial,
 * advertising or promotional purposes (the "License"). The License shall be
 * deemed effective as of the date CC0 was applied by Affirmer to the Work.
 * Should any part of the License for any reason be judged legally invalid or
 * ineffective under applicable law, such partial invalidity or ineffectiveness
 * shall not invalidate the remainder of the License, and in such case Affirmer
 * hereby affirms that he or she will not (i) exercise any of his or her
 * remaining Copyright and Related Rights in the Work or (ii) assert any
 * associated claims and causes of action with respect to the Work, in either
 * case contrary to Affirmer's express Statement of Purpose.
 *
 * 4. Limitations and Disclaimers.
 *
 * a. No trademark or patent rights held by Affirmer are waived, abandoned,
 * surrendered, licensed or otherwise affected by this document. b. Affirmer
 * offers the Work as-is and makes no representations or warranties of any kind
 * concerning the Work, express, implied, statutory or otherwise, including
 * without limitation warranties of title, merchantability, fitness for a
 * particular purpose, non infringement, or the absence of latent or other
 * defects, accuracy, or the present or absence of errors, whether or not
 * discoverable, all to the greatest extent permissible under applicable law. c.
 * Affirmer disclaims responsibility for clearing rights of other persons that
 * may apply to the Work or any use thereof, including without limitation any
 * person's Copyright and Related Rights in the Work. Further, Affirmer
 * disclaims responsibility for obtaining any necessary consents, permissions or
 * other rights required for any use of the Work. d. Affirmer understands and
 * acknowledges that Creative Commons is not a party to this document and has no
 * duty or obligation with respect to this CC0 or use of the Work.
 *
 * ---
 *
 * Parts of this software are based on chacha20-simple:
 *
 * http://chacha20.insanecoding.org/
 *
 * Copyright (C) 2014 insane coder
 *
 * Permission to use, copy, modify, and distribute this software for any purpose
 * with or without fee is hereby granted, provided that the above copyright
 * notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 * ---
 *
 * Parts of this software are based on floodyberry/ed25519-donna:
 *
 * https://github.com/floodyberry/ed25519-donna
 *
 * Public domain by Andrew M. <liquidsun@gmail.com>
 *
 * Ed25519 reference implementation using Ed25519-donna
 *
 * ---
 *
 * Parts of this software are based on openssl/openssl:
 *
 * https://github.com/openssl/openssl
 *
 * OpenSSL License
 *
 * Copyright (c) 1998-2018 The OpenSSL Project. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. All advertising materials mentioning features or use of this software must
 * display the following acknowledgment: "This product includes software
 * developed by the OpenSSL Project for use in the OpenSSL Toolkit.
 * (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 * endorse or promote products derived from this software without prior written
 * permission. For written permission, please contact openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL" nor may
 * "OpenSSL" appear in their names without prior written permission of the
 * OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 * acknowledgment: "This product includes software developed by the OpenSSL
 * Project for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY EXPRESSED
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 * EVENT SHALL THE OpenSSL PROJECT OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com). This product includes software written by Tim Hudson
 * (tjh@cryptsoft.com).
 *
 * Original SSLeay License
 *
 * Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com) All rights reserved.
 *
 * This package is an SSL implementation written by Eric Young
 * (eay@cryptsoft.com). The implementation was written so as to conform with
 * Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as the
 * following conditions are aheared to. The following conditions apply to all
 * code found in this distribution, be it the RC4, RSA, lhash, DES, etc., code;
 * not just the SSL code. The SSL documentation included with this distribution
 * is covered by the same copyright terms except that the holder is Tim Hudson
 * (tjh@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in the code
 * are not to be removed. If this package is used in a product, Eric Young
 * should be given attribution as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or in
 * documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the copyright notice, this list
 * of conditions and the following disclaimer. 2. Redistributions in binary form
 * must reproduce the above copyright notice, this list of conditions and the
 * following disclaimer in the documentation and/or other materials provided
 * with the distribution. 3. All advertising materials mentioning features or
 * use of this software must display the following acknowledgement: "This
 * product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com)" The word 'cryptographic' can be left out if the rouines
 * from the library being used are not cryptographic related :-). 4. If you
 * include any Windows specific code (or a derivative thereof) from the apps
 * directory (application code) you must include an acknowledgement: "This
 * product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 * EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed. i.e. this code cannot simply be
 * copied and put under another distribution licence [including the GNU Public
 * Licence.]
 *
 * ---
 *
 * Parts of this software are based on bitcoin/bitcoin:
 *
 * https://github.com/bitcoin/bitcoin
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2009-2018 The Bitcoin Core developers Copyright (c) 2009-2018
 * Bitcoin Developers
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * ---
 *
 * Parts of this software are based on rhash/RHash:
 *
 * https://github.com/rhash/RHash
 *
 * Copyright (c) 2005-2014 Aleksey Kravchenko <rhash.admin@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so.
 *
 * The Software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. Use this program at your own risk!
 *
 * ---
 *
 * Parts of this software are based on emn178/js-sha3:
 *
 * https://github.com/emn178/js-sha3
 *
 * Copyright 2015-2018 Chen, Yi-Cyuan
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * ---
 *
 * Parts of this software are based on floodyberry/poly1305-donna:
 *
 * https://github.com/floodyberry/poly1305-donna
 *
 * Public domain by Andrew M. <liquidsun@gmail.com>
 *
 * Alternatively MIT (http://www.opensource.org/licenses/mit-license.php)
 *
 * ---
 *
 * Parts of this software are based on Tarsnap/scrypt:
 *
 * https://github.com/Tarsnap/scrypt
 *
 * The included code and documentation ("scrypt") is distributed under the
 * following terms:
 *
 * Copyright 2005-2016 Colin Percival. All rights reserved. Copyright 2005-2016
 * Tarsnap Backup Inc. All rights reserved. Copyright 2014 Sean Kelly. All
 * rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer. 2. Redistributions in
 * binary form must reproduce the above copyright notice, this list of
 * conditions and the following disclaimer in the documentation and/or other
 * materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ---
 *
 * Parts of this software are based on ed448-goldilocks:
 *
 * http://ed448goldilocks.sourceforge.net/
 *
 * The Python bindings are Copyright 2017 John-Mark Gurney, and are provided
 * under a BSD license as described in python/edgold/ed448.py
 *
 * Certain sections of code are public domain or CC0, as marked.
 *
 * Earlier versions of this project used small amounts of code which were
 *
 * Copyright (c) 2011 Stanford University Copyright (c) 2011 Mike Hamburg
 *
 * but I believe that all of this code has now been replaced.
 *
 * The bulk of this library is Copyright (c) 2014-2017 Cryptography Research,
 * Inc. and licensed under the following MIT license.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014-2017 Cryptography Research, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * ---
 *
 * Parts of this software are based on golang/go and golang/crypto:
 *
 * https://github.com/golang/go
 *
 * https://github.com/golang/crypto
 *
 * Copyright (c) 2009 The Go Authors. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer. * Redistributions in binary
 * form must reproduce the above copyright notice, this list of conditions and
 * the following disclaimer in the documentation and/or other materials provided
 * with the distribution. * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * ---
 *
 * Parts of this software are based on ElementsProject/secp256k1-zkp:
 *
 * https://github.com/ElementsProject/secp256k1-zkp
 *
 * Copyright (c) 2013 Pieter Wuille
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * ---
 *
 * Parts of this software are based on sipa/bip-schnorr:
 *
 * https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr/reference.py
 *
 * Copyright (c) 2018-2019, Pieter Wuille (2-clause BSD License)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * ---
 *
 * Parts of this software are based on sipa/bech32:
 *
 * https://github.com/sipa/bech32
 *
 * Copyright (c) 2017 Pieter Wuille
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * ---
 *
 * Parts of this software are based on Bitcoin-ABC/bitcoin-abc:
 *
 * https://github.com/Bitcoin-ABC/bitcoin-abc
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2009-2019 The Bitcoin Developers Copyright (c) 2009-2017 The
 * Bitcoin Core developers
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * ---
 *
 * Parts of this software are based on v8/v8:
 *
 * https://github.com/v8/v8
 *
 * Copyright 2014, the V8 project authors. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * * Neither the name of Google Inc. nor the names of its contributors may be
 * used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * ---
 *
 * Parts of this software are based on RustCrypto/hashes:
 *
 * https://github.com/RustCrypto/hashes
 *
 * Copyright (c) 2016-2018, The RustCrypto Authors (MIT License).
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * ---
 *
 * Parts of this software are based on aead/camellia:
 *
 * https://github.com/aead/camellia
 *
 * Copyright (c) 2016, Andreas Auernhammer (MIT License).
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2016 Andreas Auernhammer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * ---
 *
 * Parts of this software are based on indutny/des.js:
 *
 * https://github.com/indutny/des.js
 *
 * This software is licensed under the MIT License.
 *
 * Copyright Fedor Indutny, 2015.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * ---
 *
 * Parts of this software are based on crypto-browserify/EVP_BytesToKey:
 *
 * https://github.com/crypto-browserify/EVP_BytesToKey
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2017 crypto-browserify contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * ---
 *
 * Parts of this software are based on joyent/node-bcrypt-pbkdf:
 *
 * https://github.com/joyent/node-bcrypt-pbkdf
 *
 * Credit for the actual porting work goes to: Devi Mandiri <me@devi.web.id>
 *
 * The Blowfish portions are under the following license:
 *
 * Blowfish block cipher for OpenBSD Copyright 1997 Niels Provos
 * <provos@physnet.uni-hamburg.de> All rights reserved.
 *
 * Implementation advice by David Mazieres <dm@lcs.mit.edu>.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. The name of the author may not be used to endorse or promote products
 * derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
 * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The bcrypt_pbkdf portions are under the following license:
 *
 * Copyright (c) 2013 Ted Unangst <tedu@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any purpose
 * with or without fee is hereby granted, provided that the above copyright
 * notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 * Performance improvements (Javascript-specific):
 *
 * Copyright 2016, Joyent Inc Author: Alex Wilson <alex.wilson@joyent.com>
 *
 * Permission to use, copy, modify, and distribute this software for any purpose
 * with or without fee is hereby granted, provided that the above copyright
 * notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 * ---
 *
 * Parts of this software are based on gnutls/nettle:
 *
 * https://github.com/gnutls/nettle
 *
 * Copyright (c) 1998-2019, Niels Mller and Contributors
 *
 * GNU GENERAL PUBLIC LICENSE Version 2, June 1991
 *
 * Copyright (C) 1989, 1991 Free Software Foundation, Inc., 51 Franklin Street,
 * Fifth Floor, Boston, MA 02110-1301 USA Everyone is permitted to copy and
 * distribute verbatim copies of this license document, but changing it is not
 * allowed.
 *
 * Preamble
 *
 * The licenses for most software are designed to take away your freedom to
 * share and change it.  By contrast, the GNU General Public License is intended
 * to guarantee your freedom to share and change free software--to make sure the
 * software is free for all its users.  This General Public License applies to
 * most of the Free Software Foundation's software and to any other program
 * whose authors commit to using it.  (Some other Free Software Foundation
 * software is covered by the GNU Lesser General Public License instead.)  You
 * can apply it to your programs, too.
 *
 * When we speak of free software, we are referring to freedom, not price.  Our
 * General Public Licenses are designed to make sure that you have the freedom
 * to distribute copies of free software (and charge for this service if you
 * wish), that you receive source code or can get it if you want it, that you
 * can change the software or use pieces of it in new free programs; and that
 * you know you can do these things.
 *
 * To protect your rights, we need to make restrictions that forbid anyone to
 * deny you these rights or to ask you to surrender the rights.  These
 * restrictions translate to certain responsibilities for you if you distribute
 * copies of the software, or if you modify it.
 *
 * For example, if you distribute copies of such a program, whether gratis or
 * for a fee, you must give the recipients all the rights that you have.  You
 * must make sure that they, too, receive or can get the source code.  And you
 * must show them these terms so they know their rights.
 *
 * We protect your rights with two steps: (1) copyright the software, and (2)
 * offer you this license which gives you legal permission to copy, distribute
 * and/or modify the software.
 *
 * Also, for each author's protection and ours, we want to make certain that
 * everyone understands that there is no warranty for this free software.  If
 * the software is modified by someone else and passed on, we want its
 * recipients to know that what they have is not the original, so that any
 * problems introduced by others will not reflect on the original authors'
 * reputations.
 *
 * Finally, any free program is threatened constantly by software patents.  We
 * wish to avoid the danger that redistributors of a free program will
 * individually obtain patent licenses, in effect making the program
 * proprietary. To prevent this, we have made it clear that any patent must be
 * licensed for everyone's free use or not licensed at all.
 *
 * The precise terms and conditions for copying, distribution and modification
 * follow.
 *
 * GNU GENERAL PUBLIC LICENSE TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND
 * MODIFICATION
 *
 * 0. This License applies to any program or other work which contains a notice
 * placed by the copyright holder saying it may be distributed under the terms
 * of this General Public License.  The "Program", below, refers to any such
 * program or work, and a "work based on the Program" means either the Program
 * or any derivative work under copyright law: that is to say, a work containing
 * the Program or a portion of it, either verbatim or with modifications and/or
 * translated into another language.  (Hereinafter, translation is included
 * without limitation in the term "modification".)  Each licensee is addressed
 * as "you".
 *
 * Activities other than copying, distribution and modification are not covered
 * by this License; they are outside its scope.  The act of running the Program
 * is not restricted, and the output from the Program is covered only if its
 * contents constitute a work based on the Program (independent of having been
 * made by running the Program).  Whether that is true depends on what the
 * Program does.
 *
 * 1. You may copy and distribute verbatim copies of the Program's source code
 * as you receive it, in any medium, provided that you conspicuously and
 * appropriately publish on each copy an appropriate copyright notice and
 * disclaimer of warranty; keep intact all the notices that refer to this
 * License and to the absence of any warranty; and give any other recipients of
 * the Program a copy of this License along with the Program.
 *
 * You may charge a fee for the physical act of transferring a copy, and you may
 * at your option offer warranty protection in exchange for a fee.
 *
 * 2. You may modify your copy or copies of the Program or any portion of it,
 * thus forming a work based on the Program, and copy and distribute such
 * modifications or work under the terms of Section 1 above, provided that you
 * also meet all of these conditions:
 *
 * a) You must cause the modified files to carry prominent notices stating that
 * you changed the files and the date of any change.
 *
 * b) You must cause any work that you distribute or publish, that in whole or
 * in part contains or is derived from the Program or any part thereof, to be
 * licensed as a whole at no charge to all third parties under the terms of this
 * License.
 *
 * c) If the modified program normally reads commands interactively when run,
 * you must cause it, when started running for such interactive use in the most
 * ordinary way, to print or display an announcement including an appropriate
 * copyright notice and a notice that there is no warranty (or else, saying that
 * you provide a warranty) and that users may redistribute the program under
 * these conditions, and telling the user how to view a copy of this License. 
 * (Exception: if the Program itself is interactive but does not normally print
 * such an announcement, your work based on the Program is not required to print
 * an announcement.)
 *
 * These requirements apply to the modified work as a whole.  If identifiable
 * sections of that work are not derived from the Program, and can be reasonably
 * considered independent and separate works in themselves, then this License,
 * and its terms, do not apply to those sections when you distribute them as
 * separate works.  But when you distribute the same sections as part of a whole
 * which is a work based on the Program, the distribution of the whole must be
 * on the terms of this License, whose permissions for other licensees extend to
 * the entire whole, and thus to each and every part regardless of who wrote it.
 *
 * Thus, it is not the intent of this section to claim rights or contest your
 * rights to work written entirely by you; rather, the intent is to exercise the
 * right to control the distribution of derivative or collective works based on
 * the Program.
 *
 * In addition, mere aggregation of another work not based on the Program with
 * the Program (or with a work based on the Program) on a volume of a storage or
 * distribution medium does not bring the other work under the scope of this
 * License.
 *
 * 3. You may copy and distribute the Program (or a work based on it, under
 * Section 2) in object code or executable form under the terms of Sections 1
 * and 2 above provided that you also do one of the following:
 *
 * a) Accompany it with the complete corresponding machine-readable source code,
 * which must be distributed under the terms of Sections 1 and 2 above on a
 * medium customarily used for software interchange; or,
 *
 * b) Accompany it with a written offer, valid for at least three years, to give
 * any third party, for a charge no more than your cost of physically performing
 * source distribution, a complete machine-readable copy of the corresponding
 * source code, to be distributed under the terms of Sections 1 and 2 above on a
 * medium customarily used for software interchange; or,
 *
 * c) Accompany it with the information you received as to the offer to
 * distribute corresponding source code.  (This alternative is allowed only for
 * noncommercial distribution and only if you received the program in object
 * code or executable form with such an offer, in accord with Subsection b
 * above.)
 *
 * The source code for a work means the preferred form of the work for making
 * modifications to it.  For an executable work, complete source code means all
 * the source code for all modules it contains, plus any associated interface
 * definition files, plus the scripts used to control compilation and
 * installation of the executable.  However, as a special exception, the source
 * code distributed need not include anything that is normally distributed (in
 * either source or binary form) with the major components (compiler, kernel,
 * and so on) of the operating system on which the executable runs, unless that
 * component itself accompanies the executable.
 *
 * If distribution of executable or object code is made by offering access to
 * copy from a designated place, then offering equivalent access to copy the
 * source code from the same place counts as distribution of the source code,
 * even though third parties are not compelled to copy the source along with the
 * object code.
 *
 * 4. You may not copy, modify, sublicense, or distribute the Program except as
 * expressly provided under this License.  Any attempt otherwise to copy,
 * modify, sublicense or distribute the Program is void, and will automatically
 * terminate your rights under this License.  However, parties who have received
 * copies, or rights, from you under this License will not have their licenses
 * terminated so long as such parties remain in full compliance.
 *
 * 5. You are not required to accept this License, since you have not signed it.
 * However, nothing else grants you permission to modify or distribute the
 * Program or its derivative works.  These actions are prohibited by law if you
 * do not accept this License.  Therefore, by modifying or distributing the
 * Program (or any work based on the Program), you indicate your acceptance of
 * this License to do so, and all its terms and conditions for copying,
 * distributing or modifying the Program or works based on it.
 *
 * 6. Each time you redistribute the Program (or any work based on the Program),
 * the recipient automatically receives a license from the original licensor to
 * copy, distribute or modify the Program subject to these terms and conditions.
 * You may not impose any further restrictions on the recipients' exercise of
 * the rights granted herein.  You are not responsible for enforcing compliance
 * by third parties to this License.
 *
 * 7. If, as a consequence of a court judgment or allegation of patent
 * infringement or for any other reason (not limited to patent issues),
 * conditions are imposed on you (whether by court order, agreement or
 * otherwise) that contradict the conditions of this License, they do not excuse
 * you from the conditions of this License.  If you cannot distribute so as to
 * satisfy simultaneously your obligations under this License and any other
 * pertinent obligations, then as a consequence you may not distribute the
 * Program at all. For example, if a patent license would not permit
 * royalty-free redistribution of the Program by all those who receive copies
 * directly or indirectly through you, then the only way you could satisfy both
 * it and this License would be to refrain entirely from distribution of the
 * Program.
 *
 * If any portion of this section is held invalid or unenforceable under any
 * particular circumstance, the balance of the section is intended to apply and
 * the section as a whole is intended to apply in other circumstances.
 *
 * It is not the purpose of this section to induce you to infringe any patents
 * or other property right claims or to contest validity of any such claims;
 * this section has the sole purpose of protecting the integrity of the free
 * software distribution system, which is implemented by public license
 * practices.  Many people have made generous contributions to the wide range of
 * software distributed through that system in reliance on consistent
 * application of that system; it is up to the author/donor to decide if he or
 * she is willing to distribute software through any other system and a licensee
 * cannot impose that choice.
 *
 * This section is intended to make thoroughly clear what is believed to be a
 * consequence of the rest of this License.
 *
 * 8. If the distribution and/or use of the Program is restricted in certain
 * countries either by patents or by copyrighted interfaces, the original
 * copyright holder who places the Program under this License may add an
 * explicit geographical distribution limitation excluding those countries, so
 * that distribution is permitted only in or among countries not thus excluded. 
 * In such case, this License incorporates the limitation as if written in the
 * body of this License.
 *
 * 9. The Free Software Foundation may publish revised and/or new versions of
 * the General Public License from time to time.  Such new versions will be
 * similar in spirit to the present version, but may differ in detail to address
 * new problems or concerns.
 *
 * Each version is given a distinguishing version number.  If the Program
 * specifies a version number of this License which applies to it and "any later
 * version", you have the option of following the terms and conditions either of
 * that version or of any later version published by the Free Software
 * Foundation. If the Program does not specify a version number of this License,
 * you may choose any version ever published by the Free Software Foundation.
 *
 * 10. If you wish to incorporate parts of the Program into other free programs
 * whose distribution conditions are different, write to the author to ask for
 * permission.  For software which is copyrighted by the Free Software
 * Foundation, write to the Free Software Foundation; we sometimes make
 * exceptions for this. Our decision will be guided by the two goals of
 * preserving the free status of all derivatives of our free software and of
 * promoting the sharing and reuse of software generally.
 *
 * NO WARRANTY
 *
 * 11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR
 * THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
 * OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
 * PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR
 * IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO
 * THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM
 * PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
 * CORRECTION.
 *
 * 12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
 * WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
 * REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
 * INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
 * OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO
 * LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR
 * THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
 * PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
 *
 * END OF TERMS AND CONDITIONS
 *
 * How to Apply These Terms to Your New Programs
 *
 * If you develop a new program, and you want it to be of the greatest possible
 * use to the public, the best way to achieve this is to make it free software
 * which everyone can redistribute and change under these terms.
 *
 * To do so, attach the following notices to the program.  It is safest to
 * attach them to the start of each source file to most effectively convey the
 * exclusion of warranty; and each file should have at least the "copyright"
 * line and a pointer to where the full notice is found.
 *
 * <one line to give the program's name and a brief idea of what it does.>
 * Copyright (C) <year>  <name of author>
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Also add information on how to contact you by electronic and paper mail.
 *
 * If the program is interactive, make it output a short notice like this when
 * it starts in an interactive mode:
 *
 * Gnomovision version 69, Copyright (C) year name of author Gnomovision comes
 * with ABSOLUTELY NO WARRANTY; for details type `show w'. This is free
 * software, and you are welcome to redistribute it under certain conditions;
 * type `show c' for details.
 *
 * The hypothetical commands `show w' and `show c' should show the appropriate
 * parts of the General Public License.  Of course, the commands you use may be
 * called something other than `show w' and `show c'; they could even be
 * mouse-clicks or menu items--whatever suits your program.
 *
 * You should also get your employer (if you work as a programmer) or your
 * school, if any, to sign a "copyright disclaimer" for the program, if
 * necessary.  Here is a sample; alter the names:
 *
 * Yoyodyne, Inc., hereby disclaims all copyright interest in the program
 * `Gnomovision' (which makes passes at compilers) written by James Hacker.
 *
 * <signature of Ty Coon>, 1 April 1989 Ty Coon, President of Vice
 *
 * This General Public License does not permit incorporating your program into
 * proprietary programs.  If your program is a subroutine library, you may
 * consider it more useful to permit linking proprietary applications with the
 * library.  If this is what you want to do, use the GNU Lesser General Public
 * License instead of this License.
 *
 * ---
 *
 * Parts of this software are based on jedisct1/libsodium:
 *
 * https://github.com/jedisct1/libsodium
 *
 * ISC License
 *
 * Copyright (c) 2013-2019 Frank Denis <j at pureftpd dot org>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 * License for bfile@0.2.2:
 *
 * This software is licensed under the MIT License.
 *
 * Copyright (c) 2014-2019, Christopher Jeffrey (https://github.com/chjj)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * License for btcp@0.1.5:
 *
 * This software is licensed under the MIT License.
 *
 * Copyright (c) 2017, Christopher Jeffrey (https://github.com/chjj)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * License for budp@0.1.6:
 *
 * This software is licensed under the MIT License.
 *
 * Copyright (c) 2017, Christopher Jeffrey (https://github.com/chjj)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * License for bheep@0.1.5:
 *
 * This software is licensed under the MIT License.
 *
 * Copyright (c) 2017, Christopher Jeffrey (https://github.com/chjj)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var __browser_require__ = (function(global) {
var globalThis = global;
var undefined;

var setTimeout = global.setTimeout;
var clearTimeout = global.clearTimeout;
var setInterval = global.setInterval;
var clearInterval = global.clearInterval;
var setImmediate = global.setImmediate;
var clearImmediate = global.clearImmediate;

var process;

var Buffer;

var console = global.console;

var __browser_modules__ = [
[/* 0 */ 'bns-plus', '/lib/bns.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * bns.js - dns module
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 */



exports.API = __browser_require__(1 /* './api' */, module);
exports.Authority = __browser_require__(96 /* './authority' */, module);
exports.AuthServer = __browser_require__(97 /* './server/auth' */, module);
exports.Cache = __browser_require__(109 /* './cache' */, module);
exports.constants = __browser_require__(11 /* './constants' */, module);
exports.dane = __browser_require__(12 /* './dane' */, module);
exports.dns = __browser_require__(112 /* './dns' */, module);
exports.DNSResolver = __browser_require__(115 /* './resolver/dns' */, module);
exports.DNSServer = __browser_require__(98 /* './server/dns' */, module);
exports.dnssec = __browser_require__(99 /* './dnssec' */, module);
exports.encoding = __browser_require__(80 /* './encoding' */, module);
exports.DNSError = __browser_require__(101 /* './error' */, module);
exports.Hints = __browser_require__(116 /* './hints' */, module);
exports.Hosts = __browser_require__(113 /* './hosts' */, module);
exports.hsig = __browser_require__(117 /* './hsig' */, module);
exports.nsec3 = __browser_require__(124 /* './nsec3' */, module);
exports.openpgpkey = __browser_require__(89 /* './openpgpkey' */, module);
exports.Ownership = __browser_require__(125 /* './ownership' */, module);
exports.punycode = __browser_require__(126 /* './punycode' */, module);
exports.rdns = __browser_require__(127 /* './rdns' */, module);
exports.RecursiveResolver = __browser_require__(128 /* './resolver/recursive' */, module);
exports.RecursiveServer = __browser_require__(129 /* './server/recursive' */, module);
exports.ResolvConf = __browser_require__(91 /* './resolvconf' */, module);
exports.ROOT_HINTS = __browser_require__(108 /* './roothints' */, module);
exports.RootResolver = __browser_require__(130 /* './resolver/root' */, module);
exports.sig0 = __browser_require__(123 /* './sig0' */, module);
exports.smimea = __browser_require__(92 /* './smimea' */, module);
exports.srv = __browser_require__(131 /* './srv' */, module);
exports.sshfp = __browser_require__(93 /* './sshfp' */, module);
exports.StubResolver = __browser_require__(114 /* './resolver/stub' */, module);
exports.StubServer = __browser_require__(132 /* './server/stub' */, module);
exports.tlsa = __browser_require__(94 /* './tlsa' */, module);
exports.tsig = __browser_require__(133 /* './tsig' */, module);
exports.udns = __browser_require__(134 /* './udns' */, module);
exports.UnboundResolver = __browser_require__(135 /* './resolver/unbound' */, module);
exports.UnboundServer = __browser_require__(136 /* './server/unbound' */, module);
exports.util = __browser_require__(79 /* './util' */, module);
exports.wire = __browser_require__(90 /* './wire' */, module);
exports.Zone = __browser_require__(107 /* './zone' */, module);

exports.version = '0.15.0';
exports.unbound = exports.UnboundResolver.version;
exports.native = exports.UnboundResolver.native;
}],
[/* 1 */ 'bns-plus', '/lib/api.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * api.js - node.js api for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const EventEmitter = __browser_require__(3 /* 'events' */, module);
const IP = __browser_require__(4 /* 'binet' */, module);
const constants = __browser_require__(11 /* './constants' */, module);
const dane = __browser_require__(12 /* './dane' */, module);
const encoding = __browser_require__(80 /* './encoding' */, module);
const lazy = __browser_require__(81 /* './internal/lazy' */, module);
const openpgpkey = __browser_require__(89 /* './openpgpkey' */, module);
const ResolvConf = __browser_require__(91 /* './resolvconf' */, module);
const smimea = __browser_require__(92 /* './smimea' */, module);
const sshfp = __browser_require__(93 /* './sshfp' */, module);
const tlsa = __browser_require__(94 /* './tlsa' */, module);
const util = __browser_require__(79 /* './util' */, module);
const wire = __browser_require__(90 /* './wire' */, module);
const nodejsdns = __browser_require__(95 /* 'dns' */, module);
const {DNS_PORT} = constants;
const {types, codes} = wire;

/*
 * Constants
 */

const hasIPv4 = IP.getInterfaces('ipv4').length > 0;
const hasIPv6 = IP.getInterfaces('ipv6').length > 0;

let conf = null;

/**
 * API
 */

class API extends EventEmitter {
  constructor(create, options) {
    super();

    assert(typeof create === 'function');

    if (options == null)
      options = {};

    // Private
    this._create = create;
    this._options = options;
    this._resolvers = new Set();
    this._servers = null;
    this._onError = err => this.emit('error', err);
    this._onLog = (...args) => this.emit('log', ...args);
    this._allowInsecure = false;

    // Public
    this.Resolver = function Resolver(options) {
      return new API(create, options);
    };

    this.V4MAPPED = nodejsdns.V4MAPPED;
    this.ADDRCONFIG = nodejsdns.ADDRCONFIG;

    this.NODATA = 'ENODATA';
    this.FORMERR = 'EFORMERR';
    this.SERVFAIL = 'ESERVFAIL';
    this.NOTFOUND = 'ENOTFOUND';
    this.NOTIMP = 'ENOTIMP';
    this.REFUSED = 'EREFUSED';
    this.BADQUERY = 'EBADQUERY';
    this.BADNAME = 'EBADNAME';
    this.BADFAMILY = 'EBADFAMILY';
    this.BADRESP = 'EBADRESP';
    this.CONNREFUSED = 'ECONNREFUSED';
    this.TIMEOUT = 'ETIMEOUT';
    this.EOF = 'EOF';
    this.FILE = 'EFILE';
    this.NOMEM = 'ENOMEM';
    this.DESTRUCTION = 'EDESTRUCTION';
    this.BADSTR = 'EBADSTR';
    this.BADFLAGS = 'EBADFLAGS';
    this.NONAME = 'ENONAME';
    this.BADHINTS = 'EBADHINTS';
    this.NOTINITIALIZED = 'ENOTINITIALIZED';
    this.LOADIPHLPAPI = 'ELOADIPHLPAPI';
    this.ADDRGETNETWORKPARAMS = 'EADDRGETNETWORKPARAMS';
    this.CANCELLED = 'ECANCELLED';

    // Custom
    this.INSECURE = 'EINSECURE';
    this.BADSIGNATURE = 'EBADSIGNATURE';
    this.NORESFLAG = 'ENORESFLAG';
    this.BADQUESTION = 'EBADQUESTION';
    this.BADTRUNCATION = 'EBADTRUNCATION';
    this.BADOPCODE = 'EBADOPCODE';
    this.NOAUTHORITY = 'ENOAUTHORITY';
    this.ALIASLOOP = 'EALIASLOOP';
    this.MAXREFERRALS = 'EMAXREFERRALS';

    this.version = undefined;
    this.native = undefined;

    // Swallow errors
    this.on('error', () => {});
  }

  async _ask(resolver, name, type) {
    await resolver.open();

    this._resolvers.add(resolver);

    let res;
    try {
      res = await resolver.lookup(name, type);
    } catch (e) {
      this._resolvers.delete(resolver);

      await resolver.close();

      switch (e.message) {
        case 'Request timed out.':
          throw makeQueryError(name, type, this.TIMEOUT);
        case 'Request cancelled.':
          throw makeQueryError(name, type, this.CANCELLED);
        case 'Format error.':
          throw makeQueryError(name, type, this.FORMERR);
        case 'Encoding error.':
          throw makeQueryError(name, type, this.BADRESP);
        case 'Invalid qname.':
          throw makeQueryError(name, type, this.BADNAME);
        case 'No servers available.':
        case 'Bad address passed to query.':
          throw makeQueryError(name, type, this.BADQUERY);
        // Custom:
        case 'Could not verify response.':
          throw makeQueryError(name, type, this.BADSIGNATURE);
        case 'Not a response.':
          throw makeQueryError(name, type, this.NORESFLAG);
        case 'Invalid question.':
          throw makeQueryError(name, type, this.BADQUESTION);
        case 'Truncated TCP msg.':
          throw makeQueryError(name, type, this.BADTRUNCATION);
        case 'Unexpected opcode.':
          throw makeQueryError(name, type, this.BADOPCODE);
        case 'Authority lookup failed.':
        case 'No authority address.':
          throw makeQueryError(name, type, this.NOAUTHORITY);
        case 'Alias loop.':
          throw makeQueryError(name, type, this.ALIASLOOP);
        case 'Maximum referrals exceeded.':
          throw makeQueryError(name, type, this.MAXREFERRALS);
      }

      throw e;
    }

    this._resolvers.delete(resolver);

    await resolver.close();

    return res;
  }

  async _query(name, type) {
    assert(typeof name === 'string');
    assert((type & 0xffff) === type);

    const resolver = await this._create(this._options, this._servers);

    resolver.on('error', this._onError);
    resolver.on('log', this._onLog);

    try {
      return await this._ask(resolver, name, type);
    } finally {
      resolver.removeListener('error', this._onError);
      resolver.removeListener('log', this._onLog);
    }
  }

  async _lookup(name, type, secure, map) {
    assert(typeof secure === 'boolean');
    assert(typeof map === 'function');

    const res = await this._query(name, type);

    if (res.code !== codes.NOERROR) {
      switch (res.code) {
        case codes.FORMERR:
          throw makeQueryError(name, type, this.FORMERR);
        case codes.SERVFAIL:
          throw makeQueryError(name, type, this.SERVFAIL);
        case codes.NXDOMAIN:
          throw makeQueryError(name, type, this.NOTFOUND);
        case codes.NOTIMP:
          throw makeQueryError(name, type, this.NOTIMP);
        case codes.REFUSED:
          throw makeQueryError(name, type, this.REFUSED);
      }
      throw makeQueryError(name, type, this.BADRESP);
    }

    if (!this._allowInsecure) {
      if (secure && !res.ad)
        throw makeQueryError(name, type, this.INSECURE);
    }

    const answer = res.collect(name, type);
    const result = [];

    for (const rr of answer) {
      const obj = map(rr);
      if (obj)
        result.push(obj);
    }

    if (result.length === 0)
      throw makeQueryError(name, type, this.NODATA);

    if (type === types.SOA)
      return result[0];

    return result;
  }

  async _resolve(name, type, map) {
    return this._lookup(name, type, false, map);
  }

  async _resolveSecure(name, type, map) {
    return this._lookup(name, type, true, map);
  }

  getServers() {
    if (!this._servers) {
      if (!conf)
        conf = ResolvConf.fromSystem();
      return conf.getServers();
    }
    return this._servers.slice();
  }

  setServers(servers) {
    assert(Array.isArray(servers));

    for (const server of servers) {
      const {type} = IP.fromHost(server, DNS_PORT);
      switch (type) {
        case 4:
          break;
        case 6:
          break;
        default:
          throw new Error('Invalid address.');
      }
    }

    this._servers = servers.slice();

    return this;
  }

  async resolve(name, type = 'A') {
    assert(typeof name === 'string');
    assert(typeof type === 'string');

    switch (type) {
      case 'A':
        return this.resolve4(name);
      case 'AAAA':
        return this.resolve6(name);
      case 'CNAME':
        return this.resolveCname(name);
      case 'MX':
        return this.resolveMx(name);
      case 'NAPTR':
        return this.resolveNaptr(name);
      case 'NS':
        return this.resolveNs(name);
      case 'PTR':
        return this.resolvePtr(name);
      case 'SOA':
        return this.resolveSoa(name);
      case 'SRV':
        return this.resolveSrv(name);
      case 'TXT':
        return this.resolveTxt(name);
      case 'ANY':
        return this.resolveAny(name);
      default:
        throw new Error(`Unknown type: ${type}.`);
    }
  }

  async resolve4(name, options = {}) {
    assert(options && typeof options === 'object');

    return this._resolve(name, types.A, (rr) => {
      const {ttl} = rr;
      const {address} = rr.data;

      if (options.ttl)
        return { address, ttl };

      return address;
    });
  }

  async resolve6(name, options = {}) {
    assert(options && typeof options === 'object');

    return this._resolve(name, types.AAAA, (rr) => {
      const {ttl} = rr;
      const {address} = rr.data;

      if (options.ttl)
        return { address, ttl };

      return address;
    });
  }

  async resolveCname(name) {
    return this._resolve(name, types.CNAME, (rr) => {
      return util.trimFQDN(rr.data.target);
    });
  }

  async resolveMx(name) {
    return this._resolve(name, types.MX, (rr) => {
      const rd = rr.data;
      return {
        exchange: util.trimFQDN(rd.mx),
        priority: rd.preference
      };
    });
  }

  async resolveNaptr(name) {
    return this._resolve(name, types.NAPTR, (rr) => {
      const rd = rr.data;
      return {
        flags: rd.flags,
        service: rd.service,
        regexp: rd.regexp,
        replacement: util.trimFQDN(rd.replacement),
        order: rd.order,
        preference: rd.preference
      };
    });
  }

  async resolveNs(name) {
    return this._resolve(name, types.NS, (rr) => {
      return util.trimFQDN(rr.data.ns);
    });
  }

  async resolvePtr(name) {
    return this._resolve(name, types.PTR, (rr) => {
      return util.trimFQDN(rr.data.ptr);
    });
  }

  async resolveSoa(name) {
    return this._resolve(name, types.SOA, (rr) => {
      const rd = rr.data;
      return {
        nsname: util.trimFQDN(rd.ns),
        hostmaster: util.trimFQDN(rd.mbox),
        serial: rd.serial,
        refresh: rd.refresh,
        retry: rd.retry,
        expire: rd.expire,
        minttl: rd.minttl
      };
    });
  }

  async resolveSrv(name) {
    return this._resolve(name, types.SRV, (rr) => {
      const rd = rr.data;
      return {
        name: util.trimFQDN(rd.target),
        port: rd.port,
        priority: rd.priority,
        weight: rd.weight
      };
    });
  }

  async resolveTxt(name) {
    return this._resolve(name, types.TXT, (rr) => {
      const rd = rr.data;
      return rd.txt.slice();
    });
  }

  async resolveAny(name) {
    return this._resolve(name, types.ANY, (rr) => {
      const rd = rr.data;

      switch (rr.type) {
        case types.A:
          return {
            address: rd.address,
            ttl: rr.ttl,
            type: 'A'
          };
        case types.AAAA:
          return {
            address: rd.address,
            ttl: rr.ttl,
            type: 'AAAA'
          };
        case types.CNAME:
          return {
            value: util.trimFQDN(rd.target),
            type: 'CNAME'
          };
        case types.MX:
          return {
            exchange: util.trimFQDN(rd.mx),
            priority: rd.preference,
            type: 'MX'
          };
        case types.NAPTR:
          return {
            flags: rd.flags,
            service: rd.service,
            regexp: rd.regexp,
            replacement: util.trimFQDN(rd.replacement),
            order: rd.order,
            preference: rd.preference,
            type: 'NAPTR'
          };
        case types.NS:
          return {
            value: util.trimFQDN(rd.ns),
            type: 'NS'
          };
        case types.PTR:
          return {
            value: util.trimFQDN(rd.ptr),
            type: 'PTR'
          };
        case types.SOA:
          return {
            nsname: util.trimFQDN(rd.ns),
            hostmaster: util.trimFQDN(rd.mbox),
            serial: rd.serial,
            refresh: rd.refresh,
            retry: rd.retry,
            expire: rd.expire,
            minttl: rd.minttl,
            type: 'SOA'
          };
        case types.SRV:
          return {
            name: util.trimFQDN(rd.target),
            port: rd.port,
            priority: rd.priority,
            weight: rd.weight,
            type: 'SRV'
          };
        case types.TXT:
          return {
            entries: rd.txt.slice(),
            type: 'TXT'
          };
        default:
          return null;
      }
    });
  }

  async reverse(addr) {
    const name = encoding.reverse(addr);
    return this._resolve(name, types.PTR, (rr) => {
      return util.trimFQDN(rr.data.ptr);
    });
  }

  async _lookup4(name, addrs, map) {
    try {
      await this._resolve(name, types.A, (rr) => {
        let address = rr.data.address;
        let family = 4;

        if (map) {
          address = `::ffff:${address}`;
          family = 6;
        }

        addrs.push({ address, family });
      });
    } catch (e) {
      if (e.code !== this.NODATA)
        throw e;
    }
  }

  async _lookup6(name, addrs) {
    try {
      await this._resolve(name, types.AAAA, (rr) => {
        addrs.push({ address: rr.data.address, family: 6 });
      });
    } catch (e) {
      if (e.code !== this.NODATA)
        throw e;
    }
  }

  async lookup(name, options = {}) {
    if (typeof options === 'number')
      options = { family: options };

    assert(name == null || typeof name === 'string');
    assert(options && typeof options === 'object');

    const family = options.family >>> 0;
    const hints = options.hints >>> 0;
    const all = options.all === true;
    const verbatim = options.verbatim === true;

    verbatim;

    assert(family === 0 || family === 4 || family === 6);

    assert(hints === 0
      || hints === this.ADDRCONFIG
      || hints === this.V4MAPPED
      || hints === (this.ADDRCONFIG | this.V4MAPPED));

    if (!name) {
      if (!all)
        return { address: null, family: family === 6 ? 6 : 4 };
      return [];
    }

    if (util.isIP(name)) {
      const address = name;
      const ip = IP.toBuffer(address);
      const family = IP.isIPv4(ip) ? 4 : 6;

      if (!all)
        return { address, family };

      return [{ address, family }];
    }

    const addrs = [];

    if (!(hints & this.ADDRCONFIG) || hasIPv4) {
      if (family === 0 || family === 4)
        await this._lookup4(name, addrs, false);
    }

    if (!(hints & this.ADDRCONFIG) || hasIPv6) {
      if (family === 0 || family === 6)
        await this._lookup6(name, addrs);

      if (family === 6 && addrs.length === 0) {
        if (hints & this.V4MAPPED)
          await this._lookup4(name, addrs, true);
      }
    }

    if (addrs.length === 0)
      throw makeGAIError(name, this.NOTFOUND);

    if (!all)
      return addrs[0];

    return addrs;
  }

  async lookupService(addr, port) {
    port = port >>> 0;

    assert(typeof addr === 'string');
    assert((port & 0xffff) === port);

    const name = encoding.reverse(addr);
    const iana = lazy('./internal/iana');

    let ptrs;
    try {
      ptrs = await this._resolve(name, types.PTR, (rr) => {
        return util.trimFQDN(rr.data.ptr);
      });
    } catch (e) {
      if (e.code === this.NODATA)
        throw makeGNIError(name, this.NOTFOUND);
      throw e;
    }

    return {
      hostname: ptrs[0],
      service: iana.getService(port)
    };
  }

  cancel() {
    for (const resolver of this._resolvers)
      resolver.cancel();
  }

  /*
   * Non-standard node.js API
   */

  async resolveRaw(name, type) {
    if (type == null)
      type = types.A;

    if (typeof type === 'string')
      type = constants.stringToType(type);

    return this._query(name, type);
  }

  async reverseRaw(addr) {
    const name = encoding.reverse(addr);
    return this._query(name, types.PTR);
  }

  async resolveSSHFP(name, key) {
    assert(key == null || (key != null && key._isBuffer === true));

    return this._resolveSecure(name, types.SSHFP, (rr) => {
      const rd = rr.data;

      if (key) {
        if (!sshfp.verify(rr, key))
          return null;
      }

      return {
        algorithm: rd.algorithm,
        digestType: rd.digestType,
        fingerprint: rd.fingerprint
      };
    });
  }

  async resolveTLSA(name, protocol, port, cert) {
    assert(cert == null || (cert != null && cert._isBuffer === true));

    const rrname = tlsa.encodeName(name, protocol, port);

    return this._resolveSecure(rrname, types.TLSA, (rr) => {
      const rd = rr.data;

      if (cert) {
        if (!tlsa.verify(rr, cert))
          return null;
      }

      return {
        usage: rd.usage,
        selector: rd.selector,
        matchingType: rd.matchingType,
        certificate: rd.certificate
      };
    });
  }

  async resolveSMIMEA(email, cert) {
    assert(cert == null || (cert != null && cert._isBuffer === true));

    const rrname = smimea.encodeEmail(email);

    return this._resolveSecure(rrname, types.SMIMEA, (rr) => {
      const rd = rr.data;

      if (cert) {
        if (!smimea.verify(rr, cert))
          return null;
      }

      return {
        usage: rd.usage,
        selector: rd.selector,
        matchingType: rd.matchingType,
        certificate: rd.certificate
      };
    });
  }

  async resolveOPENPGPKEY(email, key) {
    assert(key == null || (key != null && key._isBuffer === true));

    const rrname = openpgpkey.encodeEmail(email);

    return this._resolveSecure(rrname, types.OPENPGPKEY, (rr) => {
      const rd = rr.data;

      if (key) {
        if (!openpgpkey.verify(rr, key))
          return null;
      }

      return rd.publicKey;
    });
  }

  verifySSHFP(record, key) {
    assert(record && typeof record === 'object');
    return sshfp.validate(key, record.digestType, record.fingerprint);
  }

  verifyDANE(record, cert) {
    assert(record && typeof record === 'object');
    return dane.verify(
      cert,
      record.selector,
      record.matchingType,
      record.certificate
    );
  }

  verifyTLSA(record, cert) {
    return this.verifyDANE(record, cert);
  }

  verifySMIMEA(record, cert) {
    return this.verifyDANE(record, cert);
  }

  verifyOPENPGPKEY(publicKey, key) {
    assert((publicKey != null && publicKey._isBuffer === true));
    assert((key != null && key._isBuffer === true));
    return publicKey.equals(key);
  }

  /*
   * Legacy lookup function (used everywhere in node.js)
   */

  legacy(hostname, options, callback) {
    let hints = 0;
    let family = -1;
    let all = false;
    let verbatim = false;

    if (hostname && typeof hostname !== 'string') {
      throw makeTypeError('ERR_INVALID_ARG_TYPE', 'hostname');
    } else if (typeof options === 'function') {
      callback = options;
      family = 0;
    } else if (typeof callback !== 'function') {
      throw makeTypeError('ERR_INVALID_CALLBACK', 'callback');
    } else if (options !== null && typeof options === 'object') {
      hints = options.hints >>> 0;
      family = options.family >>> 0;
      all = options.all === true;
      verbatim = options.verbatim === true;

      if (hints !== 0
          && hints !== this.ADDRCONFIG
          && hints !== this.V4MAPPED
          && hints !== (this.ADDRCONFIG | this.V4MAPPED)) {
        throw makeTypeError('ERR_INVALID_OPT_VALUE', 'hints');
      }
    } else {
      family = options >>> 0;
    }

    if (family !== 0 && family !== 4 && family !== 6)
      throw makeTypeError('ERR_INVALID_OPT_VALUE', 'family');

    const opt = {
      hints,
      family,
      all,
      verbatim
    };

    if (!hostname && hostname != null)
      hostname = null;

    this.lookup(hostname, opt).then((result) => {
      if (!all) {
        const {address, family} = result;
        process.nextTick(() => callback(null, address, family));
      } else {
        process.nextTick(() => callback(null, result));
      }
    }).catch((err) => {
      process.nextTick(() => callback(err));
    });
  }

  static make(create, options) {
    const keys = Object.getOwnPropertyNames(this.prototype);
    const api = new this(create, options);

    for (const key of keys) {
      const func = api[key];

      if (typeof func !== 'function')
        continue;

      if (key.length === 0)
        continue;

      if (key === 'constructor')
        continue;

      if (key[0] === '_')
        continue;

      api[key] = func.bind(api);
    }

    // Hack:
    // Get the object out
    // of hashtable mode.
    ({ __proto__: api });

    return api;
  }
}

/*
 * Helpers
 */

function makeError(name, syscall, code) {
  const err = new Error(`${syscall} ${code} ${name}`);
  err.errno = code;
  err.code = code;
  err.syscall = syscall;
  err.hostname = name;
  return err;
}

function makeQueryError(name, type, code) {
  const syscall = `query${constants.typeToString(type)}`;
  return makeError(name, syscall, code);
}

function makeGAIError(name, code) {
  return makeError(name, 'getaddrinfo', code);
}

function makeGNIError(name, code) {
  return makeError(name, 'getnameinfo', code);
}

function makeTypeError(code, arg) {
  const err = new TypeError(`Invalid argument: "${arg}".`);
  err.code = code;
  err.name = `TypeError [${code}]`;
  return err;
}

/*
 * Expose
 */

module.exports = API;
}],
[/* 2 */ 'bsert', '/lib/assert.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * assert.js - assertions for javascript
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bsert
 */



/**
 * AssertionError
 */

class AssertionError extends Error {
  constructor(options) {
    if (typeof options === 'string')
      options = { message: options };

    if (options === null || typeof options !== 'object')
      options = {};

    let message = null;
    let operator = 'fail';
    let generatedMessage = Boolean(options.generatedMessage);

    if (options.message != null)
      message = toString(options.message);

    if (typeof options.operator === 'string')
      operator = options.operator;

    if (message == null) {
      if (operator === 'fail') {
        message = 'Assertion failed.';
      } else {
        const a = stringify(options.actual);
        const b = stringify(options.expected);

        message = `${a} ${operator} ${b}`;
      }

      generatedMessage = true;
    }

    super(message);

    let start = this.constructor;

    if (typeof options.stackStartFunction === 'function')
      start = options.stackStartFunction;
    else if (typeof options.stackStartFn === 'function')
      start = options.stackStartFn;

    this.type = 'AssertionError';
    this.name = 'AssertionError [ERR_ASSERTION]';
    this.code = 'ERR_ASSERTION';
    this.generatedMessage = generatedMessage;
    this.actual = options.actual;
    this.expected = options.expected;
    this.operator = operator;

    if (Error.captureStackTrace)
      Error.captureStackTrace(this, start);
  }
}

/*
 * Assert
 */

function assert(value, message) {
  if (!value) {
    let generatedMessage = false;

    if (arguments.length === 0) {
      message = 'No value argument passed to `assert()`.';
      generatedMessage = true;
    } else if (message == null) {
      message = 'Assertion failed.';
      generatedMessage = true;
    } else if (isError(message)) {
      throw message;
    }

    throw new AssertionError({
      message,
      actual: value,
      expected: true,
      operator: '==',
      generatedMessage,
      stackStartFn: assert
    });
  }
}

function equal(actual, expected, message) {
  if (!Object.is(actual, expected)) {
    if (isError(message))
      throw message;

    throw new AssertionError({
      message,
      actual,
      expected,
      operator: 'strictEqual',
      stackStartFn: equal
    });
  }
}

function notEqual(actual, expected, message) {
  if (Object.is(actual, expected)) {
    if (isError(message))
      throw message;

    throw new AssertionError({
      message,
      actual,
      expected,
      operator: 'notStrictEqual',
      stackStartFn: notEqual
    });
  }
}

function fail(message) {
  let generatedMessage = false;

  if (isError(message))
    throw message;

  if (message == null) {
    message = 'Assertion failed.';
    generatedMessage = true;
  }

  throw new AssertionError({
    message,
    actual: false,
    expected: true,
    operator: 'fail',
    generatedMessage,
    stackStartFn: fail
  });
}

function throws(func, expected, message) {
  if (typeof expected === 'string') {
    message = expected;
    expected = undefined;
  }

  let thrown = false;
  let err = null;

  enforce(typeof func === 'function', 'func', 'function');

  try {
    func();
  } catch (e) {
    thrown = true;
    err = e;
  }

  if (!thrown) {
    let generatedMessage = false;

    if (message == null) {
      message = 'Missing expected exception.';
      generatedMessage = true;
    }

    throw new AssertionError({
      message,
      actual: undefined,
      expected,
      operator: 'throws',
      generatedMessage,
      stackStartFn: throws
    });
  }

  if (!testError(err, expected, message, throws))
    throw err;
}

function doesNotThrow(func, expected, message) {
  if (typeof expected === 'string') {
    message = expected;
    expected = undefined;
  }

  let thrown = false;
  let err = null;

  enforce(typeof func === 'function', 'func', 'function');

  try {
    func();
  } catch (e) {
    thrown = true;
    err = e;
  }

  if (!thrown)
    return;

  if (testError(err, expected, message, doesNotThrow)) {
    let generatedMessage = false;

    if (message == null) {
      message = 'Got unwanted exception.';
      generatedMessage = true;
    }

    throw new AssertionError({
      message,
      actual: err,
      expected,
      operator: 'doesNotThrow',
      generatedMessage,
      stackStartFn: doesNotThrow
    });
  }

  throw err;
}

async function rejects(func, expected, message) {
  if (typeof expected === 'string') {
    message = expected;
    expected = undefined;
  }

  let thrown = false;
  let err = null;

  if (typeof func !== 'function')
    enforce(isPromise(func), 'func', 'promise');

  try {
    if (isPromise(func))
      await func;
    else
      await func();
  } catch (e) {
    thrown = true;
    err = e;
  }

  if (!thrown) {
    let generatedMessage = false;

    if (message == null) {
      message = 'Missing expected rejection.';
      generatedMessage = true;
    }

    throw new AssertionError({
      message,
      actual: undefined,
      expected,
      operator: 'rejects',
      generatedMessage,
      stackStartFn: rejects
    });
  }

  if (!testError(err, expected, message, rejects))
    throw err;
}

async function doesNotReject(func, expected, message) {
  if (typeof expected === 'string') {
    message = expected;
    expected = undefined;
  }

  let thrown = false;
  let err = null;

  if (typeof func !== 'function')
    enforce(isPromise(func), 'func', 'promise');

  try {
    if (isPromise(func))
      await func;
    else
      await func();
  } catch (e) {
    thrown = true;
    err = e;
  }

  if (!thrown)
    return;

  if (testError(err, expected, message, doesNotReject)) {
    let generatedMessage = false;

    if (message == null) {
      message = 'Got unwanted rejection.';
      generatedMessage = true;
    }

    throw new AssertionError({
      message,
      actual: undefined,
      expected,
      operator: 'doesNotReject',
      generatedMessage,
      stackStartFn: doesNotReject
    });
  }

  throw err;
}

function ifError(err) {
  if (err != null) {
    let message = 'ifError got unwanted exception: ';

    if (typeof err === 'object' && typeof err.message === 'string') {
      if (err.message.length === 0 && err.constructor)
        message += err.constructor.name;
      else
        message += err.message;
    } else {
      message += stringify(err);
    }

    throw new AssertionError({
      message,
      actual: err,
      expected: null,
      operator: 'ifError',
      generatedMessage: true,
      stackStartFn: ifError
    });
  }
}

function deepEqual(actual, expected, message) {
  if (!isDeepEqual(actual, expected, false)) {
    if (isError(message))
      throw message;

    throw new AssertionError({
      message,
      actual,
      expected,
      operator: 'deepStrictEqual',
      stackStartFn: deepEqual
    });
  }
}

function notDeepEqual(actual, expected, message) {
  if (isDeepEqual(actual, expected, true)) {
    if (isError(message))
      throw message;

    throw new AssertionError({
      message,
      actual,
      expected,
      operator: 'notDeepStrictEqual',
      stackStartFn: notDeepEqual
    });
  }
}

function bufferEqual(actual, expected, enc, message) {
  if (!isEncoding(enc)) {
    message = enc;
    enc = null;
  }

  if (enc == null)
    enc = 'hex';

  expected = bufferize(actual, expected, enc);

  enforce(isBuffer(actual), 'actual', 'buffer');
  enforce(isBuffer(expected), 'expected', 'buffer');

  if (actual !== expected && !actual.equals(expected)) {
    if (isError(message))
      throw message;

    throw new AssertionError({
      message,
      actual: actual.toString(enc),
      expected: expected.toString(enc),
      operator: 'bufferEqual',
      stackStartFn: bufferEqual
    });
  }
}

function notBufferEqual(actual, expected, enc, message) {
  if (!isEncoding(enc)) {
    message = enc;
    enc = null;
  }

  if (enc == null)
    enc = 'hex';

  expected = bufferize(actual, expected, enc);

  enforce(isBuffer(actual), 'actual', 'buffer');
  enforce(isBuffer(expected), 'expected', 'buffer');

  if (actual === expected || actual.equals(expected)) {
    if (isError(message))
      throw message;

    throw new AssertionError({
      message,
      actual: actual.toString(enc),
      expected: expected.toString(enc),
      operator: 'notBufferEqual',
      stackStartFn: notBufferEqual
    });
  }
}

function enforce(value, name, type) {
  if (!value) {
    let msg;

    if (name == null) {
      msg = 'Invalid type for parameter.';
    } else {
      if (type == null)
        msg = `Invalid type for "${name}".`;
      else
        msg = `"${name}" must be a(n) ${type}.`;
    }

    const err = new TypeError(msg);

    if (Error.captureStackTrace)
      Error.captureStackTrace(err, enforce);

    throw err;
  }
}

function range(value, name) {
  if (!value) {
    const msg = name != null
      ? `"${name}" is out of range.`
      : 'Parameter is out of range.';

    const err = new RangeError(msg);

    if (Error.captureStackTrace)
      Error.captureStackTrace(err, range);

    throw err;
  }
}

/*
 * Stringification
 */

function stringify(value) {
  switch (typeof value) {
    case 'undefined':
      return 'undefined';
    case 'object':
      if (value === null)
        return 'null';
      return `[${objectName(value)}]`;
    case 'boolean':
      return `${value}`;
    case 'number':
      return `${value}`;
    case 'string':
      if (value.length > 80)
        value = `${value.substring(0, 77)}...`;
      return JSON.stringify(value);
    case 'symbol':
      return tryString(value);
    case 'function':
      return `[${funcName(value)}]`;
    case 'bigint':
      return `${value}n`;
    default:
      return `[${typeof value}]`;
  }
}

function toString(value) {
  if (typeof value === 'string')
    return value;

  if (isError(value))
    return tryString(value);

  return stringify(value);
}

function tryString(value) {
  try {
    return String(value);
  } catch (e) {
    return 'Object';
  }
}

/*
 * Error Testing
 */

function testError(err, expected, message, func) {
  if (expected == null)
    return true;

  if (isRegExp(expected))
    return expected.test(err);

  if (typeof expected !== 'function') {
    if (func === doesNotThrow || func === doesNotReject)
      throw new TypeError('"expected" must not be an object.');

    if (typeof expected !== 'object')
      throw new TypeError('"expected" must be an object.');

    let generatedMessage = false;

    if (message == null) {
      const name = func === rejects ? 'rejection' : 'exception';
      message = `Missing expected ${name}.`;
      generatedMessage = true;
    }

    if (err == null || typeof err !== 'object') {
      throw new AssertionError({
        actual: err,
        expected,
        message,
        operator: func.name,
        generatedMessage,
        stackStartFn: func
      });
    }

    const keys = Object.keys(expected);

    if (isError(expected))
      keys.push('name', 'message');

    if (keys.length === 0)
      throw new TypeError('"expected" may not be an empty object.');

    for (const key of keys) {
      const expect = expected[key];
      const value = err[key];

      if (typeof value === 'string'
          && isRegExp(expect)
          && expect.test(value)) {
        continue;
      }

      if ((key in err) && isDeepEqual(value, expect, false))
        continue;

      throw new AssertionError({
        actual: err,
        expected: expected,
        message,
        operator: func.name,
        generatedMessage,
        stackStartFn: func
      });
    }

    return true;
  }

  if (expected.prototype !== undefined && (err instanceof expected))
    return true;

  if (Error.isPrototypeOf(expected))
    return false;

  return expected.call({}, err) === true;
}

/*
 * Comparisons
 */

function isDeepEqual(x, y, fail) {
  try {
    return compare(x, y, null);
  } catch (e) {
    return fail;
  }
}

function compare(a, b, cache) {
  // Primitives.
  if (Object.is(a, b))
    return true;

  if (!isObject(a) || !isObject(b))
    return false;

  // Semi-primitives.
  if (objectString(a) !== objectString(b))
    return false;

  if (Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;

  if (isBuffer(a) && isBuffer(b))
    return a.equals(b);

  if (isDate(a))
    return Object.is(a.getTime(), b.getTime());

  if (isRegExp(a)) {
    return a.source === b.source
        && a.global === b.global
        && a.multiline === b.multiline
        && a.lastIndex === b.lastIndex
        && a.ignoreCase === b.ignoreCase;
  }

  if (isError(a)) {
    if (a.message !== b.message)
      return false;
  }

  if (isArrayBuffer(a)) {
    a = new Uint8Array(a);
    b = new Uint8Array(b);
  }

  if (isView(a) && !isBuffer(a)) {
    if (isBuffer(b))
      return false;

    const x = new Uint8Array(a.buffer);
    const y = new Uint8Array(b.buffer);

    if (x.length !== y.length)
      return false;

    for (let i = 0; i < x.length; i++) {
      if (x[i] !== y[i])
        return false;
    }

    return true;
  }

  if (isSet(a)) {
    if (a.size !== b.size)
      return false;

    const keys = new Set([...a, ...b]);

    return keys.size === a.size;
  }

  // Recursive.
  if (!cache) {
    cache = {
      a: new Map(),
      b: new Map(),
      p: 0
    };
  } else {
    const aa = cache.a.get(a);

    if (aa != null) {
      const bb = cache.b.get(b);
      if (bb != null)
        return aa === bb;
    }

    cache.p += 1;
  }

  cache.a.set(a, cache.p);
  cache.b.set(b, cache.p);

  const ret = recurse(a, b, cache);

  cache.a.delete(a);
  cache.b.delete(b);

  return ret;
}

function recurse(a, b, cache) {
  if (isMap(a)) {
    if (a.size !== b.size)
      return false;

    const keys = new Set([...a.keys(), ...b.keys()]);

    if (keys.size !== a.size)
      return false;

    for (const key of keys) {
      if (!compare(a.get(key), b.get(key), cache))
        return false;
    }

    return true;
  }

  if (isArray(a)) {
    if (a.length !== b.length)
      return false;

    for (let i = 0; i < a.length; i++) {
      if (!compare(a[i], b[i], cache))
        return false;
    }

    return true;
  }

  const ak = ownKeys(a);
  const bk = ownKeys(b);

  if (ak.length !== bk.length)
    return false;

  const keys = new Set([...ak, ...bk]);

  if (keys.size !== ak.length)
    return false;

  for (const key of keys) {
    if (!compare(a[key], b[key], cache))
      return false;
  }

  return true;
}

function ownKeys(obj) {
  const keys = Object.keys(obj);

  if (!Object.getOwnPropertySymbols)
    return keys;

  if (!Object.getOwnPropertyDescriptor)
    return keys;

  const symbols = Object.getOwnPropertySymbols(obj);

  for (const symbol of symbols) {
    const desc = Object.getOwnPropertyDescriptor(obj, symbol);

    if (desc && desc.enumerable)
      keys.push(symbol);
  }

  return keys;
}

/*
 * Helpers
 */

function objectString(obj) {
  if (obj === undefined)
    return '[object Undefined]';

  if (obj === null)
    return '[object Null]';

  try {
    return Object.prototype.toString.call(obj);
  } catch (e) {
    return '[object Object]';
  }
}

function objectType(obj) {
  return objectString(obj).slice(8, -1);
}

function objectName(obj) {
  const type = objectType(obj);

  if (obj == null)
    return type;

  if (type !== 'Object' && type !== 'Error')
    return type;

  let ctor, name;

  try {
    ctor = obj.constructor;
  } catch (e) {
    ;
  }

  if (ctor == null)
    return type;

  try {
    name = ctor.name;
  } catch (e) {
    return type;
  }

  if (typeof name !== 'string' || name.length === 0)
    return type;

  return name;
}

function funcName(func) {
  let name;

  try {
    name = func.name;
  } catch (e) {
    ;
  }

  if (typeof name !== 'string' || name.length === 0)
    return 'Function';

  return `Function: ${name}`;
}

function isArray(obj) {
  return Array.isArray(obj);
}

function isArrayBuffer(obj) {
  return obj instanceof ArrayBuffer;
}

function isBuffer(obj) {
  return isObject(obj)
      && typeof obj.writeUInt32LE === 'function'
      && typeof obj.equals === 'function';
}

function isDate(obj) {
  return obj instanceof Date;
}

function isError(obj) {
  return obj instanceof Error;
}

function isMap(obj) {
  return obj instanceof Map;
}

function isObject(obj) {
  return obj && typeof obj === 'object';
}

function isPromise(obj) {
  return obj instanceof Promise;
}

function isRegExp(obj) {
  return obj instanceof RegExp;
}

function isSet(obj) {
  return obj instanceof Set;
}

function isView(obj) {
  return ArrayBuffer.isView(obj);
}

function isEncoding(enc) {
  if (typeof enc !== 'string')
    return false;

  switch (enc) {
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'hex':
    case 'latin1':
    case 'ucs2':
    case 'utf8':
    case 'utf16le':
      return true;
  }

  return false;
}

function bufferize(actual, expected, enc) {
  if (typeof expected === 'string') {
    if (!isBuffer(actual))
      return null;

    const {constructor} = actual;

    if (!constructor || typeof constructor.from !== 'function')
      return null;

    if (!isEncoding(enc))
      return null;

    if (enc === 'hex' && (expected.length & 1))
      return null;

    const raw = constructor.from(expected, enc);

    if (enc === 'hex' && raw.length !== (expected.length >>> 1))
      return null;

    return raw;
  }

  return expected;
}

/*
 * API
 */

assert.AssertionError = AssertionError;
assert.assert = assert;
assert.strict = assert;
assert.ok = assert;
assert.equal = equal;
assert.notEqual = notEqual;
assert.strictEqual = equal;
assert.notStrictEqual = notEqual;
assert.fail = fail;
assert.throws = throws;
assert.doesNotThrow = doesNotThrow;
assert.rejects = rejects;
assert.doesNotReject = doesNotReject;
assert.ifError = ifError;
assert.deepEqual = deepEqual;
assert.notDeepEqual = notDeepEqual;
assert.deepStrictEqual = deepEqual;
assert.notDeepStrictEqual = notDeepEqual;
assert.bufferEqual = bufferEqual;
assert.notBufferEqual = notBufferEqual;
assert.enforce = enforce;
assert.range = range;

/*
 * Expose
 */

module.exports = assert;
}],
[/* 3 */ 'bpkg', '/lib/builtins/events.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * events@3.0.0 - Node's event emitter for all engines.
 * Copyright (c) 2019, Irakli Gozalishvili (MIT)
 * https://github.com/Gozala/events#readme
 *
 * License for events@3.0.0:
 *
 * MIT
 *
 * Copyright Joyent, Inc. and other Node contributors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to permit
 * persons to whom the Software is furnished to do so, subject to the
 * following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
 * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = $getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  var args = [];
  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    ReflectApply(this.listener, this.target, args);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
}],
[/* 4 */ 'binet', '/lib/binet.js', function(exports, require, module, __filename, __dirname, __meta) {
module.exports = __browser_require__(5 /* './ip' */, module);
}],
[/* 5 */ 'binet', '/lib/ip.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * ip.js - ip utils for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License).
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 *
 * Parts of this software are based on node-ip.
 * https://github.com/indutny/node-ip
 * Copyright (c) 2012, Fedor Indutny (MIT License).
 *
 * Parts of this software are based on bitcoin/bitcoin:
 * Copyright (c) 2009-2019, The Bitcoin Core Developers (MIT License).
 * Copyright (c) 2009-2019, The Bitcoin Developers (MIT License).
 * https://github.com/bitcoin/bitcoin
 *
 * Resources:
 *   https://github.com/bitcoin/bitcoin/blob/master/src/netaddress.cpp
 */

/* eslint no-unreachable: "off" */
/* eslint spaced-comment: "off" */



const assert = __browser_require__(2 /* 'bsert' */, module);
const os = __browser_require__(6 /* 'os' */, module);
const base32 = __browser_require__(7 /* 'bs32' */, module);
const inet = __browser_require__(9 /* './inet' */, module);
const onion = __browser_require__(10 /* './onion' */, module);
const binet = exports;

/*
 * Constants
 */

const ZERO_IP = Buffer.from('00000000000000000000000000000000', 'hex');
const ZERO_IPV4 = Buffer.from('00000000000000000000ffff00000000', 'hex');
const LOCAL_IP = Buffer.from('00000000000000000000000000000001', 'hex');
const RFC6052 = Buffer.from('0064ff9b0000000000000000', 'hex');
const RFC4862 = Buffer.from('fe80000000000000', 'hex');
const RFC6145 = Buffer.from('0000000000000000ffff0000', 'hex');
const SHIFTED = Buffer.from('00000000000000ffff', 'hex');
const TOR_ONION = Buffer.from('fd87d87eeb43', 'hex');
const ZERO_KEY = Buffer.alloc(33, 0x00);
const POOL = Buffer.alloc(16, 0x00);
const POOLX = Buffer.alloc(16, 0x00);
const POOLY = Buffer.alloc(16, 0x00);

const ALL = 0;
const LOCAL = 1;
const NONLOCAL = 2;
const PRIVATE = 3;
const PUBLIC = 4;

/**
 * Address types.
 * @enum {Number}
 */

const types = {
  NONE: 0,
  INET4: 4,
  INET6: 6,
  ONION: 10
};

/**
 * Address networks.
 * @enum {Number}
 */

const networks = {
  NONE: 0,
  INET4: 1,
  INET6: 2,
  ONION: 3,
  TEREDO: 4
};

/**
 * Convert a buffer to an ip string.
 * @param {Buffer} raw
 * @returns {String}
 */

binet.encode = function encode(raw) {
  assert((raw != null && raw._isBuffer === true));
  return binet.read(raw, 0, raw.length);
};

/**
 * Parse an IP string and return a buffer.
 * @param {String} str
 * @returns {Buffer}
 */

binet.decode = function decode(str) {
  const raw = Buffer.allocUnsafeSlow(16);
  binet.write(raw, str, 0, 16);
  return raw;
};

/**
 * Read an IP string from a buffer.
 * @param {Buffer} raw
 * @param {Number} [off=0]
 * @param {Number} [size=16]
 * @returns {String}
 */

binet.read = function read(raw, off, size) {
  if (off == null)
    off = 0;

  if (size == null)
    size = 16;

  assert((raw != null && raw._isBuffer === true));
  assert((off >>> 0) === off);
  assert((size >>> 0) === size);

  if (off + size > raw.length)
    throw new Error('Out of bounds read.');

  if (size === 4) {
    const str = inet.ntop4(raw, off);

    if (!str)
      throw new Error('Invalid IPv4 address.');

    return str;
  }

  if (size === 16) {
    if (inet.onion(raw, off)) {
      const on = raw.slice(off + 6, off + 16);
      const str = onion.encodeLegacy(on);
      return str;
    }

    let str;

    if (inet.mapped(raw, off))
      str = inet.ntop4(raw, off + 12);
    else
      str = inet.ntop6(raw, off);

    if (!str)
      throw new Error('Invalid IPv6 address.');

    return str;
  }

  throw new Error('Invalid IP address.');
};

/**
 * Write an IP string to a buffer.
 * @param {Buffer} dst
 * @param {String} str
 * @param {Number} [off=0]
 * @param {Number} [size=16]
 * @returns {Number}
 */

binet.write = function write(dst, str, off, size) {
  if (off == null)
    off = 0;

  if (size == null)
    size = 16;

  assert((dst != null && dst._isBuffer === true));
  assert(typeof str === 'string');
  assert((off >>> 0) === off);
  assert((size >>> 0) === size);

  if (off + size > dst.length)
    throw new Error('Out of bounds write.');

  if (size === 4) {
    if (inet.pton4(str, dst, off) >= 0)
      return off + 4;

    const raw = POOL;

    if (inet.pton6(str, raw, 0) < 0)
      throw new Error('Invalid IPv4 address.');

    if (!inet.mapped(raw, 0))
      throw new Error('Out of bounds write.');

    off += raw.copy(dst, off, 12, 16);

    return off;
  }

  if (size === 16) {
    if (onion.isLegacyString(str)) {
      const prefix = TOR_ONION;
      const data = onion.decodeLegacy(str);

      off += prefix.copy(dst, off);
      off += data.copy(dst, off);

      return off;
    }

    if (inet.pton4(str, dst, off + 12) >= 0) {
      dst.fill(0x00, off, off + 10);
      off += 10;
      dst[off++] = 0xff;
      dst[off++] = 0xff;
      return off + 4;
    }

    if (inet.pton6(str, dst, off) >= 0)
      return off + 16;

    throw new Error('Invalid IPv6 address.');
  }

  throw new Error('Invalid IP address.');
};

/**
 * Write an IP string to a buffer writer.
 * @param {BufferWriter} bw
 * @param {String} str
 * @param {Number} [size=16]
 * @returns {BufferWriter}
 */

binet.writeBW = function writeBW(bw, str, size) {
  assert(bw && typeof bw === 'object');

  // StaticWriter
  if (bw.data) {
    bw.offset = binet.write(bw.data, str, bw.offset, size);
    return bw;
  }

  const buf = Buffer.alloc(size);
  const off = binet.write(buf, str, 0, size);
  // these must always match.
  assert(off === size);
  bw.writeBytes(buf);
  return bw;
};

/**
 * Read an IP string from a buffer reader.
 * @param {BufferReader} br
 * @param {Number} [size=16]
 * @returns {String}
 */

binet.readBR = function readBR(br, size) {
  if (size == null)
    size = 16;

  assert(br && typeof br === 'object');

  const str = binet.read(br.data, br.offset, size);

  br.offset += size;

  return str;
};

/**
 * Normalize an ip.
 * @param {String} str
 * @returns {String}
 */

binet.normalize = function normalize(str) {
  if (onion.isLegacyString(str))
    return onion.normalizeLegacy(str);

  const raw = POOL;

  if (inet.pton4(str, raw, 0) >= 0)
    return inet.ntop4(raw, 0);

  if (inet.pton6(str, raw, 0) >= 0) {
    if (binet.isMapped(raw))
      return inet.ntop4(raw, 12);
    return inet.ntop6(raw, 0);
  }

  throw new Error('Invalid IP address.');
};

/**
 * Convert 4 byte ip address
 * to IPv4 mapped IPv6 address.
 * @param {Buffer} raw
 * @returns {Buffer}
 */

binet.map = function map(raw) {
  assert((raw != null && raw._isBuffer === true));

  if (raw.length === 16)
    return raw;

  if (raw.length !== 4)
    throw new Error('Not an IPv4 address.');

  const data = Buffer.allocUnsafeSlow(16);

  data.fill(0x00, 0, 10);

  data[10] = 0xff;
  data[11] = 0xff;

  raw.copy(data, 12);

  return data;
};

/**
 * Convert 16 byte ip address
 * from a IPv4 mapped IPv6 address.
 * @param {Buffer} raw
 * @returns {Buffer}
 */

binet.unmap = function unmap(raw) {
  assert((raw != null && raw._isBuffer === true));

  if (raw.length === 4)
    return raw;

  if (raw.length !== 16)
    throw new Error('Not an IPv6 address.');

  if (!binet.isMapped(raw))
    throw new Error('Not an IPv4 mapped address.');

  return raw.slice(12, 16);
};

/**
 * Concatenate a host and port.
 * @param {String} host
 * @param {Number} port
 * @param {Buffer|null} key
 * @returns {String}
 */

binet.toHost = function toHost(host, port, key) {
  if (key == null)
    key = null;

  assert(typeof host === 'string');
  assert((port & 0xffff) === port);
  assert(key === null || (key != null && key._isBuffer === true));
  assert(!key || key.length === 33);

  if (host.length === 0)
    throw new Error('Invalid host (zero length).');

  if (host.length > 255 + 1 + 5)
    throw new Error('Invalid host (too large).');

  let colon = false;

  for (let i = 0; i < host.length; i++) {
    const ch = host.charCodeAt(i);

    switch (ch) {
      case 0x3a /*:*/:
        colon = true;
        break;
      case 0x40 /*@*/:
      case 0x5b /*[*/:
      case 0x5d /*]*/:
        throw new Error('Bad host.');
      default:
        if (ch < 0x20 || ch > 0x7e)
          throw new Error('Bad host.');
        break;
    }
  }

  if (colon) {
    if (inet.pton6(host, null, 0) < 0)
      throw new Error('Unexpected colon.');
  }

  const type = binet.getTypeString(host);

  if (type !== types.NONE)
    host = binet.normalize(host);

  let prefix = '';

  if (key && !key.equals(ZERO_KEY))
    prefix = `${base32.encode(key)}@`;

  if (type === types.INET6)
    return `${prefix}[${host}]:${port}`;

  return `${prefix}${host}:${port}`;
};

/**
 * Parse a hostname.
 * @param {String} addr
 * @param {Number?} fport - Fallback port.
 * @param {Buffer?} fkey - Fallback key.
 * @returns {Object} Contains `host`, `port`, and `type`.
 */

binet.fromHost = function fromHost(addr, fport, fkey) {
  if (fport == null)
    fport = 0;

  if (fkey == null)
    fkey = null;

  assert(typeof addr === 'string');
  assert((fport & 0xffff) === fport);
  assert(fkey === null || (fkey != null && fkey._isBuffer === true));

  if (addr.length === 0)
    throw new Error('Invalid host (zero length).');

  if (addr.length > 53 + 1 + 255 + 1 + 5)
    throw new Error('Invalid host (too large).');

  if (fkey && fkey.length !== 33)
    throw new Error('Invalid fallback key (bad size).');

  let key = fkey;
  let host = '';
  let port = null;
  let inet6 = false;

  const at = addr.indexOf('@');

  if (at !== -1) {
    const front = addr.substring(0, at);
    const back = addr.substring(at + 1);

    if (front.length > 53)
      throw new Error('Invalid identity key (too large).');

    key = base32.decode(front);

    if (key.length !== 33)
      throw new Error('Invalid identity key (bad size).');

    addr = back;
  }

  if (addr[0] === '[') {
    if (addr[addr.length - 1] === ']') {
      // Case:
      // [::1]
      host = addr.slice(1, -1);
      port = null;
      inet6 = true;
    } else {
      // Case:
      // [::1]:80
      const colon = addr.indexOf(']:');

      if (colon === -1)
        throw new Error('IPv6 bracket mismatch.');

      host = addr.substring(1, colon);
      port = addr.substring(colon + 2);
      inet6 = true;
    }
  } else {
    const colon = addr.indexOf(':');

    if (colon !== -1) {
      const front = addr.substring(0, colon);
      const back = addr.substring(colon + 1);

      if (back.indexOf(':') !== -1) {
        // Case:
        // ::1
        host = addr;
        port = null;
        inet6 = true;
      } else {
        // Cases:
        // 127.0.0.1:80
        // localhost:80
        host = front;
        port = back;
      }
    } else {
      // Cases:
      // 127.0.0.1
      // localhost
      host = addr;
      port = null;
    }
  }

  if (host.length === 0)
    throw new Error('Invalid host (zero length).');

  if (port != null) {
    let word = 0;
    let total = 0;

    for (let i = 0; i < port.length; i++) {
      const ch = port.charCodeAt(i);

      if (ch < 0x30 || ch > 0x39)
        throw new Error('Invalid port (bad character).');

      if (total > 0 && word === 0)
        throw new Error('Invalid port (leading zero).');

      word *= 10;
      word += ch - 0x30;
      total += 1;

      if (total > 5 || word > 0xffff)
        throw new Error('Invalid port (overflow).');
    }

    if (total === 0)
      throw new Error('Invalid port (bad size).');

    port = word;
  } else {
    port = fport;
  }

  if (inet6) {
    if (inet.pton6(host, null, 0) < 0)
      throw new Error('Invalid IPv6 address.');
  }

  let raw = null;
  let type = types.NONE;
  let hostname;

  try {
    raw = binet.decode(host);
  } catch (e) {
    ;
  }

  if (raw) {
    host = binet.encode(raw);
    type = binet.getType(raw);
  }

  if (type === types.INET6)
    hostname = `[${host}]:${port}`;
  else
    hostname = `${host}:${port}`;

  return {
    host,
    port,
    type,
    hostname,
    raw,
    key
  };
};

/**
 * Get address type (0=none, 4=inet4, 6=inet6, 10=tor).
 * @param {String} str
 * @returns {Number}
 */

binet.getTypeString = function getTypeString(str) {
  assert(typeof str === 'string');

  if (str.length === 0)
    return types.NONE;

  if (str.length > 255)
    return types.NONE;

  if (onion.isLegacyString(str))
    return types.ONION;

  if (inet.pton4(str, null, 0) >= 0)
    return types.INET4;

  const raw = POOL;

  if (inet.pton6(str, raw, 0) >= 0)
    return binet.getType(raw);

  return types.NONE;
};

/**
 * Test whether a string is IPv4 mapped.
 * @param {String} str
 * @returns {Boolean}
 */

binet.isMappedString = function isMappedString(str) {
  const raw = POOL;

  if (inet.pton6(str, raw, 0) >= 0) {
    if (binet.isMapped(raw))
      return true;
  }

  return false;
};

/**
 * Test whether a string is IPv4.
 * @param {String} str
 * @returns {Boolean}
 */

binet.isIPv4String = function isIPv4String(str) {
  return binet.getTypeString(str) === types.INET4;
};

/**
 * Test whether a string is IPv6.
 * @param {String} str
 * @returns {Boolean}
 */

binet.isIPv6String = function isIPv6String(str) {
  return binet.getTypeString(str) === types.INET6;
};

/**
 * Test whether a string is an onion address.
 * @param {String} str
 * @returns {Boolean}
 */

binet.isOnionString = function isOnionString(str) {
  return binet.getTypeString(str) === types.ONION;
};

/**
 * Test whether a string is a domain name.
 * @param {String} str
 * @returns {Boolean}
 */

binet.isUnknownString = function isUnknownString(str) {
  return binet.getTypeString(str) === types.NONE;
};

/**
 * Test whether a string is IPv4 or IPv6.
 * @param {String} str
 * @returns {Number}
 */

binet.isIPString = function isIPString(str) {
  const type = binet.getTypeString(str);

  switch (type) {
    case types.INET4:
    case types.INET6:
      return type;
    default:
      return types.NONE;
  }
};

/**
 * Test whether two IPs are equal.
 * @param {String} a
 * @param {String} b
 * @returns {Boolean}
 */

binet.isEqualString = function isEqualString(a, b) {
  const x = POOLX;
  const y = POOLY;

  binet.write(x, a, 0, 16);
  binet.write(y, b, 0, 16);

  return x.equals(y);
};

/**
 * Apply a network mask to IP.
 * @param {String} str
 * @param {String} mask
 * @returns {Buffer}
 */

binet.maskString = function maskString(str, mask) {
  const x = POOLX;
  const y = POOLY;

  binet.write(x, str, 0, 16);
  binet.write(y, mask, 0, 16);
  binet.mask(x, y, x);

  return binet.encode(x);
};

/**
 * Apply a network mask
 * to IP from CIDR bits.
 * @param {String} str
 * @param {Number} bits
 * @returns {Buffer}
 */

binet.cidrString = function cidrString(str, bits) {
  const x = POOLX;

  binet.write(x, str, 0, 16);
  binet.cidr(x, bits, x);

  return binet.encode(x);
};

/**
 * Get address type.
 * @param {Buffer} raw
 * @returns {Number}
 */

binet.getType = function getType(raw) {
  if (binet.isMapped(raw))
    return types.INET4;

  if (binet.isOnion(raw))
    return types.ONION;

  return types.INET6;
};

/**
 * Test whether the address is IPv4 mapped.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

binet.isMapped = function isMapped(raw) {
  assert((raw != null && raw._isBuffer === true));
  assert(raw.length === 16);
  return inet.mapped(raw, 0);
};

/**
 * Test whether the address is IPv4.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

binet.isIPv4 = function isIPv4(raw) {
  return binet.isMapped(raw);
};

/**
 * Test whether the address is IPv6.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

binet.isIPv6 = function isIPv6(raw) {
  return !binet.isMapped(raw) && !binet.isOnion(raw);
};

/**
 * Test whether the ip has a tor onion prefix.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

binet.isOnion = function isOnion(raw) {
  assert((raw != null && raw._isBuffer === true));
  assert(raw.length === 16);
  return inet.onion(raw, 0);
};

/**
 * Test whether the address is IPv4 or IPv6.
 * @param {Buffer} raw
 * @returns {Number}
 */

binet.isIP = function isIP(raw) {
  if (binet.isIPv4(raw))
    return types.INET4;

  if (binet.isIPv6(raw))
    return types.INET6;

  return types.NONE;
};

/**
 * Test whether two IPs are equal.
 * @param {Buffer} a
 * @param {Buffer} b
 * @returns {Boolean}
 */

binet.isEqual = function isEqual(a, b) {
  assert((a != null && a._isBuffer === true));
  assert((b != null && b._isBuffer === true));
  assert(a.length === 16);
  assert(b.length === 16);
  return a.equals(b);
};

/**
 * Apply a network mask to IP.
 * @param {Buffer} raw
 * @param {Buffer} mask
 * @param {Buffer?} dst
 * @returns {Buffer}
 */

binet.mask = function(raw, mask, dst) {
  if (dst == null)
    dst = Buffer.allocUnsafeSlow(16);

  assert((raw != null && raw._isBuffer === true));
  assert((mask != null && mask._isBuffer === true));
  assert((dst != null && dst._isBuffer === true));
  assert(raw.length === 16);
  assert(mask.length === 16);
  assert(dst.length === 16);

  const start = binet.isMapped(raw) ? 12 : 0;

  if (raw !== dst)
    raw.copy(dst, 0, 0, 16);

  for (let i = start; i < 16; i++)
    dst[i] = raw[i] & mask[i];

  return dst;
};

/**
 * Apply a network mask
 * to IP from CIDR bits.
 * @param {Buffer} raw
 * @param {Number} bits
 * @param {Buffer?} dst
 * @returns {Buffer}
 */

binet.cidr = function cidr(raw, bits, dst) {
  assert((raw != null && raw._isBuffer === true));
  assert(raw.length === 16);
  assert((bits & 0xff) === bits);

  const mask = POOL;

  let start = 0;
  let max = 128;

  if (binet.isMapped(raw)) {
    start = 12;
    max = 32;
    mask.fill(0x00, 0, 10);
    mask[10] = 0xff;
    mask[11] = 0xff;
  }

  if (bits > max)
    throw new Error('Too many CIDR bits.');

  for (let i = start; i < 16; i++) {
    let b = 8;

    if (bits < 8)
      b = bits;

    bits -= b;

    mask[i] = ~(0xff >> b) & 0xff;
  }

  return binet.mask(raw, mask, dst);
};

/**
 * Test whether the host is null.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

binet.isNull = function isNull(raw) {
  if (binet.isIPv4(raw)) {
    // 0.0.0.0
    return raw[12] === 0
      && raw[13] === 0
      && raw[14] === 0
      && raw[15] === 0;
  }
  // ::
  return binet.isEqual(raw, ZERO_IP);
};

/**
 * Test whether the host is a broadcast address.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

binet.isBroadcast = function isBroadcast(raw) {
  if (!binet.isIPv4(raw))
    return false;

  // 255.255.255.255
  return raw[12] === 255
    && raw[13] === 255
    && raw[14] === 255
    && raw[15] === 255;
};

/**
 * Test whether the ip is RFC 1918.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

binet.isRFC1918 = function isRFC1918(raw) {
  if (!binet.isIPv4(raw))
    return false;

  if (raw[12] === 10)
    return true;

  if (raw[12] === 192 && raw[13] === 168)
    return true;

  if (raw[12] === 172 && (raw[13] >= 16 && raw[13] <= 31))
    return true;

  return false;
};

/**
 * Test whether the ip is RFC 2544.
 * IPv4 inter-network communications (198.18.0.0/15)
 * https://tools.ietf.org/html/rfc3330
 * https://tools.ietf.org/html/rfc2544
 * @param {Buffer} raw
 * @returns {Boolean}
 */

binet.isRFC2544 = function isRFC2544(raw) {
  if (!binet.isIPv4(raw))
    return false;

  if (raw[12] === 198 && (raw[13] === 18 || raw[13] === 19))
    return true;

  return false;
};

/**
 * Test whether the ip is RFC 3927.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

binet.isRFC3927 = function isRFC3927(raw) {
  if (!binet.isIPv4(raw))
    return false;

  if (raw[12] === 169 && raw[13] === 254)
    return true;

  return false;
};

/**
 * Test whether the ip is RFC 6598.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

binet.isRFC6598 = function isRFC6598(raw) {
  if (!binet.isIPv4(raw))
    return false;

  if (raw[12] === 100
      && (raw[13] >= 64 && raw[13] <= 127)) {
    return true;
  }

  return false;
};

/**
 * Test whether the ip is RFC 5737.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

binet.isRFC5737 = function isRFC5737(raw) {
  if (!binet.isIPv4(raw))
    return false;

  if (raw[12] === 192
      && (raw[13] === 0 && raw[14] === 2)) {
    return true;
  }

  if (raw[12] === 198 && raw[13] === 51 && raw[14] === 100)
    return true;

  if (raw[12] === 203 && raw[13] === 0 && raw[14] === 113)
    return true;

  return false;
};

/**
 * Test whether the ip is RFC 3849.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

binet.isRFC3849 = function isRFC3849(raw) {
  assert((raw != null && raw._isBuffer === true));
  assert(raw.length === 16);

  if (raw[0] === 0x20 && raw[1] === 0x01
      && raw[2] === 0x0d && raw[3] === 0xb8) {
    return true;
  }

  return false;
};

/**
 * Test whether the ip is RFC 3964.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

binet.isRFC3964 = function isRFC3964(raw) {
  assert((raw != null && raw._isBuffer === true));
  assert(raw.length === 16);

  if (raw[0] === 0x20 && raw[1] === 0x02)
    return true;

  return false;
};

/**
 * Test whether the ip is RFC 6052.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

binet.isRFC6052 = function isRFC6052(raw) {
  return hasPrefix(raw, RFC6052);
};

/**
 * Test whether the ip is RFC 4380.
 * IPv6 Teredo tunnelling (2001::/32)
 * https://tools.ietf.org/html/rfc4380
 * https://tools.ietf.org/html/rfc5156#section-2.8
 * @param {Buffer} raw
 * @returns {Boolean}
 */

binet.isRFC4380 = function isRFC4380(raw) {
  assert((raw != null && raw._isBuffer === true));
  assert(raw.length === 16);

  if (raw[0] === 0x20 && raw[1] === 0x01
      && raw[2] === 0x00 && raw[3] === 0x00) {
    return true;
  }

  return false;
};

/**
 * Test whether the ip is RFC 4862.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

binet.isRFC4862 = function isRFC4862(raw) {
  return hasPrefix(raw, RFC4862);
};

/**
 * Test whether the ip is RFC 4193.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

binet.isRFC4193 = function isRFC4193(raw) {
  assert((raw != null && raw._isBuffer === true));
  assert(raw.length === 16);

  if ((raw[0] & 0xfe) === 0xfc)
    return true;

  return false;
};

/**
 * Test whether the ip is RFC 6145.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

binet.isRFC6145 = function isRFC6145(raw) {
  return hasPrefix(raw, RFC6145);
};

/**
 * Test whether the ip is RFC 4843.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

binet.isRFC4843 = function isRFC4843(raw) {
  assert((raw != null && raw._isBuffer === true));
  assert(raw.length === 16);

  if (raw[0] === 0x20 && raw[1] === 0x01
      && raw[2] === 0x00 && (raw[3] & 0xf0) === 0x10) {
    return true;
  }

  return false;
};

/**
 * Test whether the ip is RFC 7343.
 * IPv6 ORCHIDv2 (2001:20::/28)
 * https://tools.ietf.org/html/rfc7343
 * @param {Buffer} raw
 * @returns {Boolean}
 */

binet.isRFC7343 = function isRFC7343(raw) {
  assert((raw != null && raw._isBuffer === true));
  assert(raw.length === 16);

  if (raw[0] === 0x20 && raw[1] === 0x01
      && raw[2] === 0x00 && (raw[3] & 0xf0) === 0x20) {
    return true;
  }

  return false;
};

/**
 * Test whether the ip is local.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

binet.isLocal = function isLocal(raw) {
  if (binet.isIPv4(raw)) {
    // IPv4 loopback (127.0.0.0/8 or 0.0.0.0/8)
    if (raw[12] === 127 || raw[12] === 0)
      return true;
    return false;
  }

  // IPv6 loopback (::1/128)
  if (binet.isEqual(raw, LOCAL_IP))
    return true;

  return false;
};

/**
 * Test whether the ip is a multicast address.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

binet.isMulticast = function isMulticast(raw) {
  if (binet.isIPv4(raw)) {
    if ((raw[12] & 0xf0) === 0xe0)
      return true;
    return false;
  }
  return raw[0] === 0xff;
};

/**
 * Test whether the ip is valid.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

binet.isValid = function isValid(raw) {
  if (hasPrefix(raw, SHIFTED))
    return false;

  if (binet.isNull(raw))
    return false;

  if (binet.isBroadcast(raw))
    return false;

  if (binet.isRFC3849(raw))
    return false;

  return true;
};

/**
 * Test whether the ip is routable.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

binet.isRoutable = function isRoutable(raw) {
  if (!binet.isValid(raw))
    return false;

  if (binet.isRFC1918(raw))
    return false;

  if (binet.isRFC2544(raw))
    return false;

  if (binet.isRFC3927(raw))
    return false;

  if (binet.isRFC4862(raw))
    return false;

  if (binet.isRFC6598(raw))
    return false;

  if (binet.isRFC5737(raw))
    return false;

  if (binet.isRFC4193(raw) && !binet.isOnion(raw))
    return false;

  if (binet.isRFC4843(raw))
    return false;

  if (binet.isRFC7343(raw))
    return false;

  if (binet.isLocal(raw))
    return false;

  return true;
};

/**
 * Get addr network. Similar to
 * type, but includes teredo.
 * @param {Buffer} raw
 * @returns {Number}
 */

binet.getNetwork = function getNetwork(raw) {
  if (!binet.isRoutable(raw))
    return networks.NONE;

  if (binet.isIPv4(raw))
    return networks.INET4;

  if (binet.isRFC4380(raw))
    return networks.TEREDO;

  if (binet.isOnion(raw))
    return networks.ONION;

  return networks.INET6;
};

/**
 * Calculate reachable score from source to destination.
 * @param {Buffer} src
 * @param {Buffer} dest
 * @returns {Number} Ranges from 0-6.
 */

binet.getReachability = function getReachability(src, dest) {
  const UNREACHABLE = 0;
  const DEFAULT = 1;
  const TEREDO = 2;
  const IPV6_WEAK = 3;
  const IPV4 = 4;
  const IPV6_STRONG = 5;
  const PRIVATE = 6;

  if (!binet.isRoutable(src))
    return UNREACHABLE;

  const srcNet = binet.getNetwork(src);
  const destNet = binet.getNetwork(dest);

  switch (destNet) {
    case networks.INET4:
      switch (srcNet) {
        case networks.INET4:
          return IPV4;
        default:
          return DEFAULT;
      }
      break;
    case networks.INET6:
      switch (srcNet) {
        case networks.TEREDO:
          return TEREDO;
        case networks.INET4:
          return IPV4;
        case networks.INET6:
          if (binet.isRFC3964(src)
              || binet.isRFC6052(src)
              || binet.isRFC6145(src)) {
            // tunnel
            return IPV6_WEAK;
          }
          return IPV6_STRONG;
        default:
          return DEFAULT;
      }
      break;
    case networks.ONION:
      switch (srcNet) {
        case networks.INET4:
          return IPV4;
        case networks.ONION:
          return PRIVATE;
        default:
          return DEFAULT;
      }
      break;
    case networks.TEREDO:
      switch (srcNet) {
        case networks.TEREDO:
          return TEREDO;
        case networks.INET6:
          return IPV6_WEAK;
        case networks.INET4:
          return IPV4;
        default:
          return DEFAULT;
      }
      break;
    default:
      switch (srcNet) {
        case networks.TEREDO:
          return TEREDO;
        case networks.INET6:
          return IPV6_WEAK;
        case networks.INET4:
          return IPV4;
        case networks.ONION:
          return PRIVATE;
        default:
          return DEFAULT;
      }
      break;
  }
};

/**
 * Get IP address from network interfaces.
 * @private
 * @param {Number} filter
 * @param {Number} af
 * @returns {String}
 */

binet._interfaces = function _interfaces(filter, af) {
  if (typeof os.networkInterfaces !== 'function')
    return [];

  assert((filter >>> 0) === filter);

  const family = af2str(af);
  const interfaces = os.networkInterfaces();
  const result = [];
  const raw = POOL;

  for (const key of Object.keys(interfaces)) {
    const items = interfaces[key];

    for (const details of items) {
      if (family && details.family !== family)
        continue;

      try {
        binet.write(raw, details.address, 0, 16);
      } catch (e) {
        continue;
      }

      if (!binet.isValid(raw))
        continue;

      switch (af) {
        case types.NONE: {
          break;
        }
        case types.INET4: {
          if (!binet.isIPv4(raw))
            continue;
          break;
        }
        case types.INET6: {
          if (binet.isIPv4(raw))
            continue;
          break;
        }
      }

      switch (filter) {
        case ALL: {
          break;
        }
        case LOCAL: {
          if (!binet.isLocal(raw))
            continue;
          break;
        }
        case NONLOCAL: {
          if (binet.isLocal(raw))
            continue;
          break;
        }
        case PRIVATE: {
          if (binet.isLocal(raw))
            continue;

          if (binet.isRoutable(raw))
            continue;

          break;
        }
        case PUBLIC: {
          if (binet.isLocal(raw))
            continue;

          if (!binet.isRoutable(raw))
            continue;

          break;
        }
      }

      result.push(binet.encode(raw));
    }
  }

  return result;
};

/**
 * Get local IP from network interfaces.
 * @param {String?} family - IP family name.
 * @returns {String}
 */

binet.getInterfaces = function getInterfaces(family) {
  return binet._interfaces(ALL, str2af(family));
};

/**
 * Get local IP from network interfaces.
 * @param {String?} family - IP family name.
 * @returns {String}
 */

binet.getLocal = function getLocal(family) {
  return binet._interfaces(LOCAL, str2af(family));
};

/**
 * Get non-local IP from network interfaces.
 * @param {String?} family - IP family name.
 * @returns {String}
 */

binet.getNonlocal = function getNonlocal(family) {
  return binet._interfaces(NONLOCAL, str2af(family));
};

/**
 * Get private IP from network interfaces.
 * @param {String?} family - IP family name.
 * @returns {String}
 */

binet.getPrivate = function getPrivate(family) {
  return binet._interfaces(PRIVATE, str2af(family));
};

/**
 * Get public IP from network interfaces.
 * @param {String?} family - IP family name.
 * @returns {String}
 */

binet.getPublic = function getPublic(family) {
  return binet._interfaces(PUBLIC, str2af(family));
};

/*
 * Helpers
 */

function hasPrefix(raw, prefix) {
  assert((raw != null && raw._isBuffer === true));
  assert((prefix != null && prefix._isBuffer === true));
  assert(raw.length >= prefix.length);

  for (let i = 0; i < prefix.length; i++) {
    if (raw[i] !== prefix[i])
      return false;
  }

  return true;
}

function af2str(af) {
  assert((af >>> 0) === af);

  switch (af) {
    case types.NONE:
      return null;
    case types.INET4:
      return 'IPv4';
    case types.INET6:
      return 'IPv6';
  }

  throw new Error(`Invalid address family: ${af}.`);
}

function str2af(family) {
  if (family == null)
    return types.NONE;

  if ((family >>> 0) === family)
    return family;

  assert(typeof family === 'string');
  assert(family.length <= 4);

  const name = family.toLowerCase();

  switch (name) {
    case 'all':
      return types.NONE;
    case 'ipv4':
      return types.INET4;
    case 'ipv6':
      return types.INET6;
  }

  throw new Error(`Invalid address family: ${family}.`);
}

/*
 * Aliases
 */

binet.type = binet.getTypeString;
binet.family = binet.isIPString;
binet.test = binet.getTypeString;
binet.equal = binet.isEqualString;

/*
 * Compat (deprecated)
 */

types.NAME = 0;
types.DNS = 0;
types.IPV4 = 4;
types.IPV6 = 6;

binet.toString = binet.encode;
binet.toBuffer = binet.decode;
binet.toMapped = binet.map;
binet.isNameString = binet.isUnknownString;
binet.hasPrefix = hasPrefix;
binet.getStringType = binet.getTypeString;
binet.isV4String = binet.isIPv4String;
binet.isV6String = binet.isIPv6String;
binet.isDNSString = binet.isUnknownString;
binet.fromHostname = binet.fromHost;
binet.toHostname = binet.toHost;
binet.IP = binet;
binet.ip = binet;

/*
 * Expose
 */

binet.types = types;
binet.networks = networks;
binet.ZERO_IP = ZERO_IP;
binet.ZERO_IPV6 = ZERO_IP;
binet.ZERO_IPV4 = ZERO_IPV4;
binet.onion = onion;
binet.inet = inet;
}],
[/* 6 */ 'bpkg', '/lib/builtins/os.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * os-browserify@0.3.0
 * Copyright (c) 2019, CoderPuppy (MIT)
 * https://github.com/CoderPuppy/os-browserify#readme
 *
 * License for os-browserify@0.3.0:
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2017 CoderPuppy
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/* eslint no-var: "off" */
/* global location, navigator */



var os = exports;
var boot = Number(new Date());
var MAX_SAFE_INTEGER = 9007199254740991;

var BE = typeof Int8Array === 'function'
  ? new Int8Array(new Int16Array([1]).buffer)[0] === 0
  : false;

os.constants = {};

os.EOL = '\n';

os.arch = function() {
  return 'javascript';
};

os.cpus = function() {
  return [];
};

os.endianness = function() {
  return BE ? 'BE' : 'LE';
};

os.freemem = function() {
  return MAX_SAFE_INTEGER;
};

os.getPriority = function(pid) {
  return 0;
};

os.homedir = function() {
  return '/';
};

os.hostname = function() {
  if (typeof location === 'object' && location !== null) {
    if (typeof location.hostname === 'string')
      return location.hostname;
  }
  return 'localhost';
};

os.loadavg = function() {
  return [0, 0, 0];
};

os.networkInterfaces = function() {
  return {};
};

os.getNetworkInterfaces = os.networkInterfaces;

os.platform = function() {
  return 'browser';
};

os.release = function() {
  if (typeof navigator === 'object' && navigator !== null) {
    if (typeof navigator.appVersion === 'string')
      return navigator.appVersion;
  }
  return '';
};

os.setPriority = function(pid, priority) {};

os.tmpdir = function() {
  return '/tmp';
};

os.tmpDir = os.tmpdir;

os.totalmem = function() {
  return MAX_SAFE_INTEGER;
};

os.type = function() {
  return 'Browser';
};

os.uptime = function() {
  var now = Number(new Date()) - boot;

  if (now < 0) {
    boot = Number(new Date());
    now = 0;
  }

  return now / 1000;
};

os.userInfo = function(options) {
  return {
    uid: 0,
    gid: 0,
    username: 'root',
    homedir: '/',
    shell: '/bin/sh'
  };
};
}],
[/* 7 */ 'bs32', '/lib/bs32.js', function(exports, require, module, __filename, __dirname, __meta) {
module.exports = __browser_require__(8 /* './base32' */, module);
}],
[/* 8 */ 'bs32', '/lib/base32.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * base32.js - base32 for bcrypto
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on bitcoin/bitcoin:
 *   Copyright (c) 2009-2019, The Bitcoin Core Developers (MIT License).
 *   Copyright (c) 2009-2019, The Bitcoin Developers (MIT License).
 *   https://github.com/bitcoin/bitcoin
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc4648
 *   https://github.com/bitcoin/bitcoin/blob/11d486d/src/utilstrencodings.cpp#L230
 */



const assert = __browser_require__(2 /* 'bsert' */, module);

/*
 * Constants
 */

const CHARSET = 'abcdefghijklmnopqrstuvwxyz234567';
const TABLE = [
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, 26, 27, 28, 29, 30, 31, -1, -1, -1, -1, -1, -1, -1, -1,
  -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
  -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1
];

const CHARSET_HEX = '0123456789abcdefghijklmnopqrstuv';
const TABLE_HEX = [
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,
  -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
  25, 26, 27, 28, 29, 30, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
  25, 26, 27, 28, 29, 30, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1
];

const PADDING = [0, 6, 4, 3, 1];

/**
 * Encode a base32 string.
 * @param {Buffer} data
 * @param {Boolean} [pad=false]
 * @returns {String}
 */

function encode(data, pad = false) {
  return _encode(data, CHARSET, pad);
}

/**
 * Encode a base32hex string.
 * @param {Buffer} data
 * @param {Boolean} [pad=false]
 * @returns {String}
 */

function encodeHex(data, pad = false) {
  return _encode(data, CHARSET_HEX, pad);
}

/**
 * Encode a base32 string.
 * @private
 * @param {Buffer} data
 * @param {String} charset
 * @param {Boolean} [pad=false]
 * @returns {String}
 */

function _encode(data, charset, pad = false) {
  assert((data != null && data._isBuffer === true));
  assert(typeof pad === 'boolean');

  let str = '';
  let mode = 0;
  let left = 0;

  for (let i = 0; i < data.length; i++) {
    const ch = data[i];

    switch (mode) {
      case 0:
        str += charset[ch >>> 3];
        left = (ch & 7) << 2;
        mode = 1;
        break;
      case 1:
        str += charset[left | (ch >>> 6)];
        str += charset[(ch >>> 1) & 31];
        left = (ch & 1) << 4;
        mode = 2;
        break;
      case 2:
        str += charset[left | (ch >>> 4)];
        left = (ch & 15) << 1;
        mode = 3;
        break;
      case 3:
        str += charset[left | (ch >>> 7)];
        str += charset[(ch >>> 2) & 31];
        left = (ch & 3) << 3;
        mode = 4;
        break;
      case 4:
        str += charset[left | (ch >>> 5)];
        str += charset[ch & 31];
        mode = 0;
        break;
    }
  }

  if (mode > 0) {
    str += charset[left];
    if (pad) {
      for (let i = 0; i < PADDING[mode]; i++)
        str += '=';
    }
  }

  return str;
}

/**
 * Decode a base32 string.
 * @param {String} str
 * @param {Boolean} [unpad=false]
 * @returns {Buffer}
 */

function decode(str, unpad = false) {
  return _decode(str, TABLE, unpad);
}

/**
 * Decode a base32hex string.
 * @param {String} str
 * @param {Boolean} [unpad=false]
 * @returns {Buffer}
 */

function decodeHex(str, unpad = false) {
  return _decode(str, TABLE_HEX, unpad);
}

/**
 * Decode a base32 string.
 * @private
 * @param {String} str
 * @param {Array} table
 * @param {Boolean} [unpad=false]
 * @returns {Buffer}
 */

function _decode(str, table, unpad) {
  assert(typeof str === 'string');
  assert(typeof unpad === 'boolean');

  const data = Buffer.allocUnsafe((str.length * 5 + 7) / 8 | 0);

  let mode = 0;
  let left = 0;
  let j = 0;
  let i = 0;

  for (; i < str.length; i++) {
    const ch = str.charCodeAt(i);
    const v = (ch & 0xff80) ? -1 : table[ch];

    if (v === -1)
      break;

    switch (mode) {
      case 0:
        left = v;
        mode = 1;
        break;
      case 1:
        data[j++] = (left << 3) | (v >>> 2);
        left = v & 3;
        mode = 2;
        break;
      case 2:
        left = left << 5 | v;
        mode = 3;
        break;
      case 3:
        data[j++] = (left << 1) | (v >>> 4);
        left = v & 15;
        mode = 4;
        break;
      case 4:
        data[j++] = (left << 4) | (v >>> 1);
        left = v & 1;
        mode = 5;
        break;
      case 5:
        left = left << 5 | v;
        mode = 6;
        break;
      case 6:
        data[j++] = (left << 2) | (v >>> 3);
        left = v & 7;
        mode = 7;
        break;
      case 7:
        data[j++] = (left << 5) | v;
        left = 0;
        mode = 0;
        break;
    }
  }

  if (mode === 1 || mode === 3 || mode === 6)
    throw new Error('Invalid base32 string.');

  if (left > 0)
    throw new Error('Invalid base32 string.');

  if (str.length !== i + (-mode & 7) * unpad)
    throw new Error('Invalid base32 string.');

  for (; i < str.length; i++) {
    const ch = str.charCodeAt(i);

    if (ch !== 0x3d)
      throw new Error('Invalid base32 string.');
  }

  return data.slice(0, j);
}

/**
 * Test a base32 string.
 * @param {String} str
 * @param {Boolean} [unpad=false]
 * @returns {Buffer}
 */

function test(str, unpad = false) {
  try {
    decode(str, unpad);
    return true;
  } catch (e) {
    return false;
  }
}

/**
 * Test a base32 hex string.
 * @param {String} str
 * @param {Boolean} [unpad=false]
 * @returns {Buffer}
 */

function testHex(str, unpad = false) {
  try {
    decodeHex(str, unpad);
    return true;
  } catch (e) {
    return false;
  }
}

/*
 * Expose
 */

exports.encode = encode;
exports.encodeHex = encodeHex;
exports.decode = decode;
exports.decodeHex = decodeHex;
exports.test = test;
exports.testHex = testHex;
}],
[/* 9 */ 'binet', '/lib/inet.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * inet.js - inet pton/ntop for bcoin
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 *
 * Parts of this software are based on c-ares:
 *   Copyright (c) 2007-2018, Daniel Stenberg (MIT License)
 *   https://github.com/c-ares/c-ares
 *   https://github.com/c-ares/c-ares/blob/master/inet_net_pton.c
 *   https://github.com/c-ares/c-ares/blob/master/inet_ntop.c
 */

/* eslint spaced-comment: "off" */



const assert = __browser_require__(2 /* 'bsert' */, module);

/*
 * Constants
 */

const ENOENT = 1;
const EMSGSIZE = 2;

const POOL16 = Buffer.allocUnsafe(16);
const BUFFER16 = Buffer.allocUnsafe(16);
const UINT16 = new Uint16Array(16 / 2);

const CHARSET = [
  '0', '1', '2', '3', '4', '5', '6', '7',
  '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
];

const TABLE = new Int8Array([
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
   0,  1,  2,  3,  4,  5,  6,  7,
   8,  9, -1, -1, -1, -1, -1, -1,
  -1, 10, 11, 12, 13, 14, 15, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, 10, 11, 12, 13, 14, 15, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1
]);

/*
 * Presentation to Network
 */

/**
 * Convert IPv4 network string to network format.
 * @param {String} src - IP String
 * @param {Buffer} dst - buffer where to decode to
 * @param {Number} off - from where to start.
 * @returns {Number} - number of bits, either imputed classfully or specified
 *  with /CIDR, or -1 if some failure occurred (check errno).  ENOENT means it
 *  was not an IPv4 network specification.
 */

function pton4(src, dst, off) {
  if (dst == null)
    dst = null;

  if (off == null)
    off = 0;

  assert(typeof src === 'string');
  assert(dst === null || (dst != null && dst._isBuffer === true));
  assert((off >>> 0) === off);

  const start = off;

  let i = 0;
  let ch = -1;
  let first = -1;

  if (dst) {
    if (off + 4 > dst.length)
      return -ENOENT;
  }

  if (isHex(src, i)) {
    i += 2;

    let dirty = 0;
    let word = 0;
    let total = 0;

    for (; i < src.length; i++) {
      ch = byte(src, i);

      const n = TABLE[ch];

      if (n === -1)
        break;

      if (dirty === 0)
        word = n;
      else
        word = (word << 4) | n;

      total += 1;
      dirty += 1;

      if (total > 8)
        return -ENOENT;

      if (dirty === 2) {
        if ((off + 1) - start > 4)
          return -EMSGSIZE;

        if (dst)
          dst[off] = word;

        if (first === -1)
          first = word;

        off += 1;
        dirty = 0;
      }

      ch = -1;
    }

    if (dirty) {
      if ((off + 1) - start > 4)
        return -EMSGSIZE;

      if (dst)
        dst[off] = word << 4;

      if (first === -1)
        first = word << 4;

      off += 1;
    }
  } else if (isDecimal(src, i)) {
    let t = 0;

    for (;;) {
      let word = 0;
      let total = 0;

      for (; i < src.length; i++) {
        ch = byte(src, i);

        if (ch < 0x30 || ch > 0x39)
          break;

        word *= 10;
        word += ch - 0x30;
        total += 1;

        if (total > 3 || word > 255)
          return -ENOENT;

        ch = -1;
      }

      t += total;

      if (t > 12)
        return -ENOENT;

      if ((off + 1) - start > 4)
        return -EMSGSIZE;

      if (dst)
        dst[off] = word;

      if (first === -1)
        first = word;

      off += 1;

      if (ch === -1 || ch === 0x2f /*/*/)
        break;

      if (ch !== 0x2e /*.*/)
        return -ENOENT;

      i += 1;

      ch = byte(src, i);

      if (ch < 0x30 || ch > 0x39)
        return -ENOENT;
    }
  } else {
    return -ENOENT;
  }

  let bits = -1;

  if (isCIDR(src, i) && off > start) {
    i += 1;
    bits = 0;
    ch = -1;

    let total = 0;

    for (; i < src.length; i++) {
      ch = byte(src, i);

      if (ch < 0x30 || ch > 0x39)
        break;

      bits *= 10;
      bits += ch - 0x30;
      total += 1;

      if (total > 3 || bits > 32)
        return -ENOENT;

      ch = -1;
    }
  }

  if (ch !== -1)
    return -ENOENT;

  if (off === start)
    return -ENOENT;

  if (bits === -1) {
    assert(first !== -1);

    if (first >= 240)
      bits = 32;
    else if (first >= 224)
      bits = 8;
    else if (first >= 192)
      bits = 24;
    else if (first >= 128)
      bits = 16;
    else
      bits = 8;

    if (bits < (off - start) * 8)
      bits = (off - start) * 8;

    if (bits === 8 && first === 224)
      bits = 4;
  }

  assert(bits <= 32);

  const left = 4 - (off - start);
  assert(left >= 0 && left <= 4);

  if (dst) {
    assert(off + left <= dst.length);
    dst.fill(0x00, off, off + left);
  }

  off += left;

  return bits;
}

/**
 * Convert IPv6 network string to network format.
 * @param {String} src - IP String
 * @param {Buffer} dst - buffer where to decode to
 * @param {Number} off - from where to start.
 * @returns {Number} - number of bits, either imputed classfully or specified
 *  with /CIDR, or -1 if some failure occurred (check errno).  ENOENT means it
 *  was not an IPv6 network specification.
 */

function pton6(src, dst, off) {
  if (dst == null)
    dst = null;

  if (off == null)
    off = 0;

  assert(typeof src === 'string');
  assert(dst === null || (dst != null && dst._isBuffer === true));
  assert((off >>> 0) === off);

  const tmp = POOL16;

  let i = 0;
  let ptr = 0;
  let end = 16;
  let col = -1;
  let cur = 0;
  let digit = false;
  let word = 0;
  let digits = 0;
  let bits = -1;
  let inet4 = false;

  if (dst) {
    if (off + 16 > dst.length)
      return -EMSGSIZE;
  }

  if (isColon(src, i)) {
    if (!isColon(src, i + 1))
      return -ENOENT;
    i += 1;
  }

  tmp.fill(0x00, 0, 16);
  cur = i;

  for (; i < src.length; i++) {
    const ch = byte(src, i);
    const n = TABLE[ch];

    if (n !== -1) {
      word <<= 4;
      word |= n;

      digits += 1;

      if (digits > 4)
        return -ENOENT;

      digit = true;

      continue;
    }

    if (ch === 0x3a /*:*/) {
      cur = i + 1;

      if (!digit) {
        if (col !== -1)
          return -ENOENT;
        col = ptr;
        continue;
      }

      if (i === src.length)
        return -ENOENT;

      if (ptr + 2 > end)
        return -ENOENT;

      tmp[ptr++] = (word >>> 8) & 0xff;
      tmp[ptr++] = word & 0xff;

      digit = false;
      digits = 0;
      word = 0;

      continue;
    }

    if (ch === 0x2e /*.*/ && ptr + 4 <= end) {
      const b = getV4(src, cur, tmp, ptr);

      if (b !== -1) {
        if (b !== 0)
          bits = b;
        ptr += 4;
        digit = false;
        inet4 = true;
        break;
      }
    }

    if (ch === 0x2f /*/*/) {
      const b = getBits(src, i + 1);
      if (b !== -1) {
        bits = b;
        break;
      }
    }

    return -ENOENT;
  }

  if (digit) {
    if (ptr + 2 > end)
      return -ENOENT;

    tmp[ptr++] = (word >>> 8) & 0xff;
    tmp[ptr++] = word & 0xff;
  }

  if (bits === -1)
    bits = 128;

  assert(bits <= 128);

  let words = (bits + 15) / 16 | 0;

  if (words < 2)
    words = 2;

  if (inet4)
    words = 8;

  end = 2 * words;

  if (col !== -1) {
    const n = ptr - col;

    let i;

    if (ptr === end)
      return -ENOENT;

    for (i = 1; i <= n; i++) {
      tmp[end - i] = tmp[col + n - i];
      tmp[col + n - i] = 0;
    }

    ptr = end;
  }

  if (ptr !== end)
    return -ENOENT;

  const bytes = (bits + 7) / 8 | 0;
  const left = 16 - bytes;

  assert(bytes >= 0 && bytes <= 16);

  if (dst) {
    assert(off + bytes + left <= dst.length);
    off += tmp.copy(dst, off, 0, bytes);
    dst.fill(0x00, off, off + left);
    off += left;
  } else {
    off += bytes;
    off += left;
  }

  return bits;
}

function pton(af, src, dst, off) {
  if (dst == null)
    dst = null;

  if (off == null)
    off = 0;

  assert((af >>> 0) === af);
  assert(typeof src === 'string');
  assert(dst === null || (dst != null && dst._isBuffer === true));
  assert((off >>> 0) === off);

  if (af === 4)
    return pton4(src, dst, off);

  if (af === 6)
    return pton6(src, dst, off);

  return -ENOENT;
}

/*
 * Network to Presentation
 */

function ntop4(src, off) {
  if (off == null)
    off = 0;

  assert((src != null && src._isBuffer === true));
  assert((off >>> 0) === off);

  if (off + 4 > src.length)
    return '';

  let str = '';
  str += dec(src[off + 0]);
  str += '.';
  str += dec(src[off + 1]);
  str += '.';
  str += dec(src[off + 2]);
  str += '.';
  str += dec(src[off + 3]);

  return str;
}

function ntop6(src, off) {
  if (off == null)
    off = 0;

  assert((src != null && src._isBuffer === true));
  assert((off >>> 0) === off);

  if (off + 16 > src.length)
    return '';

  let bestBase = -1;
  let bestLen = 0;
  let curBase = -1;
  let curLen = 0;
  let str = '';

  const words = UINT16;

  for (let i = 0; i < 16; i++)
    words[i] = 0;

  for (let i = 0; i < 16; i++)
    words[i >>> 1] |= src[off + i] << ((1 - (i & 1)) << 3);

  for (let i = 0; i < (16 / 2); i++) {
    if (words[i] === 0) {
      if (curBase === -1) {
        curBase = i;
        curLen = 1;
      } else {
        curLen += 1;
      }
    } else {
      if (curBase !== -1) {
        if (bestBase === -1 || curLen > bestLen) {
          bestBase = curBase;
          bestLen = curLen;
        }
        curBase = -1;
      }
    }
  }

  if (curBase !== -1) {
    if (bestBase === -1 || curLen > bestLen) {
      bestBase = curBase;
      bestLen = curLen;
    }
  }

  if (bestBase !== -1 && bestLen < 2)
    bestBase = -1;

  for (let i = 0; i < (16 / 2); i++) {
    // Are we inside the best run of 0x00's?
    if (bestBase !== -1 && i >= bestBase && i < bestBase + bestLen) {
      if (i === bestBase)
        str += ':';
      continue;
    }

    // Are we following an initial run of 0x00s or any real hex?
    if (i !== 0)
      str += ':';

    // Is this address an encapsulated IPv4?
    if (i === 6
        && bestBase === 0
        && (bestLen === 6
        || (bestLen === 7 && words[7] !== 0x0001)
        || (bestLen === 5 && words[5] === 0xffff))) {
      const s = ntop4(src, off + 12);

      if (!s)
        return '';

      str += s;

      break;
    }

    str += hex(words[i]);
  }

  // Was it a trailing run of 0x00's?
  if (bestBase !== -1 && bestBase + bestLen === 16 / 2)
    str += ':';

  return str;
}

function ntop(af, src, off) {
  if (off == null)
    off = 0;

  assert((af >>> 0) === af);
  assert((src != null && src._isBuffer === true));
  assert((off >>> 0) === off);

  if (af === 4)
    return ntop4(src, off);

  if (af === 6)
    return ntop6(src, off);

  return '';
}

/*
 * Public Helpers
 */

function family(str) {
  if (pton4(str, null, 0) >= 0)
    return 4;

  if (pton6(str, null, 0) >= 0)
    return 6;

  return 0;
}

/**
 * IPv4 Mapped - RFC 2765
 * @param {Buffer} raw
 * @param {Number} off
 * @returns {Boolean}
 */

function mapped(raw, off) {
  if (off == null)
    off = 0;

  assert((raw != null && raw._isBuffer === true));
  assert((off >>> 0) === off);

  if (off + 12 > raw.length)
    return false;

  return raw[off++] === 0x00
      && raw[off++] === 0x00
      && raw[off++] === 0x00
      && raw[off++] === 0x00
      && raw[off++] === 0x00
      && raw[off++] === 0x00
      && raw[off++] === 0x00
      && raw[off++] === 0x00
      && raw[off++] === 0x00
      && raw[off++] === 0x00
      && raw[off++] === 0xff
      && raw[off++] === 0xff;
}

function onion(raw, off) {
  if (off == null)
    off = 0;

  assert((raw != null && raw._isBuffer === true));
  assert((off >>> 0) === off);

  if (off + 6 > raw.length)
    return false;

  return raw[off++] === 0xfd
      && raw[off++] === 0x87
      && raw[off++] === 0xd8
      && raw[off++] === 0x7e
      && raw[off++] === 0xeb
      && raw[off++] === 0x43;
}

function normalize(str) {
  const raw = BUFFER16;

  if (pton4(str, raw, 0) >= 0)
    return ntop4(raw, 0);

  if (pton6(str, raw, 0) >= 0)
    return ntop6(raw, 0);

  return '';
}

/*
 * Helpers
 */

function byte(str, i) {
  const ch = str.charCodeAt(i);

  if (ch & 0xff80)
    return 0x00;

  return ch;
}

function dec(ch, i) {
  return ch.toString(10);
}

function hex(w) {
  let str = '';

  for (let i = 3; i >= 0; i--) {
    const n = (w >>> (i * 4)) & 0x0f;

    if (n === 0 && str.length === 0)
      continue;

    str += CHARSET[n];
  }

  if (str.length === 0)
    str += CHARSET[0];

  return str;
}

function isDecimal(str, i) {
  if (i + 1 > str.length)
    return false;

  const ch = byte(str, i);

  return ch >= 0x30 && ch <= 0x39;
}

function isHex(str, i) {
  if (i + 3 > str.length)
    return false;

  const a = byte(str, i);

  if (a !== 0x30 /*0*/)
    return false;

  const b = byte(str, i + 1);

  if (b !== 0x58 /*X*/ && b !== 0x78 /*x*/)
    return false;

  const c = byte(str, i + 2);

  if (TABLE[c] === -1)
    return false;

  return true;
}

function isCIDR(str, i) {
  if (i + 2 > str.length)
    return false;

  const a = byte(str, i);

  if (a !== 0x2f /*/*/)
    return false;

  const b = byte(str, i + 1);

  if (b < 0x30 || b > 0x39)
    return false;

  return true;
}

function isColon(str, i) {
  if (i + 1 > str.length)
    return false;

  return byte(str, i) === 0x3a /*:*/;
}

function getBits(src, i) {
  let word = 0;
  let total = 0;

  for (; i < src.length; i++) {
    const ch = byte(src, i);

    if (ch < 0x30 || ch > 0x39)
      return -1;

    if (total > 0 && word === 0)
      return -1;

    word *= 10;
    word += ch - 0x30;
    total += 1;

    if (total > 3 || word > 128)
      return -1;
  }

  if (total === 0)
    return -1;

  return word;
}

function getV4(src, i, dst, off) {
  const start = off;

  let word = 0;
  let total = 0;

  for (; i < src.length; i++) {
    const ch = byte(src, i);

    if (ch >= 0x30 && ch <= 0x39) {
      if (total > 0 && word === 0)
        return -1;

      word *= 10;
      word += ch - 0x30;
      total += 1;

      if (total > 3 || word > 255)
        return -1;

      continue;
    }

    if (ch === 0x2e /*.*/ || ch === 0x2f /*/*/) {
      if (off - start > 3)
        return -1;

      if (dst) {
        if (off + 1 > dst.length)
          return -1;
        dst[off] = word;
      }

      off += 1;

      if (ch === 0x2f)
        return getBits(src, i + 1);

      word = 0;
      total = 0;

      continue;
    }

    return -1;
  }

  if (total === 0)
    return -1;

  if (off - start > 3)
    return -1;

  if (dst) {
    if (off + 1 > dst.length)
      return -1;
    dst[off] = word;
  }

  off += 1;

  return 0;
}

/*
 * Expose
 */

exports.pton4 = pton4;
exports.pton6 = pton6;
exports.pton = pton;

exports.ntop4 = ntop4;
exports.ntop6 = ntop6;
exports.ntop = ntop;

exports.family = family;
exports.mapped = mapped;
exports.onion = onion;
exports.normalize = normalize;
}],
[/* 10 */ 'binet', '/lib/onion.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * onion.js - onion utils for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License).
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 *
 * Parts of this software are based on node-ip.
 * https://github.com/indutny/node-ip
 * Copyright (c) 2012, Fedor Indutny (MIT License).
 */

/* eslint no-unreachable: "off" */



const assert = __browser_require__(2 /* 'bsert' */, module);
const base32 = __browser_require__(7 /* 'bs32' */, module);
const onion = exports;

/**
 * Test whether a string is an onion address.
 * @param {String?} str
 * @returns {Boolean}
 */

onion.isString = function isString(str) {
  return onion.isLegacyString(str) || onion.isNGString(str);
};

/**
 * Test whether the buffer is a tor onion.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

onion.is = function is(raw) {
  return onion.isLegacy(raw) || onion.isNG(raw);
};

/**
 * Encode onion address.
 * @param {Buffer} key
 * @param {Function} sha3
 * @returns {String}
 */

onion.encode = function encode(raw, sha3) {
  if (onion.isLegacy(raw))
    return onion.encodeLegacy(raw);

  if (onion.isNG(raw))
    return onion.encodeNG(raw, sha3);

  throw new Error('Not an onion buffer.');
};

/**
 * Decode onion address.
 * @param {String} str
 * @param {Function} sha3
 * @returns {Buffer}
 */

onion.decode = function decode(str, sha3) {
  if (onion.isLegacyString(str))
    return onion.decodeLegacy(str);

  if (onion.isNGString(str))
    return onion.decodeNG(str, sha3);

  throw new Error('Not an onion string.');
};

/**
 * Normalize onion address.
 * @param {String} str
 * @param {Function} sha3
 * @returns {String}
 */

onion.normalize = function normalize(str, sha3) {
  if (onion.isLegacyString(str))
    return onion.normalizeLegacy(str);

  if (onion.isNGString(str))
    return onion.normalizeNG(str, sha3);

  throw new Error('Not an onion string.');
};

/**
 * Test whether a string is an onion address.
 * @param {String?} str
 * @returns {Boolean}
 */

onion.isLegacyString = function isLegacyString(str) {
  assert(typeof str === 'string');

  if (str.length !== 16 + 6)
    return false;

  return str.slice(-6).toLowerCase() === '.onion';
};

/**
 * Test whether the buffer is a tor onion.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

onion.isLegacy = function isLegacy(raw) {
  assert((raw != null && raw._isBuffer === true));
  return raw.length === 10;
};

/**
 * Encode onion address.
 * @param {Buffer} key
 * @returns {String}
 */

onion.encodeLegacy = function encodeLegacy(raw) {
  assert(onion.isLegacy(raw));
  const host = base32.encode(raw);
  return `${host}.onion`;
};

/**
 * Decode onion address.
 * @param {String} str
 * @returns {Buffer}
 */

onion.decodeLegacy = function decodeLegacy(str) {
  assert(onion.isLegacyString(str));
  const data = base32.decode(str.slice(0, -6));
  assert(data.length === 10, 'Invalid onion address.');
  return data;
};

/**
 * Normalize onion address.
 * @param {String} str
 * @returns {String}
 */

onion.normalizeLegacy = function normalizeLegacy(str) {
  return onion.encodeLegacy(onion.decodeLegacy(str));
};

/**
 * Test whether a string is an onion-ng address.
 * @param {String?} str
 * @returns {Boolean}
 */

onion.isNGString = function isNGString(str) {
  assert(typeof str === 'string');

  if (str.length !== 56 + 6)
    return false;

  return str.slice(-6).toLowerCase() === '.onion';
};

/**
 * Test whether the address
 * is an onion-ng buffer.
 * @param {Buffer} raw
 * @returns {Boolean}
 */

onion.isNG = function isNG(raw) {
  assert((raw != null && raw._isBuffer === true));
  return raw.length === 33;
};

/**
 * Encode onion-ng address.
 * @see https://github.com/torproject/torspec/blob/master/proposals/224-rend-spec-ng.txt
 * @see https://github.com/torproject/tor/blob/master/src/or/hs_common.c
 * @param {Buffer} key
 * @param {Function} sha3
 * @returns {String}
 */

onion.encodeNG = function encodeNG(key, sha3) {
  assert((key != null && key._isBuffer === true));
  assert(key.length === 33);

  // onion_address = base32(PUBKEY | CHECKSUM | VERSION) + ".onion"
  const data = Buffer.alloc(32 + 2 + 1);

  // Ed25519 Pubkey
  key.copy(data, 0, 1, 33);

  // Checksum
  const chk = checksum(key, sha3);
  data[32] = chk >>> 8;
  data[33] = chk & 0xff;

  // Version
  data[34] = key[0];

  const host = base32.encode(data);

  return `${host}.onion`;
};

/**
 * Decode onion-ng address.
 * @see https://github.com/torproject/torspec/blob/master/proposals/224-rend-spec-ng.txt
 * @see https://github.com/torproject/tor/blob/master/src/or/hs_common.c
 * @param {String} str
 * @param {Function} sha3
 * @returns {Buffer}
 */

onion.decodeNG = function decodeNG(str, sha3) {
  // onion_address = base32(PUBKEY | CHECKSUM | VERSION) + ".onion"
  assert(onion.isNGString(str), 'Invalid onion address.');

  const data = base32.decode(str.slice(0, -6));
  assert(data.length === 35, 'Invalid onion address.');

  // Ed25519 Pubkey
  const key = Buffer.alloc(1 + 32);

  // Version
  key[0] = data[34];

  // Key
  data.copy(key, 1, 0, 32);

  // Checksum
  assert(verify(key, data, sha3), 'Invalid checksum for onion address.');

  return key;
};

/**
 * Normalize onion-ng address.
 * @param {String} str
 * @param {Function} sha3
 * @returns {String}
 */

onion.normalizeNG = function normalizeNG(str, sha3) {
  return onion.encodeNG(onion.decodeNG(str, sha3), sha3);
};

/*
 * Helpers
 */

function checksum(key, sha3) {
  assert((key != null && key._isBuffer === true));
  assert(key.length === 33);

  if (sha3 == null)
    return 0;

  assert(typeof sha3 === 'function');

  // CHECKSUM = H(".onion checksum" | PUBKEY | VERSION)[:2]
  const buf = Buffer.alloc(15 + 32 + 1);
  buf.write('.onion checksum', 0, 15, 'ascii');
  key.copy(buf, 15, 1, 33);
  buf[47] = key[0];

  return sha3(buf).readUInt16BE(0);
}

function verify(key, data, sha3) {
  assert((data != null && data._isBuffer === true));
  assert(data.length === 35);

  if (sha3 == null)
    return true;

  const chk = data.readUInt16BE(32);
  return chk === checksum(key, sha3);
}
}],
[/* 11 */ 'bns-plus', '/lib/constants.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * constants.js - constants for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 *
 * Parts of this software are based on miekg/dns and golang/go:
 *   https://github.com/miekg/dns/blob/master/msg.go
 *   https://github.com/miekg/dns/blob/master/types.go
 *   https://github.com/golang/go/blob/master/src/net/dnsmsg.go
 *
 * Resources:
 *   https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml
 */



/**
 * Message Opcodes
 * @enum {Number}
 * @default
 */

const opcodes = {
  QUERY: 0,
  IQUERY: 1,
  STATUS: 2,
  // 3 is unassigned
  NOTIFY: 4,
  UPDATE: 5
  // 6-15 are unassigned
};

/**
 * Message Opcodes By Value
 * @enum {String}
 * @default
 */

const opcodesByVal = {
  [opcodes.QUERY]: 'QUERY',
  [opcodes.IQUERY]: 'IQUERY',
  [opcodes.STATUS]: 'STATUS',
  [opcodes.NOTIFY]: 'NOTIFY',
  [opcodes.UPDATE]: 'UPDATE'
};

/**
 * Message Flags
 * @enum {Number}
 * @default
 */

const flags = {
  QR: 1 << 15, // query/response (response=1)
  AA: 1 << 10, // authoritative
  TC: 1 << 9,  // truncated
  RD: 1 << 8,  // recursion desired
  RA: 1 << 7,  // recursion available
  Z: 1 << 6,  // Z
  AD: 1 << 5,  // authenticated data
  CD: 1 << 4  // checking disabled
};

/**
 * Message Flags By Value
 * @enum {String}
 * @default
 */

const flagsByVal = {
  [flags.QR]: 'QR',
  [flags.AA]: 'AA',
  [flags.TC]: 'TC',
  [flags.RD]: 'RD',
  [flags.RA]: 'RA',
  [flags.Z]: 'Z',
  [flags.AD]: 'AD',
  [flags.CD]: 'CD'
};

/**
 * Response Codes (rcodes)
 * @see https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml
 * @enum {Number}
 * @default
 */

const codes = {
  NOERROR: 0, // No Error
  SUCCESS: 0, // No Error
  FORMERR: 1, // Format Error
  SERVFAIL: 2, // Server Failure
  NXDOMAIN: 3, // Non-Existent Domain
  NOTIMP: 4, // Not Implemented
  REFUSED: 5, // Query Refused
  YXDOMAIN: 6, // Name Exists when it should not
  YXRRSET: 7, // RR Set Exists when it should not
  NXRRSET: 8, // RR Set that should exist does not
  NOTAUTH: 9, // Server Not Authoritative for zone
  NOTZONE: 10, // Name not contained in zone

  // 11-15 are unassigned

  // EDNS
  BADSIG: 16, // TSIG Signature Failure
  BADVERS: 16, // Bad OPT Version
  BADKEY: 17, // Key not recognized
  BADTIME: 18, // Signature out of time window
  BADMODE: 19, // Bad TKEY Mode
  BADNAME: 20, // Duplicate key name
  BADALG: 21, // Algorithm not supported
  BADTRUNC: 22, // Bad Truncation
  BADCOOKIE: 23, // Bad/missing Server Cookie

  // 24-3840 are unassigned

  // 3841-4095 reserved for private use

  // 4096-65534 unassigned

  RESERVED: 65535
};

/**
 * Response Codes By Value
 * @enum {String}
 * @default
 */

const codesByVal = {
  [codes.NOERROR]: 'NOERROR',
  [codes.FORMERR]: 'FORMERR',
  [codes.SERVFAIL]: 'SERVFAIL',
  [codes.NXDOMAIN]: 'NXDOMAIN',
  [codes.NOTIMP]: 'NOTIMP',
  [codes.REFUSED]: 'REFUSED',
  [codes.YXDOMAIN]: 'YXDOMAIN',
  [codes.YXRRSET]: 'YXRRSET',
  [codes.NXRRSET]: 'NXRRSET',
  [codes.NOTAUTH]: 'NOTAUTH',
  [codes.NOTZONE]: 'NOTZONE',
  // edns
  [codes.BADVERS]: 'BADVERS',
  [codes.BADKEY]: 'BADKEY',
  [codes.BADTIME]: 'BADTIME',
  [codes.BADMODE]: 'BADMODE',
  [codes.BADNAME]: 'BADNAME',
  [codes.BADALG]: 'BADALG',
  [codes.BADTRUNC]: 'BADTRUNC',
  [codes.BADCOOKIE]: 'BADCOOKIE',
  [codes.RESERVED]: 'RESERVED'
};

/**
 * Record Types (rrtypes)
 * @enum {Number}
 * @default
 */

const types = {
  UNKNOWN: 0,
  A: 1,
  NS: 2,
  MD: 3, // obsolete
  MF: 4, // obsolete
  CNAME: 5,
  SOA: 6,
  MB: 7, // experimental
  MG: 8, // experimental
  MR: 9, // experimental
  NULL: 10, // obsolete
  WKS: 11, // deprecated
  PTR: 12,
  HINFO: 13, // not-in-use
  MINFO: 14, // experimental
  MX: 15,
  TXT: 16,
  RP: 17,
  AFSDB: 18,
  X25: 19, // not-in-use
  ISDN: 20, // not-in-use
  RT: 21, // not-in-use
  NSAP: 22, // not-in-use
  NSAPPTR: 23, // not-in-use
  SIG: 24, // obsolete
  KEY: 25, // obsolete
  PX: 26, // not-in-use
  GPOS: 27, // deprecated
  AAAA: 28,
  LOC: 29,
  NXT: 30, // obsolete
  EID: 31, // not-in-use
  NIMLOC: 32, // not-in-use (used to be NB)
  SRV: 33, // used to be NBSTAT
  ATMA: 34, // not-in-use
  NAPTR: 35,
  KX: 36,
  CERT: 37,
  A6: 38, // historic
  DNAME: 39,
  SINK: 40, // unimpl (joke?)
  OPT: 41, // impl (pseudo-record, edns)
  APL: 42, // not-in-use
  DS: 43,
  SSHFP: 44,
  IPSECKEY: 45,
  RRSIG: 46,
  NSEC: 47,
  DNSKEY: 48,
  DHCID: 49,
  NSEC3: 50,
  NSEC3PARAM: 51,
  TLSA: 52,
  SMIMEA: 53,

  // 54 is unassigned

  HIP: 55,
  NINFO: 56, // proposed
  RKEY: 57, // proposed
  TALINK: 58, // proposed
  CDS: 59,
  CDNSKEY: 60,
  OPENPGPKEY: 61,
  CSYNC: 62,

  // 63-98 are unassigned

  SPF: 99, // obsolete
  UINFO: 100, // obsolete
  UID: 101, // obsolete
  GID: 102, // obsolete
  UNSPEC: 103, // obsolete
  NID: 104,
  L32: 105,
  L64: 106,
  LP: 107,
  EUI48: 108,
  EUI64: 109,

  // 110-248 are unassigned

  TKEY: 249,
  TSIG: 250,
  IXFR: 251, // unimpl (pseudo-record)
  AXFR: 252, // unimpl (pseudo-record)
  MAILB: 253, // experimental, unimpl (qtype)
  MAILA: 254, // obsolete, unimpl (qtype)

  ANY: 255, // impl (qtype)
  URI: 256,
  CAA: 257,
  AVC: 258, // proposed
  DOA: 259, // proposed
  // OX: 260, // proposed successor to DOA?

  // 260-32767 are unassigned

  TA: 32768,
  DLV: 32769,

  // 32770-65279 are unassigned
  // 65280-65534 reserved for private use

  RESERVED: 65535 // unimpl
};

/**
 * Record Types by value
 * @enum {String}
 * @default
 */

const typesByVal = {
  [types.UNKNOWN]: 'UNKNOWN',
  [types.A]: 'A',
  [types.NS]: 'NS',
  [types.MD]: 'MD',
  [types.MF]: 'MF',
  [types.CNAME]: 'CNAME',
  [types.SOA]: 'SOA',
  [types.MB]: 'MB',
  [types.MG]: 'MG',
  [types.MR]: 'MR',
  [types.NULL]: 'NULL',
  [types.WKS]: 'WKS',
  [types.PTR]: 'PTR',
  [types.HINFO]: 'HINFO',
  [types.MINFO]: 'MINFO',
  [types.MX]: 'MX',
  [types.TXT]: 'TXT',
  [types.RP]: 'RP',
  [types.AFSDB]: 'AFSDB',
  [types.X25]: 'X25',
  [types.ISDN]: 'ISDN',
  [types.RT]: 'RT',
  [types.NSAP]: 'NSAP',
  [types.NSAPPTR]: 'NSAPPTR',
  [types.SIG]: 'SIG',
  [types.KEY]: 'KEY',
  [types.PX]: 'PX',
  [types.GPOS]: 'GPOS',
  [types.AAAA]: 'AAAA',
  [types.LOC]: 'LOC',
  [types.NXT]: 'NXT',
  [types.EID]: 'EID',
  [types.NIMLOC]: 'NIMLOC',
  [types.SRV]: 'SRV',
  [types.ATMA]: 'ATMA',
  [types.NAPTR]: 'NAPTR',
  [types.KX]: 'KX',
  [types.CERT]: 'CERT',
  [types.A6]: 'A6',
  [types.DNAME]: 'DNAME',
  [types.SINK]: 'SINK',
  [types.OPT]: 'OPT',
  [types.APL]: 'APL',
  [types.DS]: 'DS',
  [types.SSHFP]: 'SSHFP',
  [types.IPSECKEY]: 'IPSECKEY',
  [types.RRSIG]: 'RRSIG',
  [types.NSEC]: 'NSEC',
  [types.DNSKEY]: 'DNSKEY',
  [types.DHCID]: 'DHCID',
  [types.NSEC3]: 'NSEC3',
  [types.NSEC3PARAM]: 'NSEC3PARAM',
  [types.TLSA]: 'TLSA',
  [types.SMIMEA]: 'SMIMEA',
  [types.HIP]: 'HIP',
  [types.NINFO]: 'NINFO',
  [types.RKEY]: 'RKEY',
  [types.TALINK]: 'TALINK',
  [types.CDS]: 'CDS',
  [types.CDNSKEY]: 'CDNSKEY',
  [types.OPENPGPKEY]: 'OPENPGPKEY',
  [types.CSYNC]: 'CSYNC',
  [types.SPF]: 'SPF',
  [types.UINFO]: 'UINFO',
  [types.UID]: 'UID',
  [types.GID]: 'GID',
  [types.UNSPEC]: 'UNSPEC',
  [types.NID]: 'NID',
  [types.L32]: 'L32',
  [types.L64]: 'L64',
  [types.LP]: 'LP',
  [types.EUI48]: 'EUI48',
  [types.EUI64]: 'EUI64',
  [types.TKEY]: 'TKEY',
  [types.TSIG]: 'TSIG',
  [types.IXFR]: 'IXFR',
  [types.AXFR]: 'AXFR',
  [types.MAILB]: 'MAILB',
  [types.MAILA]: 'MAILA',
  [types.URI]: 'URI',
  [types.CAA]: 'CAA',
  [types.AVC]: 'AVC',
  [types.DOA]: 'DOA',
  // [types.OX]: 'OX',
  [types.ANY]: 'ANY',
  [types.TA]: 'TA',
  [types.DLV]: 'DLV',
  [types.RESERVED]: 'RESERVED'
};

/**
 * Question and Record Classes (qclass/rclass)
 * @enum {Number}
 * @default
 */

const classes = {
  RESERVED0: 0,
  IN: 1, // INET

  // 2 is unassigned (used to be CSNET/CS)

  CH: 3, // CHAOS
  HS: 4, // HESIOD

  // 5-253 are unassigned

  NONE: 254,
  ANY: 255,

  // 256-65279 are unassigned
  // 65280-65534 are reserved for private use

  RESERVED65535: 65535
};

/**
 * Question and Record Classes By Value
 * @enum {String}
 * @default
 */

const classesByVal = {
  [classes.RESERVED0]: 'RESERVED0',
  [classes.IN]: 'IN',
  [classes.CH]: 'CH',
  [classes.HS]: 'HS',
  [classes.NONE]: 'NONE',
  [classes.ANY]: 'ANY',
  [classes.RESERVED65535]: 'RESERVED65535'
};

/**
 * EDNS0 Flags
 * @enum {Number}
 * @default
 */

const eflags = {
  DO: 1 << 15 // DNSSEC OK
  // 1-15 are reserved
};

/**
 * EDNS0 Flags by value
 * @enum {Number}
 * @default
 */

const eflagsByVal = {
  [eflags.DO]: 'DO'
};

/**
 * EDNS0 Option Codes
 * @enum {Number}
 * @default
 */

const options = {
  RESERVED: 0, // None
  LLQ: 1, // Long Lived Queries
  UL: 2, // Update Lease Draft
  NSID: 3, // Nameserver Identifier
  DAU: 5, // DNSSEC Algorithm Understood
  DHU: 6, // DS Hash Understood
  N3U: 7, // NSEC3 Hash Understood
  SUBNET: 8, // Client Subnet
  EXPIRE: 9, // Expire
  COOKIE: 10, // Cookie
  TCPKEEPALIVE: 11, // TCP Keep-Alive
  PADDING: 12, // Padding
  CHAIN: 13, // Chain
  KEYTAG: 14, // EDNS Key Tag

  // 15-26945 are unassigned

  // DEVICEID: 26946,

  // 26947-65000 are unassigned

  LOCAL: 65001, // Beginning of range reserved for local/experimental use
  LOCALSTART: 65001, // Beginning of range reserved for local/experimental use

  // 65001-65534 are reserved for experimental use

  LOCALEND: 65534 // End of range reserved for local/experimental use

  // 65535 is reserved
};

/**
 * EDNS0 Option Codes By Value
 * @enum {Number}
 * @default
 */

const optionsByVal = {
  [options.RESERVED]: 'RESERVED',
  [options.LLQ]: 'LLQ',
  [options.UL]: 'UL',
  [options.NSID]: 'NSID',
  [options.DAU]: 'DAU',
  [options.DHU]: 'DHU',
  [options.N3U]: 'N3U',
  [options.SUBNET]: 'SUBNET',
  [options.EXPIRE]: 'EXPIRE',
  [options.COOKIE]: 'COOKIE',
  [options.TCPKEEPALIVE]: 'TCPKEEPALIVE',
  [options.PADDING]: 'PADDING',
  [options.CHAIN]: 'CHAIN',
  [options.KEYTAG]: 'KEYTAG',
  // [options.DEVICEID]: 'DEVICEID',
  [options.LOCAL]: 'LOCAL'
};

/**
 * DNSKEY flag values.
 * See RFC4034, Section 2.1.1
 * Note that their endianness is backwards,
 * Subtract each bit value from 15 to convert.
 * @see https://www.ietf.org/rfc/rfc4034.txt
 * @enum {Number}
 * @default
 */

const keyFlags = {
  KSK: 1 << 0,
  SEP: 1 << 0,
  // 1-6 reserved
  REVOKE: 1 << 7,
  ZONE: 1 << 8
  // 9-15 reserved
};

/**
 * DNSSEC encryption algorithm codes.
 * @enum {Number}
 * @default
 */

const algs = {
  // _: 0,
  RSAMD5: 1,
  DH: 2,
  DSA: 3,
  ECC: 4,
  RSASHA1: 5,
  DSANSEC3SHA1: 6,
  RSASHA1NSEC3SHA1: 7,
  RSASHA256: 8,
  // _: 9,
  RSASHA512: 10,
  // _: 11,
  ECCGOST: 12,
  ECDSAP256SHA256: 13,
  ECDSAP384SHA384: 14,
  ED25519: 15,
  ED448: 16,
  INDIRECT: 252,
  PRIVATEDNS: 253, // Private (experimental keys)
  PRIVATEOID: 254
};

/**
 * DNSSEC algorithm codes by value.
 * @const {Object}
 */

const algsByVal = {
  [algs.RSAMD5]: 'RSAMD5',
  [algs.DH]: 'DH',
  [algs.DSA]: 'DSA',
  [algs.ECC]: 'ECC',
  [algs.RSASHA1]: 'RSASHA1',
  [algs.DSANSEC3SHA1]: 'DSANSEC3SHA1',
  [algs.RSASHA1NSEC3SHA1]: 'RSASHA1NSEC3SHA1',
  [algs.RSASHA256]: 'RSASHA256',
  [algs.RSASHA512]: 'RSASHA512',
  [algs.ECCGOST]: 'ECCGOST',
  [algs.ECDSAP256SHA256]: 'ECDSAP256SHA256',
  [algs.ECDSAP384SHA384]: 'ECDSAP384SHA384',
  [algs.ED25519]: 'ED25519',
  [algs.ED448]: 'ED448',
  [algs.INDIRECT]: 'INDIRECT',
  [algs.PRIVATEDNS]: 'PRIVATEDNS',
  [algs.PRIVATEOID]: 'PRIVATEOID'
};

/**
 * DNSSEC hashing algorithm codes.
 * @enum {Number}
 * @default
 */

const hashes = {
  // _: 0,
  SHA1: 1, // RFC 4034
  SHA256: 2, // RFC 4509
  GOST94: 3, // RFC 5933
  SHA384: 4, // Experimental
  SHA512: 5 // Experimental
};

/**
 * DNSSEC hashing algorithm codes by value.
 * @const {Object}
 */

const hashesByVal = {
  [hashes.SHA1]: 'SHA1',
  [hashes.SHA256]: 'SHA256',
  [hashes.GOST94]: 'GOST94',
  [hashes.SHA384]: 'SHA384',
  [hashes.SHA512]: 'SHA512'
};

/**
 * Corresponding hashes for algorithms.
 * @const {Object}
 */

const algHashes = {
  [algs.RSAMD5]: null, // Deprecated in RFC 6725 (introduced in rfc2537)
  [algs.DSA]: hashes.SHA1,
  [algs.RSASHA1]: hashes.SHA1,
  [algs.DSANSEC3SHA1]: hashes.SHA1,
  [algs.RSASHA1NSEC3SHA1]: hashes.SHA1,
  [algs.RSASHA256]: hashes.SHA256,
  [algs.ECDSAP256SHA256]: hashes.SHA256,
  [algs.ECDSAP384SHA384]: hashes.SHA384,
  [algs.RSASHA512]: hashes.SHA512,
  [algs.ED25519]: null,
  [algs.ED448]: null
};

/**
 * NSEC3 hashes.
 * @enum {Number}
 * @default
 */

const nsecHashes = {
  SHA1: 1
};

/**
 * NSEC3 hashes by value.
 * @const {Object}
 */

const nsecHashesByVal = {
  [nsecHashes.SHA1]: 'SHA1'
};

/**
 * CERT types (rfc4398).
 * @enum {Number}
 * @default
 */

const certTypes = {
  // 0 reserved
  PKIX: 1,
  SPKI: 2,
  PGP: 3,
  IPKIX: 4,
  ISPKI: 5,
  IPGP: 6,
  ACPKIX: 7,
  IACPKIX: 8,
  // 9-252 unassigned
  URI: 253,
  OID: 254
  // 255 reserved
  // 256-65279 unassigned
  // 65280-65534 experimental
  // 65535 reserved
};

/**
 * CERT types by value.
 * @const {Object}
 */

const certTypesByVal = {
  [certTypes.PKIX]: 'PKIX',
  [certTypes.SPKI]: 'SPKI',
  [certTypes.PGP]: 'PGP',
  [certTypes.IPKIX]: 'IPKIX',
  [certTypes.ISPKI]: 'ISPKI',
  [certTypes.IPGP]: 'IPGP',
  [certTypes.ACPKIX]: 'ACPKIX',
  [certTypes.IACPKIX]: 'IACPKIX',
  [certTypes.URI]: 'URI',
  [certTypes.OID]: 'OID'
};

/**
 * DANE usages.
 * @enum {Number}
 * @default
 */

const usages = {
  CAC: 0, // CA constraint
  SCC: 1, // Service certificate constraint
  TAA: 2, // Trust anchor assertion
  DIC: 3, // Domain-issued certificate
  // 4-254 are unassigned
  PRIVATE: 255 // Private Use
};

/**
 * DANE usages by value.
 * @const {Object}
 */

const usagesByVal = {
  [usages.CAC]: 'CAC',
  [usages.SCC]: 'SCC',
  [usages.TAA]: 'TAA',
  [usages.DIC]: 'DIC',
  [usages.PRIVATE]: 'PRIVATE'
};

/**
 * DANE selectors.
 * @enum {Number}
 * @default
 */

const selectors = {
  FULL: 0, // Full Certificate
  SPKI: 1, // SubjectPublicKeyInfo
  // 2-254 are unassigned
  PRIVATE: 255 // Private Use
};

/**
 * DANE selectors by value.
 * @const {Object}
 */

const selectorsByVal = {
  [selectors.FULL]: 'FULL',
  [selectors.SPKI]: 'SPKI',
  [selectors.PRIVATE]: 'PRIVATE'
};

/**
 * DANE matching types.
 * @enum {Number}
 * @default
 */

const matchingTypes = {
  NONE: 0, // No hash used
  SHA256: 1,
  SHA512: 2,
  // 3-254 are unassigned
  PRIVATE: 255 // Private Use
};

/**
 * DANE matching types by value.
 * @const {Object}
 */

const matchingTypesByVal = {
  [matchingTypes.NONE]: 'NONE',
  [matchingTypes.SHA256]: 'SHA256',
  [matchingTypes.SHA512]: 'SHA512',
  [matchingTypes.PRIVATE]: 'PRIVATE'
};

/**
 * SSHFP algorithms.
 * @enum {Number}
 * @default
 */

const sshAlgs = {
  RSA: 1,
  DSA: 2,
  ECDSA: 3,
  ED25519: 4
};

/**
 * SSHFP algorithms by value.
 * @const {Object}
 * @default
 */

const sshAlgsByVal = {
  [sshAlgs.RSA]: 'RSA',
  [sshAlgs.DSA]: 'DSA',
  [sshAlgs.ECDSA]: 'ECDSA',
  [sshAlgs.ED25519]: 'ED25519'
};

/**
 * SSHFP hashes.
 * @enum {Number}
 * @default
 */

const sshHashes = {
  SHA1: 1,
  SHA256: 2
};

/**
 * SSHFP hashes by value.
 * @const {Object}
 * @default
 */

const sshHashesByVal = {
  [sshHashes.SHA1]: 'SHA1',
  [sshHashes.SHA256]: 'SHA256'
};

/**
 * TSIG hash algorithms.
 * @const {Object}
 * @default
 */

const tsigAlgs = {
  MD5: 'hmac-md5.sig-alg.reg.int.',
  SHA1: 'hmac-sha1.',
  SHA256: 'hmac-sha256.',
  SHA512: 'hmac-sha512.'
};

/**
 * TSIG hash algorithms by value.
 * @const {Object}
 * @default
 */

const tsigAlgsByVal = {
  [tsigAlgs.MD5]: 'MD5',
  [tsigAlgs.SHA1]: 'SHA1',
  [tsigAlgs.SHA256]: 'SHA256',
  [tsigAlgs.SHA512]: 'SHA512'
};

/**
 * TKEY modes.
 * @enum {Number}
 * @default
 */

const tkeyModes = {
  RESERVED: 0, // reserved
  SERVER: 1, // server assignment
  DH: 2, // Diffie-Hellman exchange
  GSS: 3, // GSS-API negotiation
  RESOLVER: 4, // resolver assignment
  DELETE: 5 // key deletion
  // 6-65534 unassigned
  // 65535 reserved
};

/**
 * TKEY modes by value.
 * @const {Object}
 * @default
 */

const tkeyModesByVal = {
  [tkeyModes.RESERVED]: 'RESERVED',
  [tkeyModes.SERVER]: 'SERVER',
  [tkeyModes.DH]: 'DH',
  [tkeyModes.GSS]: 'GSS',
  [tkeyModes.RESOLVER]: 'RESOLVER',
  [tkeyModes.DELETE]: 'DELETE'
};

/**
 * For RFC1982 (Serial Arithmetic) calculations in 32 bits.
 * @const {Number}
 * @default
 */

const YEAR68 = (1 << 31) >>> 0;

/**
 * Equator.
 * @const {Number}
 * @default
 */

const LOC_EQUATOR = (1 << 31) >>> 0; // RFC 1876, Section 2.

/**
 * Prime meridian.
 * @const {Number}
 * @default
 */

const LOC_PRIMEMERIDIAN = (1 << 31) >>> 0; // RFC 1876, Section 2.

/**
 * Location hours.
 * @const {Number}
 * @default
 */

const LOC_HOURS = 60 * 1000;

/**
 * Location degrees.
 * @const {Number}
 * @default
 */

const LOC_DEGREES = 60 * LOC_HOURS;

/**
 * Altitude base.
 * @const {Number}
 * @default
 */

const LOC_ALTITUDEBASE = 100000;

/**
 * Max domain name length.
 * @const {Number}
 * @default
 */

const MAX_NAME_SIZE = 255;

/**
 * Max label length.
 * @const {Number}
 * @default
 */

const MAX_LABEL_SIZE = 63;

/**
 * Max udp size.
 * @const {Number}
 * @default
 */

const MAX_UDP_SIZE = 512;

/**
 * Standard udp+edns size (rfc 2671).
 * @const {Number}
 * @default
 */

const STD_EDNS_SIZE = 1280;

/**
 * Max udp+edns size.
 * @const {Number}
 * @default
 */

const MAX_EDNS_SIZE = 4096;

/**
 * Max tcp size.
 * @const {Number}
 * @default
 */

const MAX_MSG_SIZE = 65535;

/**
 * Default DNS port.
 * @const {Number}
 * @default
 */

const DNS_PORT = 53;

/**
 * Default TTL.
 * @const {Number}
 * @default
 */

const DEFAULT_TTL = 3600;

/**
 * ICANN Root Trust Anchor (2010).
 * @const {String}
 * @see https://data.iana.org/root-anchors/root-anchors.xml
 */

const KSK_2010 = '. 172800 IN DS 19036 8 2'
  + ' 49AAC11D7B6F6446702E54A1607371607A1A41855200FD2CE1CDDE32F24E8FB5';

/**
 * ICANN Root Trust Anchor (2017).
 * @const {String}
 * @see https://data.iana.org/root-anchors/root-anchors.xml
 */

const KSK_2017 = '. 172800 IN DS 20326 8 2'
  + ' E06D44B80B8F1D39A95C0B0D7C65D08458E880409BBC683457104237C7F8EC8D';

/**
 * ICANN ARPA Trust Anchor
 * @const {String}
 */

const KSK_ARPA = 'arpa. 86400 IN DS 42581 8 2'
  + ' F28391C1ED4DC0F151EDD251A3103DCE0B9A5A251ACF6E24073771D71F3C40F9';

/*
 * Helpers
 */

function toSymbol(value, name, map, prefix, max, size) {
  if (typeof value !== 'number')
    throw new Error(`'${name}' must be a number.`);

  if ((value & max) !== value)
    throw new Error(`Invalid ${name}: ${value}.`);

  const symbol = map[value];

  if (typeof symbol === 'string')
    return symbol;

  return `${prefix}${value.toString(10)}`;
}

function fromSymbol(symbol, name, map, prefix, max, size) {
  if (typeof symbol !== 'string')
    throw new Error(`'${name}' must be a string.`);

  if (symbol.length > 64)
    throw new Error(`Unknown ${name}.`);

  const value = map[symbol];

  if (typeof value === 'number')
    return value;

  if (symbol.length <= prefix.length)
    throw new Error(`Unknown ${name}: ${symbol}.`);

  if (symbol.substring(0, prefix.length) !== prefix)
    throw new Error(`Unknown ${name}: ${symbol}.`);

  if (symbol.length > prefix.length + size)
    throw new Error(`Unknown ${name}: ${symbol}.`);

  let word = 0;

  for (let i = prefix.length; i < symbol.length; i++) {
    const ch = symbol.charCodeAt(i) - 0x30;

    if (ch < 0 || ch > 9)
      throw new Error(`Unknown ${name}: ${symbol}.`);

    word *= 10;
    word += ch;

    if (word > max)
      throw new Error(`Unknown ${name}: ${symbol}.`);
  }

  return word;
}

function isSymbol(symbol, name, map, prefix, max, size) {
  if (typeof symbol !== 'string')
    throw new Error(`'${name}' must be a string.`);

  try {
    fromSymbol(symbol, name, map, prefix, max, size);
    return true;
  } catch (e) {
    return false;
  }
}

function opcodeToString(opcode) {
  return toSymbol(opcode, 'opcode', opcodesByVal, 'OPCODE', 0x0f, 2);
}

function stringToOpcode(symbol) {
  return fromSymbol(symbol, 'opcode', opcodes, 'OPCODE', 0x0f, 2);
}

function isOpcodeString(symbol) {
  return isSymbol(symbol, 'opcode', opcodes, 'OPCODE', 0x0f, 2);
}

function codeToString(code) {
  return toSymbol(code, 'code', codesByVal, 'RCODE', 0x0f, 2);
}

function stringToCode(symbol) {
  return fromSymbol(symbol, 'code', codes, 'RCODE', 0x0fff, 4);
}

function isCodeString(symbol) {
  return isSymbol(symbol, 'code', codes, 'RCODE', 0x0fff, 4);
}

function typeToString(type) {
  return toSymbol(type, 'type', typesByVal, 'TYPE', 0xffff, 5);
}

function stringToType(symbol) {
  return fromSymbol(symbol, 'type', types, 'TYPE', 0xffff, 5);
}

function isTypeString(symbol) {
  return isSymbol(symbol, 'type', types, 'TYPE', 0xffff, 5);
}

function classToString(class_) {
  return toSymbol(class_, 'class', classesByVal, 'CLASS', 0xffff, 5);
}

function stringToClass(symbol) {
  return fromSymbol(symbol, 'class', classes, 'CLASS', 0xffff, 5);
}

function isClassString(symbol) {
  return isSymbol(symbol, 'class', classes, 'CLASS', 0xffff, 5);
}

function optionToString(option) {
  return toSymbol(option, 'option', optionsByVal, 'OPTION', 0xffff, 5);
}

function stringToOption(symbol) {
  return fromSymbol(symbol, 'option', options, 'OPTION', 0xffff, 5);
}

function isOptionString(symbol) {
  return isSymbol(symbol, 'option', options, 'OPTION', 0xffff, 5);
}

function algToString(alg) {
  return toSymbol(alg, 'algorithm', algsByVal, 'ALG', 0xff, 3);
}

function stringToAlg(symbol) {
  return fromSymbol(symbol, 'algorithm', algs, 'ALG', 0xff, 3);
}

function isAlgString(symbol) {
  return isSymbol(symbol, 'algorithm', algs, 'ALG', 0xff, 3);
}

function hashToString(hash) {
  return toSymbol(hash, 'hash', hashesByVal, 'HASH', 0xff, 3);
}

function stringToHash(symbol) {
  return fromSymbol(symbol, 'hash', hashes, 'HASH', 0xff, 3);
}

function isHashString(symbol) {
  return isSymbol(symbol, 'hash', hashes, 'HASH', 0xff, 3);
}

/*
 * Expose
 */

exports.opcodes = opcodes;
exports.opcodesByVal = opcodesByVal;
exports.flags = flags;
exports.flagsByVal = flagsByVal;
exports.codes = codes;
exports.codesByVal = codesByVal;
exports.types = types;
exports.typesByVal = typesByVal;
exports.classes = classes;
exports.classesByVal = classesByVal;
exports.eflags = eflags;
exports.eflagsByVal = eflagsByVal;
exports.options = options;
exports.optionsByVal = optionsByVal;
exports.keyFlags = keyFlags;
exports.algs = algs;
exports.algsByVal = algsByVal;
exports.hashes = hashes;
exports.hashesByVal = hashesByVal;
exports.algHashes = algHashes;
exports.nsecHashes = nsecHashes;
exports.nsecHashesByVal = nsecHashesByVal;
exports.certTypes = certTypes;
exports.certTypesByVal = certTypesByVal;
exports.usages = usages;
exports.usagesByVal = usagesByVal;
exports.selectors = selectors;
exports.selectorsByVal = selectorsByVal;
exports.matchingTypes = matchingTypes;
exports.matchingTypesByVal = matchingTypesByVal;
exports.sshAlgs = sshAlgs;
exports.sshAlgsByVal = sshAlgsByVal;
exports.sshHashes = sshHashes;
exports.sshHashesByVal = sshHashesByVal;
exports.tsigAlgs = tsigAlgs;
exports.tsigAlgsByVal = tsigAlgsByVal;
exports.tkeyModes = tkeyModes;
exports.tkeyModesByVal = tkeyModesByVal;

exports.YEAR68 = YEAR68;
exports.LOC_EQUATOR = LOC_EQUATOR;
exports.LOC_PRIMEMERIDIAN = LOC_PRIMEMERIDIAN;
exports.LOC_HOURS = LOC_HOURS;
exports.LOC_DEGREES = LOC_DEGREES;
exports.LOC_ALTITUDEBASE = LOC_ALTITUDEBASE;

exports.MAX_NAME_SIZE = MAX_NAME_SIZE;
exports.MAX_LABEL_SIZE = MAX_LABEL_SIZE;
exports.MAX_UDP_SIZE = MAX_UDP_SIZE;
exports.STD_EDNS_SIZE = STD_EDNS_SIZE;
exports.MAX_EDNS_SIZE = MAX_EDNS_SIZE;
exports.MAX_MSG_SIZE = MAX_MSG_SIZE;
exports.DNS_PORT = DNS_PORT;
exports.DEFAULT_TTL = DEFAULT_TTL;
exports.KSK_2010 = KSK_2010;
exports.KSK_2017 = KSK_2017;
exports.KSK_ARPA = KSK_ARPA;

exports.opcodeToString = opcodeToString;
exports.stringToOpcode = stringToOpcode;
exports.isOpcodeString = isOpcodeString;

exports.codeToString = codeToString;
exports.stringToCode = stringToCode;
exports.isCodeString = isCodeString;

exports.typeToString = typeToString;
exports.stringToType = stringToType;
exports.isTypeString = isTypeString;

exports.classToString = classToString;
exports.stringToClass = stringToClass;
exports.isClassString = isClassString;

exports.optionToString = optionToString;
exports.stringToOption = stringToOption;
exports.isOptionString = isOptionString;

exports.algToString = algToString;
exports.stringToAlg = stringToAlg;
exports.isAlgString = isAlgString;

exports.hashToString = hashToString;
exports.stringToHash = stringToHash;
exports.isHashString = isHashString;

exports._toSymbol = toSymbol;
exports._fromSymbol = fromSymbol;
exports._isSymbol = isSymbol;
}],
[/* 12 */ 'bns-plus', '/lib/dane.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * dane.js - DANE for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 *
 * Parts of this software are based on miekg/dns:
 *   https://github.com/miekg/dns/blob/master/dane.go
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc6698
 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const constants = __browser_require__(11 /* './constants' */, module);
const crypto = __browser_require__(13 /* './internal/crypto' */, module);
const util = __browser_require__(79 /* './util' */, module);

const {
  usages,
  usagesByVal,
  selectors,
  selectorsByVal,
  matchingTypes,
  matchingTypesByVal
} = constants;

/*
 * DANE
 */

const dane = exports;

dane.select = function select(cert, selector) {
  assert((cert != null && cert._isBuffer === true));
  assert((selector & 0xff) === selector);

  switch (selector) {
    case selectors.FULL:
      return getCert(cert);
    case selectors.SPKI:
      return getPubkeyInfo(cert);
  }

  return null;
};

dane.hash = function hash(data, matchingType) {
  assert((data != null && data._isBuffer === true));
  assert((matchingType & 0xff) === matchingType);

  switch (matchingType) {
    case matchingTypes.NONE:
      return data;
    case matchingTypes.SHA256:
      return crypto.sha256.digest(data);
    case matchingTypes.SHA512:
      return crypto.sha512.digest(data);
  }

  return null;
};

dane.sign = function sign(cert, selector, matchingType) {
  const data = dane.select(cert, selector);

  if (!data)
    return null;

  const hash = dane.hash(data, matchingType);

  if (!hash)
    return null;

  return hash;
};

dane.verify = function verify(cert, selector, matchingType, certificate) {
  const hash = dane.sign(cert, selector, matchingType);

  if (!hash)
    return false;

  return hash.equals(certificate);
};

dane.encodeEmail = function encodeEmail(email, tag, bits) {
  assert(typeof email === 'string');
  assert(email.length >= 3 && email.length <= 320);

  const index = email.indexOf('@');
  assert(index !== -1);

  const local = email.substring(0, index);
  const name = email.substring(index + 1);

  return dane.encodeName(name, tag, local, bits);
};

dane.hashLocal = function hashLocal(local, bits, enc) {
  if (bits == null)
    bits = 256;

  if (enc == null)
    enc = null;

  assert(typeof local === 'string');
  assert(local.length <= 64);
  assert(local.indexOf('@') === -1);
  assert(typeof bits === 'number');
  assert(bits === 224 || bits === 256);
  assert(enc === null || enc === 'hex');

  const raw = Buffer.from(local, 'utf8');
  const hash = bits === 224
    ? crypto.sha224.digest(raw)
    : crypto.sha256.digest(raw);

  if (enc === 'hex')
    return hash.toString('hex', 0, 28);

  return hash.slice(0, 28);
};

dane.encodeName = function encodeName(name, tag, local, bits) {
  assert(util.isName(name));
  assert(name.length === 0 || name[0] !== '_');
  assert(util.isName(tag));
  assert(tag.length >= 1 && tag.length <= 62);
  assert(tag[0] !== '_');
  assert(tag.indexOf('.') === -1);

  if (name === '.')
    name = '';

  const hash = dane.hashLocal(local, bits, 'hex');
  const encoded = util.fqdn(`${hash}._${tag}.${name}`);

  assert(util.isName(encoded));

  return encoded;
};

dane.decodeName = function decodeName(name, tag) {
  assert(util.isName(name));
  assert(util.isName(tag));
  assert(tag.length >= 1 && tag.length <= 62);
  assert(tag[0] !== '_');
  assert(tag.indexOf('.') === -1);

  const labels = util.split(name);

  assert(labels.length >= 3);

  const hex = util.label(name, labels, 0);
  const part = util.label(name, labels, 1);

  assert(hex.length >= 1);
  assert(part.length >= 2);
  assert(part[0] === '_');

  if (part.toLowerCase() !== `_${tag}`)
    throw new Error('Invalid DANE name.');

  if (hex.length !== 56)
    throw new Error('Invalid DANE hash.');

  const hash = Buffer.from(hex, 'hex');

  if (hash.length !== 28)
    throw new Error('Invalid DANE hash.');

  return {
    name: util.fqdn(util.from(name, labels, 2)),
    hash: hash
  };
};

dane.isName = function isName(name, tag) {
  assert(util.isName(name));
  assert(util.isName(tag));
  assert(tag.length >= 1 && tag.length <= 62);
  assert(tag[0] !== '_');
  assert(tag.indexOf('.') === -1);

  try {
    dane.decodeName(name, tag);
    return true;
  } catch (e) {
    return false;
  }
};

/*
 * Helpers
 */

function getCert(data) {
  const size = gauge(data, 0);
  assert(size <= data.length);
  return data.slice(0, size);
}

function getPubkeyInfo(data) {
  let off = 0;

  // cert
  off = seq(data, off);

  // tbs
  off = seq(data, off);

  // version
  off = xint(data, off);

  // serial
  off = int(data, off);

  // alg ident
  off = skip(data, off);

  // issuer
  off = skip(data, off);

  // validity
  off = skip(data, off);

  // subject
  off = skip(data, off);

  // pubkeyinfo
  const size = gauge(data, off);

  assert(off + size <= data.length);

  return data.slice(off, off + size);
}

function tag(data, off, expect, explicit) {
  assert(off < data.length);

  const start = off;

  let type = data[off++];

  const primitive = (type & 0x20) === 0;

  if ((type & 0x1f) === 0x1f) {
    let oct = type;
    type = 0;
    while ((oct & 0x80) === 0x80) {
      assert(off < data.length);
      oct = data[off++];
      type <<= 7;
      type |= oct & 0x7f;
    }
  } else {
    type &= 0x1f;
  }

  if (type !== expect) {
    if (explicit)
      return [start, 0];
    throw new Error(`Expected type: ${expect}. Got: ${type}.`);
  }

  assert(off < data.length);

  let size = data[off++];

  if (!primitive && size === 0x80)
    throw new Error('Indefinite size.');

  if ((size & 0x80) === 0)
    return [off, size];

  const bytes = size & 0x7f;

  if (bytes > 3)
    throw new Error('Length octet is too long.');

  size = 0;

  for (let i = 0; i < bytes; i++) {
    assert(off < data.length);
    size <<= 8;
    size |= data[off++];
  }

  // Return:
  // [0]: Offset after the header.
  // [1]: Size of bytes to read next.
  return [off, size];
}

function read(data, off) {
  // Read seq-header, update offset to after header.
  return tag(data, off, 0x10, false);
}

function gauge(data, off) {
  // Get total size of seq-header + data.
  const [pos, size] = read(data, off);
  return (pos - off) + size;
}

function seq(data, off) {
  // Read seq-header, return offset after header.
  return read(data, off)[0];
}

function skip(data, off) {
  // Read seq-header, return offset after header+data.
  const [offset, size] = read(data, off);
  return offset + size;
}

function int(data, off) {
  // Read int-header, return offset after header+data.
  const [offset, size] = tag(data, off, 0x02, false);
  return offset + size;
}

function xint(data, off) {
  // Read int-header (explicit), return offset after header+data.
  const [offset, size] = tag(data, off, 0x00, true);
  return offset + size;
}

/*
 * Expose
 */

dane.usages = usages;
dane.usagesByVal = usagesByVal;
dane.selectors = selectors;
dane.selectorsByVal = selectorsByVal;
dane.matchingTypes = matchingTypes;
dane.matchingTypesByVal = matchingTypesByVal;
}],
[/* 13 */ 'bns-plus', '/lib/internal/crypto.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * crypto.js - crypto for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const bio = __browser_require__(14 /* 'bufio' */, module);
const {safeEqual} = __browser_require__(23 /* 'bcrypto/lib/safe' */, module);
const MD5 = __browser_require__(25 /* 'bcrypto/lib/md5' */, module);
const SHA1 = __browser_require__(28 /* 'bcrypto/lib/sha1' */, module);
const SHA224 = __browser_require__(30 /* 'bcrypto/lib/sha224' */, module);
const SHA256 = __browser_require__(33 /* 'bcrypto/lib/sha256' */, module);
const SHA384 = __browser_require__(34 /* 'bcrypto/lib/sha384' */, module);
const SHA512 = __browser_require__(37 /* 'bcrypto/lib/sha512' */, module);
const GOST94 = __browser_require__(38 /* 'bcrypto/lib/gost94' */, module);
const dsa = __browser_require__(40 /* 'bcrypto/lib/dsa' */, module);
const rsa = __browser_require__(54 /* 'bcrypto/lib/rsa' */, module);
const p256 = __browser_require__(58 /* 'bcrypto/lib/p256' */, module);
const p384 = __browser_require__(66 /* 'bcrypto/lib/p384' */, module);
const ed25519 = __browser_require__(68 /* 'bcrypto/lib/ed25519' */, module);
const ed448 = __browser_require__(72 /* 'bcrypto/lib/ed448' */, module);
const {padLeft} = __browser_require__(78 /* 'bcrypto/lib/encoding/util' */, module);

/*
 * Hashes
 */

exports.md5 = MD5;
exports.sha1 = SHA1;
exports.sha224 = SHA224;
exports.sha256 = SHA256;
exports.sha384 = SHA384;
exports.sha512 = SHA512;
exports.gost94 = GOST94;

/*
 * Helpers
 */

exports.safeEqual = safeEqual;

/*
 * DSA
 */

exports.generateDSA = function generateDSA(bits) {
  if (bits == null)
    bits = 1024;

  assert((bits >>> 0) === bits);

  if (bits > 1024)
    throw new RangeError('DSA prime cannot exceed 1024 bits.');

  return dsa.privateKeyGenerate(bits);
};

exports.generateDSAAsync = async function generateDSAAsync(bits) {
  if (bits == null)
    bits = 1024;

  assert((bits >>> 0) === bits);

  if (bits > 1024)
    throw new RangeError('DSA prime cannot exceed 1024 bits.');

  return dsa.privateKeyGenerateAsync(bits);
};

exports.createDSA = function createDSA(key) {
  const pub = dsa.publicKeyCreate(key);
  return dsaKeyExport(pub);
};

exports.signDSA = function signDSA(hash, data, key) {
  assert(hash && typeof hash.id === 'string');

  const pbits = dsa.privateKeyBits(key);
  const qbits = dsa.privateKeyScalarBits(key);

  if (pbits > 1024 || qbits !== 160)
    throw new Error('Invalid DSA private key.');

  const msg = hash.digest(data);
  const sig = dsa.sign(msg, key);

  return dsaSigExport(sig, key);
};

exports.verifyDSA = function verifyDSA(hash, data, sig, key) {
  assert(hash && typeof hash.id === 'string');
  assert((key != null && key._isBuffer === true));
  assert((sig != null && sig._isBuffer === true));

  let pub;
  try {
    pub = dsaKeyImport(key);
  } catch (e) {
    return false;
  }

  let s;
  try {
    s = dsaSigImport(sig);
  } catch (e) {
    return false;
  }

  const pbits = dsa.publicKeyBits(pub);
  const qbits = dsa.publicKeyScalarBits(pub);

  if (pbits > 1024 || qbits !== 160)
    return false;

  const msg = hash.digest(data);

  return dsa.verify(msg, s, pub);
};

/*
 * RSA
 */

exports.generateRSA = function generateRSA(bits, exp) {
  if (bits == null)
    bits = 2048;

  assert((bits >>> 0) === bits);
  assert(bits <= 4096);

  return rsa.privateKeyGenerate(bits, exp);
};

exports.generateRSAAsync = async function generateRSAAsync(bits, exp) {
  if (bits == null)
    bits = 2048;

  assert((bits >>> 0) === bits);
  assert(bits <= 4096);

  return rsa.privateKeyGenerateAsync(bits, exp);
};

exports.createRSA = function createRSA(key) {
  const pub = rsa.publicKeyCreate(key);
  return rsaKeyExport(pub);
};

exports.signRSA = function signRSA(hash, data, key) {
  assert(hash && typeof hash.id === 'string');

  const msg = hash.digest(data);

  return rsa.sign(hash, msg, key);
};

exports.verifyRSA = function verifyRSA(hash, data, sig, key) {
  assert(hash && typeof hash.id === 'string');
  assert((sig != null && sig._isBuffer === true));

  let pub;
  try {
    pub = rsaKeyImport(key);
  } catch (e) {
    return false;
  }

  // Modulus limited to 4096 bits.
  //
  // See:
  //   - https://tools.ietf.org/html/rfc3110#section-2
  //   - https://www.imperialviolet.org/2012/03/17/rsados.html
  //   - https://github.com/isc-projects/bind9/blob/fa03f94/lib/dns/opensslrsa_link.c#L482
  //
  // Note that our RSA implementation limits
  // the exponent to 33 bits. This differs
  // from BIND which limits it at 35. 33 was
  // chosen because a lot of people use
  // `0x01000001` as an exponent for DNSSEC
  // (due BIND's dnssec-keygen using a stupid
  // exponent for no reason).
  //
  // See:
  //   - https://www.imperialviolet.org/2012/03/16/rsae.html
  //   - https://github.com/isc-projects/bind9/blob/fa03f94/lib/dns/opensslrsa_link.c#L47
  const bits = rsa.publicKeyBits(pub);

  if (bits > 4096)
    return false;

  const msg = hash.digest(data);

  // Since BIND is essentially "DNSSEC consensus"
  // we do something here once again. None of
  // this is specified in any RFC, but in order
  // to maintain compatibility with BIND, RSA
  // signatures which are smaller than the key's
  // modulus (in terms of bytes) must be accepted.
  // This is due to BIND's usage of OpenSSL's
  // EVP interface.
  //
  // This means a signature which is created with
  // leading zero bytes are allowed to have them
  // chopped off before hitting the protocol layer.
  // According to OpenSSL, PGP implementations
  // also do funky stuff like this!
  //
  // See:
  //   - https://github.com/isc-projects/bind9/blob/fa03f94/lib/dns/opensslrsa_link.c#L352
  //   - https://github.com/openssl/openssl/blob/41bfd5e/crypto/rsa/rsa_ossl.c#L538
  //
  // Note that the raw OpenSSL RSA api requires
  // signatures be a proper length:
  //   - https://github.com/openssl/openssl/blob/41bfd5e/crypto/rsa/rsa_saos.c#L64
  const size = (bits + 7) >>> 3;

  if (sig.length < size)
    sig = padLeft(sig, size);

  return rsa.verify(hash, msg, sig, pub);
};

/*
 * P256
 */

exports.generateP256 = function generateP256() {
  return p256.privateKeyGenerate();
};

exports.createP256 = function createP256(key) {
  const {x, y} = p256.privateKeyExport(key);
  return Buffer.concat([x, y]);
};

exports.signP256 = function signP256(hash, data, key) {
  assert(hash && typeof hash.id === 'string');

  const msg = hash.digest(data);

  return p256.sign(msg, key);
};

exports.verifyP256 = function verifyP256(hash, data, sig, key) {
  assert(hash && typeof hash.id === 'string');
  assert((key != null && key._isBuffer === true));

  if (key.length !== 64)
    return false;

  let pub;
  try {
    pub = p256.publicKeyImport({
      x: key.slice(0, 32),
      y: key.slice(32)
    });
  } catch (e) {
    return false;
  }

  const msg = hash.digest(data);

  return p256.verify(msg, sig, pub);
};

/*
 * P384
 */

exports.generateP384 = function generateP384() {
  return p384.privateKeyGenerate();
};

exports.createP384 = function createP384(key) {
  const {x, y} = p384.privateKeyExport(key);
  return Buffer.concat([x, y]);
};

exports.signP384 = function signP384(hash, data, key) {
  assert(hash && typeof hash.id === 'string');

  const msg = hash.digest(data);

  return p384.sign(msg, key);
};

exports.verifyP384 = function verifyP384(hash, data, sig, key) {
  assert(hash && typeof hash.id === 'string');
  assert((key != null && key._isBuffer === true));

  if (key.length !== 96)
    return false;

  let pub;
  try {
    pub = p384.publicKeyImport({
      x: key.slice(0, 48),
      y: key.slice(48)
    });
  } catch (e) {
    return false;
  }

  const msg = hash.digest(data);

  return p384.verify(msg, sig, pub);
};

/*
 * ED25519
 */

exports.generateED25519 = function generateED25519() {
  return ed25519.privateKeyGenerate();
};

exports.createED25519 = function createED25519(key) {
  return ed25519.publicKeyCreate(key);
};

exports.signED25519 = function signED25519(data, key) {
  return ed25519.sign(data, key);
};

exports.verifyED25519 = function verifyED25519(data, sig, key) {
  return ed25519.verify(data, sig, key);
};

/*
 * ED448
 */

exports.generateED448 = function generateED448() {
  return ed448.privateKeyGenerate();
};

exports.createED448 = function createED448(key) {
  return ed448.publicKeyCreate(key);
};

exports.signED448 = function signED448(data, key) {
  return ed448.sign(data, key);
};

exports.verifyED448 = function verifyED448(data, sig, key) {
  return ed448.verify(data, sig, key);
};

/*
 * Helpers
 */

exports.rsaBits = function rsaBits(raw) {
  assert((raw != null && raw._isBuffer === true));

  let pub;
  try {
    pub = rsaKeyImport(raw);
  } catch (e) {
    return 0;
  }

  return rsa.publicKeyBits(pub);
};

/*
 * Helpers
 */

function rsaKeyExport(key) {
  const {n, e} = rsa.publicKeyExport(key);

  let size = 1 + e.length + n.length;

  if (e.length > 255)
    size += 2;

  const bw = bio.write(size);

  if (e.length > 255) {
    bw.writeU8(0);
    bw.writeU16BE(e.length);
  } else {
    bw.writeU8(e.length);
  }

  bw.writeBytes(e);
  bw.writeBytes(n);

  return bw.render();
}

function rsaKeyImport(data) {
  assert((data != null && data._isBuffer === true));

  const br = bio.read(data);

  let len = br.readU8();

  if (len === 0)
    len = br.readU16BE();

  const e = br.readBytes(len);
  const n = br.readBytes(br.left());

  return rsa.publicKeyImport({ n, e });
}

function dsaKeyExport(key) {
  const {p, q, g, y} = dsa.publicKeyExport(key);

  if (p.length < 64 || q.length > 20)
    throw new Error('Invalid DSA public key.');

  const T = ((p.length - 64) + 7) >>> 3;
  const len = 64 + T * 8;

  if (p.length > len)
    throw new Error('Invalid P value.');

  const size = 21 + len * 3;
  const bw = bio.write(size);

  bw.writeU8(T);
  bw.writeBytes(padLeft(q, 20));
  bw.writeBytes(padLeft(p, len));
  bw.writeBytes(padLeft(g, len));
  bw.writeBytes(padLeft(y, len));

  return bw.render();
}

function dsaKeyImport(data) {
  assert((data != null && data._isBuffer === true));

  // See: https://github.com/NLnetLabs/ldns/blob/develop/dnssec.c#L337
  const br = bio.read(data);

  // Compressed L value.
  const T = br.readU8();

  if (T > 8)
    throw new Error('Invalid L value.');

  // L = 512 + T (max=1024)
  // N = 160
  const len = 64 + T * 8;
  const q = br.readBytes(20);
  const p = br.readBytes(len);
  const g = br.readBytes(len);
  const y = br.readBytes(len);

  return dsa.publicKeyImport({ p, q, g, y });
}

function dsaSigExport(sig, key) {
  assert((sig != null && sig._isBuffer === true));

  const plen = (dsa.privateKeyBits(key) + 7) >>> 3;
  const qlen = (dsa.privateKeyScalarBits(key) + 7) >>> 3;

  if (plen < 64 || qlen > 20)
    throw new Error('Invalid DSA private key.');

  const T = ((plen - 64) + 7) >>> 3;
  const len = 64 + T * 8;

  if (plen > len)
    throw new Error('Invalid P value.');

  if (sig.length !== qlen * 2)
    throw new Error('Invalid signature.');

  const r = sig.slice(0, qlen);
  const s = sig.slice(qlen);
  const bw = bio.write(41);

  bw.writeU8(T);
  bw.writeBytes(padLeft(r, 20));
  bw.writeBytes(padLeft(s, 20));

  return bw.render();
}

function dsaSigImport(data) {
  assert((data != null && data._isBuffer === true));

  // Signatures are [T] [R] [S] (20 byte R and S) -- T is ignored.
  // See: https://github.com/NLnetLabs/ldns/blob/develop/dnssec.c#L1795
  // See: https://github.com/miekg/dns/blob/master/dnssec.go#L373
  const br = bio.read(data);

  // Compressed L value.
  const T = br.readU8();

  if (T > 8)
    throw new Error('Invalid L value.');

  return br.readBytes(40);
}
}],
[/* 14 */ 'bufio', '/lib/bufio.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * bufio.js - buffer utilities for javascript
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */



const custom = __browser_require__(15 /* './custom' */, module);
const encoding = __browser_require__(16 /* './encoding' */, module);
const enforce = __browser_require__(17 /* './enforce' */, module);
const EncodingError = __browser_require__(18 /* './error' */, module);
const BufferReader = __browser_require__(19 /* './reader' */, module);
const BufferWriter = __browser_require__(20 /* './writer' */, module);
const StaticWriter = __browser_require__(21 /* './staticwriter' */, module);
const Struct = __browser_require__(22 /* './struct' */, module);

exports.custom = custom;
exports.encoding = encoding;
exports.EncodingError = EncodingError;
exports.BufferReader = BufferReader;
exports.BufferWriter = BufferWriter;
exports.StaticWriter = StaticWriter;
exports.Struct = Struct;

exports.read = function read(data, zeroCopy) {
  return new BufferReader(data, zeroCopy);
};

exports.write = function write(size) {
  return size != null
    ? new StaticWriter(size)
    : new BufferWriter();
};

exports.pool = function pool(size) {
  return StaticWriter.pool(size);
};

function _read(func, size) {
  return function(data, off) {
    enforce((data != null && data._isBuffer === true), 'data', 'buffer');
    enforce((off >>> 0) === off, 'off', 'integer');

    if (off + size > data.length)
      throw new EncodingError(off, 'Out of bounds read');

    return func(data, off);
  };
}

function _readn(func) {
  return function(data, off, len) {
    enforce((data != null && data._isBuffer === true), 'data', 'buffer');
    enforce((off >>> 0) === off, 'off', 'integer');
    enforce((len >>> 0) === len, 'len', 'integer');

    if (off + len > data.length)
      throw new EncodingError(off, 'Out of bounds read');

    return func(data, off, len);
  };
}

function _readvar(func) {
  return function(data, off) {
    enforce((data != null && data._isBuffer === true), 'data', 'buffer');
    enforce((off >>> 0) === off, 'off', 'integer');
    return func(data, off);
  };
}

function _write(func, size) {
  return function(data, num, off) {
    enforce((data != null && data._isBuffer === true), 'data', 'buffer');
    enforce((off >>> 0) === off, 'off', 'integer');

    if (off + size > data.length)
      throw new EncodingError(off, 'Out of bounds write');

    return func(data, num, off);
  };
}

function _writen(func) {
  return function(data, num, off, len) {
    enforce((data != null && data._isBuffer === true), 'data', 'buffer');
    enforce((off >>> 0) === off, 'off', 'integer');
    enforce((len >>> 0) === len, 'len', 'integer');

    if (off + len > data.length)
      throw new EncodingError(off, 'Out of bounds write');

    return func(data, num, off, len);
  };
}

function _writecb(func, size) {
  return function(data, num, off) {
    enforce((data != null && data._isBuffer === true), 'data', 'buffer');
    enforce((off >>> 0) === off, 'off', 'integer');

    if (off + size(num) > data.length)
      throw new EncodingError(off, 'Out of bounds write');

    return func(data, num, off);
  };
}

exports.readU = _readn(encoding.readU);
exports.readU64 = _read(encoding.readU64, 8);
exports.readU56 = _read(encoding.readU56, 7);
exports.readU48 = _read(encoding.readU48, 6);
exports.readU40 = _read(encoding.readU40, 5);
exports.readU32 = _read(encoding.readU32, 4);
exports.readU24 = _read(encoding.readU24, 3);
exports.readU16 = _read(encoding.readU16, 2);
exports.readU8 = _read(encoding.readU8, 1);

exports.readUBE = _readn(encoding.readUBE);
exports.readU64BE = _read(encoding.readU64BE, 8);
exports.readU56BE = _read(encoding.readU56BE, 7);
exports.readU48BE = _read(encoding.readU48BE, 6);
exports.readU40BE = _read(encoding.readU40BE, 5);
exports.readU32BE = _read(encoding.readU32BE, 4);
exports.readU24BE = _read(encoding.readU24BE, 3);
exports.readU16BE = _read(encoding.readU16BE, 2);

exports.readI = _readn(encoding.readI);
exports.readI64 = _read(encoding.readI64, 8);
exports.readI56 = _read(encoding.readI56, 7);
exports.readI48 = _read(encoding.readI48, 6);
exports.readI40 = _read(encoding.readI40, 5);
exports.readI32 = _read(encoding.readI32, 4);
exports.readI24 = _read(encoding.readI24, 3);
exports.readI16 = _read(encoding.readI16, 2);
exports.readI8 = _read(encoding.readI8, 1);

exports.readIBE = _readn(encoding.readIBE);
exports.readI64BE = _read(encoding.readI64BE, 8);
exports.readI56BE = _read(encoding.readI56BE, 7);
exports.readI48BE = _read(encoding.readI48BE, 6);
exports.readI40BE = _read(encoding.readI40BE, 5);
exports.readI32BE = _read(encoding.readI32BE, 4);
exports.readI24BE = _read(encoding.readI24BE, 3);
exports.readI16BE = _read(encoding.readI16BE, 2);

exports.readFloat = _read(encoding.readFloat, 4);
exports.readFloatBE = _read(encoding.readFloatBE, 4);
exports.readDouble = _read(encoding.readDouble, 8);
exports.readDoubleBE = _read(encoding.readDoubleBE, 8);

exports.writeU = _writen(encoding.writeU);
exports.writeU64 = _write(encoding.writeU64, 8);
exports.writeU56 = _write(encoding.writeU56, 7);
exports.writeU48 = _write(encoding.writeU48, 6);
exports.writeU40 = _write(encoding.writeU40, 5);
exports.writeU32 = _write(encoding.writeU32, 4);
exports.writeU24 = _write(encoding.writeU24, 3);
exports.writeU16 = _write(encoding.writeU16, 2);
exports.writeU8 = _write(encoding.writeU8, 1);

exports.writeUBE = _writen(encoding.writeUBE);
exports.writeU64BE = _write(encoding.writeU64BE, 8);
exports.writeU56BE = _write(encoding.writeU56BE, 7);
exports.writeU48BE = _write(encoding.writeU48BE, 6);
exports.writeU40BE = _write(encoding.writeU40BE, 5);
exports.writeU32BE = _write(encoding.writeU32BE, 4);
exports.writeU24BE = _write(encoding.writeU24BE, 3);
exports.writeU16BE = _write(encoding.writeU16BE, 2);

exports.writeI = _writen(encoding.writeI);
exports.writeI64 = _write(encoding.writeI64, 8);
exports.writeI56 = _write(encoding.writeI56, 7);
exports.writeI48 = _write(encoding.writeI48, 6);
exports.writeI40 = _write(encoding.writeI40, 5);
exports.writeI32 = _write(encoding.writeI32, 4);
exports.writeI24 = _write(encoding.writeI24, 3);
exports.writeI16 = _write(encoding.writeI16, 2);
exports.writeI8 = _write(encoding.writeI8, 1);

exports.writeIBE = _writen(encoding.writeIBE);
exports.writeI64BE = _write(encoding.writeI64BE, 8);
exports.writeI56BE = _write(encoding.writeI56BE, 7);
exports.writeI48BE = _write(encoding.writeI48BE, 6);
exports.writeI40BE = _write(encoding.writeI40BE, 5);
exports.writeI32BE = _write(encoding.writeI32BE, 4);
exports.writeI24BE = _write(encoding.writeI24BE, 3);
exports.writeI16BE = _write(encoding.writeI16BE, 2);

exports.writeFloat = _write(encoding.writeFloat, 4);
exports.writeFloatBE = _write(encoding.writeFloatBE, 4);
exports.writeDouble = _write(encoding.writeDouble, 8);
exports.writeDoubleBE = _write(encoding.writeDoubleBE, 8);

exports.readVarint = _readvar(encoding.readVarint);
exports.writeVarint = _writecb(encoding.writeVarint, encoding.sizeVarint);
exports.sizeVarint = encoding.sizeVarint;
exports.readVarint2 = _readvar(encoding.readVarint2);
exports.writeVarint2 = _writecb(encoding.writeVarint2, encoding.sizeVarint2);
exports.sizeVarint2 = encoding.sizeVarint2;

exports.sliceBytes = encoding.sliceBytes;
exports.readBytes = encoding.readBytes;
exports.writeBytes = encoding.writeBytes;
exports.readString = encoding.readString;
exports.writeString = encoding.writeString;

exports.realloc = encoding.realloc;
exports.copy = encoding.copy;
exports.concat = encoding.concat;

exports.sizeVarBytes = encoding.sizeVarBytes;
exports.sizeVarlen = encoding.sizeVarlen;
exports.sizeVarString = encoding.sizeVarString;
}],
[/* 15 */ 'bufio', '/lib/custom-browser.js', function(exports, require, module, __filename, __dirname, __meta) {
exports.custom = 'inspect';
}],
[/* 16 */ 'bufio', '/lib/encoding.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * encoding.js - encoding utils for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

/* eslint no-implicit-coercion: "off" */



const enforce = __browser_require__(17 /* './enforce' */, module);
const EncodingError = __browser_require__(18 /* './error' */, module);

/*
 * Constants
 */

const HI = 1 / 0x100000000;
const {MAX_SAFE_INTEGER} = Number;
const F32_ARRAY = new Float32Array(1);
const F328_ARRAY = new Uint8Array(F32_ARRAY.buffer);
const F64_ARRAY = new Float64Array(1);
const F648_ARRAY = new Uint8Array(F64_ARRAY.buffer);

F32_ARRAY[0] = -1;

const BIG_ENDIAN = F328_ARRAY[3] === 0;

/*
 * Read Unsigned LE
 */

function readU(data, off, len) {
  switch (len) {
    case 8:
      return readU64(data, off);
    case 7:
      return readU56(data, off);
    case 6:
      return readU48(data, off);
    case 5:
      return readU40(data, off);
    case 4:
      return readU32(data, off);
    case 3:
      return readU24(data, off);
    case 2:
      return readU16(data, off);
    case 1:
      return readU8(data, off);
    default:
      throw new EncodingError(off, 'Invalid read length');
  }
}

function readU64(data, off) {
  const hi = readU32(data, off + 4);
  const lo = readU32(data, off);

  check((hi & 0xffe00000) === 0, off, 'Number exceeds 2^53-1');

  return hi * 0x100000000 + lo;
}

function readU56(data, off) {
  const hi = readU24(data, off + 4);
  const lo = readU32(data, off);

  check((hi & 0xffe00000) === 0, off, 'Number exceeds 2^53-1');

  return hi * 0x100000000 + lo;
}

function readU48(data, off) {
  return (data[off++]
        + data[off++] * 0x100
        + data[off++] * 0x10000
        + data[off++] * 0x1000000
        + data[off++] * 0x100000000
        + data[off] * 0x10000000000);
}

function readU40(data, off) {
  return (data[off++]
        + data[off++] * 0x100
        + data[off++] * 0x10000
        + data[off++] * 0x1000000
        + data[off] * 0x100000000);
}

function readU32(data, off) {
  return (data[off++]
        + data[off++] * 0x100
        + data[off++] * 0x10000
        + data[off] * 0x1000000);
}

function readU24(data, off) {
  return (data[off++]
        + data[off++] * 0x100
        + data[off] * 0x10000);
}

function readU16(data, off) {
  return data[off++] + data[off] * 0x100;
}

function readU8(data, off) {
  return data[off];
}

/*
 * Read Unsigned BE
 */

function readUBE(data, off, len) {
  switch (len) {
    case 8:
      return readU64BE(data, off);
    case 7:
      return readU56BE(data, off);
    case 6:
      return readU48BE(data, off);
    case 5:
      return readU40BE(data, off);
    case 4:
      return readU32BE(data, off);
    case 3:
      return readU24BE(data, off);
    case 2:
      return readU16BE(data, off);
    case 1:
      return readU8(data, off);
    default:
      throw new EncodingError(off, 'Invalid read length');
  }
}

function readU64BE(data, off) {
  const hi = readU32BE(data, off);
  const lo = readU32BE(data, off + 4);

  check((hi & 0xffe00000) === 0, off, 'Number exceeds 2^53-1');

  return hi * 0x100000000 + lo;
}

function readU56BE(data, off) {
  const hi = readU24BE(data, off);
  const lo = readU32BE(data, off + 3);

  check((hi & 0xffe00000) === 0, off, 'Number exceeds 2^53-1');

  return hi * 0x100000000 + lo;
}

function readU48BE(data, off) {
  return (data[off++] * 0x10000000000
        + data[off++] * 0x100000000
        + data[off++] * 0x1000000
        + data[off++] * 0x10000
        + data[off++] * 0x100
        + data[off]);
}

function readU40BE(data, off) {
  return (data[off++] * 0x100000000
        + data[off++] * 0x1000000
        + data[off++] * 0x10000
        + data[off++] * 0x100
        + data[off]);
}

function readU32BE(data, off) {
  return (data[off++] * 0x1000000
        + data[off++] * 0x10000
        + data[off++] * 0x100
        + data[off]);
}

function readU24BE(data, off) {
  return (data[off++] * 0x10000
        + data[off++] * 0x100
        + data[off]);
}

function readU16BE(data, off) {
  return data[off++] * 0x100 + data[off];
}

/*
 * Read Signed LE
 */

function readI(data, off, len) {
  switch (len) {
    case 8:
      return readI64(data, off);
    case 7:
      return readI56(data, off);
    case 6:
      return readI48(data, off);
    case 5:
      return readI40(data, off);
    case 4:
      return readI32(data, off);
    case 3:
      return readI24(data, off);
    case 2:
      return readI16(data, off);
    case 1:
      return readI8(data, off);
    default:
      throw new EncodingError(off, 'Invalid read length');
  }
}

function readI64(data, off) {
  const hi = readI32(data, off + 4);
  const lo = readU32(data, off);

  check(isSafe(hi, lo), 'Number exceeds 2^53-1');

  return hi * 0x100000000 + lo;
}

function readI56(data, off) {
  const hi = readI24(data, off + 4);
  const lo = readU32(data, off);

  check(isSafe(hi, lo), 'Number exceeds 2^53-1');

  return hi * 0x100000000 + lo;
}

function readI48(data, off) {
  const val = data[off + 4] + data[off + 5] * 0x100;

  return (data[off++]
        + data[off++] * 0x100
        + data[off++] * 0x10000
        + data[off] * 0x1000000
        + (val | (val & 0x8000) * 0x1fffe) * 0x100000000);
}

function readI40(data, off) {
  return (data[off++]
        + data[off++] * 0x100
        + data[off++] * 0x10000
        + data[off++] * 0x1000000
        + (data[off] | (data[off] & 0x80) * 0x1fffffe) * 0x100000000);
}

function readI32(data, off) {
  return (data[off++]
        + data[off++] * 0x100
        + data[off++] * 0x10000
        + (data[off] << 24));
}

function readI24(data, off) {
  const val = (data[off++]
             + data[off++] * 0x100
             + data[off] * 0x10000);

  return val | (val & 0x800000) * 0x1fe;
}

function readI16(data, off) {
  const val = data[off++] + data[off] * 0x100;
  return val | (val & 0x8000) * 0x1fffe;
}

function readI8(data, off) {
  const val = data[off];
  return val | (val & 0x80) * 0x1fffffe;
}

/*
 * Read Signed BE
 */

function readIBE(data, off, len) {
  switch (len) {
    case 8:
      return readI64BE(data, off);
    case 7:
      return readI56BE(data, off);
    case 6:
      return readI48BE(data, off);
    case 5:
      return readI40BE(data, off);
    case 4:
      return readI32BE(data, off);
    case 3:
      return readI24BE(data, off);
    case 2:
      return readI16BE(data, off);
    case 1:
      return readI8(data, off);
    default:
      throw new EncodingError(off, 'Invalid read length');
  }
}

function readI64BE(data, off) {
  const hi = readI32BE(data, off);
  const lo = readU32BE(data, off + 4);

  check(isSafe(hi, lo), 'Number exceeds 2^53-1');

  return hi * 0x100000000 + lo;
}

function readI56BE(data, off) {
  const hi = readI24BE(data, off);
  const lo = readU32BE(data, off + 3);

  check(isSafe(hi, lo), 'Number exceeds 2^53-1');

  return hi * 0x100000000 + lo;
}

function readI48BE(data, off) {
  const val = data[off++] * 0x100 + data[off++];

  return ((val | (val & 0x8000) * 0x1fffe) * 0x100000000
        + data[off++] * 0x1000000
        + data[off++] * 0x10000
        + data[off++] * 0x100
        + data[off]);
}

function readI40BE(data, off) {
  const val = data[off++];

  return ((val | (val & 0x80) * 0x1fffffe) * 0x100000000
        + data[off++] * 0x1000000
        + data[off++] * 0x10000
        + data[off++] * 0x100
        + data[off]);
}

function readI32BE(data, off) {
  return ((data[off++] << 24)
        + data[off++] * 0x10000
        + data[off++] * 0x100
        + data[off]);
}

function readI24BE(data, off) {
  const val = (data[off++] * 0x10000
             + data[off++] * 0x100
             + data[off]);

  return val | (val & 0x800000) * 0x1fe;
}

function readI16BE(data, off) {
  const val = data[off++] * 0x100 + data[off];
  return val | (val & 0x8000) * 0x1fffe;
}

/*
 * Read Float
 */

function _readFloatBackwards(data, off) {
  F328_ARRAY[3] = data[off++];
  F328_ARRAY[2] = data[off++];
  F328_ARRAY[1] = data[off++];
  F328_ARRAY[0] = data[off];
  return F32_ARRAY[0];
}

function _readFloatForwards(data, off) {
  F328_ARRAY[0] = data[off++];
  F328_ARRAY[1] = data[off++];
  F328_ARRAY[2] = data[off++];
  F328_ARRAY[3] = data[off];
  return F32_ARRAY[0];
}

function _readDoubleBackwards(data, off) {
  F648_ARRAY[7] = data[off++];
  F648_ARRAY[6] = data[off++];
  F648_ARRAY[5] = data[off++];
  F648_ARRAY[4] = data[off++];
  F648_ARRAY[3] = data[off++];
  F648_ARRAY[2] = data[off++];
  F648_ARRAY[1] = data[off++];
  F648_ARRAY[0] = data[off];
  return F64_ARRAY[0];
}

function _readDoubleForwards(data, off) {
  F648_ARRAY[0] = data[off++];
  F648_ARRAY[1] = data[off++];
  F648_ARRAY[2] = data[off++];
  F648_ARRAY[3] = data[off++];
  F648_ARRAY[4] = data[off++];
  F648_ARRAY[5] = data[off++];
  F648_ARRAY[6] = data[off++];
  F648_ARRAY[7] = data[off];
  return F64_ARRAY[0];
}

const readFloat = BIG_ENDIAN ? _readFloatBackwards : _readFloatForwards;
const readFloatBE = BIG_ENDIAN ? _readFloatForwards : _readFloatBackwards;
const readDouble = BIG_ENDIAN ? _readDoubleBackwards : _readDoubleForwards;
const readDoubleBE = BIG_ENDIAN ? _readDoubleForwards : _readDoubleBackwards;

/*
 * Write Unsigned LE
 */

function writeU(dst, num, off, len) {
  switch (len) {
    case 8:
      return writeU64(dst, num, off);
    case 7:
      return writeU56(dst, num, off);
    case 6:
      return writeU48(dst, num, off);
    case 5:
      return writeU40(dst, num, off);
    case 4:
      return writeU32(dst, num, off);
    case 3:
      return writeU24(dst, num, off);
    case 2:
      return writeU16(dst, num, off);
    case 1:
      return writeU8(dst, num, off);
    default:
      throw new EncodingError(off, 'Invalid write length');
  }
}

function writeU64(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');
  return write64(dst, num, off, false);
}

function writeU56(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');
  return write56(dst, num, off, false);
}

function writeU48(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');

  const hi = (num * HI) | 0;

  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  dst[off++] = hi;
  dst[off++] = hi >>> 8;

  return off;
}

function writeU40(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');

  const hi = (num * HI) | 0;

  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  dst[off++] = hi;

  return off;
}

function writeU32(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');

  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;

  return off;
}

function writeU24(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');

  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;

  return off;
}

function writeU16(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');

  dst[off++] = num;
  dst[off++] = num >>> 8;

  return off;
}

function writeU8(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');

  dst[off] = num;

  return off + 1;
}

/*
 * Write Unsigned BE
 */

function writeUBE(dst, num, off, len) {
  switch (len) {
    case 8:
      return writeU64BE(dst, num, off);
    case 7:
      return writeU56BE(dst, num, off);
    case 6:
      return writeU48BE(dst, num, off);
    case 5:
      return writeU40BE(dst, num, off);
    case 4:
      return writeU32BE(dst, num, off);
    case 3:
      return writeU24BE(dst, num, off);
    case 2:
      return writeU16BE(dst, num, off);
    case 1:
      return writeU8(dst, num, off);
    default:
      throw new EncodingError(off, 'Invalid write length');
  }
}

function writeU64BE(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');
  return write64(dst, num, off, true);
}

function writeU56BE(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');
  return write56(dst, num, off, true);
}

function writeU48BE(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');

  const hi = (num * HI) | 0;

  dst[off++] = hi >>> 8;
  dst[off++] = hi;
  dst[off + 3] = num;
  num >>>= 8;
  dst[off + 2] = num;
  num >>>= 8;
  dst[off + 1] = num;
  num >>>= 8;
  dst[off] = num;

  return off + 4;
}

function writeU40BE(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');

  const hi = (num * HI) | 0;

  dst[off++] = hi;
  dst[off + 3] = num;
  num >>>= 8;
  dst[off + 2] = num;
  num >>>= 8;
  dst[off + 1] = num;
  num >>>= 8;
  dst[off] = num;

  return off + 4;
}

function writeU32BE(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');

  dst[off + 3] = num;
  num >>>= 8;
  dst[off + 2] = num;
  num >>>= 8;
  dst[off + 1] = num;
  num >>>= 8;
  dst[off] = num;

  return off + 4;
}

function writeU24BE(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');

  dst[off + 2] = num;
  num >>>= 8;
  dst[off + 1] = num;
  num >>>= 8;
  dst[off] = num;

  return off + 3;
}

function writeU16BE(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');

  dst[off++] = num >>> 8;
  dst[off++] = num;

  return off;
}

/*
 * Write Signed LE
 */

function writeI(dst, num, off, len) {
  switch (len) {
    case 8:
      return writeU64(dst, num, off);
    case 7:
      return writeU56(dst, num, off);
    case 6:
      return writeU48(dst, num, off);
    case 5:
      return writeU40(dst, num, off);
    case 4:
      return writeU24(dst, num, off);
    case 3:
      return writeU32(dst, num, off);
    case 2:
      return writeU16(dst, num, off);
    case 1:
      return writeU8(dst, num, off);
    default:
      throw new EncodingError(off, 'Invalid write length');
  }
}

function writeI64(dst, num, off) {
  return writeU64(dst, num, off);
}

function writeI56(dst, num, off) {
  return writeU56(dst, num, off);
}

function writeI48(dst, num, off) {
  return writeU48(dst, num, off);
}

function writeI40(dst, num, off) {
  return writeU40(dst, num, off);
}

function writeI32(dst, num, off) {
  return writeU32(dst, num, off);
}

function writeI24(dst, num, off) {
  return writeU24(dst, num, off);
}

function writeI16(dst, num, off) {
  return writeU16(dst, num, off);
}

function writeI8(dst, num, off) {
  return writeU8(dst, num, off);
}

/*
 * Write Signed BE
 */

function writeIBE(dst, num, off, len) {
  switch (len) {
    case 8:
      return writeU64BE(dst, num, off);
    case 7:
      return writeU56BE(dst, num, off);
    case 6:
      return writeU48BE(dst, num, off);
    case 5:
      return writeU40BE(dst, num, off);
    case 4:
      return writeU32BE(dst, num, off);
    case 3:
      return writeU24BE(dst, num, off);
    case 2:
      return writeU16BE(dst, num, off);
    case 1:
      return writeU8(dst, num, off);
    default:
      throw new EncodingError(off, 'Invalid write length');
  }
}

function writeI64BE(dst, num, off) {
  return writeU64BE(dst, num, off);
}

function writeI56BE(dst, num, off) {
  return writeU56BE(dst, num, off);
}

function writeI48BE(dst, num, off) {
  return writeU48BE(dst, num, off);
}

function writeI40BE(dst, num, off) {
  return writeU40BE(dst, num, off);
}

function writeI32BE(dst, num, off) {
  return writeU32BE(dst, num, off);
}

function writeI24BE(dst, num, off) {
  return writeU24BE(dst, num, off);
}

function writeI16BE(dst, num, off) {
  return writeU16BE(dst, num, off);
}

function _writeDoubleForwards(dst, num, off) {
  enforce(isNumber(num), 'num', 'number');

  F64_ARRAY[0] = num;

  dst[off++] = F648_ARRAY[0];
  dst[off++] = F648_ARRAY[1];
  dst[off++] = F648_ARRAY[2];
  dst[off++] = F648_ARRAY[3];
  dst[off++] = F648_ARRAY[4];
  dst[off++] = F648_ARRAY[5];
  dst[off++] = F648_ARRAY[6];
  dst[off++] = F648_ARRAY[7];

  return off;
}

function _writeDoubleBackwards(dst, num, off) {
  enforce(isNumber(num), 'num', 'number');

  F64_ARRAY[0] = num;

  dst[off++] = F648_ARRAY[7];
  dst[off++] = F648_ARRAY[6];
  dst[off++] = F648_ARRAY[5];
  dst[off++] = F648_ARRAY[4];
  dst[off++] = F648_ARRAY[3];
  dst[off++] = F648_ARRAY[2];
  dst[off++] = F648_ARRAY[1];
  dst[off++] = F648_ARRAY[0];

  return off;
}

function _writeFloatForwards(dst, num, off) {
  enforce(isNumber(num), 'num', 'number');

  F32_ARRAY[0] = num;

  dst[off++] = F328_ARRAY[0];
  dst[off++] = F328_ARRAY[1];
  dst[off++] = F328_ARRAY[2];
  dst[off++] = F328_ARRAY[3];

  return off;
}

function _writeFloatBackwards(dst, num, off) {
  enforce(isNumber(num), 'num', 'number');

  F32_ARRAY[0] = num;

  dst[off++] = F328_ARRAY[3];
  dst[off++] = F328_ARRAY[2];
  dst[off++] = F328_ARRAY[1];
  dst[off++] = F328_ARRAY[0];

  return off;
}

const writeFloat = BIG_ENDIAN ? _writeFloatBackwards : _writeFloatForwards;
const writeFloatBE = BIG_ENDIAN ? _writeFloatForwards : _writeFloatBackwards;
const writeDouble = BIG_ENDIAN ? _writeDoubleBackwards : _writeDoubleForwards;
const writeDoubleBE = BIG_ENDIAN ? _writeDoubleForwards : _writeDoubleBackwards;

/*
 * Varints
 */

function readVarint(data, off) {
  let value, size;

  checkRead(off < data.length, off);

  switch (data[off]) {
    case 0xff:
      size = 9;
      checkRead(off + size <= data.length, off);
      value = readU64(data, off + 1);
      check(value > 0xffffffff, off, 'Non-canonical varint');
      break;
    case 0xfe:
      size = 5;
      checkRead(off + size <= data.length, off);
      value = readU32(data, off + 1);
      check(value > 0xffff, off, 'Non-canonical varint');
      break;
    case 0xfd:
      size = 3;
      checkRead(off + size <= data.length, off);
      value = readU16(data, off + 1);
      check(value >= 0xfd, off, 'Non-canonical varint');
      break;
    default:
      size = 1;
      value = data[off];
      break;
  }

  return new Varint(size, value);
}

function writeVarint(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');

  if (num < 0xfd) {
    dst[off++] = num;
    return off;
  }

  if (num <= 0xffff) {
    dst[off++] = 0xfd;
    return writeU16(dst, num, off);
  }

  if (num <= 0xffffffff) {
    dst[off++] = 0xfe;
    return writeU32(dst, num, off);
  }

  dst[off++] = 0xff;

  return writeU64(dst, num, off);
}

function sizeVarint(num) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');

  if (num < 0xfd)
    return 1;

  if (num <= 0xffff)
    return 3;

  if (num <= 0xffffffff)
    return 5;

  return 9;
}

function readVarint2(data, off) {
  let num = 0;
  let size = 0;

  for (;;) {
    checkRead(off < data.length, off);

    const ch = data[off++];

    size += 1;

    // Number.MAX_SAFE_INTEGER >>> 7
    check(num <= 0x3fffffffffff - (ch & 0x7f), off, 'Number exceeds 2^53-1');

    // num = (num << 7) | (ch & 0x7f);
    num = (num * 0x80) + (ch & 0x7f);

    if ((ch & 0x80) === 0)
      break;

    check(num !== MAX_SAFE_INTEGER, off, 'Number exceeds 2^53-1');
    num += 1;
  }

  return new Varint(size, num);
}

function writeVarint2(dst, num, off) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');

  const tmp = [];

  let len = 0;

  for (;;) {
    tmp[len] = (num & 0x7f) | (len ? 0x80 : 0x00);

    if (num <= 0x7f)
      break;

    // num = (num >>> 7) - 1;
    num = ((num - (num % 0x80)) / 0x80) - 1;
    len += 1;
  }

  checkRead(off + len + 1 <= dst.length, off);

  do {
    dst[off++] = tmp[len];
  } while (len--);

  return off;
}

function sizeVarint2(num) {
  enforce(Number.isSafeInteger(num), 'num', 'integer');

  let size = 0;

  for (;;) {
    size += 1;

    if (num <= 0x7f)
      break;

    // num = (num >>> 7) - 1;
    num = ((num - (num % 0x80)) / 0x80) - 1;
  }

  return size;
}

/*
 * Bytes
 */

function sliceBytes(data, off, size) {
  enforce((data != null && data._isBuffer === true), 'data', 'buffer');
  enforce((off >>> 0) === off, 'off', 'integer');
  enforce((size >>> 0) === size, 'size', 'integer');

  if (off + size > data.length)
    throw new EncodingError(off, 'Out of bounds read');

  return data.slice(off, off + size);
}

function readBytes(data, off, size) {
  enforce((data != null && data._isBuffer === true), 'data', 'buffer');
  enforce((off >>> 0) === off, 'off', 'integer');
  enforce((size >>> 0) === size, 'size', 'integer');

  if (off + size > data.length)
    throw new EncodingError(off, 'Out of bounds read');

  const buf = Buffer.allocUnsafeSlow(size);

  data.copy(buf, 0, off, off + size);

  return buf;
}

function writeBytes(data, value, off) {
  enforce((data != null && data._isBuffer === true), 'data', 'buffer');
  enforce((value != null && value._isBuffer === true), 'value', 'buffer');
  enforce((off >>> 0) === off, 'off', 'integer');

  if (off + value.length > data.length)
    throw new EncodingError(off, 'Out of bounds write');

  return value.copy(data, off, 0, value.length);
}

function readString(data, off, size, enc) {
  if (enc == null)
    enc = 'binary';

  enforce((data != null && data._isBuffer === true), 'data', 'buffer');
  enforce((off >>> 0) === off, 'off', 'integer');
  enforce((size >>> 0) === size, 'size', 'integer');
  enforce(typeof enc === 'string', 'enc', 'string');

  if (off + size > data.length)
    throw new EncodingError(off, 'Out of bounds read');

  return data.toString(enc, off, off + size);
}

function writeString(data, str, off, enc) {
  if (enc == null)
    enc = 'binary';

  enforce((data != null && data._isBuffer === true), 'data', 'buffer');
  enforce(typeof str === 'string', 'str', 'string');
  enforce((off >>> 0) === off, 'off', 'integer');
  enforce(typeof enc === 'string', 'enc', 'string');

  if (str.length === 0)
    return 0;

  const size = Buffer.byteLength(str, enc);

  if (off + size > data.length)
    throw new EncodingError(off, 'Out of bounds write');

  return data.write(str, off, enc);
}

function realloc(data, size) {
  enforce((data != null && data._isBuffer === true), 'data', 'buffer');

  const buf = Buffer.allocUnsafeSlow(size);

  data.copy(buf, 0);

  return buf;
}

function copy(data) {
  enforce((data != null && data._isBuffer === true), 'data', 'buffer');
  return realloc(data, data.length);
}

function concat(a, b) {
  enforce((a != null && a._isBuffer === true), 'a', 'buffer');
  enforce((b != null && b._isBuffer === true), 'b', 'buffer');

  const size = a.length + b.length;
  const buf = Buffer.allocUnsafeSlow(size);

  a.copy(buf, 0);
  b.copy(buf, a.length);

  return buf;
}

/*
 * Size Helpers
 */

function sizeVarBytes(data) {
  enforce((data != null && data._isBuffer === true), 'data', 'buffer');
  return sizeVarint(data.length) + data.length;
}

function sizeVarlen(len) {
  return sizeVarint(len) + len;
}

function sizeVarString(str, enc) {
  if (enc == null)
    enc = 'binary';

  enforce(typeof str === 'string', 'str', 'string');
  enforce(typeof enc === 'string', 'enc', 'string');

  if (str.length === 0)
    return 1;

  const len = Buffer.byteLength(str, enc);

  return sizeVarint(len) + len;
}

/*
 * Helpers
 */

function isSafe(hi, lo) {
  if (hi < 0) {
    hi = ~hi;
    if (lo === 0)
      hi += 1;
  }

  return (hi & 0xffe00000) === 0;
}

function write64(dst, num, off, be) {
  let neg = false;

  if (num < 0) {
    num = -num;
    neg = true;
  }

  let hi = (num * HI) | 0;
  let lo = num | 0;

  if (neg) {
    if (lo === 0) {
      hi = (~hi + 1) | 0;
    } else {
      hi = ~hi;
      lo = ~lo + 1;
    }
  }

  if (be) {
    off = writeI32BE(dst, hi, off);
    off = writeI32BE(dst, lo, off);
  } else {
    off = writeI32(dst, lo, off);
    off = writeI32(dst, hi, off);
  }

  return off;
}

function write56(dst, num, off, be) {
  let neg = false;

  if (num < 0) {
    num = -num;
    neg = true;
  }

  let hi = (num * HI) | 0;
  let lo = num | 0;

  if (neg) {
    if (lo === 0) {
      hi = (~hi + 1) | 0;
    } else {
      hi = ~hi;
      lo = ~lo + 1;
    }
  }

  if (be) {
    off = writeI24BE(dst, hi, off);
    off = writeI32BE(dst, lo, off);
  } else {
    off = writeI32(dst, lo, off);
    off = writeI24(dst, hi, off);
  }

  return off;
}

class Varint {
  constructor(size, value) {
    this.size = size;
    this.value = value;
  }
}

function isNumber(num) {
  return typeof num === 'number' && isFinite(num);
}

function checkRead(value, offset) {
  if (!value)
    throw new EncodingError(offset, 'Out of bounds read', checkRead);
}

function check(value, offset, reason) {
  if (!value)
    throw new EncodingError(offset, reason, check);
}

/*
 * Expose
 */

exports.readU = readU;
exports.readU64 = readU64;
exports.readU56 = readU56;
exports.readU48 = readU48;
exports.readU40 = readU40;
exports.readU32 = readU32;
exports.readU24 = readU24;
exports.readU16 = readU16;
exports.readU8 = readU8;

exports.readUBE = readUBE;
exports.readU64BE = readU64BE;
exports.readU56BE = readU56BE;
exports.readU48BE = readU48BE;
exports.readU40BE = readU40BE;
exports.readU32BE = readU32BE;
exports.readU24BE = readU24BE;
exports.readU16BE = readU16BE;

exports.readI = readI;
exports.readI64 = readI64;
exports.readI56 = readI56;
exports.readI48 = readI48;
exports.readI40 = readI40;
exports.readI32 = readI32;
exports.readI24 = readI24;
exports.readI16 = readI16;
exports.readI8 = readI8;

exports.readIBE = readIBE;
exports.readI64BE = readI64BE;
exports.readI56BE = readI56BE;
exports.readI48BE = readI48BE;
exports.readI40BE = readI40BE;
exports.readI32BE = readI32BE;
exports.readI24BE = readI24BE;
exports.readI16BE = readI16BE;

exports.readFloat = readFloat;
exports.readFloatBE = readFloatBE;
exports.readDouble = readDouble;
exports.readDoubleBE = readDoubleBE;

exports.writeU = writeU;
exports.writeU64 = writeU64;
exports.writeU56 = writeU56;
exports.writeU48 = writeU48;
exports.writeU40 = writeU40;
exports.writeU32 = writeU32;
exports.writeU24 = writeU24;
exports.writeU16 = writeU16;
exports.writeU8 = writeU8;

exports.writeUBE = writeUBE;
exports.writeU64BE = writeU64BE;
exports.writeU56BE = writeU56BE;
exports.writeU48BE = writeU48BE;
exports.writeU40BE = writeU40BE;
exports.writeU32BE = writeU32BE;
exports.writeU24BE = writeU24BE;
exports.writeU16BE = writeU16BE;

exports.writeI = writeI;
exports.writeI64 = writeI64;
exports.writeI56 = writeI56;
exports.writeI48 = writeI48;
exports.writeI40 = writeI40;
exports.writeI32 = writeI32;
exports.writeI24 = writeI24;
exports.writeI16 = writeI16;
exports.writeI8 = writeI8;

exports.writeIBE = writeIBE;
exports.writeI64BE = writeI64BE;
exports.writeI56BE = writeI56BE;
exports.writeI48BE = writeI48BE;
exports.writeI40BE = writeI40BE;
exports.writeI32BE = writeI32BE;
exports.writeI24BE = writeI24BE;
exports.writeI16BE = writeI16BE;

exports.writeFloat = writeFloat;
exports.writeFloatBE = writeFloatBE;
exports.writeDouble = writeDouble;
exports.writeDoubleBE = writeDoubleBE;

exports.readVarint = readVarint;
exports.writeVarint = writeVarint;
exports.sizeVarint = sizeVarint;
exports.readVarint2 = readVarint2;
exports.writeVarint2 = writeVarint2;
exports.sizeVarint2 = sizeVarint2;

exports.sliceBytes = sliceBytes;
exports.readBytes = readBytes;
exports.writeBytes = writeBytes;
exports.readString = readString;
exports.writeString = writeString;

exports.realloc = realloc;
exports.copy = copy;
exports.concat = concat;

exports.sizeVarBytes = sizeVarBytes;
exports.sizeVarlen = sizeVarlen;
exports.sizeVarString = sizeVarString;
}],
[/* 17 */ 'bufio', '/lib/enforce.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * enforce.js - type enforcement for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */



/*
 * Enforce
 */

function enforce(value, name, type) {
  if (!value) {
    const err = new TypeError(`'${name}' must be a(n) ${type}.`);

    if (Error.captureStackTrace)
      Error.captureStackTrace(err, enforce);

    throw err;
  }
}

/*
 * Expose
 */

module.exports = enforce;
}],
[/* 18 */ 'bufio', '/lib/error.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * error.js - encoding error for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */



/**
 * Encoding Error
 * @extends {Error}
 */

class EncodingError extends Error {
  /**
   * Create an encoding error.
   * @constructor
   * @param {Number} offset
   * @param {String} reason
   */

  constructor(offset, reason, start) {
    super();

    this.type = 'EncodingError';
    this.name = 'EncodingError';
    this.code = 'ERR_ENCODING';
    this.message = `${reason} (offset=${offset}).`;

    if (Error.captureStackTrace)
      Error.captureStackTrace(this, start || EncodingError);
  }
}

/*
 * Expose
 */

module.exports = EncodingError;
}],
[/* 19 */ 'bufio', '/lib/reader.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * reader.js - buffer reader for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */



const enforce = __browser_require__(17 /* './enforce' */, module);
const encoding = __browser_require__(16 /* './encoding' */, module);
const EncodingError = __browser_require__(18 /* './error' */, module);

/*
 * Constants
 */

const EMPTY = Buffer.alloc(0);

/**
 * Buffer Reader
 */

class BufferReader {
  /**
   * Create a buffer reader.
   * @constructor
   * @param {Buffer} data
   * @param {Boolean?} zeroCopy - Do not reallocate buffers when
   * slicing. Note that this can lead to memory leaks if not used
   * carefully.
   */

  constructor(data, zeroCopy = false) {
    enforce((data != null && data._isBuffer === true), 'data', 'buffer');
    enforce(typeof zeroCopy === 'boolean', 'zeroCopy', 'boolean');

    this.data = data;
    this.offset = 0;
    this.zeroCopy = zeroCopy;
    this.stack = [];
  }

  /**
   * Assertion.
   * @param {Number} size
   */

  check(size) {
    if (this.offset + size > this.data.length)
      throw new EncodingError(this.offset, 'Out of bounds read', this.check);
  }

  /**
   * Get total size of passed-in Buffer.
   * @returns {Buffer}
   */

  getSize() {
    return this.data.length;
  }

  /**
   * Calculate number of bytes left to read.
   * @returns {Number}
   */

  left() {
    this.check(0);
    return this.data.length - this.offset;
  }

  /**
   * Seek to a position to read from by offset.
   * @param {Number} off - Offset (positive or negative).
   */

  seek(off) {
    enforce(Number.isSafeInteger(off), 'off', 'integer');

    if (this.offset + off < 0)
      throw new EncodingError(this.offset, 'Out of bounds read');

    this.check(off);
    this.offset += off;

    return this;
  }

  /**
   * Mark the current starting position.
   */

  start() {
    this.stack.push(this.offset);
    return this.offset;
  }

  /**
   * Stop reading. Pop the start position off the stack
   * and calculate the size of the data read.
   * @returns {Number} Size.
   * @throws on empty stack.
   */

  end() {
    if (this.stack.length === 0)
      throw new Error('Cannot end without a stack item.');

    const start = this.stack.pop();

    return this.offset - start;
  }

  /**
   * Stop reading. Pop the start position off the stack
   * and return the data read.
   * @param {Bolean?} zeroCopy - Do a fast buffer
   * slice instead of allocating a new buffer (warning:
   * may cause memory leaks if not used with care).
   * @returns {Buffer} Data read.
   * @throws on empty stack.
   */

  endData(zeroCopy = false) {
    enforce(typeof zeroCopy === 'boolean', 'zeroCopy', 'boolean');

    if (this.stack.length === 0)
      throw new Error('Cannot end without a stack item.');

    const start = this.stack.pop();
    const end = this.offset;
    const size = end - start;
    const data = this.data;

    if (size === data.length)
      return data;

    if (this.zeroCopy || zeroCopy)
      return data.slice(start, end);

    const ret = Buffer.allocUnsafeSlow(size);

    data.copy(ret, 0, start, end);

    return ret;
  }

  /**
   * Destroy the reader. Remove references to the data.
   */

  destroy() {
    this.data = EMPTY;
    this.offset = 0;
    this.stack.length = 0;
    return this;
  }

  /**
   * Read uint8.
   * @returns {Number}
   */

  readU8() {
    this.check(1);

    const ret = this.data[this.offset];

    this.offset += 1;

    return ret;
  }

  /**
   * Read uint16le.
   * @returns {Number}
   */

  readU16() {
    this.check(2);

    const ret = encoding.readU16(this.data, this.offset);

    this.offset += 2;

    return ret;
  }

  /**
   * Read uint16be.
   * @returns {Number}
   */

  readU16BE() {
    this.check(2);

    const ret = encoding.readU16BE(this.data, this.offset);

    this.offset += 2;

    return ret;
  }

  /**
   * Read uint24le.
   * @returns {Number}
   */

  readU24() {
    this.check(3);

    const ret = encoding.readU24(this.data, this.offset);

    this.offset += 3;

    return ret;
  }

  /**
   * Read uint24be.
   * @returns {Number}
   */

  readU24BE() {
    this.check(3);

    const ret = encoding.readU24BE(this.data, this.offset);

    this.offset += 3;

    return ret;
  }

  /**
   * Read uint32le.
   * @returns {Number}
   */

  readU32() {
    this.check(4);

    const ret = encoding.readU32(this.data, this.offset);

    this.offset += 4;

    return ret;
  }

  /**
   * Read uint32be.
   * @returns {Number}
   */

  readU32BE() {
    this.check(4);

    const ret = encoding.readU32BE(this.data, this.offset);

    this.offset += 4;

    return ret;
  }

  /**
   * Read uint40le.
   * @returns {Number}
   */

  readU40() {
    this.check(5);

    const ret = encoding.readU40(this.data, this.offset);

    this.offset += 5;

    return ret;
  }

  /**
   * Read uint40be.
   * @returns {Number}
   */

  readU40BE() {
    this.check(5);

    const ret = encoding.readU40BE(this.data, this.offset);

    this.offset += 5;

    return ret;
  }

  /**
   * Read uint48le.
   * @returns {Number}
   */

  readU48() {
    this.check(6);

    const ret = encoding.readU48(this.data, this.offset);

    this.offset += 6;

    return ret;
  }

  /**
   * Read uint48be.
   * @returns {Number}
   */

  readU48BE() {
    this.check(6);

    const ret = encoding.readU48BE(this.data, this.offset);

    this.offset += 6;

    return ret;
  }

  /**
   * Read uint56le.
   * @returns {Number}
   */

  readU56() {
    this.check(7);

    const ret = encoding.readU56(this.data, this.offset);

    this.offset += 7;

    return ret;
  }

  /**
   * Read uint56be.
   * @returns {Number}
   */

  readU56BE() {
    this.check(7);

    const ret = encoding.readU56BE(this.data, this.offset);

    this.offset += 7;

    return ret;
  }

  /**
   * Read uint64le as a js number.
   * @returns {Number}
   * @throws on num > MAX_SAFE_INTEGER
   */

  readU64() {
    this.check(8);

    const ret = encoding.readU64(this.data, this.offset);

    this.offset += 8;

    return ret;
  }

  /**
   * Read uint64be as a js number.
   * @returns {Number}
   * @throws on num > MAX_SAFE_INTEGER
   */

  readU64BE() {
    this.check(8);

    const ret = encoding.readU64BE(this.data, this.offset);

    this.offset += 8;

    return ret;
  }

  /**
   * Read int8.
   * @returns {Number}
   */

  readI8() {
    this.check(1);

    const ret = encoding.readI8(this.data, this.offset);

    this.offset += 1;

    return ret;
  }

  /**
   * Read int16le.
   * @returns {Number}
   */

  readI16() {
    this.check(2);

    const ret = encoding.readI16(this.data, this.offset);

    this.offset += 2;

    return ret;
  }

  /**
   * Read int16be.
   * @returns {Number}
   */

  readI16BE() {
    this.check(2);

    const ret = encoding.readI16BE(this.data, this.offset);

    this.offset += 2;

    return ret;
  }

  /**
   * Read int24le.
   * @returns {Number}
   */

  readI24() {
    this.check(3);

    const ret = encoding.readI24(this.data, this.offset);

    this.offset += 3;

    return ret;
  }

  /**
   * Read int24be.
   * @returns {Number}
   */

  readI24BE() {
    this.check(3);

    const ret = encoding.readI24BE(this.data, this.offset);

    this.offset += 3;

    return ret;
  }

  /**
   * Read int32le.
   * @returns {Number}
   */

  readI32() {
    this.check(4);

    const ret = encoding.readI32(this.data, this.offset);

    this.offset += 4;

    return ret;
  }

  /**
   * Read int32be.
   * @returns {Number}
   */

  readI32BE() {
    this.check(4);

    const ret = encoding.readI32BE(this.data, this.offset);

    this.offset += 4;

    return ret;
  }

  /**
   * Read int40le.
   * @returns {Number}
   */

  readI40() {
    this.check(5);

    const ret = encoding.readI40(this.data, this.offset);

    this.offset += 5;

    return ret;
  }

  /**
   * Read int40be.
   * @returns {Number}
   */

  readI40BE() {
    this.check(5);

    const ret = encoding.readI40BE(this.data, this.offset);

    this.offset += 5;

    return ret;
  }

  /**
   * Read int48le.
   * @returns {Number}
   */

  readI48() {
    this.check(6);

    const ret = encoding.readI48(this.data, this.offset);

    this.offset += 6;

    return ret;
  }

  /**
   * Read int48be.
   * @returns {Number}
   */

  readI48BE() {
    this.check(6);

    const ret = encoding.readI48BE(this.data, this.offset);

    this.offset += 6;

    return ret;
  }

  /**
   * Read int56le.
   * @returns {Number}
   */

  readI56() {
    this.check(7);

    const ret = encoding.readI56(this.data, this.offset);

    this.offset += 7;

    return ret;
  }

  /**
   * Read int56be.
   * @returns {Number}
   */

  readI56BE() {
    this.check(7);

    const ret = encoding.readI56BE(this.data, this.offset);

    this.offset += 7;

    return ret;
  }

  /**
   * Read int64le as a js number.
   * @returns {Number}
   * @throws on num > MAX_SAFE_INTEGER
   */

  readI64() {
    this.check(8);

    const ret = encoding.readI64(this.data, this.offset);

    this.offset += 8;

    return ret;
  }

  /**
   * Read int64be as a js number.
   * @returns {Number}
   * @throws on num > MAX_SAFE_INTEGER
   */

  readI64BE() {
    this.check(8);

    const ret = encoding.readI64BE(this.data, this.offset);

    this.offset += 8;

    return ret;
  }

  /**
   * Read float le.
   * @returns {Number}
   */

  readFloat() {
    this.check(4);

    const ret = encoding.readFloat(this.data, this.offset);

    this.offset += 4;

    return ret;
  }

  /**
   * Read float be.
   * @returns {Number}
   */

  readFloatBE() {
    this.check(4);

    const ret = encoding.readFloatBE(this.data, this.offset);

    this.offset += 4;

    return ret;
  }

  /**
   * Read double float le.
   * @returns {Number}
   */

  readDouble() {
    this.check(8);

    const ret = encoding.readDouble(this.data, this.offset);

    this.offset += 8;

    return ret;
  }

  /**
   * Read double float be.
   * @returns {Number}
   */

  readDoubleBE() {
    this.check(8);

    const ret = encoding.readDoubleBE(this.data, this.offset);

    this.offset += 8;

    return ret;
  }

  /**
   * Read a varint.
   * @returns {Number}
   */

  readVarint() {
    const {size, value} = encoding.readVarint(this.data, this.offset);

    this.offset += size;

    return value;
  }

  /**
   * Read a varint (type 2).
   * @returns {Number}
   */

  readVarint2() {
    const {size, value} = encoding.readVarint2(this.data, this.offset);

    this.offset += size;

    return value;
  }

  /**
   * Read N bytes (will do a fast slice if zero copy).
   * @param {Number} size
   * @param {Bolean?} zeroCopy - Do a fast buffer
   * slice instead of allocating a new buffer (warning:
   * may cause memory leaks if not used with care).
   * @returns {Buffer}
   */

  readBytes(size, zeroCopy = false) {
    enforce((size >>> 0) === size, 'size', 'integer');
    enforce(typeof zeroCopy === 'boolean', 'zeroCopy', 'boolean');

    this.check(size);

    let ret;

    if (this.zeroCopy || zeroCopy) {
      ret = this.data.slice(this.offset, this.offset + size);
    } else {
      ret = Buffer.allocUnsafeSlow(size);
      this.data.copy(ret, 0, this.offset, this.offset + size);
    }

    this.offset += size;

    return ret;
  }

  /**
   * Read a varint number of bytes (will do a fast slice if zero copy).
   * @param {Bolean?} zeroCopy - Do a fast buffer
   * slice instead of allocating a new buffer (warning:
   * may cause memory leaks if not used with care).
   * @returns {Buffer}
   */

  readVarBytes(zeroCopy = false) {
    return this.readBytes(this.readVarint(), zeroCopy);
  }

  /**
   * Slice N bytes and create a child reader.
   * @param {Number} size
   * @returns {BufferReader}
   */

  readChild(size) {
    enforce((size >>> 0) === size, 'size', 'integer');

    this.check(size);

    const data = this.data.slice(0, this.offset + size);
    const br = new this.constructor(data);

    br.offset = this.offset;

    this.offset += size;

    return br;
  }

  /**
   * Read a string.
   * @param {Number} size
   * @param {String} enc - Any buffer-supported encoding.
   * @returns {String}
   */

  readString(size, enc) {
    if (enc == null)
      enc = 'binary';

    enforce((size >>> 0) === size, 'size', 'integer');
    enforce(typeof enc === 'string', 'enc', 'string');

    this.check(size);

    const ret = this.data.toString(enc, this.offset, this.offset + size);

    this.offset += size;

    return ret;
  }

  /**
   * Read a 32-byte hash.
   * @param {String} enc - `"hex"` or `null`.
   * @returns {Hash|Buffer}
   */

  readHash(enc) {
    if (enc)
      return this.readString(32, enc);
    return this.readBytes(32);
  }

  /**
   * Read string of a varint length.
   * @param {String} enc - Any buffer-supported encoding.
   * @param {Number?} limit - Size limit.
   * @returns {String}
   */

  readVarString(enc, limit = 0) {
    if (enc == null)
      enc = 'binary';

    enforce(typeof enc === 'string', 'enc', 'string');
    enforce((limit >>> 0) === limit, 'limit', 'integer');

    const size = this.readVarint();

    if (limit !== 0 && size > limit)
      throw new EncodingError(this.offset, 'String exceeds limit');

    return this.readString(size, enc);
  }

  /**
   * Read a null-terminated string.
   * @param {String} enc - Any buffer-supported encoding.
   * @returns {String}
   */

  readNullString(enc) {
    if (enc == null)
      enc = 'binary';

    enforce(typeof enc === 'string', 'enc', 'string');

    let i = this.offset;

    for (; i < this.data.length; i++) {
      if (this.data[i] === 0)
        break;
    }

    if (i === this.data.length)
      throw new EncodingError(this.offset, 'No NUL terminator');

    const ret = this.readString(i - this.offset, enc);

    this.offset = i + 1;

    return ret;
  }

  /**
   * Create a checksum from the last start position.
   * @param {Function} hash
   * @returns {Number} Checksum.
   */

  createChecksum(hash) {
    if (!hash || typeof hash.digest !== 'function')
      enforce(typeof hash === 'function', 'hash', 'function');

    let start = 0;

    if (this.stack.length > 0)
      start = this.stack[this.stack.length - 1];

    const data = this.data.slice(start, this.offset);
    const raw = hash.digest ? hash.digest(data) : hash(data);

    return encoding.readU32(raw, 0);
  }

  /**
   * Verify a 4-byte checksum against a calculated checksum.
   * @param {Function} hash
   * @returns {Number} checksum
   * @throws on bad checksum
   */

  verifyChecksum(hash) {
    const checksum = this.createChecksum(hash);
    const expect = this.readU32();

    if (checksum !== expect)
      throw new EncodingError(this.offset, 'Checksum mismatch');

    return checksum;
  }
}

/*
 * Expose
 */

module.exports = BufferReader;
}],
[/* 20 */ 'bufio', '/lib/writer.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * writer.js - buffer writer for bcoin
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */



const enforce = __browser_require__(17 /* './enforce' */, module);
const encoding = __browser_require__(16 /* './encoding' */, module);
const EncodingError = __browser_require__(18 /* './error' */, module);

/*
 * Constants
 */

const SEEK = 0;
const U8 = 1;
const U16 = 2;
const U16BE = 3;
const U24 = 4;
const U24BE = 5;
const U32 = 6;
const U32BE = 7;
const U40 = 8;
const U40BE = 9;
const U48 = 10;
const U48BE = 11;
const U56 = 12;
const U56BE = 13;
const U64 = 14;
const U64BE = 15;
const I8 = 16;
const I16 = 17;
const I16BE = 18;
const I24 = 19;
const I24BE = 20;
const I32 = 21;
const I32BE = 22;
const I40 = 23;
const I40BE = 24;
const I48 = 25;
const I48BE = 26;
const I56 = 27;
const I56BE = 28;
const I64 = 29;
const I64BE = 30;
const FL = 31;
const FLBE = 32;
const DBL = 33;
const DBLBE = 34;
const VARINT = 35;
const VARINT2 = 36;
const BYTES = 37;
const STR = 38;
const CHECKSUM = 39;
const FILL = 40;

/**
 * Buffer Writer
 */

class BufferWriter {
  /**
   * Create a buffer writer.
   * @constructor
   */

  constructor() {
    this.ops = [];
    this.offset = 0;
  }

  /**
   * Allocate and render the final buffer.
   * @returns {Buffer} Rendered buffer.
   */

  render() {
    const data = Buffer.allocUnsafeSlow(this.offset);

    let off = 0;

    for (const op of this.ops) {
      switch (op.type) {
        case SEEK:
          off += op.value;
          break;
        case U8:
          off = encoding.writeU8(data, op.value, off);
          break;
        case U16:
          off = encoding.writeU16(data, op.value, off);
          break;
        case U16BE:
          off = encoding.writeU16BE(data, op.value, off);
          break;
        case U24:
          off = encoding.writeU24(data, op.value, off);
          break;
        case U24BE:
          off = encoding.writeU24BE(data, op.value, off);
          break;
        case U32:
          off = encoding.writeU32(data, op.value, off);
          break;
        case U32BE:
          off = encoding.writeU32BE(data, op.value, off);
          break;
        case U40:
          off = encoding.writeU40(data, op.value, off);
          break;
        case U40BE:
          off = encoding.writeU40BE(data, op.value, off);
          break;
        case U48:
          off = encoding.writeU48(data, op.value, off);
          break;
        case U48BE:
          off = encoding.writeU48BE(data, op.value, off);
          break;
        case U56:
          off = encoding.writeU56(data, op.value, off);
          break;
        case U56BE:
          off = encoding.writeU56BE(data, op.value, off);
          break;
        case U64:
          off = encoding.writeU64(data, op.value, off);
          break;
        case U64BE:
          off = encoding.writeU64BE(data, op.value, off);
          break;
        case I8:
          off = encoding.writeI8(data, op.value, off);
          break;
        case I16:
          off = encoding.writeI16(data, op.value, off);
          break;
        case I16BE:
          off = encoding.writeI16BE(data, op.value, off);
          break;
        case I24:
          off = encoding.writeI24(data, op.value, off);
          break;
        case I24BE:
          off = encoding.writeI24BE(data, op.value, off);
          break;
        case I32:
          off = encoding.writeI32(data, op.value, off);
          break;
        case I32BE:
          off = encoding.writeI32BE(data, op.value, off);
          break;
        case I40:
          off = encoding.writeI40(data, op.value, off);
          break;
        case I40BE:
          off = encoding.writeI40BE(data, op.value, off);
          break;
        case I48:
          off = encoding.writeI48(data, op.value, off);
          break;
        case I48BE:
          off = encoding.writeI48BE(data, op.value, off);
          break;
        case I56:
          off = encoding.writeI56(data, op.value, off);
          break;
        case I56BE:
          off = encoding.writeI56BE(data, op.value, off);
          break;
        case I64:
          off = encoding.writeI64(data, op.value, off);
          break;
        case I64BE:
          off = encoding.writeI64BE(data, op.value, off);
          break;
        case FL:
          off = encoding.writeFloat(data, op.value, off);
          break;
        case FLBE:
          off = encoding.writeFloatBE(data, op.value, off);
          break;
        case DBL:
          off = encoding.writeDouble(data, op.value, off);
          break;
        case DBLBE:
          off = encoding.writeDoubleBE(data, op.value, off);
          break;
        case VARINT:
          off = encoding.writeVarint(data, op.value, off);
          break;
        case VARINT2:
          off = encoding.writeVarint2(data, op.value, off);
          break;
        case BYTES:
          off += op.data.copy(data, off);
          break;
        case STR:
          off += data.write(op.value, off, op.enc);
          break;
        case CHECKSUM:
          off += op.func(data.slice(0, off)).copy(data, off, 0, 4);
          break;
        case FILL:
          data.fill(op.value, off, off + op.size);
          off += op.size;
          break;
        default:
          throw new Error('Invalid type.');
      }
    }

    if (off !== data.length)
      throw new EncodingError(off, 'Out of bounds write');

    this.destroy();

    return data;
  }

  /**
   * Get size of data written so far.
   * @returns {Number}
   */

  getSize() {
    return this.offset;
  }

  /**
   * Seek to relative offset.
   * @param {Number} offset
   */

  seek(off) {
    enforce(Number.isSafeInteger(off), 'off', 'integer');

    if (this.offset + off < 0)
      throw new EncodingError(this.offset, 'Out of bounds write');

    this.offset += off;
    this.ops.push(new NumberOp(SEEK, off));

    return this;
  }

  /**
   * Destroy the buffer writer. Remove references to `ops`.
   */

  destroy() {
    this.ops.length = 0;
    this.offset = 0;
    return this;
  }

  /**
   * Write uint8.
   * @param {Number} value
   */

  writeU8(value) {
    this.offset += 1;
    this.ops.push(new NumberOp(U8, value));
    return this;
  }

  /**
   * Write uint16le.
   * @param {Number} value
   */

  writeU16(value) {
    this.offset += 2;
    this.ops.push(new NumberOp(U16, value));
    return this;
  }

  /**
   * Write uint16be.
   * @param {Number} value
   */

  writeU16BE(value) {
    this.offset += 2;
    this.ops.push(new NumberOp(U16BE, value));
    return this;
  }

  /**
   * Write uint24le.
   * @param {Number} value
   */

  writeU24(value) {
    this.offset += 3;
    this.ops.push(new NumberOp(U24, value));
    return this;
  }

  /**
   * Write uint24be.
   * @param {Number} value
   */

  writeU24BE(value) {
    this.offset += 3;
    this.ops.push(new NumberOp(U24BE, value));
    return this;
  }

  /**
   * Write uint32le.
   * @param {Number} value
   */

  writeU32(value) {
    this.offset += 4;
    this.ops.push(new NumberOp(U32, value));
    return this;
  }

  /**
   * Write uint32be.
   * @param {Number} value
   */

  writeU32BE(value) {
    this.offset += 4;
    this.ops.push(new NumberOp(U32BE, value));
    return this;
  }

  /**
   * Write uint40le.
   * @param {Number} value
   */

  writeU40(value) {
    this.offset += 5;
    this.ops.push(new NumberOp(U40, value));
    return this;
  }

  /**
   * Write uint40be.
   * @param {Number} value
   */

  writeU40BE(value) {
    this.offset += 5;
    this.ops.push(new NumberOp(U40BE, value));
    return this;
  }

  /**
   * Write uint48le.
   * @param {Number} value
   */

  writeU48(value) {
    this.offset += 6;
    this.ops.push(new NumberOp(U48, value));
    return this;
  }

  /**
   * Write uint48be.
   * @param {Number} value
   */

  writeU48BE(value) {
    this.offset += 6;
    this.ops.push(new NumberOp(U48BE, value));
    return this;
  }

  /**
   * Write uint56le.
   * @param {Number} value
   */

  writeU56(value) {
    this.offset += 7;
    this.ops.push(new NumberOp(U56, value));
    return this;
  }

  /**
   * Write uint56be.
   * @param {Number} value
   */

  writeU56BE(value) {
    this.offset += 7;
    this.ops.push(new NumberOp(U56BE, value));
    return this;
  }

  /**
   * Write uint64le.
   * @param {Number} value
   */

  writeU64(value) {
    this.offset += 8;
    this.ops.push(new NumberOp(U64, value));
    return this;
  }

  /**
   * Write uint64be.
   * @param {Number} value
   */

  writeU64BE(value) {
    this.offset += 8;
    this.ops.push(new NumberOp(U64BE, value));
    return this;
  }

  /**
   * Write int8.
   * @param {Number} value
   */

  writeI8(value) {
    this.offset += 1;
    this.ops.push(new NumberOp(I8, value));
    return this;
  }

  /**
   * Write int16le.
   * @param {Number} value
   */

  writeI16(value) {
    this.offset += 2;
    this.ops.push(new NumberOp(I16, value));
    return this;
  }

  /**
   * Write int16be.
   * @param {Number} value
   */

  writeI16BE(value) {
    this.offset += 2;
    this.ops.push(new NumberOp(I16BE, value));
    return this;
  }

  /**
   * Write int24le.
   * @param {Number} value
   */

  writeI24(value) {
    this.offset += 3;
    this.ops.push(new NumberOp(I24, value));
    return this;
  }

  /**
   * Write int24be.
   * @param {Number} value
   */

  writeI24BE(value) {
    this.offset += 3;
    this.ops.push(new NumberOp(I24BE, value));
    return this;
  }

  /**
   * Write int32le.
   * @param {Number} value
   */

  writeI32(value) {
    this.offset += 4;
    this.ops.push(new NumberOp(I32, value));
    return this;
  }

  /**
   * Write int32be.
   * @param {Number} value
   */

  writeI32BE(value) {
    this.offset += 4;
    this.ops.push(new NumberOp(I32BE, value));
    return this;
  }

  /**
   * Write int40le.
   * @param {Number} value
   */

  writeI40(value) {
    this.offset += 5;
    this.ops.push(new NumberOp(I40, value));
    return this;
  }

  /**
   * Write int40be.
   * @param {Number} value
   */

  writeI40BE(value) {
    this.offset += 5;
    this.ops.push(new NumberOp(I40BE, value));
    return this;
  }

  /**
   * Write int48le.
   * @param {Number} value
   */

  writeI48(value) {
    this.offset += 6;
    this.ops.push(new NumberOp(I48, value));
    return this;
  }

  /**
   * Write int48be.
   * @param {Number} value
   */

  writeI48BE(value) {
    this.offset += 6;
    this.ops.push(new NumberOp(I48BE, value));
    return this;
  }

  /**
   * Write int56le.
   * @param {Number} value
   */

  writeI56(value) {
    this.offset += 7;
    this.ops.push(new NumberOp(I56, value));
    return this;
  }

  /**
   * Write int56be.
   * @param {Number} value
   */

  writeI56BE(value) {
    this.offset += 7;
    this.ops.push(new NumberOp(I56BE, value));
    return this;
  }

  /**
   * Write int64le.
   * @param {Number} value
   */

  writeI64(value) {
    this.offset += 8;
    this.ops.push(new NumberOp(I64, value));
    return this;
  }

  /**
   * Write int64be.
   * @param {Number} value
   */

  writeI64BE(value) {
    this.offset += 8;
    this.ops.push(new NumberOp(I64BE, value));
    return this;
  }

  /**
   * Write float le.
   * @param {Number} value
   */

  writeFloat(value) {
    this.offset += 4;
    this.ops.push(new NumberOp(FL, value));
    return this;
  }

  /**
   * Write float be.
   * @param {Number} value
   */

  writeFloatBE(value) {
    this.offset += 4;
    this.ops.push(new NumberOp(FLBE, value));
    return this;
  }

  /**
   * Write double le.
   * @param {Number} value
   */

  writeDouble(value) {
    this.offset += 8;
    this.ops.push(new NumberOp(DBL, value));
    return this;
  }

  /**
   * Write double be.
   * @param {Number} value
   */

  writeDoubleBE(value) {
    this.offset += 8;
    this.ops.push(new NumberOp(DBLBE, value));
    return this;
  }

  /**
   * Write a varint.
   * @param {Number} value
   */

  writeVarint(value) {
    this.offset += encoding.sizeVarint(value);
    this.ops.push(new NumberOp(VARINT, value));
    return this;
  }

  /**
   * Write a varint (type 2).
   * @param {Number} value
   */

  writeVarint2(value) {
    this.offset += encoding.sizeVarint2(value);
    this.ops.push(new NumberOp(VARINT2, value));
    return this;
  }

  /**
   * Write bytes.
   * @param {Buffer} value
   */

  writeBytes(value) {
    enforce((value != null && value._isBuffer === true), 'value', 'buffer');

    if (value.length === 0)
      return this;

    this.offset += value.length;
    this.ops.push(new BufferOp(BYTES, value));

    return this;
  }

  /**
   * Write bytes with a varint length before them.
   * @param {Buffer} value
   */

  writeVarBytes(value) {
    enforce((value != null && value._isBuffer === true), 'value', 'buffer');

    this.offset += encoding.sizeVarint(value.length);
    this.ops.push(new NumberOp(VARINT, value.length));

    if (value.length === 0)
      return this;

    this.offset += value.length;
    this.ops.push(new BufferOp(BYTES, value));

    return this;
  }

  /**
   * Copy bytes.
   * @param {Buffer} value
   * @param {Number} start
   * @param {Number} end
   */

  copy(value, start, end) {
    enforce((value != null && value._isBuffer === true), 'value', 'buffer');
    enforce((start >>> 0) === start, 'start', 'integer');
    enforce((end >>> 0) === end, 'end', 'integer');
    enforce(end >= start, 'start', 'integer');

    const buf = value.slice(start, end);

    this.writeBytes(buf);

    return this;
  }

  /**
   * Write string to buffer.
   * @param {String} value
   * @param {String?} enc - Any buffer-supported encoding.
   */

  writeString(value, enc) {
    if (enc == null)
      enc = 'binary';

    enforce(typeof value === 'string', 'value', 'string');
    enforce(typeof enc === 'string', 'enc', 'string');

    if (value.length === 0)
      return this;

    this.offset += Buffer.byteLength(value, enc);
    this.ops.push(new StringOp(STR, value, enc));

    return this;
  }

  /**
   * Write a 32 byte hash.
   * @param {Hash} value
   */

  writeHash(value) {
    if (typeof value !== 'string') {
      enforce((value != null && value._isBuffer === true), 'value', 'buffer');
      enforce(value.length === 32, 'value', '32-byte hash');
      this.writeBytes(value);
      return this;
    }

    enforce(value.length === 64, 'value', '32-byte hash');

    this.writeString(value, 'hex');

    return this;
  }

  /**
   * Write a string with a varint length before it.
   * @param {String}
   * @param {String?} enc - Any buffer-supported encoding.
   */

  writeVarString(value, enc) {
    if (enc == null)
      enc = 'binary';

    enforce(typeof value === 'string', 'value', 'string');
    enforce(typeof enc === 'string', 'enc', 'string');

    if (value.length === 0) {
      this.ops.push(new NumberOp(VARINT, 0));
      return this;
    }

    const size = Buffer.byteLength(value, enc);

    this.offset += encoding.sizeVarint(size);
    this.offset += size;

    this.ops.push(new NumberOp(VARINT, size));
    this.ops.push(new StringOp(STR, value, enc));

    return this;
  }

  /**
   * Write a null-terminated string.
   * @param {String|Buffer}
   * @param {String?} enc - Any buffer-supported encoding.
   */

  writeNullString(value, enc) {
    this.writeString(value, enc);
    this.writeU8(0);
    return this;
  }

  /**
   * Calculate and write a checksum for the data written so far.
   * @param {Function} hash
   */

  writeChecksum(hash) {
    if (hash && typeof hash.digest === 'function')
      hash = hash.digest.bind(hash);

    enforce(typeof hash === 'function', 'hash', 'function');

    this.offset += 4;
    this.ops.push(new FunctionOp(CHECKSUM, hash));

    return this;
  }

  /**
   * Fill N bytes with value.
   * @param {Number} value
   * @param {Number} size
   */

  fill(value, size) {
    enforce((value & 0xff) === value, 'value', 'byte');
    enforce((size >>> 0) === size, 'size', 'integer');

    if (size === 0)
      return this;

    this.offset += size;
    this.ops.push(new FillOp(FILL, value, size));

    return this;
  }
}

/*
 * Helpers
 */

class WriteOp {
  constructor(type) {
    this.type = type;
  }
}

class NumberOp extends WriteOp {
  constructor(type, value) {
    super(type);
    this.value = value;
  }
}

class BufferOp extends WriteOp {
  constructor(type, data) {
    super(type);
    this.data = data;
  }
}

class StringOp extends WriteOp {
  constructor(type, value, enc) {
    super(type);
    this.value = value;
    this.enc = enc;
  }
}

class FunctionOp extends WriteOp {
  constructor(type, func) {
    super(type);
    this.func = func;
  }
}

class FillOp extends WriteOp {
  constructor(type, value, size) {
    super(type);
    this.value = value;
    this.size = size;
  }
}

/*
 * Expose
 */

module.exports = BufferWriter;
}],
[/* 21 */ 'bufio', '/lib/staticwriter.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * staticwriter.js - buffer writer for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */



const enforce = __browser_require__(17 /* './enforce' */, module);
const encoding = __browser_require__(16 /* './encoding' */, module);
const EncodingError = __browser_require__(18 /* './error' */, module);

/*
 * Constants
 */

const EMPTY = Buffer.alloc(0);
const POOL_SIZE = 100 << 10;

let POOL = null;

/**
 * Statically Allocated Writer
 */

class StaticWriter {
  /**
   * Statically allocated buffer writer.
   * @constructor
   * @param {Number|Buffer} options
   */

  constructor(options) {
    this.data = EMPTY;
    this.offset = 0;

    if (options != null)
      this.init(options);
  }

  /**
   * Assertion.
   * @param {Number} size
   */

  check(size) {
    if (this.offset + size > this.data.length)
      throw new EncodingError(this.offset, 'Out of bounds write', this.check);
  }

  /**
   * Initialize options.
   * @param {Object} options
   */

  init(options) {
    if ((options != null && options._isBuffer === true)) {
      this.data = options;
      this.offset = 0;
      return this;
    }

    enforce((options >>> 0) === options, 'size', 'integer');

    this.data = Buffer.allocUnsafeSlow(options);
    this.offset = 0;

    return this;
  }

  /**
   * Allocate writer from preallocated 100kb pool.
   * @param {Number} size
   * @returns {StaticWriter}
   */

  static pool(size) {
    enforce((size >>> 0) === size, 'size', 'integer');

    if (size <= POOL_SIZE) {
      if (!POOL)
        POOL = Buffer.allocUnsafeSlow(POOL_SIZE);

      const bw = new StaticWriter();

      bw.data = POOL.slice(0, size);

      return bw;
    }

    return new StaticWriter(size);
  }

  /**
   * Allocate and render the final buffer.
   * @returns {Buffer} Rendered buffer.
   */

  render() {
    const {data, offset} = this;

    if (offset !== data.length)
      throw new EncodingError(offset, 'Out of bounds write');

    this.destroy();

    return data;
  }

  /**
   * Slice the final buffer at written offset.
   * @returns {Buffer} Rendered buffer.
   */

  slice() {
    const {data, offset} = this;

    if (offset > data.length)
      throw new EncodingError(offset, 'Out of bounds write');

    this.destroy();

    return data.slice(0, offset);
  }

  /**
   * Get size of data written so far.
   * @returns {Number}
   */

  getSize() {
    return this.offset;
  }

  /**
   * Seek to relative offset.
   * @param {Number} off
   */

  seek(off) {
    enforce(Number.isSafeInteger(off), 'off', 'integer');

    if (this.offset + off < 0)
      throw new EncodingError(this.offset, 'Out of bounds write');

    this.check(off);
    this.offset += off;

    return this;
  }

  /**
   * Destroy the buffer writer.
   */

  destroy() {
    this.data = EMPTY;
    this.offset = 0;
    return this;
  }

  /**
   * Write uint8.
   * @param {Number} value
   */

  writeU8(value) {
    this.check(1);
    this.offset = encoding.writeU8(this.data, value, this.offset);
    return this;
  }

  /**
   * Write uint16le.
   * @param {Number} value
   */

  writeU16(value) {
    this.check(2);
    this.offset = encoding.writeU16(this.data, value, this.offset);
    return this;
  }

  /**
   * Write uint16be.
   * @param {Number} value
   */

  writeU16BE(value) {
    this.check(2);
    this.offset = encoding.writeU16BE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write uint24le.
   * @param {Number} value
   */

  writeU24(value) {
    this.check(3);
    this.offset = encoding.writeU24(this.data, value, this.offset);
    return this;
  }

  /**
   * Write uint24be.
   * @param {Number} value
   */

  writeU24BE(value) {
    this.check(3);
    this.offset = encoding.writeU24BE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write uint32le.
   * @param {Number} value
   */

  writeU32(value) {
    this.check(4);
    this.offset = encoding.writeU32(this.data, value, this.offset);
    return this;
  }

  /**
   * Write uint32be.
   * @param {Number} value
   */

  writeU32BE(value) {
    this.check(4);
    this.offset = encoding.writeU32BE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write uint40le.
   * @param {Number} value
   */

  writeU40(value) {
    this.check(5);
    this.offset = encoding.writeU40(this.data, value, this.offset);
    return this;
  }

  /**
   * Write uint40be.
   * @param {Number} value
   */

  writeU40BE(value) {
    this.check(5);
    this.offset = encoding.writeU40BE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write uint48le.
   * @param {Number} value
   */

  writeU48(value) {
    this.check(6);
    this.offset = encoding.writeU48(this.data, value, this.offset);
    return this;
  }

  /**
   * Write uint48be.
   * @param {Number} value
   */

  writeU48BE(value) {
    this.check(6);
    this.offset = encoding.writeU48BE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write uint56le.
   * @param {Number} value
   */

  writeU56(value) {
    this.check(7);
    this.offset = encoding.writeU56(this.data, value, this.offset);
    return this;
  }

  /**
   * Write uint56be.
   * @param {Number} value
   */

  writeU56BE(value) {
    this.check(7);
    this.offset = encoding.writeU56BE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write uint64le.
   * @param {Number} value
   */

  writeU64(value) {
    this.check(8);
    this.offset = encoding.writeU64(this.data, value, this.offset);
    return this;
  }

  /**
   * Write uint64be.
   * @param {Number} value
   */

  writeU64BE(value) {
    this.check(8);
    this.offset = encoding.writeU64BE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write int8.
   * @param {Number} value
   */

  writeI8(value) {
    this.check(1);
    this.offset = encoding.writeI8(this.data, value, this.offset);
    return this;
  }

  /**
   * Write int16le.
   * @param {Number} value
   */

  writeI16(value) {
    this.check(2);
    this.offset = encoding.writeI16(this.data, value, this.offset);
    return this;
  }

  /**
   * Write int16be.
   * @param {Number} value
   */

  writeI16BE(value) {
    this.check(2);
    this.offset = encoding.writeI16BE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write int24le.
   * @param {Number} value
   */

  writeI24(value) {
    this.check(3);
    this.offset = encoding.writeI24(this.data, value, this.offset);
    return this;
  }

  /**
   * Write int24be.
   * @param {Number} value
   */

  writeI24BE(value) {
    this.check(3);
    this.offset = encoding.writeI24BE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write int32le.
   * @param {Number} value
   */

  writeI32(value) {
    this.check(4);
    this.offset = encoding.writeI32(this.data, value, this.offset);
    return this;
  }

  /**
   * Write int32be.
   * @param {Number} value
   */

  writeI32BE(value) {
    this.check(4);
    this.offset = encoding.writeI32BE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write int40le.
   * @param {Number} value
   */

  writeI40(value) {
    this.check(5);
    this.offset = encoding.writeI40(this.data, value, this.offset);
    return this;
  }

  /**
   * Write int40be.
   * @param {Number} value
   */

  writeI40BE(value) {
    this.check(5);
    this.offset = encoding.writeI40BE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write int48le.
   * @param {Number} value
   */

  writeI48(value) {
    this.check(6);
    this.offset = encoding.writeI48(this.data, value, this.offset);
    return this;
  }

  /**
   * Write int48be.
   * @param {Number} value
   */

  writeI48BE(value) {
    this.check(6);
    this.offset = encoding.writeI48BE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write int56le.
   * @param {Number} value
   */

  writeI56(value) {
    this.check(7);
    this.offset = encoding.writeI56(this.data, value, this.offset);
    return this;
  }

  /**
   * Write int56be.
   * @param {Number} value
   */

  writeI56BE(value) {
    this.check(7);
    this.offset = encoding.writeI56BE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write int64le.
   * @param {Number} value
   */

  writeI64(value) {
    this.check(8);
    this.offset = encoding.writeI64(this.data, value, this.offset);
    return this;
  }

  /**
   * Write int64be.
   * @param {Number} value
   */

  writeI64BE(value) {
    this.check(8);
    this.offset = encoding.writeI64BE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write float le.
   * @param {Number} value
   */

  writeFloat(value) {
    this.check(4);
    this.offset = encoding.writeFloat(this.data, value, this.offset);
    return this;
  }

  /**
   * Write float be.
   * @param {Number} value
   */

  writeFloatBE(value) {
    this.check(4);
    this.offset = encoding.writeFloatBE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write double le.
   * @param {Number} value
   */

  writeDouble(value) {
    this.check(8);
    this.offset = encoding.writeDouble(this.data, value, this.offset);
    return this;
  }

  /**
   * Write double be.
   * @param {Number} value
   */

  writeDoubleBE(value) {
    this.check(8);
    this.offset = encoding.writeDoubleBE(this.data, value, this.offset);
    return this;
  }

  /**
   * Write a varint.
   * @param {Number} value
   */

  writeVarint(value) {
    this.offset = encoding.writeVarint(this.data, value, this.offset);
    return this;
  }

  /**
   * Write a varint (type 2).
   * @param {Number} value
   */

  writeVarint2(value) {
    this.offset = encoding.writeVarint2(this.data, value, this.offset);
    return this;
  }

  /**
   * Write bytes.
   * @param {Buffer} value
   */

  writeBytes(value) {
    enforce((value != null && value._isBuffer === true), 'value', 'buffer');

    this.check(value.length);
    this.offset += value.copy(this.data, this.offset);

    return this;
  }

  /**
   * Write bytes with a varint length before them.
   * @param {Buffer} value
   */

  writeVarBytes(value) {
    enforce((value != null && value._isBuffer === true), 'value', 'buffer');

    this.writeVarint(value.length);
    this.writeBytes(value);

    return this;
  }

  /**
   * Copy bytes.
   * @param {Buffer} value
   * @param {Number} start
   * @param {Number} end
   */

  copy(value, start, end) {
    enforce((value != null && value._isBuffer === true), 'value', 'buffer');
    enforce((start >>> 0) === start, 'start', 'integer');
    enforce((end >>> 0) === end, 'end', 'integer');
    enforce(end >= start, 'start', 'integer');

    this.check(end - start);
    this.offset += value.copy(this.data, this.offset, start, end);

    return this;
  }

  /**
   * Write string to buffer.
   * @param {String} value
   * @param {String?} enc - Any buffer-supported encoding.
   */

  writeString(value, enc) {
    if (enc == null)
      enc = 'binary';

    enforce(typeof value === 'string', 'value', 'string');
    enforce(typeof enc === 'string', 'enc', 'string');

    if (value.length === 0)
      return this;

    const size = Buffer.byteLength(value, enc);

    this.check(size);

    this.offset += this.data.write(value, this.offset, enc);

    return this;
  }

  /**
   * Write a 32 byte hash.
   * @param {Hash} value
   */

  writeHash(value) {
    if (typeof value !== 'string') {
      enforce((value != null && value._isBuffer === true), 'value', 'buffer');
      enforce(value.length === 32, 'value', '32-byte hash');
      this.writeBytes(value);
      return this;
    }

    enforce(value.length === 64, 'value', '32-byte hash');

    this.check(32);
    this.offset += this.data.write(value, this.offset, 'hex');

    return this;
  }

  /**
   * Write a string with a varint length before it.
   * @param {String}
   * @param {String?} enc - Any buffer-supported encoding.
   */

  writeVarString(value, enc) {
    if (enc == null)
      enc = 'binary';

    enforce(typeof value === 'string', 'value', 'string');
    enforce(typeof enc === 'string', 'enc', 'string');

    if (value.length === 0) {
      this.writeVarint(0);
      return this;
    }

    const size = Buffer.byteLength(value, enc);

    this.writeVarint(size);
    this.check(size);
    this.offset += this.data.write(value, this.offset, enc);

    return this;
  }

  /**
   * Write a null-terminated string.
   * @param {String|Buffer}
   * @param {String?} enc - Any buffer-supported encoding.
   */

  writeNullString(value, enc) {
    this.writeString(value, enc);
    this.writeU8(0);
    return this;
  }

  /**
   * Calculate and write a checksum for the data written so far.
   * @param {Function} hash
   */

  writeChecksum(hash) {
    if (!hash || typeof hash.digest !== 'function')
      enforce(typeof hash === 'function', 'hash', 'function');

    this.check(4);

    const data = this.data.slice(0, this.offset);
    const raw = hash.digest ? hash.digest(data) : hash(data);

    raw.copy(this.data, this.offset, 0, 4);

    this.offset += 4;

    return this;
  }

  /**
   * Fill N bytes with value.
   * @param {Number} value
   * @param {Number} size
   */

  fill(value, size) {
    enforce((value & 0xff) === value, 'value', 'byte');
    enforce((size >>> 0) === size, 'size', 'integer');

    this.check(size);

    this.data.fill(value, this.offset, this.offset + size);
    this.offset += size;

    return this;
  }
}

/*
 * Expose
 */

module.exports = StaticWriter;
}],
[/* 22 */ 'bufio', '/lib/struct.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * struct.js - struct object for bcoin
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */



const enforce = __browser_require__(17 /* './enforce' */, module);
const BufferReader = __browser_require__(19 /* './reader' */, module);
const BufferWriter = __browser_require__(20 /* './writer' */, module);
const StaticWriter = __browser_require__(21 /* './staticwriter' */, module);
const {custom} = __browser_require__(15 /* './custom' */, module);

/**
 * Struct
 */

class Struct {
  constructor() {}

  inject(obj) {
    enforce(obj instanceof this.constructor, 'obj', 'struct');
    return this.decode(obj.encode());
  }

  clone() {
    const copy = new this.constructor();
    return copy.inject(this);
  }

  /*
   * Bindable
   */

  getSize(extra) {
    return -1;
  }

  write(bw, extra) {
    return bw;
  }

  read(br, extra) {
    return this;
  }

  toString() {
    return Object.prototype.toString.call(this);
  }

  fromString(str, extra) {
    return this;
  }

  getJSON() {
    return this;
  }

  fromJSON(json, extra) {
    return this;
  }

  fromOptions(options, extra) {
    return this;
  }

  from(options, extra) {
    return this.fromOptions(options, extra);
  }

  format() {
    return this.getJSON();
  }

  /*
   * API
   */

  encode(extra) {
    const size = this.getSize(extra);
    const bw = size === -1
      ? new BufferWriter()
      : new StaticWriter(size);

    this.write(bw, extra);

    return bw.render();
  }

  decode(data, extra) {
    const br = new BufferReader(data);

    this.read(br, extra);

    return this;
  }

  toHex(extra) {
    return this.encode(extra).toString('hex');
  }

  fromHex(str, extra) {
    enforce(typeof str === 'string', 'str', 'string');

    const size = str.length >>> 1;
    const data = Buffer.from(str, 'hex');

    if (data.length !== size)
      throw new Error('Invalid hex string.');

    return this.decode(data, extra);
  }

  toBase64(extra) {
    return this.encode(extra).toString('base64');
  }

  fromBase64(str, extra) {
    enforce(typeof str === 'string', 'str', 'string');

    const data = Buffer.from(str, 'base64');

    if (str.length > size64(data.length))
      throw new Error('Invalid base64 string.');

    return this.decode(data, extra);
  }

  toJSON() {
    return this.getJSON();
  }

  [custom]() {
    return this.format();
  }

  /*
   * Static API
   */

  static read(br, extra) {
    return new this().read(br, extra);
  }

  static decode(data, extra) {
    return new this().decode(data, extra);
  }

  static fromHex(str, extra) {
    return new this().fromHex(str, extra);
  }

  static fromBase64(str, extra) {
    return new this().fromBase64(str, extra);
  }

  static fromString(str, extra) {
    return new this().fromString(str, extra);
  }

  static fromJSON(json, extra) {
    return new this().fromJSON(json, extra);
  }

  static fromOptions(options, extra) {
    return new this().fromOptions(options, extra);
  }

  static from(options, extra) {
    return new this().from(options, extra);
  }

  /*
   * Aliases
   */

  toWriter(bw, extra) {
    return this.write(bw, extra);
  }

  fromReader(br, extra) {
    return this.read(br, extra);
  }

  toRaw(extra) {
    return this.encode(extra);
  }

  fromRaw(data, extra) {
    return this.decode(data, extra);
  }

  /*
   * Static Aliases
   */

  static fromReader(br, extra) {
    return this.read(br, extra);
  }

  static fromRaw(data, extra) {
    return this.decode(data, extra);
  }
}

/*
 * Helpers
 */

function size64(size) {
  const expect = ((4 * size / 3) + 3) & ~3;
  return expect >>> 0;
}

/*
 * Expose
 */

module.exports = Struct;
}],
[/* 23 */ 'bcrypto', '/lib/safe.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * safe.js - constant-time equals for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009 The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Resources:
 *   https://github.com/golang/go/blob/master/src/crypto/subtle/constant_time.go
 */



const assert = __browser_require__(24 /* './internal/assert' */, module);

/*
 * Safe
 */

function safeCompare(x, y) {
  assert((x != null && x._isBuffer === true));
  assert((y != null && y._isBuffer === true));

  if (safeEqualInt(x.length, 0))
    return safeEqualInt(y.length, 0);

  // Assumes `y` is the "constant size"
  // parameter. Note that constant size
  // doesn't necessarily mean secret.
  // Assuming we have a constant-size
  // secret key or passphrase. This
  // function should be called as:
  //
  // if (!safeCompare(input, key))
  //   throw new Error('Bad passphrase.');
  let v = x.length ^ y.length;

  for (let i = 0; i < y.length; i++)
    v |= x[i % x.length] ^ y[i];

  return (v - 1) >>> 31;
}

function safeEqual(x, y) {
  assert((x != null && x._isBuffer === true));
  assert((y != null && y._isBuffer === true));

  // Assumes the lengths of both
  // `x` and `y` are not secret.
  if (!safeEqualInt(x.length, y.length))
    return 0;

  let v = 0;

  for (let i = 0; i < x.length; i++)
    v |= x[i] ^ y[i];

  return (v - 1) >>> 31;
}

function safeEqualByte(x, y) {
  return safeEqualInt(x & 0xff, y & 0xff);
}

function safeEqualInt(x, y) {
  return ((x ^ y) - 1) >>> 31;
}

function safeSelect(x, y, v) {
  return (x & (v - 1)) | (y & ~(v - 1));
}

function safeLT(x, y) {
  return (x - y) >>> 31;
}

function safeLTE(x, y) {
  return (x - y - 1) >>> 31;
}

function safeGT(x, y) {
  return (y - x) >>> 31;
}

function safeGTE(x, y) {
  return (y - x - 1) >>> 31;
}

function safeMin(x, y) {
  return safeSelect(x, y, safeLT(y, x));
}

function safeMax(x, y) {
  return safeSelect(x, y, safeGT(y, x));
}

function safeAbs(x) {
  return (x | 0) * ((x >> 31) | 1);
}

function safeBool(x) {
  return ((x >> 31) | (-x >> 31)) & 1;
}

function safeCopy(x, y, v) {
  assert((x != null && x._isBuffer === true));
  assert((y != null && y._isBuffer === true));
  assert(safeEqualInt(x.length, y.length));

  const xmask = (v - 1) & 0xff;
  const ymask = ~(v - 1) & 0xff;

  for (let i = 0; i < x.length; i++)
    x[i] = (x[i] & xmask) | (y[i] & ymask);
}

/*
 * Expose
 */

exports.safeCompare = safeCompare;
exports.safeEqual = safeEqual;
exports.safeEqualByte = safeEqualByte;
exports.safeEqualInt = safeEqualInt;
exports.safeSelect = safeSelect;
exports.safeLT = safeLT;
exports.safeLTE = safeLTE;
exports.safeGT = safeGT;
exports.safeGTE = safeGTE;
exports.safeMin = safeMin;
exports.safeMax = safeMax;
exports.safeAbs = safeAbs;
exports.safeBool = safeBool;
exports.safeCopy = safeCopy;
}],
[/* 24 */ 'bcrypto', '/lib/internal/assert.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * assert.js - assert for bcrypto
 * Copyright (c) 2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */



/*
 * Assert
 */

function assert(val, msg) {
  if (!val) {
    const err = new Error(msg || 'Assertion failed');

    if (Error.captureStackTrace)
      Error.captureStackTrace(err, assert);

    throw err;
  }
}

/*
 * Expose
 */

module.exports = assert;
}],
[/* 25 */ 'bcrypto', '/lib/md5-browser.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * md5.js - MD5 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */



module.exports = __browser_require__(26 /* './js/md5' */, module);
}],
[/* 26 */ 'bcrypto', '/lib/js/md5.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * md5.js - MD5 implementation for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/MD5
 *   https://tools.ietf.org/html/rfc1321
 */



const assert = __browser_require__(24 /* '../internal/assert' */, module);
const HMAC = __browser_require__(27 /* '../internal/hmac' */, module);

/*
 * Constants
 */

const FINALIZED = -1;
const DESC = Buffer.alloc(8, 0x00);
const PADDING = Buffer.alloc(64, 0x00);

PADDING[0] = 0x80;

const K = new Uint32Array([
  0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
  0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
  0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
  0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
  0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
  0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
  0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
  0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
  0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
  0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
  0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
  0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
  0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
  0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
  0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
  0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391
]);

const S = new Uint8Array([
  7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,
  7, 12, 17, 22, 5,  9, 14, 20, 5,  9, 14, 20,
  5,  9, 14, 20, 5,  9, 14, 20, 4, 11, 16, 23,
  4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,
  6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21,
  6, 10, 15, 21
]);

/**
 * MD5
 */

class MD5 {
  constructor() {
    this.state = new Uint32Array(4);
    this.msg = new Uint32Array(16);
    this.block = Buffer.alloc(64);
    this.size = FINALIZED;
  }

  init() {
    this.state[0] = 0x67452301;
    this.state[1] = 0xefcdab89;
    this.state[2] = 0x98badcfe;
    this.state[3] = 0x10325476;
    this.size = 0;
    return this;
  }

  update(data) {
    assert((data != null && data._isBuffer === true));
    this._update(data, data.length);
    return this;
  }

  final() {
    return this._final(Buffer.alloc(16));
  }

  _update(data, len) {
    assert(this.size !== FINALIZED, 'Context is not initialized.');

    let pos = this.size & 63;
    let off = 0;

    this.size += len;

    if (pos > 0) {
      let want = 64 - pos;

      if (want > len)
        want = len;

      data.copy(this.block, pos, off, off + want);

      pos += want;
      len -= want;
      off += want;

      if (pos < 64)
        return;

      this._transform(this.block, 0);
    }

    while (len >= 64) {
      this._transform(data, off);
      off += 64;
      len -= 64;
    }

    if (len > 0)
      data.copy(this.block, 0, off, off + len);
  }

  _final(out) {
    assert(this.size !== FINALIZED, 'Context is not initialized.');

    const pos = this.size & 63;
    const len = this.size * 8;

    writeU32(DESC, len >>> 0, 0);
    writeU32(DESC, (len * (1 / 0x100000000)) >>> 0, 4);

    this._update(PADDING, 1 + ((119 - pos) & 63));
    this._update(DESC, 8);

    for (let i = 0; i < 4; i++) {
      writeU32(out, this.state[i], i * 4);
      this.state[i] = 0;
    }

    for (let i = 0; i < 16; i++)
      this.msg[i] = 0;

    for (let i = 0; i < 64; i++)
      this.block[i] = 0;

    this.size = FINALIZED;

    return out;
  }

  _transform(chunk, pos) {
    const W = this.msg;

    let a = this.state[0];
    let b = this.state[1];
    let c = this.state[2];
    let d = this.state[3];
    let i = 0;

    for (; i < 16; i++)
      W[i] = readU32(chunk, pos + i * 4);

    for (i = 0; i < 64; i++) {
      let f, g;

       if (i < 16) {
        f = (b & c) | (~b & d);
        g = i;
      } else if (i < 32) {
        f = (d & b) | (~d & c);
        g = (5 * i + 1) & 15;
      } else if (i < 48) {
        f = b ^ c ^ d;
        g = (3 * i + 5) & 15;
      } else {
        f = c ^ (b | ~d);
        g = (7 * i) & 15;
      }

      f >>>= 0;

      f = f + a + K[i] + W[g];
      f >>>= 0;

      a = d;
      d = c;
      c = b;
      b = b + rotl32(f, S[i]);
      b >>>= 0;
    }

    this.state[0] += a;
    this.state[1] += b;
    this.state[2] += c;
    this.state[3] += d;
  }

  static hash() {
    return new MD5();
  }

  static hmac() {
    return new HMAC(MD5, 64);
  }

  static digest(data) {
    return MD5.ctx.init().update(data).final();
  }

  static root(left, right) {
    assert((left != null && left._isBuffer === true) && left.length === 16);
    assert((right != null && right._isBuffer === true) && right.length === 16);
    return MD5.ctx.init().update(left).update(right).final();
  }

  static multi(x, y, z) {
    const {ctx} = MD5;

    ctx.init();
    ctx.update(x);
    ctx.update(y);

    if (z)
      ctx.update(z);

    return ctx.final();
  }

  static mac(data, key) {
    return MD5.hmac().init(key).update(data).final();
  }
}

/*
 * Static
 */

MD5.native = 0;
MD5.id = 'MD5';
MD5.size = 16;
MD5.bits = 128;
MD5.blockSize = 64;
MD5.zero = Buffer.alloc(16, 0x00);
MD5.ctx = new MD5();

/*
 * Helpers
 */

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}

function readU32(data, off) {
  return (data[off++]
        + data[off++] * 0x100
        + data[off++] * 0x10000
        + data[off] * 0x1000000);
}

function writeU32(dst, num, off) {
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  return off;
}

/*
 * Expose
 */

module.exports = MD5;
}],
[/* 27 */ 'bcrypto', '/lib/internal/hmac.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * hmac.js - hmac for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/HMAC
 *   https://tools.ietf.org/html/rfc2104
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/hmac.js
 */



const assert = __browser_require__(24 /* '../internal/assert' */, module);

/**
 * HMAC
 */

class HMAC {
  /**
   * Create an HMAC.
   * @param {Function} Hash
   * @param {Number} size
   * @param {Array} [x=[]]
   * @param {Array} [y=[]]
   */

  constructor(Hash, size, x = [], y = []) {
    assert(typeof Hash === 'function');
    assert((size >>> 0) === size);
    assert(Array.isArray(x));
    assert(Array.isArray(y));

    this.hash = Hash;
    this.size = size;
    this.x = x;
    this.y = y;

    this.inner = new Hash();
    this.outer = new Hash();
  }

  /**
   * Initialize HMAC context.
   * @param {Buffer} data
   */

  init(key) {
    assert((key != null && key._isBuffer === true));

    // Shorten key
    if (key.length > this.size) {
      const Hash = this.hash;
      const h = new Hash();

      h.init(...this.x);
      h.update(key);

      key = h.final(...this.y);

      assert(key.length <= this.size);
    }

    // Pad key
    const pad = Buffer.alloc(this.size);

    for (let i = 0; i < key.length; i++)
      pad[i] = key[i] ^ 0x36;

    for (let i = key.length; i < pad.length; i++)
      pad[i] = 0x36;

    this.inner.init(...this.x);
    this.inner.update(pad);

    for (let i = 0; i < key.length; i++)
      pad[i] = key[i] ^ 0x5c;

    for (let i = key.length; i < pad.length; i++)
      pad[i] = 0x5c;

    this.outer.init(...this.x);
    this.outer.update(pad);

    return this;
  }

  /**
   * Update HMAC context.
   * @param {Buffer} data
   */

  update(data) {
    this.inner.update(data);
    return this;
  }

  /**
   * Finalize HMAC context.
   * @returns {Buffer}
   */

  final() {
    this.outer.update(this.inner.final(...this.y));
    return this.outer.final(...this.y);
  }
}

/*
 * Expose
 */

module.exports = HMAC;
}],
[/* 28 */ 'bcrypto', '/lib/sha1-browser.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * sha1.js - sha1 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */



module.exports = __browser_require__(29 /* './js/sha1' */, module);
}],
[/* 29 */ 'bcrypto', '/lib/js/sha1.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * sha1.js - SHA1 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-1
 *   https://tools.ietf.org/html/rfc3174
 *   http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/1.js
 */

/* eslint camelcase: "off" */



const assert = __browser_require__(24 /* '../internal/assert' */, module);
const HMAC = __browser_require__(27 /* '../internal/hmac' */, module);

/*
 * Constants
 */

const FINALIZED = -1;
const DESC = Buffer.alloc(8, 0x00);
const PADDING = Buffer.alloc(64, 0x00);

PADDING[0] = 0x80;

const K = new Uint32Array([
  0x5a827999,
  0x6ed9eba1,
  0x8f1bbcdc,
  0xca62c1d6
]);

/**
 * SHA1
 */

class SHA1 {
  constructor() {
    this.state = new Uint32Array(5);
    this.msg = new Uint32Array(80);
    this.block = Buffer.alloc(64);
    this.size = FINALIZED;
  }

  init() {
    this.state[0] = 0x67452301;
    this.state[1] = 0xefcdab89;
    this.state[2] = 0x98badcfe;
    this.state[3] = 0x10325476;
    this.state[4] = 0xc3d2e1f0;
    this.size = 0;
    return this;
  }

  update(data) {
    assert((data != null && data._isBuffer === true));
    this._update(data, data.length);
    return this;
  }

  final() {
    return this._final(Buffer.alloc(20));
  }

  _update(data, len) {
    assert(this.size !== FINALIZED, 'Context is not initialized.');

    let pos = this.size & 63;
    let off = 0;

    this.size += len;

    if (pos > 0) {
      let want = 64 - pos;

      if (want > len)
        want = len;

      data.copy(this.block, pos, off, off + want);

      pos += want;
      len -= want;
      off += want;

      if (pos < 64)
        return;

      this._transform(this.block, 0);
    }

    while (len >= 64) {
      this._transform(data, off);
      off += 64;
      len -= 64;
    }

    if (len > 0)
      data.copy(this.block, 0, off, off + len);
  }

  _final(out) {
    assert(this.size !== FINALIZED, 'Context is not initialized.');

    const pos = this.size & 63;
    const len = this.size * 8;

    writeU32(DESC, (len * (1 / 0x100000000)) >>> 0, 0);
    writeU32(DESC, len >>> 0, 4);

    this._update(PADDING, 1 + ((119 - pos) & 63));
    this._update(DESC, 8);

    for (let i = 0; i < 5; i++) {
      writeU32(out, this.state[i], i * 4);
      this.state[i] = 0;
    }

    for (let i = 0; i < 80; i++)
      this.msg[i] = 0;

    for (let i = 0; i < 64; i++)
      this.block[i] = 0;

    this.size = FINALIZED;

    return out;
  }

  _transform(chunk, pos) {
    const W = this.msg;

    let a = this.state[0];
    let b = this.state[1];
    let c = this.state[2];
    let d = this.state[3];
    let e = this.state[4];
    let i = 0;

    for (; i < 16; i++)
      W[i] = readU32(chunk, pos + i * 4);

    for (; i < 80; i++)
      W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

    for (i = 0; i < 80; i++) {
      const s = i / 20 | 0;
      const t = rotl32(a, 5) + ft_1(s, b, c, d) + e + W[i] + K[s];

      e = d;
      d = c;
      c = rotl32(b, 30);
      b = a;
      a = t >>> 0;
    }

    this.state[0] += a;
    this.state[1] += b;
    this.state[2] += c;
    this.state[3] += d;
    this.state[4] += e;
  }

  static hash() {
    return new SHA1();
  }

  static hmac() {
    return new HMAC(SHA1, 64);
  }

  static digest(data) {
    return SHA1.ctx.init().update(data).final();
  }

  static root(left, right) {
    assert((left != null && left._isBuffer === true) && left.length === 20);
    assert((right != null && right._isBuffer === true) && right.length === 20);
    return SHA1.ctx.init().update(left).update(right).final();
  }

  static multi(x, y, z) {
    const {ctx} = SHA1;

    ctx.init();
    ctx.update(x);
    ctx.update(y);

    if (z)
      ctx.update(z);

    return ctx.final();
  }

  static mac(data, key) {
    return SHA1.hmac().init(key).update(data).final();
  }
}

/*
 * Static
 */

SHA1.native = 0;
SHA1.id = 'SHA1';
SHA1.size = 20;
SHA1.bits = 160;
SHA1.blockSize = 64;
SHA1.zero = Buffer.alloc(20, 0x00);
SHA1.ctx = new SHA1();

/*
 * Helpers
 */

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);

  if (s === 1 || s === 3)
    return p32(x, y, z);

  if (s === 2)
    return maj32(x, y, z);

  return 0;
}

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}

function p32(x, y, z) {
  return x ^ y ^ z;
}

function readU32(data, off) {
  return (data[off++] * 0x1000000
        + data[off++] * 0x10000
        + data[off++] * 0x100
        + data[off]);
}

function writeU32(data, num, off) {
  data[off++] = num >>> 24;
  data[off++] = num >>> 16;
  data[off++] = num >>> 8;
  data[off++] = num;
  return off;
}

/*
 * Expose
 */

module.exports = SHA1;
}],
[/* 30 */ 'bcrypto', '/lib/sha224-browser.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * sha224.js - SHA224 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */



module.exports = __browser_require__(31 /* './js/sha224' */, module);
}],
[/* 31 */ 'bcrypto', '/lib/js/sha224.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * sha224.js - SHA224 implementation for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-2
 *   https://tools.ietf.org/html/rfc4634
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/224.js
 */



const assert = __browser_require__(24 /* '../internal/assert' */, module);
const SHA256 = __browser_require__(32 /* './sha256' */, module);
const HMAC = __browser_require__(27 /* '../internal/hmac' */, module);

/**
 * SHA224
 */

class SHA224 extends SHA256 {
  constructor() {
    super();
  }

  init() {
    this.state[0] = 0xc1059ed8;
    this.state[1] = 0x367cd507;
    this.state[2] = 0x3070dd17;
    this.state[3] = 0xf70e5939;
    this.state[4] = 0xffc00b31;
    this.state[5] = 0x68581511;
    this.state[6] = 0x64f98fa7;
    this.state[7] = 0xbefa4fa4;
    this.size = 0;
    return this;
  }

  final() {
    return super.final().slice(0, 28);
  }

  static hash() {
    return new SHA224();
  }

  static hmac() {
    return new HMAC(SHA224, 64);
  }

  static digest(data) {
    return SHA224.ctx.init().update(data).final();
  }

  static root(left, right) {
    assert((left != null && left._isBuffer === true) && left.length === 28);
    assert((right != null && right._isBuffer === true) && right.length === 28);
    return SHA224.ctx.init().update(left).update(right).final();
  }

  static multi(x, y, z) {
    const {ctx} = SHA224;

    ctx.init();
    ctx.update(x);
    ctx.update(y);

    if (z)
      ctx.update(z);

    return ctx.final();
  }

  static mac(data, key) {
    return SHA224.hmac().init(key).update(data).final();
  }
}

/*
 * Static
 */

SHA224.native = 0;
SHA224.id = 'SHA224';
SHA224.size = 28;
SHA224.bits = 224;
SHA224.blockSize = 64;
SHA224.zero = Buffer.alloc(28, 0x00);
SHA224.ctx = new SHA224();

/*
 * Expose
 */

module.exports = SHA224;
}],
[/* 32 */ 'bcrypto', '/lib/js/sha256.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * sha256.js - SHA256 implementation for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-2
 *   https://tools.ietf.org/html/rfc4634
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/256.js
 */



const assert = __browser_require__(24 /* '../internal/assert' */, module);
const HMAC = __browser_require__(27 /* '../internal/hmac' */, module);

/*
 * Constants
 */

const FINALIZED = -1;
const DESC = Buffer.alloc(8, 0x00);
const PADDING = Buffer.alloc(64, 0x00);

PADDING[0] = 0x80;

const K = new Uint32Array([
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);

/**
 * SHA256
 */

class SHA256 {
  constructor() {
    this.state = new Uint32Array(8);
    this.msg = new Uint32Array(64);
    this.block = Buffer.alloc(64);
    this.size = FINALIZED;
  }

  init() {
    this.state[0] = 0x6a09e667;
    this.state[1] = 0xbb67ae85;
    this.state[2] = 0x3c6ef372;
    this.state[3] = 0xa54ff53a;
    this.state[4] = 0x510e527f;
    this.state[5] = 0x9b05688c;
    this.state[6] = 0x1f83d9ab;
    this.state[7] = 0x5be0cd19;
    this.size = 0;
    return this;
  }

  update(data) {
    assert((data != null && data._isBuffer === true));
    this._update(data, data.length);
    return this;
  }

  final() {
    return this._final(Buffer.alloc(32));
  }

  _update(data, len) {
    assert(this.size !== FINALIZED, 'Context is not initialized.');

    let pos = this.size & 63;
    let off = 0;

    this.size += len;

    if (pos > 0) {
      let want = 64 - pos;

      if (want > len)
        want = len;

      data.copy(this.block, pos, off, off + want);

      pos += want;
      len -= want;
      off += want;

      if (pos < 64)
        return;

      this._transform(this.block, 0);
    }

    while (len >= 64) {
      this._transform(data, off);
      off += 64;
      len -= 64;
    }

    if (len > 0)
      data.copy(this.block, 0, off, off + len);
  }

  _final(out) {
    assert(this.size !== FINALIZED, 'Context is not initialized.');

    const pos = this.size & 63;
    const len = this.size * 8;

    writeU32(DESC, (len * (1 / 0x100000000)) >>> 0, 0);
    writeU32(DESC, len >>> 0, 4);

    this._update(PADDING, 1 + ((119 - pos) & 63));
    this._update(DESC, 8);

    for (let i = 0; i < 8; i++) {
      writeU32(out, this.state[i], i * 4);
      this.state[i] = 0;
    }

    for (let i = 0; i < 64; i++)
      this.msg[i] = 0;

    for (let i = 0; i < 64; i++)
      this.block[i] = 0;

    this.size = FINALIZED;

    return out;
  }

  _transform(chunk, pos) {
    const W = this.msg;

    let a = this.state[0];
    let b = this.state[1];
    let c = this.state[2];
    let d = this.state[3];
    let e = this.state[4];
    let f = this.state[5];
    let g = this.state[6];
    let h = this.state[7];
    let i = 0;

    for (; i < 16; i++)
      W[i] = readU32(chunk, pos + i * 4);

    for (; i < 64; i++)
      W[i] = sigma1(W[i - 2]) + W[i - 7] + sigma0(W[i - 15]) + W[i - 16];

    for (i = 0; i < 64; i++) {
      const t1 = h + Sigma1(e) + Ch(e, f, g) + K[i] + W[i];
      const t2 = Sigma0(a) + Maj(a, b, c);

      h = g;
      g = f;
      f = e;

      e = (d + t1) >>> 0;

      d = c;
      c = b;
      b = a;

      a = (t1 + t2) >>> 0;
    }

    this.state[0] += a;
    this.state[1] += b;
    this.state[2] += c;
    this.state[3] += d;
    this.state[4] += e;
    this.state[5] += f;
    this.state[6] += g;
    this.state[7] += h;
  }

  static hash() {
    return new SHA256();
  }

  static hmac() {
    return new HMAC(SHA256, 64);
  }

  static digest(data) {
    return SHA256.ctx.init().update(data).final();
  }

  static root(left, right) {
    assert((left != null && left._isBuffer === true) && left.length === 32);
    assert((right != null && right._isBuffer === true) && right.length === 32);
    return SHA256.ctx.init().update(left).update(right).final();
  }

  static multi(x, y, z) {
    const {ctx} = SHA256;

    ctx.init();
    ctx.update(x);
    ctx.update(y);

    if (z)
      ctx.update(z);

    return ctx.final();
  }

  static mac(data, key) {
    return SHA256.hmac().init(key).update(data).final();
  }
}

/*
 * Static
 */

SHA256.native = 0;
SHA256.id = 'SHA256';
SHA256.size = 32;
SHA256.bits = 256;
SHA256.blockSize = 64;
SHA256.zero = Buffer.alloc(32, 0x00);
SHA256.ctx = new SHA256();

/*
 * Helpers
 */

function Sigma0(x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
}

function Sigma1(x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
}

function sigma0(x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3);
}

function sigma1(x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10);
}

function Ch(x, y, z) {
  return z ^ (x & (y ^ z));
}

function Maj(x, y, z) {
  return (x & y) | (z & (x | y));
}

function readU32(data, off) {
  return (data[off++] * 0x1000000
        + data[off++] * 0x10000
        + data[off++] * 0x100
        + data[off]);
}

function writeU32(data, num, off) {
  data[off++] = num >>> 24;
  data[off++] = num >>> 16;
  data[off++] = num >>> 8;
  data[off++] = num;
  return off;
}

/*
 * Expose
 */

module.exports = SHA256;
}],
[/* 33 */ 'bcrypto', '/lib/sha256-browser.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * sha256.js - sha256 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */



module.exports = __browser_require__(32 /* './js/sha256' */, module);
}],
[/* 34 */ 'bcrypto', '/lib/sha384-browser.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * sha384.js - SHA384 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */



module.exports = __browser_require__(35 /* './js/sha384' */, module);
}],
[/* 35 */ 'bcrypto', '/lib/js/sha384.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * sha384.js - SHA384 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-2
 *   https://tools.ietf.org/html/rfc4634
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/384.js
 */



const assert = __browser_require__(24 /* '../internal/assert' */, module);
const SHA512 = __browser_require__(36 /* './sha512' */, module);
const HMAC = __browser_require__(27 /* '../internal/hmac' */, module);

/**
 * SHA384
 */

class SHA384 extends SHA512 {
  constructor() {
    super();
  }

  init() {
    this.state[0] = 0xcbbb9d5d;
    this.state[1] = 0xc1059ed8;
    this.state[2] = 0x629a292a;
    this.state[3] = 0x367cd507;
    this.state[4] = 0x9159015a;
    this.state[5] = 0x3070dd17;
    this.state[6] = 0x152fecd8;
    this.state[7] = 0xf70e5939;
    this.state[8] = 0x67332667;
    this.state[9] = 0xffc00b31;
    this.state[10] = 0x8eb44a87;
    this.state[11] = 0x68581511;
    this.state[12] = 0xdb0c2e0d;
    this.state[13] = 0x64f98fa7;
    this.state[14] = 0x47b5481d;
    this.state[15] = 0xbefa4fa4;
    this.size = 0;
    return this;
  }

  final() {
    return super.final().slice(0, 48);
  }

  static hash() {
    return new SHA384();
  }

  static hmac() {
    return new HMAC(SHA384, 128);
  }

  static digest(data) {
    return SHA384.ctx.init().update(data).final();
  }

  static root(left, right) {
    assert((left != null && left._isBuffer === true) && left.length === 48);
    assert((right != null && right._isBuffer === true) && right.length === 48);
    return SHA384.ctx.init().update(left).update(right).final();
  }

  static multi(x, y, z) {
    const {ctx} = SHA384;

    ctx.init();
    ctx.update(x);
    ctx.update(y);

    if (z)
      ctx.update(z);

    return ctx.final();
  }

  static mac(data, key) {
    return SHA384.hmac().init(key).update(data).final();
  }
}

/*
 * Static
 */

SHA384.native = 0;
SHA384.id = 'SHA384';
SHA384.size = 48;
SHA384.bits = 384;
SHA384.blockSize = 128;
SHA384.zero = Buffer.alloc(48, 0x00);
SHA384.ctx = new SHA384();

/*
 * Expose
 */

module.exports = SHA384;
}],
[/* 36 */ 'bcrypto', '/lib/js/sha512.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * sha512.js - SHA512 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-2
 *   https://tools.ietf.org/html/rfc4634
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/512.js
 */

/* eslint camelcase: "off" */



const assert = __browser_require__(24 /* '../internal/assert' */, module);
const HMAC = __browser_require__(27 /* '../internal/hmac' */, module);

/*
 * Constants
 */

const FINALIZED = -1;
const DESC = Buffer.alloc(16, 0x00);
const PADDING = Buffer.alloc(128, 0x00);

PADDING[0] = 0x80;

const K = new Uint32Array([
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]);

/**
 * SHA512
 */

class SHA512 {
  constructor() {
    this.state = new Uint32Array(16);
    this.msg = new Uint32Array(160);
    this.block = Buffer.alloc(128);
    this.size = FINALIZED;
  }

  init() {
    this.state[0] = 0x6a09e667;
    this.state[1] = 0xf3bcc908;
    this.state[2] = 0xbb67ae85;
    this.state[3] = 0x84caa73b;
    this.state[4] = 0x3c6ef372;
    this.state[5] = 0xfe94f82b;
    this.state[6] = 0xa54ff53a;
    this.state[7] = 0x5f1d36f1;
    this.state[8] = 0x510e527f;
    this.state[9] = 0xade682d1;
    this.state[10] = 0x9b05688c;
    this.state[11] = 0x2b3e6c1f;
    this.state[12] = 0x1f83d9ab;
    this.state[13] = 0xfb41bd6b;
    this.state[14] = 0x5be0cd19;
    this.state[15] = 0x137e2179;
    this.size = 0;
    return this;
  }

  update(data) {
    assert((data != null && data._isBuffer === true));
    this._update(data, data.length);
    return this;
  }

  final() {
    return this._final(Buffer.alloc(64));
  }

  _update(data, len) {
    assert(this.size !== FINALIZED, 'Context is not initialized.');

    let pos = this.size & 127;
    let off = 0;

    this.size += len;

    if (pos > 0) {
      let want = 128 - pos;

      if (want > len)
        want = len;

      data.copy(this.block, pos, off, off + want);

      pos += want;
      len -= want;
      off += want;

      if (pos < 128)
        return;

      this._transform(this.block, 0);
    }

    while (len >= 128) {
      this._transform(data, off);
      off += 128;
      len -= 128;
    }

    if (len > 0)
      data.copy(this.block, 0, off, off + len);
  }

  /**
   * Finalize SHA512 context.
   * @private
   * @param {Buffer} out
   * @returns {Buffer}
   */

  _final(out) {
    assert(this.size !== FINALIZED, 'Context is not initialized.');

    const pos = this.size & 127;
    const len = this.size * 8;

    writeU32(DESC, (len * (1 / 0x100000000)) >>> 0, 8);
    writeU32(DESC, len >>> 0, 12);

    this._update(PADDING, 1 + ((239 - pos) & 127));
    this._update(DESC, 16);

    for (let i = 0; i < 16; i++) {
      writeU32(out, this.state[i], i * 4);
      this.state[i] = 0;
    }

    for (let i = 0; i < 160; i++)
      this.msg[i] = 0;

    for (let i = 0; i < 128; i++)
      this.block[i] = 0;

    this.size = FINALIZED;

    return out;
  }

  _prepare(chunk, pos) {
    const W = this.msg;

    let i = 0;

    for (; i < 32; i++)
      W[i] = readU32(chunk, pos + i * 4);

    for (; i < 160; i += 2) {
      const c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
      const c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
      const c1_hi = W[i - 14];
      const c1_lo = W[i - 13];
      const c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
      const c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
      const c3_hi = W[i - 32];
      const c3_lo = W[i - 31];

      W[i + 0] = sum64_4_hi(c0_hi, c0_lo,
                            c1_hi, c1_lo,
                            c2_hi, c2_lo,
                            c3_hi, c3_lo);

      W[i + 1] = sum64_4_lo(c0_hi, c0_lo,
                            c1_hi, c1_lo,
                            c2_hi, c2_lo,
                            c3_hi, c3_lo);
    }
  }

  _transform(chunk, pos) {
    const W = this.msg;

    this._prepare(chunk, pos);

    let ah = this.state[0];
    let al = this.state[1];
    let bh = this.state[2];
    let bl = this.state[3];
    let ch = this.state[4];
    let cl = this.state[5];
    let dh = this.state[6];
    let dl = this.state[7];
    let eh = this.state[8];
    let el = this.state[9];
    let fh = this.state[10];
    let fl = this.state[11];
    let gh = this.state[12];
    let gl = this.state[13];
    let hh = this.state[14];
    let hl = this.state[15];

    for (let i = 0; i < W.length; i += 2) {
      let c0_hi = hh;
      let c0_lo = hl;
      let c1_hi = s1_512_hi(eh, el);
      let c1_lo = s1_512_lo(eh, el);

      const c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
      const c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
      const c3_hi = K[i + 0];
      const c3_lo = K[i + 1];
      const c4_hi = W[i + 0];
      const c4_lo = W[i + 1];

      const T1_hi = sum64_5_hi(c0_hi, c0_lo,
                               c1_hi, c1_lo,
                               c2_hi, c2_lo,
                               c3_hi, c3_lo,
                               c4_hi, c4_lo);

      const T1_lo = sum64_5_lo(c0_hi, c0_lo,
                               c1_hi, c1_lo,
                               c2_hi, c2_lo,
                               c3_hi, c3_lo,
                               c4_hi, c4_lo);

      c0_hi = s0_512_hi(ah, al);
      c0_lo = s0_512_lo(ah, al);
      c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
      c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

      const T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
      const T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

      hh = gh;
      hl = gl;

      gh = fh;
      gl = fl;

      fh = eh;
      fl = el;

      eh = sum64_hi(dh, dl, T1_hi, T1_lo);
      el = sum64_lo(dl, dl, T1_hi, T1_lo);

      dh = ch;
      dl = cl;

      ch = bh;
      cl = bl;

      bh = ah;
      bl = al;

      ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
      al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
    }

    sum64(this.state, 0, ah, al);
    sum64(this.state, 2, bh, bl);
    sum64(this.state, 4, ch, cl);
    sum64(this.state, 6, dh, dl);
    sum64(this.state, 8, eh, el);
    sum64(this.state, 10, fh, fl);
    sum64(this.state, 12, gh, gl);
    sum64(this.state, 14, hh, hl);
  }

  static hash() {
    return new SHA512();
  }

  static hmac() {
    return new HMAC(SHA512, 128);
  }

  static digest(data) {
    return SHA512.ctx.init().update(data).final();
  }

  static root(left, right) {
    assert((left != null && left._isBuffer === true) && left.length === 64);
    assert((right != null && right._isBuffer === true) && right.length === 64);
    return SHA512.ctx.init().update(left).update(right).final();
  }

  static multi(x, y, z) {
    const {ctx} = SHA512;

    ctx.init();
    ctx.update(x);
    ctx.update(y);

    if (z)
      ctx.update(z);

    return ctx.final();
  }

  static mac(data, key) {
    return SHA512.hmac().init(key).update(data).final();
  }
}

/*
 * Static
 */

SHA512.native = 0;
SHA512.id = 'SHA512';
SHA512.size = 64;
SHA512.bits = 512;
SHA512.blockSize = 128;
SHA512.zero = Buffer.alloc(64, 0x00);
SHA512.ctx = new SHA512();

/*
 * Helpers
 */

function sum64(buf, pos, ah, al) {
  const bh = buf[pos + 0];
  const bl = buf[pos + 1];

  const lo = (al + bl) >>> 0;
  const hi = (lo < al) + ah + bh;

  buf[pos + 0] = hi >>> 0;
  buf[pos + 1] = lo;
}

function sum64_hi(ah, al, bh, bl) {
  const lo = (al + bl) >>> 0;
  const hi = (lo < al) + ah + bh;
  return hi >>> 0;
}

function sum64_lo(ah, al, bh, bl) {
  const lo = al + bl;
  return lo >>> 0;
}

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  let carry = 0;
  let lo = al;

  lo = (lo + bl) >>> 0;
  carry += (lo < al);

  lo = (lo + cl) >>> 0;
  carry += (lo < cl);

  lo = (lo + dl) >>> 0;
  carry += (lo < dl);

  const hi = ah + bh + ch + dh + carry;

  return hi >>> 0;
}

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  const lo = al + bl + cl + dl;
  return lo >>> 0;
}

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  let carry = 0;
  let lo = al;

  lo = (lo + bl) >>> 0;
  carry += (lo < al);

  lo = (lo + cl) >>> 0;
  carry += (lo < cl);

  lo = (lo + dl) >>> 0;
  carry += (lo < dl);

  lo = (lo + el) >>> 0;
  carry += (lo < el);

  const hi = ah + bh + ch + dh + eh + carry;

  return hi >>> 0;
}

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  const lo = al + bl + cl + dl + el;
  return lo >>> 0;
}

function rotr64_hi(ah, al, num) {
  const r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}

function rotr64_lo(ah, al, num) {
  const r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}

function shr64_hi(ah, al, num) {
  return ah >>> num;
}

function shr64_lo(ah, al, num) {
  const r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}

function ch64_hi(xh, xl, yh, yl, zh, zl) {
  const r = (xh & yh) ^ ((~xh) & zh);
  return r >>> 0;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  const r = (xl & yl) ^ ((~xl) & zl);
  return r >>> 0;
}

function maj64_hi(xh, xl, yh, yl, zh, zl) {
  const r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  return r >>> 0;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  const r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  return r >>> 0;
}

function s0_512_hi(xh, xl) {
  const c0_hi = rotr64_hi(xh, xl, 28);
  const c1_hi = rotr64_hi(xl, xh, 2); // 34
  const c2_hi = rotr64_hi(xl, xh, 7); // 39
  const r = c0_hi ^ c1_hi ^ c2_hi;
  return r >>> 0;
}

function s0_512_lo(xh, xl) {
  const c0_lo = rotr64_lo(xh, xl, 28);
  const c1_lo = rotr64_lo(xl, xh, 2); // 34
  const c2_lo = rotr64_lo(xl, xh, 7); // 39
  const r = c0_lo ^ c1_lo ^ c2_lo;
  return r >>> 0;
}

function s1_512_hi(xh, xl) {
  const c0_hi = rotr64_hi(xh, xl, 14);
  const c1_hi = rotr64_hi(xh, xl, 18);
  const c2_hi = rotr64_hi(xl, xh, 9); // 41
  const r = c0_hi ^ c1_hi ^ c2_hi;
  return r >>> 0;
}

function s1_512_lo(xh, xl) {
  const c0_lo = rotr64_lo(xh, xl, 14);
  const c1_lo = rotr64_lo(xh, xl, 18);
  const c2_lo = rotr64_lo(xl, xh, 9); // 41
  const r = c0_lo ^ c1_lo ^ c2_lo;
  return r >>> 0;
}

function g0_512_hi(xh, xl) {
  const c0_hi = rotr64_hi(xh, xl, 1);
  const c1_hi = rotr64_hi(xh, xl, 8);
  const c2_hi = shr64_hi(xh, xl, 7);
  const r = c0_hi ^ c1_hi ^ c2_hi;
  return r >>> 0;
}

function g0_512_lo(xh, xl) {
  const c0_lo = rotr64_lo(xh, xl, 1);
  const c1_lo = rotr64_lo(xh, xl, 8);
  const c2_lo = shr64_lo(xh, xl, 7);
  const r = c0_lo ^ c1_lo ^ c2_lo;
  return r >>> 0;
}

function g1_512_hi(xh, xl) {
  const c0_hi = rotr64_hi(xh, xl, 19);
  const c1_hi = rotr64_hi(xl, xh, 29); // 61
  const c2_hi = shr64_hi(xh, xl, 6);
  const r = c0_hi ^ c1_hi ^ c2_hi;
  return r >>> 0;
}

function g1_512_lo(xh, xl) {
  const c0_lo = rotr64_lo(xh, xl, 19);
  const c1_lo = rotr64_lo(xl, xh, 29); // 61
  const c2_lo = shr64_lo(xh, xl, 6);
  const r = c0_lo ^ c1_lo ^ c2_lo;
  return r >>> 0;
}

function readU32(data, off) {
  return (data[off++] * 0x1000000
        + data[off++] * 0x10000
        + data[off++] * 0x100
        + data[off]);
}

function writeU32(data, num, off) {
  data[off++] = num >>> 24;
  data[off++] = num >>> 16;
  data[off++] = num >>> 8;
  data[off++] = num;
  return off;
}

/*
 * Expose
 */

module.exports = SHA512;
}],
[/* 37 */ 'bcrypto', '/lib/sha512-browser.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * sha512.js - sha512 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */



module.exports = __browser_require__(36 /* './js/sha512' */, module);
}],
[/* 38 */ 'bcrypto', '/lib/gost94-browser.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * gost94.js - gost94 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */



module.exports = __browser_require__(39 /* './js/gost94' */, module);
}],
[/* 39 */ 'bcrypto', '/lib/js/gost94.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * gost94.js - GOST94 implementation for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on RustCrypto/hashes:
 *   Copyright (c) 2016-2018, The RustCrypto Authors (MIT License).
 *   https://github.com/RustCrypto/hashes
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/GOST_(hash_function)
 *   https://tools.ietf.org/html/rfc4357
 *   https://tools.ietf.org/html/rfc5831
 *   https://github.com/RustCrypto/hashes/blob/master/gost94/src/gost94.rs
 */



const assert = __browser_require__(24 /* '../internal/assert' */, module);
const HMAC = __browser_require__(27 /* '../internal/hmac' */, module);

/*
 * Constants
 */

const FINALIZED = -1;
const PADDING = Buffer.alloc(32, 0x00);
const DESC = Buffer.alloc(32, 0x00);

const C = Buffer.from([
  0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
  0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
  0x00, 0xff, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff,
  0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff
]);

const S_CRYPTOPRO = [
  Buffer.from([10, 4, 5, 6, 8, 1, 3, 7, 13, 12, 14, 0, 9, 2, 11, 15]),
  Buffer.from([5, 15, 4, 0, 2, 13, 11, 9, 1, 7, 6, 3, 12, 14, 10, 8]),
  Buffer.from([7, 15, 12, 14, 9, 4, 1, 0, 3, 11, 5, 2, 6, 10, 8, 13]),
  Buffer.from([4, 10, 7, 12, 0, 15, 2, 8, 14, 1, 6, 5, 13, 11, 9, 3]),
  Buffer.from([7, 6, 4, 11, 9, 12, 2, 10, 1, 8, 0, 14, 15, 13, 3, 5]),
  Buffer.from([7, 6, 2, 4, 13, 9, 15, 0, 10, 1, 5, 11, 8, 14, 12, 3]),
  Buffer.from([13, 14, 4, 1, 7, 0, 5, 10, 3, 12, 8, 15, 6, 2, 9, 11]),
  Buffer.from([1, 3, 10, 9, 5, 11, 4, 15, 8, 6, 7, 14, 13, 0, 2, 12])
];

const S_TEST = [
  Buffer.from([4, 10, 9, 2, 13, 8, 0, 14, 6, 11, 1, 12, 7, 15, 5, 3]),
  Buffer.from([14, 11, 4, 12, 6, 13, 15, 10, 2, 3, 8, 1, 0, 7, 5, 9]),
  Buffer.from([5, 8, 1, 13, 10, 3, 4, 2, 14, 15, 12, 7, 6, 0, 9, 11]),
  Buffer.from([7, 13, 10, 1, 0, 8, 9, 15, 14, 4, 6, 12, 11, 2, 5, 3]),
  Buffer.from([6, 12, 7, 1, 5, 15, 13, 8, 4, 10, 9, 14, 0, 3, 11, 2]),
  Buffer.from([4, 11, 10, 0, 7, 2, 1, 13, 3, 6, 8, 5, 9, 12, 15, 14]),
  Buffer.from([13, 11, 4, 1, 3, 15, 5, 9, 0, 10, 14, 7, 6, 8, 2, 12]),
  Buffer.from([1, 15, 13, 0, 5, 7, 10, 4, 9, 2, 3, 14, 6, 11, 8, 12])
];

const S_S2015 = [
  Buffer.from([12, 4, 6, 2, 10, 5, 11, 9, 14, 8, 13, 7, 0, 3, 15, 1]),
  Buffer.from([6, 8, 2, 3, 9, 10, 5, 12, 1, 14, 4, 7, 11, 13, 0, 15]),
  Buffer.from([11, 3, 5, 8, 2, 15, 10, 13, 14, 1, 7, 4, 12, 9, 6, 0]),
  Buffer.from([12, 8, 2, 1, 13, 4, 15, 6, 7, 0, 10, 5, 3, 14, 9, 11]),
  Buffer.from([7, 15, 5, 10, 8, 1, 6, 13, 0, 9, 3, 14, 11, 4, 2, 12]),
  Buffer.from([5, 13, 15, 6, 9, 2, 12, 10, 11, 7, 8, 1, 4, 3, 14, 0]),
  Buffer.from([8, 14, 2, 5, 6, 9, 1, 12, 15, 4, 11, 0, 13, 10, 3, 7]),
  Buffer.from([1, 7, 14, 13, 0, 5, 8, 3, 4, 15, 10, 6, 9, 12, 11, 2])
];

/**
 * GOST94
 */

class GOST94 {
  constructor() {
    this.S = S_CRYPTOPRO;
    this.state = Buffer.alloc(32);
    this.sigma = Buffer.alloc(32);
    this.block = Buffer.alloc(32);
    this.size = FINALIZED;
  }

  init(box) {
    if (box == null)
      box = S_CRYPTOPRO;

    assert(Array.isArray(box) && box.length === 8);

    this.S = box;
    this.state.fill(0);
    this.sigma.fill(0);
    this.size = 0;

    return this;
  }

  update(data) {
    assert((data != null && data._isBuffer === true));
    this._update(data, data.length);
    return this;
  }

  final() {
    return this._final(Buffer.alloc(32));
  }

  _update(data, len) {
    assert(this.size !== FINALIZED, 'Context is not initialized.');

    let pos = this.size & 31;
    let off = 0;

    this.size += len;

    if (pos > 0) {
      let want = 32 - pos;

      if (want > len)
        want = len;

      data.copy(this.block, pos, off, off + want);

      pos += want;
      len -= want;
      off += want;

      if (pos < 32)
        return;

      this._transform(this.block, 0);
    }

    while (len >= 32) {
      this._transform(data, off);
      off += 32;
      len -= 32;
    }

    if (len > 0)
      data.copy(this.block, 0, off, off + len);
  }

  _final(out) {
    assert(this.size !== FINALIZED, 'Context is not initialized.');

    const bits = this.size * 8;
    const pos = this.size & 31;

    if (pos !== 0)
      this._update(PADDING, 32 - pos);

    const hi = (bits * (1 / 0x100000000)) >>> 0;
    const lo = bits >>> 0;

    writeU32(DESC, lo, 0);
    writeU32(DESC, hi, 4);

    this._f(DESC);
    this._f(this.sigma);

    this.state.copy(out, 0);

    this.state.fill(0);
    this.sigma.fill(0);
    this.block.fill(0);

    DESC.fill(0, 0, 8);

    this.size = FINALIZED;

    return out;
  }

  _transform(chunk, pos) {
    const m = chunk.slice(pos, pos + 32);

    this._f(m);
    this._sum(m);
  }

  _shuffle(m, s) {
    const res = Buffer.alloc(32);
    s.copy(res, 0);

    for (let i = 0; i < 12; i++)
      psi(res);

    XM(res, m);
    psi(res);
    XM(this.state, res);

    for (let i = 0; i < 61; i++)
      psi(this.state);
  }

  _f(m) {
    const s = Buffer.alloc(32);

    this.state.copy(s, 0);

    let k, u, v;

    k = P(X(this.state, m));
    encrypt(s, 0, k, this.S);

    u = A(this.state);
    v = A(A(m));
    k = P(X(u, v));
    encrypt(s, 8, k, this.S);

    u = A(u);
    XM(u, C);
    v = A(A(v));
    k = P(X(u, v));
    encrypt(s, 16, k, this.S);

    u = A(u);
    v = A(A(v));
    k = P(X(u, v));
    encrypt(s, 24, k, this.S);

    this._shuffle(m, s);
  }

  _sum(m) {
    let c = 0;

    for (let i = 0; i < 32; i++) {
      c += this.sigma[i] + m[i];
      this.sigma[i] = c;
      c >>>= 8;
    }
  }

  static hash() {
    return new GOST94();
  }

  static hmac(box) {
    return new HMAC(GOST94, 32, [box]);
  }

  static digest(data, box) {
    return GOST94.ctx.init(box).update(data).final();
  }

  static root(left, right, box) {
    assert((left != null && left._isBuffer === true) && left.length === 32);
    assert((right != null && right._isBuffer === true) && right.length === 32);
    return GOST94.ctx.init(box).update(left).update(right).final();
  }

  static multi(x, y, z, box) {
    const {ctx} = GOST94;

    ctx.init(box);
    ctx.update(x);
    ctx.update(y);

    if (z)
      ctx.update(z);

    return ctx.final();
  }

  static mac(data, key, box) {
    return GOST94.hmac(box).init(key).update(data).final();
  }
}

/*
 * Static
 */

GOST94.native = 0;
GOST94.id = 'GOST94';
GOST94.size = 32;
GOST94.bits = 256;
GOST94.blockSize = 32;
GOST94.zero = Buffer.alloc(32, 0x00);
GOST94.ctx = new GOST94();

GOST94.CRYPTOPRO = S_CRYPTOPRO;
GOST94.TEST = S_TEST;
GOST94.S2015 = S_S2015;

/*
 * Helpers
 */

function sbox(a, S) {
  let v = 0;

  for (let i = 0; i < 8; i++) {
    const shft = 4 * i;
    const k = (a & (15 << shft)) >>> shft;
    v += S[i][k] << shft;
  }

  return v >>> 0;
}

function G(a, k, S) {
  return rotl32(sbox((a + k) >>> 0, S), 11);
}

function encrypt(msg, pos, key, sbox) {
  const k = new Uint32Array(8);

  let a = readU32(msg, pos + 0);
  let b = readU32(msg, pos + 4);

  for (let i = 0; i < 8; i++)
    k[i] = readU32(key, i * 4);

  for (let x = 0; x < 3; x++) {
    for (let i = 0; i < 8; i++) {
      const t = b ^ G(a, k[i], sbox);
      b = a;
      a = t;
    }
  }

  for (let i = 7; i >= 0; i--) {
    const t = b ^ G(a, k[i], sbox);
    b = a;
    a = t;
  }

  writeU32(msg, b, pos + 0);
  writeU32(msg, a, pos + 4);
}

function X(a, b) {
  const out = Buffer.alloc(32);

  for (let i = 0; i < 32; i++)
    out[i] = a[i] ^ b[i];

  return out;
}

function XM(a, b) {
  for (let i = 0; i < 32; i++)
    a[i] ^= b[i];
}

function A(x) {
  const out = Buffer.alloc(32);

  x.copy(out, 0, 8, 32);

  for (let i = 0; i < 8; i++)
    out[24 + i] = x[i] ^ x[i + 8];

  return out;
}

function P(y) {
  const out = Buffer.alloc(32);

  for (let i = 0; i < 4; i++) {
    for (let k = 0; k < 8; k++)
      out[i + 4 * k] = y[8 * i + k];
  }

  return out;
}

function psi(block) {
  const out = Buffer.alloc(32);

  block.copy(out, 0, 2, 32);
  block.copy(out, 30, 0, 2);

  out[30] ^= block[2];
  out[31] ^= block[3];

  out[30] ^= block[4];
  out[31] ^= block[5];

  out[30] ^= block[6];
  out[31] ^= block[7];

  out[30] ^= block[24];
  out[31] ^= block[25];

  out[30] ^= block[30];
  out[31] ^= block[31];

  out.copy(block, 0);
}

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}

function readU32(data, off) {
  return (data[off++]
        + data[off++] * 0x100
        + data[off++] * 0x10000
        + data[off] * 0x1000000);
}

function writeU32(dst, num, off) {
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  return off;
}

/*
 * Expose
 */

module.exports = GOST94;
}],
[/* 40 */ 'bcrypto', '/lib/dsa-browser.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * dsa.js - DSA for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */



module.exports = __browser_require__(41 /* './js/dsa' */, module);
}],
[/* 41 */ 'bcrypto', '/lib/js/dsa.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * dsa.js - DSA for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * References:
 *
 *   [FIPS186] Federal Information Processing Standards Publication
 *     National Institute of Standards and Technology
 *     http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf
 *
 *   [DSA] Digital Signature Algorithm (wikipedia)
 *     https://en.wikipedia.org/wiki/Digital_Signature_Algorithm
 *
 *   [RFC6979] Deterministic Usage of the Digital Signature
 *             Algorithm (DSA) and Elliptic Curve Digital
 *             Signature Algorithm (ECDSA)
 *     T. Pornin
 *     https://tools.ietf.org/html/rfc6979
 */



const assert = __browser_require__(24 /* '../internal/assert' */, module);
const BN = __browser_require__(42 /* '../bn' */, module);
const rng = __browser_require__(45 /* '../random' */, module);
const HmacDRBG = __browser_require__(47 /* '../hmac-drbg' */, module);
const SHA256 = __browser_require__(33 /* '../sha256' */, module);
const {isProbablePrime} = __browser_require__(49 /* '../internal/primes' */, module);
const asn1 = __browser_require__(50 /* '../internal/asn1' */, module);

/*
 * Constants
 */

const DEFAULT_BITS = 2048;
const MIN_BITS = 512;
const MAX_BITS = 10000;

/**
 * DSAParams
 */

class DSAParams {
  constructor() {
    this.p = new BN(0);
    this.q = new BN(0);
    this.g = new BN(0);
  }

  bits() {
    return this.p.bitLength();
  }

  size() {
    return this.q.byteLength();
  }

  isSane() {
    if (this.p.sign() < 0 || this.q.sign() < 0)
      return false;

    const pbits = this.p.bitLength();
    const qbits = this.q.bitLength();

    if (pbits < MIN_BITS || pbits > MAX_BITS)
      return false;

    if (qbits !== 160 && qbits !== 224 && qbits !== 256)
      return false;

    if (this.g.cmpn(2) < 0 || this.g.cmp(this.p.subn(1)) >= 0)
      return false;

    if (!this.p.isOdd())
      return false;

    if (!this.q.isOdd())
      return false;

    return true;
  }

  verify() {
    return this.g.powm(this.q, this.p).cmpn(1) === 0;
  }

  generate(L, N) {
    // [FIPS186] Page 31, Appendix A.1.
    //           Page 41, Appendix A.2.
    // [DSA] "Parameter generation".
    assert((L >>> 0) === L);
    assert((N >>> 0) === N);

    if (!(L === 1024 && N === 160)
        && !(L === 2048 && N === 224)
        && !(L === 2048 && N === 256)
        && !(L === 3072 && N === 256)) {
      throw new Error('Invalid parameter sizes.');
    }

    if (L < MIN_BITS || L > MAX_BITS || (N & 7) !== 0)
      throw new Error('Invalid parameter sizes.');

    let q = null;
    let p = null;

outer:
    for (;;) {
      q = BN.randomBits(rng, N);
      q.setn(N - 1, 1);
      q.setn(0, 1);

      if (!isProbablePrime(q, 64))
        continue;

      for (let i = 0; i < 4 * L; i++) {
        p = BN.randomBits(rng, L);
        p.setn(L - 1, 1);
        p.setn(0, 1);

        p.isub(p.mod(q).isubn(1));

        const bits = p.bitLength();

        if (bits < L || bits > MAX_BITS)
          continue;

        if (!isProbablePrime(p, 64))
          continue;

        break outer;
      }
    }

    const h = new BN(2);
    const pm1 = p.subn(1);
    const e = pm1.div(q);

    for (;;) {
      const g = h.powm(e, p);

      if (g.cmpn(1) === 0) {
        h.iaddn(1);
        continue;
      }

      this.p = p;
      this.q = q;
      this.g = g;

      return this;
    }
  }

  toParams() {
    const group = new DSAParams();

    group.p = this.p;
    group.q = this.q;
    group.g = this.g;

    return group;
  }

  encode() {
    let size = 0;

    size += asn1.sizeInt(this.p);
    size += asn1.sizeInt(this.q);
    size += asn1.sizeInt(this.g);

    const out = Buffer.alloc(asn1.sizeSeq(size));

    let pos = 0;

    pos = asn1.writeSeq(out, pos, size);
    pos = asn1.writeInt(out, pos, this.p);
    pos = asn1.writeInt(out, pos, this.q);
    pos = asn1.writeInt(out, pos, this.g);

    assert(pos === out.length);

    return out;
  }

  decode(data) {
    assert((data != null && data._isBuffer === true));

    let pos = 0;

    pos = asn1.readSeq(data, pos);

    [this.p, pos] = asn1.readInt(data, pos);
    [this.q, pos] = asn1.readInt(data, pos);
    [this.g, pos] = asn1.readInt(data, pos);

    if (pos !== data.length)
      throw new Error('Trailing bytes.');

    return this;
  }

  static generate(L, N) {
    return new DSAParams().generate(L, N);
  }

  static decode(data) {
    return new DSAParams().decode(data);
  }
}

/**
 * DSAPublicKey
 */

class DSAPublicKey extends DSAParams {
  constructor() {
    super();
    this.y = new BN(0);
  }

  isSane() {
    if (!super.isSane())
      return false;

    if (this.y.cmpn(2) < 0 || this.y.cmp(this.p.subn(1)) >= 0)
      return false;

    return true;
  }

  verify() {
    if (!super.verify())
      return false;

    return this.y.powm(this.q, this.p).cmpn(1) === 0;
  }

  encode() {
    let size = 0;

    size += asn1.sizeInt(this.y);
    size += asn1.sizeInt(this.p);
    size += asn1.sizeInt(this.q);
    size += asn1.sizeInt(this.g);

    const out = Buffer.alloc(asn1.sizeSeq(size));

    let pos = 0;

    pos = asn1.writeSeq(out, pos, size);
    pos = asn1.writeInt(out, pos, this.y);
    pos = asn1.writeInt(out, pos, this.p);
    pos = asn1.writeInt(out, pos, this.q);
    pos = asn1.writeInt(out, pos, this.g);

    assert(pos === out.length);

    return out;
  }

  decode(data) {
    assert((data != null && data._isBuffer === true));

    let pos = 0;

    pos = asn1.readSeq(data, pos);

    [this.y, pos] = asn1.readInt(data, pos);
    [this.p, pos] = asn1.readInt(data, pos);
    [this.q, pos] = asn1.readInt(data, pos);
    [this.g, pos] = asn1.readInt(data, pos);

    if (pos !== data.length)
      throw new Error('Trailing bytes.');

    return this;
  }

  static decode(data) {
    return new DSAPublicKey().decode(data);
  }
}

/**
 * DSAPrivateKey
 */

class DSAPrivateKey extends DSAPublicKey {
  constructor() {
    super();
    this.x = new BN(0);
  }

  isSane() {
    if (!super.isSane())
      return false;

    if (this.x.sign() <= 0 || this.x.cmp(this.q) >= 0)
      return false;

    return true;
  }

  isSaneCompute() {
    const group = new DSAParams();

    group.p = this.p;
    group.q = this.q;
    group.g = this.g;

    if (!group.isSane())
      return false;

    if (this.x.sign() <= 0 || this.x.cmp(this.q) >= 0)
      return false;

    return true;
  }

  verify() {
    if (!super.verify())
      return false;

    const y = this.g.powm(this.x, this.p);

    return this.y.eq(y);
  }

  toPublic() {
    const pub = new DSAPublicKey();

    pub.p = this.p;
    pub.q = this.q;
    pub.g = this.g;
    pub.y = this.y;

    return pub;
  }

  encode() {
    let size = 0;

    size += asn1.sizeVersion(0);
    size += asn1.sizeInt(this.p);
    size += asn1.sizeInt(this.q);
    size += asn1.sizeInt(this.g);
    size += asn1.sizeInt(this.y);
    size += asn1.sizeInt(this.x);

    const out = Buffer.alloc(asn1.sizeSeq(size));

    let pos = 0;

    pos = asn1.writeSeq(out, pos, size);
    pos = asn1.writeVersion(out, pos, 0);
    pos = asn1.writeInt(out, pos, this.p);
    pos = asn1.writeInt(out, pos, this.q);
    pos = asn1.writeInt(out, pos, this.g);
    pos = asn1.writeInt(out, pos, this.y);
    pos = asn1.writeInt(out, pos, this.x);

    assert(pos === out.length);

    return out;
  }

  decode(data) {
    assert((data != null && data._isBuffer === true));

    let pos = 0;

    pos = asn1.readSeq(data, pos);
    pos = asn1.readVersion(data, pos, 0);

    [this.p, pos] = asn1.readInt(data, pos);
    [this.q, pos] = asn1.readInt(data, pos);
    [this.g, pos] = asn1.readInt(data, pos);
    [this.y, pos] = asn1.readInt(data, pos);
    [this.x, pos] = asn1.readInt(data, pos);

    if (pos !== data.length)
      throw new Error('Trailing bytes.');

    return this;
  }

  static decode(data) {
    return new DSAPrivateKey().decode(data);
  }
}

/**
 * DSASignature
 */

class DSASignature {
  constructor() {
    this.r = new BN(0);
    this.s = new BN(0);
  }

  encode() {
    const size = asn1.sizeInt(this.r) + asn1.sizeInt(this.s);
    const out = Buffer.alloc(asn1.sizeSeq(size));

    let pos = 0;

    pos = asn1.writeSeq(out, pos, size);
    pos = asn1.writeInt(out, pos, this.r);
    pos = asn1.writeInt(out, pos, this.s);

    assert(pos === out.length);

    return out;
  }

  decode(data) {
    assert((data != null && data._isBuffer === true));

    let pos = 0;

    pos = asn1.readSeq(data, pos);

    [this.r, pos] = asn1.readInt(data, pos);
    [this.s, pos] = asn1.readInt(data, pos);

    if (pos !== data.length)
      throw new Error('Trailing bytes.');

    return this;
  }

  encodeRS(size) {
    assert((size >> 0) === size);

    return Buffer.concat([
      this.r.encode('be', size),
      this.s.encode('be', size)
    ]);
  }

  decodeRS(data, size) {
    assert((data != null && data._isBuffer === true));

    if (size == null)
      size = data.length >>> 1;

    assert((size >> 0) === size);
    assert(data.length === size * 2);

    this.r = BN.decode(data.slice(0, size));
    this.s = BN.decode(data.slice(size, size * 2));

    return this;
  }

  static decode(data) {
    return new DSASignature().decode(data);
  }

  static decodeRS(data, size) {
    return new DSASignature().decodeRS(data, size);
  }
}

/**
 * Create params from key.
 * @param {Buffer} key
 * @returns {Buffer}
 */

function paramsCreate(key) {
  assert((key != null && key._isBuffer === true));

  let k;

  try {
    k = DSAPrivateKey.decode(key);
  } catch (e) {
    k = DSAPublicKey.decode(key);
  }

  const group = k.toParams();

  if (!group.isSane())
    throw new Error('Invalid DSA key.');

  return group.encode();
}

/**
 * Generate params.
 * @param {Number} [bits=2048]
 * @returns {Buffer}
 */

function paramsGenerate(bits) {
  if (bits == null)
    bits = DEFAULT_BITS;

  assert((bits >>> 0) === bits);

  if (bits < MIN_BITS || bits > MAX_BITS)
    throw new RangeError(`"bits" ranges from ${MIN_BITS} to ${MAX_BITS}.`);

  // OpenSSL behavior.
  const L = bits;
  const N = bits < 2048 ? 160 : 256;

  return DSAParams.generate(L, N).encode();
}

/**
 * Generate params.
 * @param {Number} [bits=2048]
 * @returns {Buffer}
 */

async function paramsGenerateAsync(bits) {
  return paramsGenerate(bits);
}

/**
 * Get params prime size in bits.
 * @param {Buffer} params
 * @returns {Number}
 */

function paramsBits(params) {
  const group = DSAParams.decode(params);

  if (!group.isSane())
    throw new Error('Invalid DSA params.');

  return group.bits();
}

/**
 * Get params scalar size in bits.
 * @param {Buffer} params
 * @returns {Number}
 */

function paramsScalarBits(params) {
  const group = DSAParams.decode(params);

  if (!group.isSane())
    throw new Error('Invalid DSA params.');

  return group.q.bitLength();
}

/**
 * Verify params.
 * @param {Buffer} params
 * @returns {Boolean}
 */

function paramsVerify(params) {
  assert((params != null && params._isBuffer === true));

  let group;
  try {
    group = DSAParams.decode(params);
  } catch (e) {
    return false;
  }

  if (!group.isSane())
    return false;

  return group.verify();
}

/**
 * Import params from an object.
 * @param {Object} json
 * @returns {Buffer}
 */

function paramsImport(json) {
  assert(json && typeof json === 'object');

  const group = new DSAParams();

  if (json.p != null)
    group.p = BN.decode(json.p);

  if (json.q != null)
    group.q = BN.decode(json.q);

  if (json.g != null)
    group.g = BN.decode(json.g);

  if (!group.isSane())
    throw new Error('Invalid DSA parameters.');

  return group.encode();
}

/**
 * Export params to an object.
 * @param {Buffer} params
 * @returns {Object}
 */

function paramsExport(params) {
  const group = DSAParams.decode(params);

  if (!group.isSane())
    throw new Error('Invalid DSA parameters.');

  return {
    p: group.p.encode(),
    q: group.q.encode(),
    g: group.g.encode()
  };
}

/**
 * Generate private key from params.
 * @param {Buffer} params
 * @returns {Buffer}
 */

function privateKeyCreate(params) {
  // [FIPS186] Page 46, Appendix B.1.
  // [DSA] "Per-user keys".
  const group = DSAParams.decode(params);

  if (!group.isSane())
    throw new Error('Invalid DSA parameters.');

  const {p, q, g} = group;
  const x = BN.random(rng, 1, q);
  const y = g.powm(x, p);
  const key = new DSAPrivateKey();

  key.p = p;
  key.q = q;
  key.g = g;
  key.x = x;
  key.y = y;

  return key.encode();
}

/**
 * Generate private key.
 * @param {Number} [bits=2048]
 * @returns {Buffer}
 */

function privateKeyGenerate(bits) {
  const params = paramsGenerate(bits);
  return privateKeyCreate(params);
}

/**
 * Generate private key.
 * @param {Number} [bits=2048]
 * @returns {Buffer}
 */

async function privateKeyGenerateAsync(bits) {
  const params = await paramsGenerateAsync(bits);
  return privateKeyCreate(params);
}

/**
 * Get private key prime size in bits.
 * @param {Buffer} key
 * @returns {Number}
 */

function privateKeyBits(key) {
  const k = DSAPrivateKey.decode(key);

  if (!k.isSane())
    throw new Error('Invalid DSA private key.');

  return k.bits();
}

/**
 * Get private key scalar size in bits.
 * @param {Buffer} key
 * @returns {Number}
 */

function privateKeyScalarBits(key) {
  const k = DSAPrivateKey.decode(key);

  if (!k.isSane())
    throw new Error('Invalid DSA private key.');

  return k.q.bitLength();
}

/**
 * Verify a private key.
 * @param {Buffer} key
 * @returns {Boolean}
 */

function privateKeyVerify(key) {
  assert((key != null && key._isBuffer === true));

  let k;
  try {
    k = DSAPrivateKey.decode(key);
  } catch (e) {
    return false;
  }

  if (!k.isSane())
    return false;

  return k.verify();
}

/**
 * Import a private key from an object.
 * @param {Object} json
 * @returns {Buffer}
 */

function privateKeyImport(json) {
  assert(json && typeof json === 'object');

  const k = new DSAPrivateKey();

  if (json.p != null)
    k.p = BN.decode(json.p);

  if (json.q != null)
    k.q = BN.decode(json.q);

  if (json.g != null)
    k.g = BN.decode(json.g);

  if (json.y != null)
    k.y = BN.decode(json.y);

  if (json.x != null)
    k.x = BN.decode(json.x);

  if (k.y.isZero()) {
    if (!k.isSaneCompute())
      throw new Error('Invalid DSA private key.');

    k.y = k.g.powm(k.x, k.p);
  } else {
    if (!k.isSane())
      throw new Error('Invalid DSA private key.');
  }

  return k.encode();
}

/**
 * Export a private key in OpenSSL ASN.1 format.
 * @param {Buffer} key
 * @returns {Buffer}
 */

function privateKeyExport(key) {
  const k = DSAPrivateKey.decode(key);

  if (!k.isSane())
    throw new Error('Invalid RSA private key.');

  return {
    p: k.p.encode(),
    q: k.q.encode(),
    g: k.g.encode(),
    y: k.y.encode(),
    x: k.x.encode()
  };
}

/**
 * Create a public key from a private key.
 * @param {Buffer} key
 * @returns {Buffer}
 */

function publicKeyCreate(key) {
  const k = DSAPrivateKey.decode(key);

  if (!k.isSane())
    throw new Error('Invalid DSA private key.');

  const p = k.toPublic();

  return p.encode();
}

/**
 * Get public key prime size in bits.
 * @param {Buffer} key
 * @returns {Number}
 */

function publicKeyBits(key) {
  const k = DSAPublicKey.decode(key);

  if (!k.isSane())
    throw new Error('Invalid DSA public key.');

  return k.bits();
}

/**
 * Get public key scalar size in bits.
 * @param {Buffer} key
 * @returns {Number}
 */

function publicKeyScalarBits(key) {
  const k = DSAPublicKey.decode(key);

  if (!k.isSane())
    throw new Error('Invalid DSA public key.');

  return k.q.bitLength();
}

/**
 * Verify a public key.
 * @param {Buffer} key
 * @returns {Boolean}
 */

function publicKeyVerify(key) {
  let k;
  try {
    k = DSAPublicKey.decode(key);
  } catch (e) {
    return false;
  }

  if (!k.isSane())
    return false;

  return k.verify();
}

/**
 * Import a public key to an object.
 * @param {Object} json
 * @returns {Buffer}
 */

function publicKeyImport(json) {
  assert(json && typeof json === 'object');

  const k = new DSAPublicKey();

  if (json.p != null)
    k.p = BN.decode(json.p);

  if (json.q != null)
    k.q = BN.decode(json.q);

  if (json.g != null)
    k.g = BN.decode(json.g);

  if (json.y != null)
    k.y = BN.decode(json.y);

  if (!k.isSane())
    throw new Error('Invalid DSA public key.');

  return k.encode();
}

/**
 * Export a public key to an object.
 * @param {Buffer} key
 * @returns {Object}
 */

function publicKeyExport(key) {
  const k = DSAPublicKey.decode(key);

  if (!k.isSane())
    throw new Error('Invalid DSA public key.');

  return {
    p: k.p.encode(),
    q: k.q.encode(),
    g: k.g.encode(),
    y: k.y.encode()
  };
}

/**
 * Convert DER signature to R/S.
 * @param {Buffer} sig
 * @param {Number} size
 * @returns {Buffer} R/S-formatted signature.
 */

function signatureImport(sig, size) {
  const S = DSASignature.decode(sig);
  return S.encodeRS(size);
}

/**
 * Convert R/S signature to DER.
 * @param {Buffer} sig
 * @param {Number} size
 * @returns {Buffer} DER-formatted signature.
 */

function signatureExport(sig, size) {
  const S = DSASignature.decodeRS(sig, size);
  return S.encode();
}

/**
 * Sign a message (R/S).
 * @param {Buffer} msg
 * @param {Buffer} key - Private key.
 * @returns {Buffer} R/S-formatted signature.
 */

function sign(msg, key) {
  const k = DSAPrivateKey.decode(key);
  const S = _sign(msg, k);
  return S.encodeRS(k.size());
}

/**
 * Sign a message (DER).
 * @param {Buffer} msg
 * @param {Buffer} key - Private key.
 * @returns {Buffer} DER-formatted signature.
 */

function signDER(msg, key) {
  const k = DSAPrivateKey.decode(key);
  const S = _sign(msg, k);
  return S.encode();
}

/**
 * Sign a message.
 * @private
 * @param {Buffer} msg
 * @param {Buffer} key
 * @returns {Signature}
 */

function _sign(msg, key) {
  // DSA Signing.
  //
  // [FIPS186] Page 19, Section 4.6.
  // [DSA] "Signing".
  // [RFC6979] Page 9, Section 2.4.
  // [RFC6979] Page 10, Section 3.2.
  //
  // Assumptions:
  //
  //   - Let `m` be an integer reduced from bytes.
  //   - Let `x` be a secret non-zero scalar.
  //   - Let `k` be a random non-zero scalar.
  //   - r != 0, s != 0.
  //
  // Computation:
  //
  //   k = random integer in [1,q-1]
  //   r' = g^k mod p
  //   r = r' mod q
  //   s = (r * x + m) / k mod q
  //   S = (r, s)
  //
  // We can blind the scalar arithmetic
  // with a random integer `b` like so:
  //
  //   b = random integer in [1,q-1]
  //   s = (r * (x * b) + m * b) / (k * b) mod q
  //
  // Note that `k` must remain secret,
  // otherwise an attacker can compute:
  //
  //   x = (s * k - m) / r mod q
  //
  // This means that if two signatures
  // share the same `r` value, an attacker
  // can compute:
  //
  //   k = (m1 - m2) / (s1 - s2) mod q
  //   x = (s1 * k - m1) / r mod q
  //
  // Assuming:
  //
  //   s1 = (r * x + m1) / k mod q
  //   s2 = (r * x + m2) / k mod q
  //
  // To mitigate this, `k` can be generated
  // deterministically using the HMAC-DRBG
  // construction described in [RFC6979].
  assert((msg != null && msg._isBuffer === true));
  assert(key instanceof DSAPrivateKey);

  if (!key.isSane())
    throw new Error('Invalid DSA private key.');

  const {p, q, g, x} = key;
  const bytes = q.byteLength();
  const m = reduce(msg, q);
  const entropy = x.encode('be', bytes);
  const nonce = m.encode('be', bytes);
  const drbg = new HmacDRBG(SHA256, entropy, nonce);

  for (;;) {
    const k = truncate(drbg.generate(bytes), q);

    if (k.isZero() || k.cmp(q) >= 0)
      continue;

    const re = powBlind(g, k, p, q);
    const r = re.mod(q);

    if (r.isZero())
      continue;

    const b = BN.random(rng, 1, q);
    const ki = k.mul(b).fermat(q);
    const bx = x.mul(b).imod(q);
    const bm = m.mul(b).imod(q);
    const sk = r.mul(bx).iadd(bm).imod(q);
    const s = sk.mul(ki).imod(q);

    if (s.isZero())
      continue;

    const S = new DSASignature();

    S.r = r;
    S.s = s;

    return S;
  }
}

/**
 * Verify a signature (R/S).
 * @private
 * @param {Buffer} msg
 * @param {Buffer} sig - R/S-formatted.
 * @param {Buffer} key
 * @returns {Boolean}
 */

function verify(msg, sig, key) {
  assert((msg != null && msg._isBuffer === true));
  assert((sig != null && sig._isBuffer === true));
  assert((key != null && key._isBuffer === true));

  let k;
  try {
    k = DSAPublicKey.decode(key);
  } catch (e) {
    return false;
  }

  let S;
  try {
    S = DSASignature.decodeRS(sig, k.size());
  } catch (e) {
    return false;
  }

  try {
    return _verify(msg, S, k);
  } catch (e) {
    return false;
  }
}

/**
 * Verify a signature (DER).
 * @param {Buffer} msg
 * @param {Buffer} sig - DER-formatted.
 * @param {Buffer} key
 * @returns {Boolean}
 */

function verifyDER(msg, sig, key) {
  assert((msg != null && msg._isBuffer === true));
  assert((sig != null && sig._isBuffer === true));
  assert((key != null && key._isBuffer === true));

  let k;
  try {
    k = DSAPublicKey.decode(key);
  } catch (e) {
    return false;
  }

  let S;
  try {
    S = DSASignature.decode(sig);
  } catch (e) {
    return false;
  }

  try {
    return _verify(msg, S, k);
  } catch (e) {
    return false;
  }
}

/**
 * Verify a signature.
 * @private
 * @param {Buffer} msg
 * @param {Signature} S
 * @param {Buffer} key
 * @returns {Boolean}
 */

function _verify(msg, S, key) {
  // DSA Verification.
  //
  // [FIPS186] Page 19, Section 4.7.
  // [DSA] "Verifying a signature".
  //
  // Assumptions:
  //
  //   - Let `m` be an integer reduced from bytes.
  //   - Let `r` and `s` be signature elements.
  //   - Let `y` be a valid group element.
  //   - r != 0, r < q.
  //   - s != 0, s < q.
  //
  // Computation:
  //
  //   u1 = m / s mod q
  //   u2 = r / s mod q
  //   r' = g^u1 * y^u2 mod p
  //   r == r' mod q
  const {r, s} = S;
  const {p, q, g, y} = key;

  if (!key.isSane())
    return false;

  if (r.isZero() || r.cmp(q) >= 0)
    return false;

  if (s.isZero() || s.cmp(q) >= 0)
    return false;

  const m = reduce(msg, q);
  const si = s.invert(q);
  const u1 = m.mul(si).imod(q);
  const u2 = r.mul(si).imod(q);
  const e1 = g.powm(u1, p);
  const e2 = y.powm(u2, p);
  const re = e1.mul(e2).imod(p);

  return re.imod(q).eq(r);
}

/**
 * Perform a diffie-hellman.
 * @param {Buffer} pub
 * @param {Buffer} priv
 * @returns {Buffer}
 */

function derive(pub, priv) {
  const k1 = DSAPublicKey.decode(pub);
  const k2 = DSAPrivateKey.decode(priv);

  if (!k1.isSane())
    throw new Error('Invalid DSA public key.');

  if (!k2.isSane())
    throw new Error('Invalid DSA private key.');

  const {p, q, g, x} = k2;
  const {y} = k1;

  if (!k1.p.eq(p) || !k1.q.eq(q) || !k1.g.eq(g))
    throw new Error('Incompatible DSA parameters.');

  if (!k1.verify())
    throw new Error('Invalid DSA public key.');

  const e = powBlind(y, x, p, q);

  return e.encode('be', p.byteLength());
}

/*
 * Helpers
 */

function truncate(msg, q) {
  // Byte array to integer conversion.
  //
  // [FIPS186] Page 68, Appendix C.2.
  //
  // Note that the FIPS186 behavior
  // differs from OpenSSL's behavior.
  // We replicate OpenSSL which takes
  // the left-most ceil(log2(q+1)) bits
  // modulo the order.
  assert((msg != null && msg._isBuffer === true));
  assert(q instanceof BN);

  const bits = q.bitLength();
  const bytes = (bits + 7) >>> 3;

  if (msg.length > bytes)
    msg = msg.slice(0, bytes);

  const m = BN.decode(msg);
  const d = msg.length * 8 - bits;

  if (d > 0)
    m.iushrn(d);

  return m;
}

function reduce(msg, q) {
  return truncate(msg, q).imod(q);
}

function powBlind(g, x, p, q) {
  // Idea: exponentiate by scalar with a
  // blinding factor, similar to how we
  // blind multiplications in EC. Note
  // that it would be safer if we had the
  // blinding factor pregenerated for each
  // key.
  //
  // Computation:
  //
  //   b = random integer in [1,q-1]
  //   k = (x - b) mod q
  //   e = g^k * g^b mod p
  //
  // In theory, we could also speed up
  // the calculation of `e` with a multi
  // exponentiation algorithm.
  assert(g instanceof BN);
  assert(x instanceof BN);
  assert(p instanceof BN);
  assert(q instanceof BN);

  const G = g.toRed(BN.mont(p));
  const b = BN.random(rng, 1, q);
  const k = x.sub(b).imod(q);
  const e1 = G.redPow(k);
  const e2 = G.redPow(b);
  const e = e1.redMul(e2);

  return e.fromRed();
}

/*
 * Expose
 */

exports.native = 0;
exports.paramsCreate = paramsCreate;
exports.paramsGenerate = paramsGenerate;
exports.paramsGenerateAsync = paramsGenerateAsync;
exports.paramsBits = paramsBits;
exports.paramsScalarBits = paramsScalarBits;
exports.paramsVerify = paramsVerify;
exports.paramsImport = paramsImport;
exports.paramsExport = paramsExport;
exports.privateKeyCreate = privateKeyCreate;
exports.privateKeyGenerate = privateKeyGenerate;
exports.privateKeyGenerateAsync = privateKeyGenerateAsync;
exports.privateKeyBits = privateKeyBits;
exports.privateKeyScalarBits = privateKeyScalarBits;
exports.privateKeyVerify = privateKeyVerify;
exports.privateKeyImport = privateKeyImport;
exports.privateKeyExport = privateKeyExport;
exports.publicKeyCreate = publicKeyCreate;
exports.publicKeyBits = publicKeyBits;
exports.publicKeyScalarBits = publicKeyScalarBits;
exports.publicKeyVerify = publicKeyVerify;
exports.publicKeyImport = publicKeyImport;
exports.publicKeyExport = publicKeyExport;
exports.signatureImport = signatureImport;
exports.signatureExport = signatureExport;
exports.sign = sign;
exports.signDER = signDER;
exports.verify = verify;
exports.verifyDER = verifyDER;
exports.derive = derive;
}],
[/* 42 */ 'bcrypto', '/lib/bn-browser.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * bn.js - big numbers for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */



module.exports = __browser_require__(43 /* './js/bn' */, module);
}],
[/* 43 */ 'bcrypto', '/lib/js/bn.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * bn.js - big numbers for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/bn.js:
 *   Copyright (c) 2015, Fedor Indutny (MIT License).
 *   https://github.com/indutny/bn.js
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Parts of this software are based on openssl/openssl:
 *   Copyright (c) 1998-2018, The OpenSSL Project (Apache License v2.0).
 *   Copyright (c) 1995-1998, Eric A. Young, Tim J. Hudson. All rights reserved.
 *   https://github.com/openssl/openssl
 *
 * Parts of this software are based on libgmp:
 *   Copyright (c) 1991-1997, 1999-2014, Free Software Foundation, Inc.
 *   https://gmplib.org/
 *
 * Parts of this software are based on v8/v8:
 *   Copyright (c) 2017, The V8 Project Authors (BSD-Style License).
 *   https://github.com/v8/v8
 *
 * Resources:
 *   https://github.com/indutny/bn.js/blob/master/lib/bn.js
 *   https://github.com/indutny/miller-rabin/blob/master/lib/mr.js
 *   https://github.com/golang/go/blob/master/src/math/big/int.go
 *   https://github.com/golang/go/blob/master/src/math/big/nat.go
 *   https://github.com/golang/go/blob/master/src/math/big/prime.go
 *   https://github.com/openssl/openssl/tree/master/crypto/bn
 *   https://github.com/openssl/openssl/blob/master/crypto/bn/bn_kron.c
 *   https://github.com/gnutls/nettle/blob/master/mini-gmp.c
 *   https://github.com/v8/v8/blob/master/src/objects/bigint.cc
 */

/* eslint valid-typeof: "off" */



const {custom} = __browser_require__(44 /* '../internal/custom' */, module);

/*
 * Constants
 */

const zeros = [
  '',
  '0',
  '00',
  '000',
  '0000',
  '00000',
  '000000',
  '0000000',
  '00000000',
  '000000000',
  '0000000000',
  '00000000000',
  '000000000000',
  '0000000000000',
  '00000000000000',
  '000000000000000',
  '0000000000000000',
  '00000000000000000',
  '000000000000000000',
  '0000000000000000000',
  '00000000000000000000',
  '000000000000000000000',
  '0000000000000000000000',
  '00000000000000000000000',
  '000000000000000000000000',
  '0000000000000000000000000'
];

const groupSizes = [
  0x00, 0x19, 0x10, 0x0c, 0x0b, 0x0a,
  0x09, 0x08, 0x08, 0x07, 0x07, 0x07,
  0x07, 0x06, 0x06, 0x06, 0x06, 0x06,
  0x06, 0x06, 0x05, 0x05, 0x05, 0x05,
  0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
  0x05, 0x05, 0x05, 0x05, 0x05, 0x05
];

const groupBases = [
  0x00000000, 0x02000000, 0x0290d741, 0x01000000,
  0x02e90edd, 0x039aa400, 0x0267bf47, 0x01000000,
  0x0290d741, 0x00989680, 0x012959c3, 0x0222c000,
  0x03bd7765, 0x0072e440, 0x00adcea1, 0x01000000,
  0x01704f61, 0x0206fc40, 0x02cddcf9, 0x03d09000,
  0x003e5185, 0x004ea360, 0x006235f7, 0x00798000,
  0x009502f9, 0x00b54ba0, 0x00daf26b, 0x01069c00,
  0x0138f9ad, 0x0172c9e0, 0x01b4d89f, 0x02000000,
  0x025528a1, 0x02b54a20, 0x03216b93, 0x039aa400
];

const primes = {
  p192: null,
  p224: null,
  p521: null,
  k256: null,
  p251: null,
  p25519: null,
  p448: null
};

const modes = {
  NONE: 0,
  QUO: 1,
  REM: 2,
  BOTH: 3,
  EUCLID: 4,
  ALL: 7
};

const WND_WIDTH = 4;
const WND_SIZE = 1 << (WND_WIDTH - 1);

const HAS_BIGINT = typeof BigInt === 'function';

/**
 * BN
 */

class BN {
  constructor(num, base, endian) {
    this.words = [0];
    this.length = 1;
    this.negative = 0;
    this.red = null;
    this.from(num, base, endian);
  }

  /*
   * Addition Engine
   */

  _iadd(a, b) {
    let carry = 0;
    let i = 0;

    // a.length > b.length
    if (a.length < b.length)
      [a, b] = [b, a];

    if (a !== this)
      this._alloc(a.length);

    for (; i < b.length; i++) {
      const r = (a.words[i] | 0) + (b.words[i] | 0) + carry;

      this.words[i] = r & 0x3ffffff;

      carry = r >>> 26;
    }

    for (; carry !== 0 && i < a.length; i++) {
      const r = (a.words[i] | 0) + carry;

      this.words[i] = r & 0x3ffffff;

      carry = r >>> 26;
    }

    this.length = a.length;

    if (carry !== 0) {
      this._alloc(this.length + 1);
      this.words[this.length++] = carry;
    } else if (a !== this) {
      // Copy the rest of the words.
      for (; i < a.length; i++)
        this.words[i] = a.words[i];
    }

    // Note: we shouldn't need to strip here.
    return this;
  }

  _iaddn(num) {
    this.words[0] += num;

    if (this.words[0] < 0x4000000)
      return this;

    // Carry.
    let i = 0;

    this._alloc(this.length + 1);

    this.words[this.length] = 0;

    for (; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      this.words[i + 1] += 1;
    }

    this.length = Math.max(this.length, i + 1);

    // Note: we shouldn't need to strip here.
    return this;
  }

  /*
   * Addition
   */

  iadd(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    if (this.negative === num.negative) {
      // x + y == x + y
      // (-x) + (-y) == -(x + y)
      this._iadd(this, num);
    } else {
      // x + (-y) == x - y == -(y - x)
      // (-x) + y == y - x == -(x - y)
      const cmp = this.ucmp(num);

      // x + (-x) == (-x) + x == 0
      if (cmp === 0) {
        this.words[0] = 0;
        this.length = 1;
        this.negative = 0;
        return this;
      }

      if (cmp < 0) {
        this._isub(num, this);
        this.negative ^= 1;
      } else {
        this._isub(this, num);
      }
    }

    return this;
  }

  iaddn(num) {
    enforce(isSMI(num), 'num', 'smi');

    const negative = (num < 0) | 0;

    if (negative)
      num = -num;

    if (this.negative === negative) {
      // x + y == x + y
      // (-x) + (-y) == -(x + y)
      this._iaddn(num);
    } else {
      // x + (-y) == x - y == -(y - x)
      // (-x) + y == y - x == -(x - y)
      if (this.length === 1 && this.words[0] < num) {
        this.words[0] = num - this.words[0];
        this.negative ^= 1;
      } else {
        this._isubn(num);
      }
    }

    return this;
  }

  add(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    if (num.length > this.length)
      return num.clone().iadd(this);

    return this.clone().iadd(num);
  }

  addn(num) {
    return this.clone().iaddn(num);
  }

  /*
   * Subtraction Engine
   */

  _isub(a, b) {
    let carry = 0;
    let i = 0;

    // a > b
    assert(a.length >= b.length);

    if (a !== this)
      this._alloc(a.length);

    for (; i < b.length; i++) {
      const r = (a.words[i] | 0) - (b.words[i] | 0) + carry;

      carry = r >> 26;

      this.words[i] = r & 0x3ffffff;
    }

    for (; carry !== 0 && i < a.length; i++) {
      const r = (a.words[i] | 0) + carry;

      carry = r >> 26;

      this.words[i] = r & 0x3ffffff;
    }

    assert(carry === 0);

    // Copy rest of the words.
    if (a !== this) {
      for (; i < a.length; i++)
        this.words[i] = a.words[i];
    }

    this.length = Math.max(this.length, i);

    return this._strip();
  }

  _isubn(num) {
    this.words[0] -= num;

    if (this.words[0] >= 0)
      return this._normalize();

    assert(this.length !== 1);

    // Carry.
    this._alloc(this.length + 1);

    for (let i = 0; i < this.length && this.words[i] < 0; i++) {
      this.words[i] += 0x4000000;
      this.words[i + 1] -= 1;
    }

    this.words[this.length] = 0;

    return this._strip();
  }

  /*
   * Subtraction
   */

  isub(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    if (this.negative !== num.negative) {
      // x - (-y) == x + y
      // (-x) - y == -(x + y)
      this._iadd(this, num);
    } else {
      // x - y == x - y == -(y - x)
      // (-x) - (-y) == y - x == -(x - y)
      const cmp = this.ucmp(num);

      // x - x == 0
      if (cmp === 0) {
        this.words[0] = 0;
        this.length = 1;
        this.negative = 0;
        return this;
      }

      if (cmp < 0) {
        this._isub(num, this);
        this.negative ^= 1;
      } else {
        this._isub(this, num);
      }
    }

    return this;
  }

  isubn(num) {
    enforce(isSMI(num), 'num', 'smi');

    const negative = (num < 0) | 0;

    if (negative)
      num = -num;

    if (this.negative !== negative) {
      // x - (-y) == x + y
      // (-x) - y == -(x + y)
      this._iaddn(num);
    } else {
      // x - y == x - y == -(y - x)
      // (-x) - (-y) == y - x == -(x - y)
      if (this.length === 1 && this.words[0] < num) {
        this.words[0] = num - this.words[0];
        this.negative ^= 1;
      } else {
        this._isubn(num);
      }
    }

    return this;
  }

  sub(num) {
    return this.clone().isub(num);
  }

  subn(num) {
    return this.clone().isubn(num);
  }

  /*
   * Multiplication Engine
   */

  _mul(num, out) {
    enforce(BN.isBN(num), 'num', 'bignum');
    enforce(BN.isBN(out), 'out', 'bignum');

    if (this.length === 10 && num.length === 10)
      return comb10MulTo(this, num, out);

    const len = this.length + num.length;

    if (len < 63)
      return smallMulTo(this, num, out);

    if (len < 1024)
      return bigMulTo(this, num, out);

    return jumboMulTo(this, num, out);
  }

  /*
   * Multiplication
   */

  imul(num) {
    return this.mul(num)._move(this);
  }

  imuln(num) {
    enforce(isSMI(num), 'num', 'smi');

    const neg = (num < 0) | 0;

    if (neg)
      num = -num;

    // Carry.
    let carry = 0;

    for (let i = 0; i < this.length; i++) {
      const w = this.words[i] * num;
      const lo = (w & 0x3ffffff) + (carry & 0x3ffffff);

      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      carry += lo >>> 26;

      this.words[i] = lo & 0x3ffffff;
    }

    this.negative ^= neg;

    if (carry !== 0) {
      this._alloc(this.length + 1);
      this.words[this.length++] = carry;
    } else {
      this._strip();
    }

    return this;
  }

  mul(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    const len = this.length + num.length;
    const out = new BN();

    out.words = new Array(len);

    for (let i = 0; i < len; i ++)
      out.words[i] = 0;

    return this._mul(num, out);
  }

  muln(num) {
    return this.clone().imuln(num);
  }

  /*
   * Multiplication + Shift
   */

  mulShift(num, bits) {
    enforce(BN.isBN(num), 'num', 'bignum');
    enforce((bits >>> 0) === bits, 'bits', 'uint32');

    const r = this.mul(num);
    const b = r.utestn(bits - 1);

    r.iushrn(bits);

    if (this.negative ^ num.negative)
      return r.isubn(b);

    return r.iaddn(b);
  }

  /*
   * Division Engine
   */

  _div(num, flags) {
    enforce(BN.isBN(num), 'num', 'bignum');
    assert((flags & modes.ALL) === flags);
    assert(flags !== modes.NONE);

    const a = this;
    const b = num;

    nonzero(!b.isZero());

    if (a.isZero())
      return [new BN(0), new BN(0)];

    const as = a.negative;
    const bs = b.negative;

    a.negative = 0;
    b.negative = 0;

    let q = null;
    let r = null;

    if (a.ucmp(b) < 0) {
      if (flags & modes.QUO)
        q = new BN(0);

      if (flags & modes.REM)
        r = a.clone();
    } else if (b.length === 1) {
      if (flags & modes.QUO)
        q = a.quon(b.words[0]);

      if (flags & modes.REM)
        r = a.remn(b.words[0]);
    } else {
      [q, r] = a._wordDiv(b, flags);
    }

    a.negative = as;
    b.negative = bs;

    if (flags & modes.QUO) {
      q.negative = a.negative ^ b.negative;
      q._normalize();
    }

    if (flags & modes.REM) {
      r.negative = a.negative;
      r._normalize();
    }

    if (flags & modes.EUCLID) {
      if (flags & modes.QUO) {
        assert((flags & modes.REM) !== 0);

        if (r.negative !== 0) {
          if (b.negative !== 0)
            q.iaddn(1);
          else
            q.isubn(1);
        }
      }

      if (flags & modes.REM) {
        if (r.negative !== 0) {
          if (b.negative !== 0)
            r.isub(b);
          else
            r.iadd(b);
        }
      }
    }

    return [q, r];
  }

  _wordDiv(num, flags) {
    let a = this.clone();
    let b = num;
    let q = null;
    let hi;

    // Normalize.
    const word = b.words[b.length - 1] | 0;
    const shift = 26 - countBits(word);

    if (shift !== 0) {
      b = b.clone();

      a.iushln(shift);
      b.iushln(shift);

      hi = b.words[b.length - 1] | 0;
    } else {
      hi = word;
    }

    // Initialize quotient.
    const m = a.length - b.length;

    assert(m >= 0);

    if (flags & modes.QUO) {
      q = new BN(0);
      q.length = m + 1;
      q.words = new Array(q.length);

      for (let i = 0; i < q.length; i++)
        q.words[i] = 0;
    }

    // Diff.
    const d = a.clone();

    d._ishlnsubmul(b, 1, m);

    if (d.negative === 0) {
      if (q)
        q.words[m] = 1;

      a = d;
    }

    // Divide.
    for (let j = m - 1; j >= 0; j--) {
      const ahi = a.words[b.length + j];
      const alo = a.words[b.length + j - 1];
      const quo = ((ahi * 0x4000000 + alo) / hi) | 0;

      let qj = Math.min(quo, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);

      while (a.negative !== 0) {
        qj -= 1;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        a.ineg();
      }

      if (q)
        q.words[j] = qj;
    }

    // Strip.
    if (q)
      q._strip();

    // Denormalize.
    // Note: we shouldn't need to strip `a` here.
    if ((flags & modes.REM) && shift !== 0)
      a.iushrn(shift);

    return [q, a];
  }

  _ishlnsubmul(num, mul, shift) {
    let carry = 0;
    let i = 0;

    this._expand(num.length + shift);

    for (; i < num.length; i++) {
      const k = (this.words[i + shift] | 0) + carry;
      const r = num.words[i] * mul;
      const w = k - (r & 0x3ffffff);

      carry = (w >> 26) - ((r / 0x4000000) | 0);

      this.words[i + shift] = w & 0x3ffffff;
    }

    for (; i < this.length - shift; i++) {
      const w = (this.words[i + shift] | 0) + carry;

      carry = w >> 26;

      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0)
      return this._strip();

    // Subtraction overflow.
    assert(carry === -1);

    carry = 0;

    for (let i = 0; i < this.length; i++) {
      const w = -(this.words[i] | 0) + carry;

      carry = w >> 26;

      this.words[i] = w & 0x3ffffff;
    }

    this.negative = 1;

    return this._strip();
  }

  /*
   * Truncation Division + Modulo
   */

  quorem(num) {
    return this._div(num, modes.BOTH);
  }

  /*
   * Truncation Division
   */

  iquo(num) {
    return this.quo(num)._move(this);
  }

  iquon(num) {
    enforce(isSMI(num), 'num', 'smi');
    nonzero(num !== 0);

    const neg = (num < 0) | 0;

    if (neg)
      num = -num;

    let carry = 0;

    for (let i = this.length - 1; i >= 0; i--) {
      const w = (this.words[i] | 0) + carry * 0x4000000;

      this.words[i] = (w / num) | 0;

      carry = w % num;
    }

    this.negative ^= neg;

    return this._strip();
  }

  quo(num) {
    return this._div(num, modes.QUO)[0];
  }

  quon(num) {
    return this.clone().iquon(num);
  }

  /*
   * Truncation Modulo
   */

  irem(num) {
    return this.rem(num)._move(this);
  }

  iremn(num) {
    let m = this.remrn(num);

    if (m < 0)
      m = -m;

    this.words[0] = m;
    this.length = 1;

    return this._normalize();
  }

  rem(num) {
    return this._div(num, modes.REM)[1];
  }

  remn(num) {
    return this.clone().iremn(num);
  }

  remrn(num) {
    enforce(isSMI(num), 'num', 'smi');
    nonzero(num !== 0);

    if (num < 0)
      num = -num;

    const p = (1 << 26) % num;

    let acc = 0;

    for (let i = this.length - 1; i >= 0; i--)
      acc = (p * acc + (this.words[i] | 0)) % num;

    return this.negative !== 0 ? (-acc | 0) : acc;
  }

  /*
   * Euclidean Division + Modulo
   */

  divmod(num) {
    return this._div(num, modes.BOTH | modes.EUCLID);
  }

  /*
   * Euclidean Division
   */

  idiv(num) {
    return this.div(num)._move(this);
  }

  idivn(num) {
    if (this.negative === 0)
      return this.iquon(num);

    const r = this.remrn(num);

    this.iquon(num);

    if (r < 0) {
      if (num < 0)
        this.iaddn(1);
      else
        this.isubn(1);
    }

    return this;
  }

  div(num) {
    return this._div(num, modes.BOTH | modes.EUCLID)[0];
  }

  divn(num) {
    return this.clone().idivn(num);
  }

  /*
   * Euclidean Modulo
   */

  imod(num) {
    if (this.ucmp(num) < 0) {
      if (this.negative !== 0) {
        this._isub(num, this);
        this.negative = 0;
      }
      return this;
    }

    return this.mod(num)._move(this);
  }

  imodn(num) {
    this.words[0] = this.modrn(num);
    this.length = 1;
    this.negative = 0;
    return this;
  }

  mod(num) {
    return this._div(num, modes.REM | modes.EUCLID)[1];
  }

  modn(num) {
    return this.clone().imodn(num);
  }

  modrn(num) {
    enforce(isSMI(num), 'num', 'smi');

    let r = this.remrn(num);

    if (r < 0) {
      if (num < 0)
        r -= num;
      else
        r += num;
    }

    return r;
  }

  /*
   * Round Division
   */

  divRound(num) {
    const [q, r] = this.quorem(num);

    // Fast case - exact division.
    if (r.isZero())
      return q;

    const bit = num.words[0] & 1;

    num.iushrn(1);

    const cmp = r.ucmp(num);

    num.iushln(1);

    num.words[0] |= bit;

    // Round down.
    if (cmp < 0 || (num.isOdd() && cmp === 0))
      return q;

    // Round up.
    if (this.negative ^ num.negative)
      return q.isubn(1);

    return q.iaddn(1);
  }

  /*
   * Exponentiation
   */

  ipow(num) {
    return this.pow(num)._move(this);
  }

  ipown(num) {
    return this.pown(num)._move(this);
  }

  pow(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    let b = countBits(num.words[num.length - 1]);
    let r = new BN(1);

    for (let i = num.length - 1; i >= 0; i--) {
      const word = num.words[i];

      for (let j = b - 1; j >= 0; j--) {
        r = r.sqr();

        if ((word >> j) & 1)
          r = r.mul(this);
      }

      b = 26;
    }

    return r;
  }

  pown(num) {
    enforce(isSMI(num), 'num', 'smi');

    if (num < 0)
      num = -num;

    if (num === 0)
      return new BN(1);

    if (num === 1)
      return this.clone();

    const bits = countBits(num);

    let r = this;

    for (let i = bits - 2; i >= 0; i--) {
      r = r.sqr();

      if ((num >> i) & 1)
        r = r.mul(this);
    }

    return r;
  }

  isqr() {
    return this.imul(this);
  }

  sqr() {
    return this.mul(this);
  }

  /*
   * Roots Engine
   */

  _rootrem(pow, rem) {
    enforce((pow >>> 0) === pow, 'num', 'uint32');

    if (pow === 0)
      throw new RangeError('Zeroth root.');

    if (~pow & this.negative)
      throw new RangeError('Negative with even root.');

    if (this.ucmpn(1) <= 0)
      return [this.clone(), new BN(0)];

    let u = new BN(0);
    let t = BN.shift(1, this.bitLength() / pow + 1 | 0);
    let v, r;

    if (this.negative !== 0)
      t.ineg();

    if (pow === 2) {
      do {
        u = t;
        t = this.quo(u);
        t.iadd(u);
        t.iushrn(1);
      } while (t.ucmp(u) < 0);
    } else {
      do {
        u = t;
        t = u.pown(pow - 1);
        t = this.quo(t);
        v = u.muln(pow - 1);
        t.iadd(v);
        t = t.quon(pow);
      } while (t.ucmp(u) < 0);
    }

    if (rem) {
      t = u.pown(pow);
      r = this.sub(t);
    }

    return [u, r];
  }

  /*
   * Roots
   */

  rootrem(pow) {
    return this._rootrem(pow, 1);
  }

  iroot(pow) {
    return this.root(pow)._move(this);
  }

  root(pow) {
    return this._rootrem(pow, 0)[0];
  }

  isPower(pow) {
    enforce((pow >>> 0) === pow, 'num', 'uint32');

    if (pow === 0 || (~pow & this.negative))
      return false;

    const [, r] = this.rootrem(pow);

    return r.sign() === 0;
  }

  sqrtrem() {
    return this.rootrem(2);
  }

  isqrt() {
    return this.sqrt()._move(this);
  }

  sqrt() {
    return this.root(2);
  }

  isSquare() {
    return this.isPower(2);
  }

  /*
   * AND
   */

  iand(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    let x = this;
    let y = num;

    if (x === y)
      return x;

    if ((x.negative | y.negative) === 0)
      return x.iuand(y);

    if ((x.negative & y.negative) === 1) {
      // (-x) & (-y) == ~(x-1) & ~(y-1)
      //             == ~((x-1) | (y-1))
      //             == -(((x-1) | (y-1)) + 1)
      x.iaddn(1);
      y.iaddn(1);
      x.iuor(y);
      x.isubn(1);
      y.isubn(1);
      return x;
    }

    // Assume x is the positive number.
    if (x.negative !== 0)
      [x, y] = [y.clone(), x];

    // x & (-y) == x & ~(y-1)
    //          == x & ~(y-1)
    const width = x.bitLength();

    y.iaddn(1);
    y.inotn(width);
    x.iuand(y);
    y.inotn(width);
    y.isubn(1);

    return x._move(this);
  }

  iandn(num) {
    enforce(isSMI(num), 'num', 'smi');

    if ((this.negative | (num < 0)) !== 0)
      return this.iand(new BN(num));

    this.words[0] &= num;
    this.length = 1;

    return this;
  }

  and(num) {
    return this.clone().iand(num);
  }

  andn(num) {
    return this.clone().iandn(num);
  }

  andrn(num) {
    enforce(isSMI(num), 'num', 'smi');

    if ((this.negative | (num < 0)) !== 0) {
      const n = this.iand(new BN(num));

      if (n.length > 1)
        throw new RangeError('Number exceeds 26 bits.');

      return n.negative !== 0 ? -n.words[0] : n.words[0];
    }

    return this.words[0] & num;
  }

  /*
   * Unsigned AND
   */

  iuand(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    this.length = Math.min(this.length, num.length);

    for (let i = 0; i < this.length; i++)
      this.words[i] &= num.words[i];

    return this._strip();
  }

  iuandn(num) {
    enforce(isSMI(num), 'num', 'smi');

    this.words[0] &= Math.abs(num);
    this.length = 1;

    return this._normalize();
  }

  uand(num) {
    return this.clone().iuand(num);
  }

  uandn(num) {
    return this.clone().iuandn(num);
  }

  uandrn(num) {
    enforce(isSMI(num), 'num', 'smi');

    const n = this.words[0] & Math.abs(num);

    return this.negative !== 0 ? (-n | 0) : n;
  }

  /*
   * OR
   */

  ior(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    let x = this;
    let y = num;

    if (x === y)
      return x;

    if ((x.negative | y.negative) === 0)
      return x.iuor(y);

    if ((x.negative & y.negative) === 1) {
      // (-x) | (-y) == ~(x-1) | ~(y-1)
      //             == ~((x-1) & (y-1))
      //             == -(((x-1) & (y-1)) + 1)
      x.iaddn(1);
      y.iaddn(1);
      x.iuand(y);
      x.isubn(1);
      y.isubn(1);
      return x;
    }

    // Assume x is the positive number.
    y = y.clone();

    if (x.negative !== 0)
      [x, y] = [y, x];

    // x | (-y) == x | ~(y-1)
    //          == ~((y-1) & ~x)
    //          == -(((y-1) & ~x) + 1)
    y.iaddn(1);
    x.inotn(y.bitLength());
    y.iuand(x);
    y.isubn(1);

    return y._move(this);
  }

  iorn(num) {
    enforce(isSMI(num), 'num', 'smi');

    if ((this.negative | (num < 0)) !== 0)
      return this.ior(new BN(num));

    this.words[0] |= num;

    return this;
  }

  or(num) {
    return this.clone().ior(num);
  }

  orn(num) {
    return this.clone().iorn(num);
  }

  /*
   * Unsigned OR
   */

  iuor(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    this._expand(num.length);

    for (let i = 0; i < num.length; i++)
      this.words[i] |= num.words[i];

    // Note: we shouldn't need to strip here.
    return this;
  }

  iuorn(num) {
    enforce(isSMI(num), 'num', 'smi');

    this.words[0] |= Math.abs(num);

    return this;
  }

  uor(num) {
    return this.clone().iuor(num);
  }

  uorn(num) {
    return this.clone().iuorn(num);
  }

  /*
   * XOR
   */

  ixor(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    let x = this;
    let y = num;

    if (x === y) {
      x.words[0] = 0;
      x.length = 1;
      x.negative = 0;
      return x;
    }

    if ((x.negative | y.negative) === 0)
      return x.iuxor(y);

    if ((x.negative & y.negative) === 1) {
      // (-x) ^ (-y) == ~(x-1) ^ ~(y-1)
      //             == (x-1) ^ (y-1)
      x.iaddn(1);
      y.iaddn(1);
      x.iuxor(y);
      x.ineg();
      y.isubn(1);
      return x;
    }

    // Assume x is the positive number.
    if (x.negative !== 0)
      [x, y] = [y.clone(), x];

    // x ^ (-y) == x ^ ~(y-1)
    //          == ~(x ^ (y-1))
    //          == -((x ^ (y-1)) + 1)
    y.iaddn(1);
    x.iuxor(y);
    x.iaddn(1);
    x.ineg();
    y.isubn(1);

    return x._move(this);
  }

  ixorn(num) {
    enforce(isSMI(num), 'num', 'smi');

    if ((this.negative | (num < 0)) !== 0)
      return this.ixor(new BN(num));

    this.words[0] ^= num;

    return this;
  }

  xor(num) {
    return this.clone().ixor(num);
  }

  xorn(num) {
    return this.clone().ixorn(num);
  }

  /*
   * Unsigned XOR
   */

  iuxor(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    let a = this;
    let b = num;

    if (a.length < b.length)
      [a, b] = [b, a];

    let i = 0;

    for (; i < b.length; i++)
      this.words[i] = a.words[i] ^ b.words[i];

    if (a !== this) {
      this._alloc(a.length);

      for (; i < a.length; i++)
        this.words[i] = a.words[i];
    }

    this.length = a.length;

    return this._strip();
  }

  iuxorn(num) {
    enforce(isSMI(num), 'num', 'smi');

    this.words[0] ^= Math.abs(num);

    return this._normalize();
  }

  uxor(num) {
    return this.clone().iuxor(num);
  }

  uxorn(num) {
    return this.clone().iuxorn(num);
  }

  /*
   * NOT
   */

  inot() {
    if (this.negative !== 0) {
      // ~(-x) == ~(~(x-1)) == x-1
      this.ineg().isubn(1);
    } else {
      // ~x == -x-1 == -(x+1)
      this.iaddn(1).ineg();
    }
    return this;
  }

  not() {
    return this.clone().inot();
  }

  inotn(width) {
    enforce((width >>> 0) === width, 'width', 'uint32');

    const r = width % 26;

    let s = Math.ceil(width / 26);
    let i = 0;

    // Extend the buffer with leading zeroes.
    this._expand(s);

    if (r > 0)
      s -= 1;

    // Handle complete words.
    for (; i < s; i++)
      this.words[i] ^= 0x3ffffff;

    // Handle the residue.
    if (r > 0)
      this.words[i] ^= (1 << r) - 1;

    // And remove leading zeroes.
    return this._strip();
  }

  notn(width) {
    return this.clone().inotn(width);
  }

  /*
   * Left Shift
   */

  ishl(num) {
    enforce(BN.isBN(num), 'bits', 'bignum');
    enforce(num.bitLength() <= 32, 'bits', 'uint32');
    return this.ishln(num.toNumber());
  }

  ishln(bits) {
    return this.iushln(bits);
  }

  shl(num) {
    return this.clone().ishl(num);
  }

  shln(bits) {
    return this.clone().ishln(bits);
  }

  /*
   * Unsigned Left Shift
   */

  iushl(num) {
    enforce(BN.isBN(num), 'bits', 'bignum');
    enforce(num.bitLength() <= 32, 'bits', 'uint32');
    return this.iushln(num.toNumber());
  }

  iushln(bits) {
    enforce((bits >>> 0) === bits, 'bits', 'uint32');

    const r = bits % 26;
    const s = (bits - r) / 26;
    const mask = ((1 << r) - 1) << (26 - r);

    if (r !== 0) {
      let carry = 0;

      for (let i = 0; i < this.length; i++) {
        const ncarry = this.words[i] & mask;
        const c = ((this.words[i] | 0) - ncarry) << r;

        this.words[i] = c | carry;

        carry = ncarry >>> (26 - r);
      }

      if (carry !== 0) {
        this._alloc(this.length + 1);
        this.words[this.length++] = carry;
      }
    }

    if (s !== 0) {
      this._alloc(this.length + s);

      for (let i = this.length - 1; i >= 0; i--)
        this.words[i + s] = this.words[i];

      for (let i = 0; i < s; i++)
        this.words[i] = 0;

      this.length += s;
    }

    return this._strip();
  }

  ushl(num) {
    return this.clone().iushl(num);
  }

  ushln(bits) {
    return this.clone().iushln(bits);
  }

  /*
   * Right Shift Engine
   */

  _split(bits, output) {
    const r = bits % 26;
    const s = Math.min((bits - r) / 26, this.length);
    const mask = (1 << r) - 1;

    // Extended mode, copy masked part.
    if (output) {
      output._alloc(s);

      for (let i = 0; i < s; i++)
        output.words[i] = this.words[i];

      output.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all.
    } else if (this.length > s) {
      this.length -= s;
      for (let i = 0; i < this.length; i++)
        this.words[i] = this.words[i + s];
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    let carry = 0;

    if (r !== 0) {
      for (let i = this.length - 1; i >= 0; i--) {
        const word = this.words[i] | 0;

        this.words[i] = (carry << (26 - r)) | (word >>> r);

        carry = word & mask;
      }
    }

    // Push carried bits as a mask.
    if (output) {
      if (carry !== 0) {
        output._alloc(output.length + 1);
        output.words[output.length++] = carry;
      } else {
        if (output.length === 0)
          output.words[output.length++] = 0;

        output._strip();
      }
    }

    return this._strip();
  }

  /*
   * Right Shift
   */

  ishr(num) {
    enforce(BN.isBN(num), 'bits', 'bignum');
    enforce(num.bitLength() <= 32, 'bits', 'uint32');
    return this.ishrn(num.toNumber());
  }

  ishrn(bits) {
    enforce((bits >>> 0) === bits, 'bits', 'uint32');

    if (this.negative !== 0) {
      // (-x) >> y == ~(x-1) >> y
      //           == ~((x-1) >> y)
      //           == -(((x-1) >> y) + 1)
      this.iaddn(1);
      this.iushrn(bits);
      this.isubn(1);
      return this;
    }

    return this.iushrn(bits);
  }

  shr(num) {
    return this.clone().ishr(num);
  }

  shrn(bits) {
    return this.clone().ishrn(bits);
  }

  /*
   * Unsigned Right Shift
   */

  iushr(num) {
    enforce(BN.isBN(num), 'bits', 'bignum');
    enforce(num.bitLength() <= 32, 'bits', 'uint32');
    return this.iushrn(num.toNumber());
  }

  iushrn(bits) {
    enforce((bits >>> 0) === bits, 'bits', 'uint32');
    return this._split(bits, null);
  }

  ushr(num) {
    return this.clone().iushr(num);
  }

  ushrn(bits) {
    return this.clone().iushrn(bits);
  }

  /*
   * Bit Manipulation
   */

  setn(bit, val) {
    enforce((bit >>> 0) === bit, 'bit', 'uint32');

    if (this.negative !== 0) {
      this.iaddn(1);
      this.usetn(bit, !val);
      this.isubn(1);
      return this;
    }

    return this.usetn(bit, val);
  }

  usetn(bit, val) {
    enforce((bit >>> 0) === bit, 'bit', 'uint32');

    const r = bit % 26;
    const s = (bit - r) / 26;

    this._expand(s + 1);

    if (val)
      this.words[s] |= (1 << r);
    else
      this.words[s] &= ~(1 << r);

    return this._strip();
  }

  testn(bit) {
    enforce((bit >>> 0) === bit, 'bit', 'uint32');

    const r = bit % 26;
    const s = (bit - r) / 26;

    // Fast case: bit is much higher than all existing words.
    if (this.length <= s)
      return this.negative;

    // Check bit and return.
    const w = this.words[s];
    const val = (w >> r) & 1;

    if (this.negative !== 0) {
      if (r > 0 && (w & ((1 << r) - 1)))
        return val ^ 1;

      let j = s;

      while (j--) {
        if (this.words[j] > 0)
          return val ^ 1;
      }
    }

    return val;
  }

  utestn(bit) {
    enforce((bit >>> 0) === bit, 'bit', 'uint32');

    const r = bit % 26;
    const s = (bit - r) / 26;

    // Fast case: bit is much higher than all existing words.
    if (this.length <= s)
      return 0;

    // Check bit and return.
    return (this.words[s] >> r) & 1;
  }

  imaskn(bits) {
    enforce((bits >>> 0) === bits, 'bits', 'uint32');

    if (this.negative !== 0) {
      this.iaddn(1);
      this.inotn(bits + 1);
      this.ineg();
    }

    return this.iumaskn(bits);
  }

  maskn(bits) {
    return this.clone().imaskn(bits);
  }

  iumaskn(bits) {
    enforce((bits >>> 0) === bits, 'bits', 'uint32');

    const r = bits % 26;

    let s = (bits - r) / 26;

    if (this.length <= s)
      return this;

    if (r !== 0)
      s += 1;

    this.length = Math.min(s, this.length);

    if (r !== 0)
      this.words[this.length - 1] &= (1 << r) - 1;

    if (this.length === 0)
      this.words[this.length++] = 0;

    return this._strip();
  }

  umaskn(bits) {
    return this.clone().iumaskn(bits);
  }

  andln(num) {
    return this.words[0] & num;
  }

  bit(pos) {
    return this.utestn(pos);
  }

  bits(pos, width) {
    enforce((pos >>> 0) === pos, 'pos', 'uint32');
    enforce((width >>> 0) === width, 'width', 'uint32');
    enforce(width <= 26, 'width', 'width');

    const shift = pos % 26;
    const index = (pos - shift) / 26;

    if (index >= this.length)
      return 0;

    let bits = (this.words[index] >> shift) & ((1 << width) - 1);

    if (shift + width > 26 && index + 1 < this.length) {
      const more = shift + width - 26;
      const next = this.words[index + 1] & ((1 << more) - 1);

      bits |= next << (26 - shift);
    }

    return bits;
  }

  /*
   * Negation
   */

  ineg() {
    if (!this.isZero())
      this.negative ^= 1;

    return this;
  }

  neg() {
    return this.clone().ineg();
  }

  iabs() {
    this.negative = 0;
    return this;
  }

  abs() {
    return this.clone().iabs();
  }

  /*
   * Comparison
   */

  cmp(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    if (this.negative !== num.negative)
      return num.negative - this.negative;

    const res = this.ucmp(num);

    if (this.negative !== 0)
      return -res | 0;

    return res;
  }

  cmpn(num) {
    enforce(isSMI(num), 'num', 'smi');

    const negative = (num < 0) | 0;

    if (this.negative !== negative)
      return negative - this.negative;

    const res = this.ucmpn(num);

    if (this.negative !== 0)
      return -res | 0;

    return res;
  }

  eq(num) {
    return this.cmp(num) === 0;
  }

  eqn(num) {
    return this.cmpn(num) === 0;
  }

  gt(num) {
    return this.cmp(num) > 0;
  }

  gtn(num) {
    return this.cmpn(num) > 0;
  }

  gte(num) {
    return this.cmp(num) >= 0;
  }

  gten(num) {
    return this.cmpn(num) >= 0;
  }

  lt(num) {
    return this.cmp(num) < 0;
  }

  ltn(num) {
    return this.cmpn(num) < 0;
  }

  lte(num) {
    return this.cmp(num) <= 0;
  }

  lten(num) {
    return this.cmpn(num) <= 0;
  }

  sign() {
    if (this.negative !== 0)
      return -1;

    if (this.length === 1 && this.words[0] === 0)
      return 0;

    return 1;
  }

  isZero() {
    return this.length === 1 && this.words[0] === 0;
  }

  isNeg() {
    return this.negative !== 0;
  }

  isPos() {
    return this.negative === 0;
  }

  isOdd() {
    return (this.words[0] & 1) === 1;
  }

  isEven() {
    return (this.words[0] & 1) === 0;
  }

  /*
   * Unsigned Comparison
   */

  ucmp(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    if (this.length < num.length)
      return -1;

    if (this.length > num.length)
      return 1;

    for (let i = this.length - 1; i >= 0; i--) {
      const a = this.words[i] | 0;
      const b = num.words[i] | 0;

      if (a === b)
        continue;

      return (a > b) - (a < b);
    }

    return 0;
  }

  ucmpn(num) {
    enforce(isSMI(num), 'num', 'smi');

    if (this.length > 1)
      return 1;

    const w = this.words[0] | 0;

    if (num < 0)
      num = -num;

    return (w > num) - (w < num);
  }

  /*
   * Number Theoretic Functions
   */

  legendre(num) {
    const red = HAS_BIGINT ? BN.red(num) : BN.mont(num);
    return this.toRed(red).redLegendre();
  }

  jacobi(num) {
    // See: A Binary Algorithm for the Jacobi Symbol
    //   J. Shallit, J. Sorenson
    //   Page 3, Section 3
    enforce(BN.isBN(num), 'num', 'bignum');

    if (num.isZero() || num.isEven())
      throw new Error('jacobi: `num` must be odd.');

    let a = this._cloneNormal();
    let b = num.clone();
    let j = 1;

    if (b.isNeg()) {
      if (a.isNeg())
        j = -1;
      b.ineg();
    }

    if (a.isNeg() || a.ucmp(b) >= 0)
      a.imod(b);

    while (!a.isZero()) {
      const bits = a._makeOdd();

      if (bits & 1) {
        const bmod8 = b.andln(7);

        if (bmod8 === 3 || bmod8 === 5)
          j = -j;
      }

      if (a.ucmp(b) < 0) {
        [a, b] = [b, a];

        if (a.andln(3) === 3 && b.andln(3) === 3)
          j = -j;
      }

      a._isub(a, b).iushrn(1);

      const bmod8 = b.andln(7);

      if (bmod8 === 3 || bmod8 === 5)
        j = -j;
    }

    if (b.cmpn(1) !== 0)
      return 0;

    return j;
  }

  kronecker(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    const table = [
      0,  1, 0, -1,
      0, -1, 0,  1
    ];

    let a = this._cloneNormal();
    let b = num.clone();
    let k = 1;

    if (b.isZero())
      return a.ucmpn(1) === 0 ? k : 0;

    if (!a.isOdd() && !b.isOdd())
      return 0;

    const bits = b._makeOdd();

    if (bits & 1)
      k = table[a.andln(7)];

    if (b.isNeg()) {
      if (a.isNeg())
        k = -k;
      b.ineg();
    }

    while (!a.isZero()) {
      const bits = a._makeOdd();

      if (bits & 1)
        k *= table[b.andln(7)];

      const w = a.words[0] ^ (a.negative * 0x3ffffff);

      if (w & b.words[0] & 2)
        k = -k;

      b.imod(a);

      [a, b] = [b, a];

      b.negative = 0;
    }

    if (b.cmpn(1) !== 0)
      return 0;

    return k;
  }

  igcd(num) {
    return this.gcd(num)._move(this);
  }

  gcd(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    if (this.isZero())
      return num.abs();

    if (num.isZero())
      return this.abs();

    let a = this.clone();
    let b = num.clone();

    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two.
    const shift = a._factor2(b);

    if (shift !== 0) {
      a.iushrn(shift);
      b.iushrn(shift);
    }

    for (;;) {
      a._makeOdd();
      b._makeOdd();

      const cmp = a.ucmp(b);

      if (cmp < 0) {
        // a > b
        [a, b] = [b, a];
      } else if (cmp === 0 || b.ucmpn(1) === 0) {
        // Break if a == b.
        // Break if b == 1 to avoid repeated subtraction.
        break;
      }

      a._isub(a, b);
    }

    return b.iushln(shift);
  }

  ilcm(num) {
    return this.lcm(num)._move(this);
  }

  lcm(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    if (this.isZero() || num.isZero())
      return new BN(0);

    return this.quo(this.gcd(num)).mul(num).iabs();
  }

  egcd(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    if (this.isZero()) {
      return [
        new BN(0),
        new BN(num.sign()),
        num.abs()
      ];
    }

    if (num.isZero()) {
      return [
        new BN(this.sign()),
        new BN(0),
        this.abs()
      ];
    }

    const x = this.clone();
    const y = num.clone();

    x.negative = 0;
    y.negative = 0;

    // A * x + B * y = x
    const A = new BN(1);
    const B = new BN(0);

    // C * x + D * y = y
    const C = new BN(0);
    const D = new BN(1);

    // Remove common factor of two.
    const g = x._factor2(y);

    if (g > 0) {
      x.iushrn(g);
      y.iushrn(g);
    }

    const xp = x.clone();
    const yp = y.clone();

    while (!x.isZero()) {
      let i = x._makeOdd();
      let j = y._makeOdd();

      while (i--) {
        if (A.isOdd() || B.isOdd()) {
          A.iadd(yp);
          B.isub(xp);
        }

        A.iushrn(1);
        B.iushrn(1);
      }

      while (j--) {
        if (C.isOdd() || D.isOdd()) {
          C.iadd(yp);
          D.isub(xp);
        }

        C.iushrn(1);
        D.iushrn(1);
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    if (this.negative !== 0)
      C.ineg();

    if (num.negative !== 0)
      D.ineg();

    return [C, D, y.iushln(g)];
  }

  iinvert(num) {
    return this.invert(num)._move(this);
  }

  invert(num) {
    enforce(BN.isBN(num), 'num', 'bignum');
    range(num.sign() > 0, 'invert');

    if (num.isOdd())
      return this._invertp(num);

    if (num.cmpn(1) === 0)
      throw new RangeError('Not invertible.');

    const [s,, g] = this.egcd(num);

    if (g.cmpn(1) !== 0)
      throw new RangeError('Not invertible.');

    return s.imod(num);
  }

  ifermat(num) {
    return this.fermat(num)._move(this);
  }

  fermat(num) {
    const red = HAS_BIGINT ? BN.red(num) : BN.mont(num);
    return this.toRed(red).redFermat().fromRed();
  }

  ipowm(y, m, mont) {
    return this.powm(y, m, mont)._move(this);
  }

  powm(y, m, mont) {
    const red = !HAS_BIGINT && mont ? BN.mont(m) : BN.red(m);
    return this.toRed(red).redPow(y).fromRed();
  }

  ipowmn(y, m, mont) {
    return this.powmn(y, m, mont)._move(this);
  }

  powmn(y, m, mont) {
    const red = mont ? BN.mont(m) : BN.red(m);
    return this.toRed(red).redPown(y).fromRed();
  }

  isqrtm(p) {
    return this.sqrtm(p)._move(this);
  }

  sqrtm(p) {
    enforce(BN.isBN(p), 'p', 'bignum');

    let red;

    if (p.andln(3) === 3 || p.andln(7) === 5) {
      // Probably not worth the setup.
      red = BN.red(p);
    } else {
      red = BN.mont(p);
    }

    return this.toRed(red).redSqrt().fromRed();
  }

  isqrtpq(p, q) {
    return this.sqrtpq(p, q)._move(this);
  }

  sqrtpq(p, q) {
    const sp = this.sqrtm(p);
    const sq = this.sqrtm(q);
    const [mp, mq] = p.egcd(q);
    const lhs = sq.mul(mp).mul(p);
    const rhs = sp.mul(mq).mul(q);
    const n = p.mul(q);

    return lhs.iadd(rhs).imod(n);
  }

  /*
   * Primality Testing
   */

  isPrime(rng, reps, limit) {
    enforce((reps >>> 0) === reps, 'reps', 'uint32');

    if (!this.isPrimeMR(rng, reps + 1, true))
      return false;

    if (!this.isPrimeLucas(limit))
      return false;

    return true;
  }

  isPrimeMR(rng, reps, force2 = false) {
    enforce((reps >>> 0) === reps, 'reps', 'uint32');
    enforce(reps > 0, 'reps', 'integer');
    enforce(typeof force2 === 'boolean', 'force2', 'boolean');

    const n = this;

    if (n.cmpn(7) < 0) {
      return n.cmpn(2) === 0
          || n.cmpn(3) === 0
          || n.cmpn(5) === 0;
    }

    if (n.isEven())
      return false;

    const nm1 = n.subn(1);
    const nm3 = nm1.subn(2);
    const k = nm1.zeroBits();
    const q = nm1.ushrn(k);

    const red = BN.red(n);
    const rnm1 = nm1.toRed(red);
    const rone = new BN(1).toRed(red);

next:
    for (let i = 0; i < reps; i++) {
      let x;

      if (i === reps - 1 && force2) {
        x = new BN(2);
      } else {
        x = BN.random(rng, 0, nm3);
        x.iaddn(2);
      }

      let y = x.toRed(red).redPow(q);

      if (y.cmp(rone) === 0 || y.cmp(rnm1) === 0)
        continue;

      for (let j = 1; j < k; j++) {
        y = y.redSqr();

        if (y.cmp(rnm1) === 0)
          continue next;

        if (y.cmp(rone) === 0)
          return false;
      }

      return false;
    }

    return true;
  }

  isPrimeLucas(limit = 0) {
    enforce((limit >>> 0) === limit, 'limit', 'uint32');

    const n = this;

    // Ignore 0 and 1.
    if (n.cmpn(1) <= 0)
      return false;

    // Two is the only even prime.
    if (n.isEven())
      return n.cmpn(2) === 0;

    let p = 3;

    for (;;) {
      if (p > 10000) {
        // Thought to be impossible.
        throw new Error(`Cannot find (D/n) = -1 for ${n.toString(10)}.`);
      }

      if (limit !== 0 && p > limit) {
        // Optional DoS limit.
        return false;
      }

      const d = new BN(p * p - 4);
      const j = d.jacobi(n);

      if (j === -1)
        break;

      if (j === 0)
        return n.cmpn(p + 2) === 0;

      if (p === 40) {
        if (n.isSquare())
          return false;
      }

      p += 1;
    }

    const s = n.addn(1);
    const r = s._makeOdd();

    let vk = new BN(2);
    let vk1 = new BN(p);

    for (let i = s.bitLength(); i >= 0; i--) {
      if (s.utestn(i)) {
        vk = vk.mul(vk1).isubn(p).imod(n);
        vk1 = vk1.sqr().isubn(2).imod(n);
      } else {
        vk1 = vk1.mul(vk).isubn(p).imod(n);
        vk = vk.sqr().isubn(2).imod(n);
      }
    }

    if (vk.cmpn(2) === 0 || vk.cmp(n.subn(2)) === 0) {
      const a = vk.muln(p).imod(n);
      const b = vk1.ushln(1).imod(n);

      if (a.cmp(b) === 0)
        return true;
    }

    for (let t = 0; t < r - 1; t++) {
      if (vk.isZero())
        return true;

      if (vk.cmpn(2) === 0)
        return false;

      vk = vk.sqr().isubn(2).imod(n);
    }

    return false;
  }

  /*
   * Twos Complement
   */

  toTwos(width) {
    if (this.negative !== 0)
      return this.abs().inotn(width).iaddn(1);

    return this.clone();
  }

  fromTwos(width) {
    enforce((width >>> 0) === width, 'width', 'uint32');
    range(width > 0, 'width');

    if (this.testn(width - 1))
      return this.notn(width).iaddn(1).ineg();

    return this.clone();
  }

  /*
   * Reduction Context
   */

  toRed(ctx) {
    enforce(ctx instanceof Red, 'ctx', 'reduction context');

    if (this.red)
      throw new Error('Already in reduction context.');

    return ctx.convertTo(this);
  }

  fromRed() {
    red(this.red, 'fromRed');
    return this.red.convertFrom(this);
  }

  forceRed(ctx) {
    enforce(ctx instanceof Red, 'ctx', 'reduction context');

    if (this.red) {
      if (!ctx.m.eq(this.red.m) || ctx.mont !== this.red.mont)
        throw new Error('Already in reduction context.');
    } else {
      range(this.negative === 0, 'red');
      range(this.ucmp(ctx.m) < 0, 'red');
    }

    return this.clone()._forceRed(ctx);
  }

  redIAdd(num) {
    enforce(BN.isBN(num), 'num', 'bignum');
    red(this.red, 'redIAdd');
    return this.red.iadd(this, num);
  }

  redAdd(num) {
    enforce(BN.isBN(num), 'num', 'bignum');
    red(this.red, 'redAdd');
    return this.red.add(this, num);
  }

  redIAddn(num) {
    enforce(isSMI(num), 'num', 'smi');
    red(this.red, 'redIAddn');
    return this.red.iaddn(this, num);
  }

  redAddn(num) {
    enforce(isSMI(num), 'num', 'smi');
    red(this.red, 'redAddn');
    return this.red.addn(this, num);
  }

  redISub(num) {
    enforce(BN.isBN(num), 'num', 'bignum');
    red(this.red, 'redISub');
    return this.red.isub(this, num);
  }

  redSub(num) {
    enforce(BN.isBN(num), 'num', 'bignum');
    red(this.red, 'redSub');
    return this.red.sub(this, num);
  }

  redISubn(num) {
    enforce(isSMI(num), 'num', 'smi');
    red(this.red, 'redISubn');
    return this.red.isubn(this, num);
  }

  redSubn(num) {
    enforce(isSMI(num), 'num', 'smi');
    red(this.red, 'redSubn');
    return this.red.subn(this, num);
  }

  redIMul(num) {
    enforce(BN.isBN(num), 'num', 'bignum');
    red(this.red, 'redIMul');
    return this.red.imul(this, num);
  }

  redMul(num) {
    enforce(BN.isBN(num), 'num', 'bignum');
    red(this.red, 'redMul');
    return this.red.mul(this, num);
  }

  redIMuln(num) {
    enforce(isSMI(num), 'num', 'smi');
    red(this.red, 'redIMuln');
    return this.red.imuln(this, num);
  }

  redMuln(num) {
    enforce(isSMI(num), 'num', 'smi');
    red(this.red, 'redMuln');
    return this.red.muln(this, num);
  }

  redIDiv(num) {
    enforce(BN.isBN(num), 'num', 'bignum');
    red(this.red, 'redIDiv');
    return this.red.idiv(this, num);
  }

  redDiv(num) {
    enforce(BN.isBN(num), 'num', 'bignum');
    red(this.red, 'redDiv');
    return this.red.div(this, num);
  }

  redIDivn(num) {
    enforce(isSMI(num), 'num', 'smi');
    red(this.red, 'redIDivn');
    return this.red.idivn(this, num);
  }

  redDivn(num) {
    enforce(isSMI(num), 'num', 'smi');
    red(this.red, 'redDivn');
    return this.red.divn(this, num);
  }

  redIPow(num) {
    enforce(BN.isBN(num), 'num', 'bignum');
    red(this.red, 'redIPow');
    nonred(!num.red, 'redIPow');
    return this.red.ipow(this, num);
  }

  redPow(num) {
    enforce(BN.isBN(num), 'num', 'bignum');
    red(this.red, 'redPow');
    nonred(!num.red, 'redPow');
    return this.red.pow(this, num);
  }

  redIPown(num) {
    enforce(isSMI(num), 'num', 'smi');
    red(this.red, 'redIPown');
    return this.red.ipown(this, num);
  }

  redPown(num) {
    enforce(isSMI(num), 'num', 'smi');
    red(this.red, 'redPown');
    return this.red.pown(this, num);
  }

  redISqr() {
    red(this.red, 'redISqr');
    return this.red.isqr(this);
  }

  redSqr() {
    red(this.red, 'redSqr');
    return this.red.sqr(this);
  }

  redISqrt() {
    red(this.red, 'redISqrt');
    return this.red.isqrt(this);
  }

  redSqrt() {
    red(this.red, 'redSqrt');
    return this.red.sqrt(this);
  }

  redIDivSqrt(v) {
    red(this.red, 'redIDivSqrt');
    return this.red.idivsqrt(this, v);
  }

  redDivSqrt(v) {
    red(this.red, 'redDivSqrt');
    return this.red.divsqrt(this, v);
  }

  redIsSquare() {
    red(this.red, 'redIsSquare');
    return this.red.isSquare(this);
  }

  redIShl(num) {
    enforce(BN.isBN(num), 'num', 'bignum');
    red(this.red, 'redIShl');
    nonred(!num.red, 'redIShl');
    return this.red.ishl(this, num);
  }

  redShl(num) {
    enforce(BN.isBN(num), 'num', 'bignum');
    red(this.red, 'redShl');
    nonred(!num.red, 'redShl');
    return this.red.shl(this, num);
  }

  redIShln(num) {
    enforce((num >>> 0) === num, 'num', 'uint32');
    red(this.red, 'redIShln');
    return this.red.ishln(this, num);
  }

  redShln(num) {
    enforce((num >>> 0) === num, 'num', 'uint32');
    red(this.red, 'redShln');
    return this.red.shln(this, num);
  }

  redINeg() {
    red(this.red, 'redINeg');
    return this.red.ineg(this);
  }

  redNeg() {
    red(this.red, 'redNeg');
    return this.red.neg(this);
  }

  redEq(num) {
    enforce(BN.isBN(num), 'num', 'bignum');
    red(this.red, 'redEq');
    return this.red.eq(this, num);
  }

  redEqn(num) {
    enforce(isSMI(num), 'num', 'smi');
    red(this.red, 'redEqn');
    return this.red.eqn(this, num);
  }

  redIsHigh() {
    red(this.red, 'redIsHigh');
    return this.red.isHigh(this);
  }

  redIsLow() {
    red(this.red, 'redIsLow');
    return this.red.isLow(this);
  }

  redIsOdd() {
    red(this.red, 'redIsOdd');
    return this.red.isOdd(this);
  }

  redIsEven() {
    red(this.red, 'redIsEven');
    return this.red.isEven(this);
  }

  redLegendre() {
    red(this.red, 'redLegendre');
    return this.red.legendre(this);
  }

  redJacobi() {
    red(this.red, 'redJacobi');
    return this.red.jacobi(this);
  }

  redKronecker() {
    red(this.red, 'redKronecker');
    return this.red.kronecker(this);
  }

  redIInvert() {
    red(this.red, 'redIInvert');
    return this.red.iinvert(this);
  }

  redInvert() {
    red(this.red, 'redInvert');
    return this.red.invert(this);
  }

  redIFermat() {
    red(this.red, 'redIFermat');
    return this.red.ifermat(this);
  }

  redFermat() {
    red(this.red, 'redFermat');
    return this.red.fermat(this);
  }

  /*
   * Internal
   */

  _move(dest) {
    dest.words = this.words;
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
    return dest;
  }

  _alloc(size) {
    while (this.words.length < size)
      this.words.push(0);

    return this;
  }

  _expand(size) {
    this._alloc(size);

    while (this.length < size)
      this.words[this.length++] = 0;

    return this;
  }

  _strip() {
    while (this.length > 1 && this.words[this.length - 1] === 0)
      this.length -= 1;

    return this._normalize();
  }

  _normalize() {
    assert(this.length > 0);

    // -0 = 0
    if (this.length === 1 && this.words[0] === 0)
      this.negative = 0;

    return this;
  }

  _check() {
    // We never have a zero length number.
    assert(this.length > 0);

    // Cannot exceed array bounds.
    assert(this.length <= this.words.length);

    if (this.length === 1) {
      // Must be normalized.
      if (this.words[0] === 0)
        assert(this.negative === 0);
      return this;
    }

    // Must be stripped.
    assert(this.words[this.length - 1] !== 0);

    return this;
  }

  _invertp(p) {
    // Penk's right shift binary EGCD.
    //
    // See: The Art of Computer Programming,
    //      Volume 2, Seminumerical Algorithms
    //   Donald E. Knuth
    //   Exercise 4.5.2.39
    enforce(BN.isBN(p), 'p', 'bignum');
    range(p.sign() > 0, 'invert');
    assert(p.isOdd());

    if (p.cmpn(1) === 0)
      throw new RangeError('Not invertible.');

    const a = this.clone();
    const b = p.clone();
    const u = new BN(1);
    const v = new BN(0);

    if (a.isNeg() || a.ucmp(b) >= 0)
      a.imod(b);

    while (!a.isZero()) {
      let i = a._makeOdd();
      let j = b._makeOdd();

      while (i--) {
        if (u.isOdd())
          u._iadd(u, p);

        u.iushrn(1);
      }

      while (j--) {
        if (v.isOdd())
          v._iadd(v, p);

        v.iushrn(1);
      }

      if (a.ucmp(b) >= 0) {
        a._isub(a, b);
        if (u.ucmp(v) < 0) {
          u._isub(v, u);
          u._isub(p, u);
        } else {
          u._isub(u, v);
        }
      } else {
        b._isub(b, a);
        if (v.ucmp(u) < 0) {
          v._isub(u, v);
          v._isub(p, v);
        } else {
          v._isub(v, u);
        }
      }
    }

    if (b.cmpn(1) !== 0)
      throw new RangeError('Not invertible.');

    assert(v.negative === 0);
    assert(v.ucmp(p) < 0);

    return v;
  }

  _makeOdd() {
    const shift = this.zeroBits();

    if (shift > 0)
      this.iushrn(shift);

    return shift;
  }

  _factor2(num) {
    // Find common factor of two.
    // Expects inputs to be non-zero.
    if ((this.words[0] | num.words[0]) & 1)
      return 0;

    const len = Math.min(this.length, num.length);

    let r = 0;

    for (let i = 0; i < len; i++) {
      const b = zeroBits(this.words[i] | num.words[i]);

      r += b;

      if (b !== 26)
        break;
    }

    return r;
  }

  _cloneNormal() {
    return this.red ? this.fromRed() : this.clone();
  }

  _forceRed(ctx) {
    this.red = ctx;
    return this;
  }

  /*
   * Helpers
   */

  clone() {
    const copy = new BN();

    copy.words = new Array(this.length);

    for (let i = 0; i < this.length; i++)
      copy.words[i] = this.words[i];

    copy.length = this.length;
    copy.negative = this.negative;
    copy.red = this.red;

    return copy;
  }

  inject(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    this._alloc(num.length);

    for (let i = 0; i < num.length; i++)
      this.words[i] = num.words[i];

    this.length = num.length;
    this.negative = num.negative;
    this.red = num.red;

    return this;
  }

  set(num, endian) {
    return this.fromNumber(num, endian);
  }

  swap(num) {
    enforce(BN.isBN(num), 'num', 'bignum');

    const x = this;
    const y = num;

    [x.words, y.words] = [y.words, x.words];
    [x.length, y.length] = [y.length, x.length];
    [x.negative, y.negative] = [y.negative, x.negative];
    [x.red, y.red] = [y.red, x.red];

    return x;
  }

  reverse() {
    const neg = this.negative;

    this.fromBuffer(this.toBuffer('be'), 'le');
    this.negative = neg;

    return this;
  }

  byteLength() {
    return Math.ceil(this.bitLength() / 8);
  }

  bitLength() {
    const w = this.words[this.length - 1];
    const hi = countBits(w);
    return (this.length - 1) * 26 + hi;
  }

  zeroBits() {
    if (this.isZero())
      return 0;

    if (this.isOdd())
      return 0;

    let r = 0;

    for (let i = 0; i < this.length; i++) {
      const b = zeroBits(this.words[i]);

      r += b;

      if (b !== 26)
        break;
    }

    return r;
  }

  isSafe() {
    if (this.length <= 2)
      return true;

    if (this.length === 3 && this.words[2] === 0x01)
      return true;

    return false;
  }

  word(pos) {
    enforce((pos >>> 0) === pos, 'pos', 'uint32');

    if (pos >= this.length)
      return 0;

    return this.words[pos];
  }

  [custom]() {
    let prefix = 'BN';

    if (this.red)
      prefix = 'BN-R';

    return `<${prefix}: ${this.toString(10)}>`;
  }

  /*
   * Conversion
   */

  toNumber() {
    let num = this.words[0];

    if (this.length === 2) {
      num += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // Note: at this stage it is known that the top bit is set.
      num += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      throw new RangeError('Number can only safely store up to 53 bits.');
    }

    return this.negative !== 0 ? -num : num;
  }

  toDouble() {
    let num = 0;

    for (let i = this.length - 1; i >= 0; i--)
      num = (num * 0x4000000) + this.words[i];

    return this.negative !== 0 ? -num : num;
  }

  valueOf() {
    return this.toDouble();
  }

  toBigInt() {
    if (!HAS_BIGINT)
      throw new Error('BigInt is not supported!');

    const s52 = BigInt(52);
    const s26 = BigInt(26);

    let i = this.length - 1;
    let num = BigInt(0);

    for (; i >= 1; i -= 2) {
      const hi = this.words[i] * 0x4000000;
      const lo = this.words[i - 1];

      num = (num << s52) | BigInt(hi + lo);
    }

    if (i >= 0)
      num = (num << s26) | BigInt(this.words[0]);

    return this.negative !== 0 ? -num : num;
  }

  toBool() {
    return !this.isZero();
  }

  toString(base, padding) {
    base = getBase(base);

    if (padding == null)
      padding = 0;

    if (padding === 0)
      padding = 1;

    enforce((base >>> 0) === base, 'base', 'uint32');
    enforce((padding >>> 0) === padding, 'padding', 'uint32');

    if (base < 2 || base > 36)
      throw new RangeError('Base ranges between 2 and 36.');

    this._check();

    if (base === 16) {
      let out = '';
      let off = 0;
      let carry = 0;

      for (let i = 0; i < this.length; i++) {
        const w = this.words[i];
        const word = (((w << off) | carry) & 0xffffff).toString(16);

        carry = (w >>> (24 - off)) & 0xffffff;

        if (carry !== 0 || i !== this.length - 1)
          out = zeros[6 - word.length] + word + out;
        else
          out = word + out;

        off += 2;

        if (off >= 26) {
          off -= 26;
          i -= 1;
        }
      }

      if (carry !== 0)
        out = carry.toString(16) + out;

      while (out.length % padding !== 0)
        out = '0' + out;

      if (this.negative !== 0)
        out = '-' + out;

      return out;
    }

    const groupSize = groupSizes[base - 1];
    const groupBase = groupBases[base - 1];
    const c = this.clone();

    let out = '';

    c.negative = 0;

    while (!c.isZero()) {
      const r = c.remrn(groupBase).toString(base);

      c.iquon(groupBase);

      if (!c.isZero())
        out = zeros[groupSize - r.length] + r + out;
      else
        out = r + out;
    }

    if (this.isZero())
      out = '0';

    while (out.length % padding !== 0)
      out = '0' + out;

    if (this.negative !== 0)
      out = '-' + out;

    return out;
  }

  toJSON() {
    return this.toString(16, 2);
  }

  toArray(endian, length) {
    return this.toArrayLike(Array, endian, length);
  }

  toBuffer(endian, length) {
    return this.toArrayLike(Buffer, endian, length);
  }

  toArrayLike(ArrayType, endian, length) {
    if (endian == null)
      endian = 'be';

    if (length == null)
      length = 0;

    enforce(typeof ArrayType === 'function', 'ArrayType', 'function');
    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');
    enforce((length >>> 0) === length, 'length', 'uint32');

    this._check();

    const bytes = this.byteLength();
    const size = length || Math.max(1, bytes);

    if (bytes > size)
      throw new RangeError('Byte array longer than desired length.');

    const res = allocate(ArrayType, size);

    // See: https://github.com/indutny/bn.js/pull/222
    if (endian === 'be') {
      let pos = res.length - 1;
      let carry = 0;

      for (let i = 0; i < this.length; i++) {
        const shift = (i & 3) << 1;
        const word = (this.words[i] << shift) | carry;

        res[pos--] = word & 0xff;

        if (pos >= 0)
          res[pos--] = (word >>> 8) & 0xff;

        if (pos >= 0)
          res[pos--] = (word >>> 16) & 0xff;

        if (shift === 6) {
          if (pos >= 0)
            res[pos--] = (word >>> 24) & 0xff;

          carry = 0;
        } else {
          carry = word >>> 24;
        }
      }

      if (pos >= 0) {
        res[pos--] = carry;

        while (pos >= 0)
          res[pos--] = 0;

        carry = 0;
      }

      assert(carry === 0);
    } else {
      let pos = 0;
      let carry = 0;

      for (let i = 0; i < this.length; i++) {
        const shift = (i & 3) << 1;
        const word = (this.words[i] << shift) | carry;

        res[pos++] = word & 0xff;

        if (pos < res.length)
          res[pos++] = (word >>> 8) & 0xff;

        if (pos < res.length)
          res[pos++] = (word >>> 16) & 0xff;

        if (shift === 6) {
          if (pos < res.length)
            res[pos++] = (word >>> 24) & 0xff;

          carry = 0;
        } else {
          carry = word >>> 24;
        }
      }

      if (pos < res.length) {
        res[pos++] = carry;

        while (pos < res.length)
          res[pos++] = 0;

        carry = 0;
      }

      assert(carry === 0);
    }

    return res;
  }

  encode(endian, length) {
    return this.toBuffer(endian, length);
  }

  /*
   * Instantiation
   */

  of(num, endian) {
    return this.fromNumber(num, endian);
  }

  fromNumber(num, endian) {
    if (endian == null)
      endian = 'be';

    enforce(isInteger(num), 'num', 'integer');
    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');

    const neg = (num < 0) | 0;

    if (neg)
      num = -num;

    if (num < 0x4000000) {
      this.words[0] = num & 0x3ffffff;
      this.length = 1;
    } else if (num < 0x10000000000000) {
      this.words = [
        num & 0x3ffffff,
        (num / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      this.words = [
        num & 0x3ffffff,
        (num / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    this.negative = neg;

    if (endian === 'le')
      this.reverse();

    return this;
  }

  fromDouble(num, endian) {
    if (endian == null)
      endian = 'be';

    enforce(typeof num === 'number', 'num', 'double');
    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');

    if (!isFinite(num))
      num = 0;

    const neg = (num <= -1) | 0;

    if (num < 0)
      num = -num;

    num = Math.floor(num);

    this.words = [];

    while (num > 0) {
      const lo = num % 0x4000000;
      const hi = (num - lo) / 0x4000000;

      this.words.push(lo);

      num = hi;
    }

    if (this.words.length === 0)
      this.words.push(0);

    this.length = this.words.length;
    this.negative = neg;

    if (endian === 'le')
      this.reverse();

    return this;
  }

  fromBigInt(num, endian) {
    if (endian == null)
      endian = 'be';

    enforce(typeof num === 'bigint', 'num', 'bigint');
    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');

    if (!HAS_BIGINT)
      throw new Error('BigInt is not supported!');

    // You know the implementation has a
    // problem when strings are twice
    // as fast as bigints.
    const start = (num < BigInt(0)) | 0;

    this._fromHex(num.toString(16), start);
    this.negative = start;

    if (endian === 'le')
      this.reverse();

    return this;
  }

  fromBool(value) {
    enforce(typeof value === 'boolean', 'value', 'boolean');

    this.words[0] = value | 0;
    this.length = 1;
    this.negative = 0;

    return this;
  }

  fromString(str, base, endian) {
    if (base === 'le' || base === 'be')
      [base, endian] = [endian, base];

    base = getBase(base);

    if (endian == null)
      endian = 'be';

    enforce(typeof str === 'string', 'string', 'string');
    enforce((base >>> 0) === base, 'base', 'uint32');
    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');

    if (base < 2 || base > 36)
      throw new Error('Base ranges between 2 and 36.');

    str = str.replace(/\s+/g, '');

    let start = 0;

    if (str.length > 0 && str.charCodeAt(0) === 0x2d)
      start = 1;

    if (base === 16)
      this._fromHex(str, start);
    else
      this._fromBase(str, base, start);

    this.negative = start;

    this._normalize();

    if (endian === 'le')
      this.reverse();

    return this;
  }

  _fromHex(str, start) {
    this.length = Math.max(2, Math.ceil((str.length - start) / 6));
    this.words = new Array(this.length);

    for (let i = 0; i < this.length; i++)
      this.words[i] = 0;

    // Scan 24-bit chunks and add them to the number.
    let off = 0;
    let i = str.length - 6;
    let j = 0;

    for (; i >= start; i -= 6) {
      const w = parseHex(str, i, i + 6);

      this.words[j] |= (w << off) & 0x3ffffff;

      // `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb.
      this.words[j + 1] |= (w >>> (26 - off)) & 0x3fffff;

      off += 24;

      if (off >= 26) {
        off -= 26;
        j += 1;
      }
    }

    if (i + 6 !== start) {
      const w = parseHex(str, start, i + 6);

      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] |= (w >>> (26 - off)) & 0x3fffff;
    }

    return this._strip();
  }

  _fromBase(str, base, start) {
    // Initialize as zero.
    this.words[0] = 0;
    this.length = 1;
    this.negative = 0;

    // Find length of limb in base.
    let limbLen = 0;
    let limbPow = 1;

    for (; limbPow <= 0x3ffffff; limbPow *= base)
      limbLen += 1;

    limbLen -= 1;
    limbPow = (limbPow / base) | 0;

    const total = str.length - start;
    const mod = total % limbLen;
    const end = Math.min(total, total - mod) + start;

    let i = start;

    for (; i < end; i += limbLen) {
      const word = parseBase(str, i, i + limbLen, base);

      this.imuln(limbPow);
      this._iaddn(word);
    }

    if (mod !== 0) {
      const pow = Math.pow(base, mod);
      const word = parseBase(str, i, str.length, base);

      this.imuln(pow);
      this._iaddn(word);
    }

    return this;
  }

  fromJSON(json) {
    if (BN.isBN(json)) {
      if (json.red)
        return json.fromRed();

      return json.clone();
    }

    if (Array.isArray(json)) {
      for (const chunk of json)
        enforce(typeof chunk === 'string', 'chunk', 'string');

      json = json.join('');
    }

    return this.fromString(json, 16);
  }

  fromBN(num) {
    return this.inject(num);
  }

  fromArray(data, endian) {
    enforce(Array.isArray(data), 'data', 'array');
    return this.fromArrayLike(data, endian);
  }

  fromBuffer(data, endian) {
    enforce((data != null && data._isBuffer === true), 'data', 'buffer');
    return this.fromArrayLike(data, endian);
  }

  fromArrayLike(data, endian) {
    if (endian == null)
      endian = 'be';

    enforce(data && (data.length >>> 0) === data.length, 'data', 'array-like');
    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');

    if (data.length === 0) {
      this.words[0] = 0;
      this.length = 1;
      this.negative = 0;
      return this;
    }

    this.length = Math.max(2, Math.ceil(data.length / 3));
    this.words = new Array(this.length);
    this.negative = 0;

    for (let i = 0; i < this.length; i++)
      this.words[i] = 0;

    const left = data.length % 3;

    let off = 0;
    let j = 0;
    let w = 0;

    if (endian === 'be') {
      for (let i = data.length - 1; i >= 2; i -= 3) {
        const w = data[i] | (data[i - 1] << 8) | (data[i - 2] << 16);

        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;

        off += 24;

        if (off >= 26) {
          off -= 26;
          j += 1;
        }
      }

      switch (left) {
        case 2:
          w = data[1] | (data[0] << 8);
          break;
        case 1:
          w = data[0];
          break;
      }
    } else {
      const len = data.length - left;

      for (let i = 0; i < len; i += 3) {
        const w = data[i] | (data[i + 1] << 8) | (data[i + 2] << 16);

        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;

        off += 24;

        if (off >= 26) {
          off -= 26;
          j += 1;
        }
      }

      switch (left) {
        case 2:
          w = data[len] | (data[len + 1] << 8);
          break;
        case 1:
          w = data[len];
          break;
      }
    }

    if (left > 0) {
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
    }

    return this._strip();
  }

  decode(data, endian) {
    return this.fromBuffer(data, endian);
  }

  from(num, base, endian) {
    if (num == null)
      return this;

    if (base === 'le' || base === 'be')
      [base, endian] = [endian, base];

    if (typeof num === 'number')
      return this.fromNumber(num, endian);

    if (typeof num === 'bigint')
      return this.fromBigInt(num, endian);

    if (typeof num === 'string')
      return this.fromString(num, base, endian);

    if (typeof num === 'object') {
      if (BN.isBN(num))
        return this.fromBN(num, endian);

      if ((num.length >>> 0) === num.length)
        return this.fromArrayLike(num, endian);
    }

    if (typeof num === 'boolean')
      return this.fromBool(num);

    throw new TypeError('Non-numeric object passed to BN.');
  }

  /*
   * Static Methods
   */

  static min(...args) {
    let min = null;

    for (const num of args) {
      enforce(BN.isBN(num), 'num', 'bignum');

      if (!min || num.cmp(min) < 0)
        min = num;
    }

    return min || new BN(0);
  }

  static max(...args) {
    let max = null;

    for (const num of args) {
      enforce(BN.isBN(num), 'num', 'bignum');

      if (!max || num.cmp(max) > 0)
        max = num;
    }

    return max || new BN(0);
  }

  static cmp(a, b) {
    enforce(BN.isBN(a), 'a', 'bignum');
    return a.cmp(b);
  }

  static ucmp(a, b) {
    enforce(BN.isBN(a), 'a', 'bignum');
    return a.ucmp(b);
  }

  static red(num) {
    return new Red(num);
  }

  static barrett(num) {
    return new Barrett(num);
  }

  static mont(num) {
    return new Mont(num);
  }

  static _prime(name) {
    if (primes[name])
      return primes[name];

    let prime;

    if (name === 'p192')
      prime = new P192();
    else if (name === 'p224')
      prime = new P224();
    else if (name === 'p521')
      prime = new P521();
    else if (name === 'k256')
      prime = new K256();
    else if (name === 'p251')
      prime = new P251();
    else if (name === 'p25519')
      prime = new P25519();
    else if (name === 'p448')
      prime = new P448();
    else
      throw new Error(`Unknown prime: "${name}".`);

    primes[name] = prime;

    return prime;
  }

  static prime(name) {
    return BN._prime(name).p.clone();
  }

  static pow(num, exp) {
    if (num === 2)
      return BN.shift(1, exp);

    return new BN().fromNumber(num).pown(exp);
  }

  static shift(num, bits) {
    if (num === 1)
      return new BN(0).usetn(bits, 1);

    return new BN().fromNumber(num).ishln(bits);
  }

  static mask(bits) {
    return BN.shift(1, bits).isubn(1);
  }

  static randomBits(rng, bits) {
    enforce(rng != null, 'rng', 'rng');
    enforce((bits >>> 0) === bits, 'bits', 'uint32');

    if (typeof rng === 'object') {
      enforce(typeof rng.randomBytes === 'function', 'rng', 'rng');

      const size = (bits + 7) >>> 3;
      const total = size * 8;
      const bytes = rng.randomBytes(size);

      enforce((bytes != null && bytes._isBuffer === true), 'bytes', 'buffer');

      if (bytes.length !== size)
        throw new RangeError('Invalid number of bytes returned from RNG.');

      const num = BN.fromBuffer(bytes);

      if (total > bits)
        num.iushrn(total - bits);

      return num;
    }

    enforce(typeof rng === 'function', 'rng', 'rng');

    const num = rng(bits);

    enforce(BN.isBN(num), 'num', 'bignum');
    range(num.negative === 0, 'RNG');
    nonred(!num.red, 'RNG');

    if (num.bitLength() > bits)
      throw new RangeError('Invalid number of bits returned from RNG.');

    return num;
  }

  static random(rng, min, max) {
    min = BN.cast(min, 16);
    max = BN.cast(max, 16);

    if (min.cmp(max) > 0)
      throw new RangeError('Minimum cannot be greater than maximum.');

    const space = max.sub(min).iabs();
    const bits = space.bitLength();

    if (bits === 0)
      return min.clone();

    for (;;) {
      const num = BN.randomBits(rng, bits);

      // Maximum is _exclusive_!
      if (num.cmp(space) >= 0)
        continue;

      // Minimum is _inclusive_!
      num.iadd(min);

      return num;
    }
  }

  static of(num, endian) {
    return new BN().of(num, endian);
  }

  static fromNumber(num, endian) {
    return new BN().fromNumber(num, endian);
  }

  static fromDouble(num, endian) {
    return new BN().fromDouble(num, endian);
  }

  static fromBigInt(num, endian) {
    return new BN().fromBigInt(num, endian);
  }

  static fromBool(value) {
    return new BN().fromBool(value);
  }

  static fromString(str, base, endian) {
    return new BN().fromString(str, base, endian);
  }

  static fromJSON(json) {
    return new BN().fromJSON(json);
  }

  static fromBN(num) {
    return new BN().fromBN(num);
  }

  static fromArray(data, endian) {
    return new BN().fromArray(data, endian);
  }

  static fromBuffer(data, endian) {
    return new BN().fromBuffer(data, endian);
  }

  static fromArrayLike(data, endian) {
    return new BN().fromArrayLike(data, endian);
  }

  static decode(data, endian) {
    return new BN().decode(data, endian);
  }

  static from(num, base, endian) {
    return new BN().from(num, base, endian);
  }

  static cast(num, base, endian) {
    if (BN.isBN(num))
      return num;

    return new BN(num, base, endian);
  }

  static isBN(obj) {
    return obj instanceof BN;
  }
}

/*
 * Static
 */

BN.BN = BN;
BN.wordSize = 26;
BN.native = 0;

/**
 * Prime
 */

class Prime {
  constructor(name, p) {
    // P = 2^N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = BN.shift(1, this.n).isub(this.p);
    this.lo = this.p.clone();
    this.one = this.p.clone();
  }

  ireduce(num) {
    // Assumes that `num` is less than `P^2`:
    // num = HI * (2^N - K) + HI * K + LO = HI * K + LO (mod P)
    const neg = num.negative !== 0;

    // Track bits.
    let bits = num.bitLength();

    // Must be less than P^2.
    assert(bits <= this.n * 2);

    // Ensure positive.
    num.negative = 0;

    // Reduce.
    while (bits > this.n) {
      // lo = num & ((1 << n) - 1)
      // num = num >> n
      this.split(num, this.lo);

      // num = num * K
      this.imulK(num);

      // num = num + lo
      num._iadd(num, this.lo);

      // bits = bitlen(num)
      bits = num.bitLength();
    }

    // Final reduction.
    const cmp = bits < this.n ? -1 : num.ucmp(this.p);

    if (cmp === 0) {
      num.words[0] = 0;
      num.length = 1;
    } else if (cmp > 0) {
      num._isub(num, this.p);
    } else {
      // Note: we shouldn't need to strip here.
    }

    // Adjust sign.
    if (neg && !num.isZero())
      num._isub(this.p, num);

    return num;
  }

  split(input, out) {
    input._split(this.n, out);
  }

  imulK(num) {
    return num.imul(this.k);
  }

  pm2(x1) {
    // Exponent: p - 2
    throw new Error('Not implemented.');
  }

  fermat(x) {
    return this.pm2(x);
  }
}

/**
 * Prime (3 mod 4)
 */

class Prime34 extends Prime {
  constructor(name, p) {
    super(name, p);
  }

  pm3d4(x1) {
    // Exponent: (p - 3) / 4
    throw new Error('Not implemented.');
  }

  pp1d4(x1) {
    // Exponent: (p + 1) / 4
    throw new Error('Not implemented.');
  }

  sqrt(x) {
    // r = x^((p + 1) / 4) mod p
    const {red} = x;
    const r = this.pp1d4(x);

    if (!red.sqr(r).eq(x))
      throw new SquareRootError(r);

    return r;
  }

  divsqrt(u, v) {
    // x = u^3 * v * (u^5 * v^3)^((p - 3) / 4) mod p
    const {red} = u;
    const u2 = red.sqr(u);
    const u3 = red.mul(u2, u);
    const u5 = red.mul(u3, u2);
    const v3 = red.mul(red.sqr(v), v);
    const p = this.pm3d4(red.mul(u5, v3));
    const x = red.mul(red.mul(u3, v), p);
    const c = red.mul(v, red.sqr(x));

    if (c.eq(u))
      return x;

    throw new SquareRootError(x);
  }
}

/**
 * Prime (5 mod 8)
 */

class Prime58 extends Prime {
  constructor(name, p, sm1) {
    super(name, p);

    this.sm1 = new BN(sm1, 16);
  }

  pm5d8(x1) {
    // Exponent: (p - 5) / 8
    throw new Error('Not implemented.');
  }

  pp3d8(x1) {
    // Exponent: (p + 3) / 8
    throw new Error('Not implemented.');
  }

  sqrt(x) {
    // r = x^((p + 3) / 8) mod p
    const {red} = x;
    const sm1 = this.sm1._forceRed(red);
    const r = this.pp3d8(x);

    if (red.sqr(r).eq(x))
      return r;

    const c = red.mul(r, sm1);

    if (red.sqr(c).eq(x))
      return c;

    throw new SquareRootError(r);
  }

  divsqrt(u, v) {
    // x = u * v^3 * (u * v^7)^((p - 5) / 8) mod p
    const {red} = u;
    const sm1 = this.sm1._forceRed(red);
    const v3 = red.mul(red.sqr(v), v);
    const v7 = red.mul(red.sqr(v3), v);
    const p = this.pm5d8(red.mul(u, v7));
    const x = red.mul(red.mul(u, v3), p);
    const c = red.mul(v, red.sqr(x));

    if (c.eq(u))
      return x;

    const mc = red.ineg(c);

    if (mc.eq(u))
      return red.mul(x, sm1);

    if (mc.eq(red.mul(u, sm1)))
      throw new SquareRootError(red.mul(x, sm1));

    throw new SquareRootError(x);
  }
}

/**
 * Prime (1 mod 16)
 */

class Prime116 extends Prime {
  constructor(name, p, g) {
    super(name, p);

    this.g = new BN(g, 16);
    this.z = this.p.subn(1).zeroBits();
  }

  powS(x1) {
    // Exponent: (p - 1) / 2^k
    throw new Error('Not implemented.');
  }

  powE(x1) {
    // Exponent: (s + 1) / 2
    throw new Error('Not implemented.');
  }

  sqrt(x) {
    // Tonelli-Shanks (variable time).
    //
    // Constants:
    //
    //   k = factors of 2 for (p - 1)
    //   s = (p - 1) / 2^k
    //   e = (s + 1) / 2
    //   n = first non-square in F(p)
    //
    // Algorithm:
    //
    //   g = n^s mod p
    //   y = x^e mod p
    //   b = x^s mod p
    //
    //   loop:
    //     t = b
    //     m = 0
    //
    //     while t != 1:
    //       t = t^2 mod p
    //       m += 1
    //
    //     if m == 0:
    //       break
    //
    //     if m >= k:
    //       fail
    //
    //     t = g^(2^(k - m - 1)) mod p
    //     g = t^2 mod p
    //     y = y * t mod p
    //     b = b * g mod p
    //     k = m
    //
    //   return y
    //
    const {red} = x;

    switch (red.jacobi(x)) {
      case -1:
        throw new SquareRootError(x);
      case 0:
        return x.clone();
      case 1:
        break;
    }

    let g = this.g._forceRed(red);
    let y = this.powE(x);
    let b = this.powS(x);
    let k = this.z;

    for (;;) {
      let t = b;
      let m = 0;

      while (t.cmpn(1) !== 0 && m < k) {
        t = red.sqr(t);
        m += 1;
      }

      if (m === 0)
        break;

      assert(m < k);

      t = red.sqrn(g, k - m - 1);
      g = red.sqr(t);
      y = red.mul(y, t);
      b = red.mul(b, g);
      k = m;
    }

    return y;
  }

  divsqrt(u, v) {
    const {red} = u;

    if (v.isZero())
      throw new SquareRootError(v);

    return this.sqrt(red.div(u, v));
  }
}

/**
 * P192
 */

class P192 extends Prime34 {
  constructor() {
    // 2^192 - 2^64 - 1 (= 3 mod 4)
    super('p192', 'ffffffff ffffffff ffffffff fffffffe'
                + 'ffffffff ffffffff');
  }

  imulK(num) {
    // K = 0x10000000000000001
    // K = 2^64 + 1
    const one = this.one.inject(num);
    return num.iushln(64)._iadd(num, one);
  }

  core(x1) {
    // Exponent: (p - 3) / 4
    // Bits: 127x1 1x0 62x1
    const {red} = x1;
    const x2 = red.sqrnmul(x1, 1, x1);
    const x3 = red.sqrnmul(x2, 1, x1);
    const x6 = red.sqrnmul(x3, 3, x3);
    const x12 = red.sqrnmul(x6, 6, x6);
    const x24 = red.sqrnmul(x12, 12, x12);
    const x30 = red.sqrnmul(x24, 6, x6);
    const x31 = red.sqrnmul(x30, 1, x1);
    const x62 = red.sqrnmul(x31, 31, x31);
    const x124 = red.sqrnmul(x62, 62, x62);
    const x127 = red.sqrnmul(x124, 3, x3);
    const r0 = red.sqrn(x127, 1);
    const r1 = red.sqrnmul(r0, 62, x62);

    return r1;
  }

  pm3d4(x1) {
    // Exponent: (p - 3) / 4
    // Bits: 127x1 1x0 62x1
    return this.core(x1);
  }

  pm2(x1) {
    // Exponent: p - 2
    // Bits: 127x1 1x0 62x1 1x0 1x1
    const {red} = x1;
    const r0 = this.core(x1);
    const r1 = red.sqrn(r0, 1);
    const r2 = red.sqrnmul(r1, 1, x1);

    return r2;
  }

  pp1d4(x1) {
    // Exponent: (p + 1) / 4
    // Bits: 128x1 62x0
    const {red} = x1;
    const x2 = red.sqrnmul(x1, 1, x1);
    const x4 = red.sqrnmul(x2, 2, x2);
    const x8 = red.sqrnmul(x4, 4, x4);
    const x16 = red.sqrnmul(x8, 8, x8);
    const x32 = red.sqrnmul(x16, 16, x16);
    const x64 = red.sqrnmul(x32, 32, x32);
    const x128 = red.sqrnmul(x64, 64, x64);
    const r0 = red.sqrn(x128, 62);

    return r0;
  }
}

/**
 * P224
 */

class P224 extends Prime116 {
  constructor() {
    // 2^224 - 2^96 + 1 (1 mod 16)
    super('p224', 'ffffffff ffffffff ffffffff ffffffff'
                + '00000000 00000000 00000001',
                  '6a0fec67 8598a792 0c55b2d4 0b2d6ffb'
                + 'bea3d8ce f3fb3632 dc691b74');
  }

  imulK(num) {
    // K = 0xffffffffffffffffffffffff
    // K = 2^96 - 1
    const one = this.one.inject(num);
    return num.iushln(96)._isub(num, one);
  }

  powS(x1) {
    // Exponent: 2^128 - 1
    // Bits: 128x1
    const {red} = x1;
    const x2 = red.sqrnmul(x1, 1, x1);
    const x4 = red.sqrnmul(x2, 2, x2);
    const x8 = red.sqrnmul(x4, 4, x4);
    const x16 = red.sqrnmul(x8, 8, x8);
    const x32 = red.sqrnmul(x16, 16, x16);
    const x64 = red.sqrnmul(x32, 32, x32);
    const x128 = red.sqrnmul(x64, 64, x64);

    return x128;
  }

  powE(x1) {
    // Exponent: 2^127
    // Bits: 1x1 127x0
    const {red} = x1;
    const r0 = red.sqrn(x1, 127);

    return r0;
  }

  pm2(x1) {
    // Exponent: p - 2
    // Bits: 127x1 1x0 96x1
    const {red} = x1;
    const x2 = red.sqrnmul(x1, 1, x1);
    const x3 = red.sqrnmul(x2, 1, x1);
    const x6 = red.sqrnmul(x3, 3, x3);
    const x12 = red.sqrnmul(x6, 6, x6);
    const x24 = red.sqrnmul(x12, 12, x12);
    const x48 = red.sqrnmul(x24, 24, x24);
    const x96 = red.sqrnmul(x48, 48, x48);
    const x120 = red.sqrnmul(x96, 24, x24);
    const x126 = red.sqrnmul(x120, 6, x6);
    const x127 = red.sqrnmul(x126, 1, x1);
    const r0 = red.sqrn(x127, 1);
    const r1 = red.sqrnmul(r0, 96, x96);

    return r1;
  }
}

/**
 * P521
 */

class P521 extends Prime34 {
  constructor() {
    // 2^521 - 1 (= 3 mod 4)
    super('p521', '000001ff ffffffff ffffffff ffffffff'
                + 'ffffffff ffffffff ffffffff ffffffff'
                + 'ffffffff ffffffff ffffffff ffffffff'
                + 'ffffffff ffffffff ffffffff ffffffff'
                + 'ffffffff');
  }

  imulK(num) {
    // K = 0x01
    return num;
  }

  core(x1) {
    // Exponent: 2^519 - 1
    // Bits: 519x1
    const {red} = x1;
    const x2 = red.sqrnmul(x1, 1, x1);
    const x3 = red.sqrnmul(x2, 1, x1);
    const x6 = red.sqrnmul(x3, 3, x3);
    const x7 = red.sqrnmul(x6, 1, x1);
    const x8 = red.sqrnmul(x7, 1, x1);
    const x16 = red.sqrnmul(x8, 8, x8);
    const x32 = red.sqrnmul(x16, 16, x16);
    const x64 = red.sqrnmul(x32, 32, x32);
    const x128 = red.sqrnmul(x64, 64, x64);
    const x256 = red.sqrnmul(x128, 128, x128);
    const x512 = red.sqrnmul(x256, 256, x256);
    const x519 = red.sqrnmul(x512, 7, x7);

    return x519;
  }

  pm3d4(x1) {
    // Exponent: 2^519 - 1
    // Bits: 519x1
    return this.core(x1);
  }

  pm2(x1) {
    // Exponent: p - 2
    // Bits: 519x1 1x0 1x1
    const {red} = x1;
    const r0 = this.core(x1);
    const r1 = red.sqrn(r0, 1);
    const r2 = red.sqrnmul(r1, 1, x1);

    return r2;
  }

  pp1d4(x1) {
    // Exponent: (p + 1) / 4
    // Bits: 1x1 519x0
    const {red} = x1;
    const r0 = red.sqrn(x1, 519);

    return r0;
  }
}

/**
 * K256
 */

class K256 extends Prime34 {
  constructor() {
    // 2^256 - 2^32 - 977 (= 3 mod 4)
    super('k256', 'ffffffff ffffffff ffffffff ffffffff'
                + 'ffffffff ffffffff fffffffe fffffc2f');
  }

  split(input, output) {
    // 256 = 9 * 26 + 22
    const mask = 0x3fffff;
    const len = Math.min(input.length, 9);

    output._alloc(len + 1);

    for (let i = 0; i < len; i++)
      output.words[i] = input.words[i];

    output.length = len;

    if (input.length <= 9) {
      output._strip();
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs.
    let prev = input.words[9];
    let i = 10;

    output.words[output.length++] = prev & mask;
    output._strip();

    for (; i < input.length; i++) {
      const next = input.words[i] | 0;

      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);

      prev = next;
    }

    prev >>>= 22;

    input.words[i - 10] = prev;

    if (prev === 0 && input.length > 10)
      input.length -= 10;
    else
      input.length -= 9;

    input._strip(); // Unsure if we need this.
  }

  imulK(num) {
    // K = 0x1000003d1 = [0x40, 0x3d1]
    // K = 2^32 + 977
    num._expand(num.length + 2);

    // Bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    let lo = 0;

    for (let i = 0; i < num.length; i++) {
      const w = num.words[i];

      lo += w * 0x3d1;

      num.words[i] = lo & 0x3ffffff;

      lo = w * 0x40 + Math.floor(lo / 0x4000000);
    }

    // Fast length reduction.
    if (num.words[num.length - 1] === 0) {
      num.length -= 1;
      if (num.words[num.length - 1] === 0)
        num.length -= 1;
    }

    // Note: we shouldn't need to strip here.
    return num;
  }

  core(x1, x2) {
    // Exponent: (p - 47) / 64
    // Bits: 223x1 1x0 22x1 4x0
    const {red} = x1;
    const x3 = red.sqrnmul(x2, 1, x1);
    const x6 = red.sqrnmul(x3, 3, x3);
    const x9 = red.sqrnmul(x6, 3, x3);
    const x11 = red.sqrnmul(x9, 2, x2);
    const x22 = red.sqrnmul(x11, 11, x11);
    const x44 = red.sqrnmul(x22, 22, x22);
    const x88 = red.sqrnmul(x44, 44, x44);
    const x176 = red.sqrnmul(x88, 88, x88);
    const x220 = red.sqrnmul(x176, 44, x44);
    const x223 = red.sqrnmul(x220, 3, x3);
    const r0 = red.sqrn(x223, 1);
    const r1 = red.sqrnmul(r0, 22, x22);
    const r2 = red.sqrn(r1, 4);

    return r2;
  }

  pm3d4(x1) {
    // Exponent: (p - 3) / 4
    // Bits: 223x1 1x0 22x1 4x0 1x1 1x0 2x1
    const {red} = x1;
    const x2 = red.sqrnmul(x1, 1, x1);
    const r2 = this.core(x1, x2);
    const r3 = red.sqrnmul(r2, 1, x1);
    const r4 = red.sqrn(r3, 1);
    const r5 = red.sqrnmul(r4, 2, x2);

    return r5;
  }

  pm2(x1) {
    // Exponent: p - 2
    // Bits: 223x1 1x0 22x1 4x0 1x1 1x0 2x1 1x0 1x1
    const {red} = x1;
    const x2 = red.sqrnmul(x1, 1, x1);
    const r2 = this.core(x1, x2);
    const r3 = red.sqrnmul(r2, 1, x1);
    const r4 = red.sqrn(r3, 1);
    const r5 = red.sqrnmul(r4, 2, x2);
    const r6 = red.sqrn(r5, 1);
    const r7 = red.sqrnmul(r6, 1, x1);

    return r7;
  }

  pp1d4(x1) {
    // Exponent: (p + 1) / 4
    // Bits: 223x1 1x0 22x1 4x0 2x1 2x0
    const {red} = x1;
    const x2 = red.sqrnmul(x1, 1, x1);
    const r2 = this.core(x1, x2);
    const r3 = red.sqrnmul(r2, 2, x2);
    const r4 = red.sqrn(r3, 2);

    return r4;
  }
}

/**
 * P251
 */

class P251 extends Prime34 {
  constructor() {
    // 2^251 - 9
    super('p251', '07ffffff ffffffff ffffffff ffffffff'
                + 'ffffffff ffffffff ffffffff fffffff7');
  }

  imulK(num) {
    // K = 0x09
    if (num.isZero())
      return num;

    let carry = 0;

    for (let i = 0; i < num.length; i++) {
      const w = num.words[i] * 0x09 + carry;

      carry = w >>> 26;

      num.words[i] = w & 0x3ffffff;
    }

    if (carry !== 0) {
      num._alloc(num.length + 1);
      num.words[num.length++] = carry;
    }

    // Note: we shouldn't need to strip here.
    return num;
  }

  core(x1) {
    // Exponent: 2^247 - 1
    // Bits: 247x1
    const {red} = x1;
    const x2 = red.sqrnmul(x1, 1, x1);
    const x3 = red.sqrnmul(x2, 1, x1);
    const x6 = red.sqrnmul(x3, 3, x3);
    const x12 = red.sqrnmul(x6, 6, x6);
    const x24 = red.sqrnmul(x12, 12, x12);
    const x48 = red.sqrnmul(x24, 24, x24);
    const x96 = red.sqrnmul(x48, 48, x48);
    const x192 = red.sqrnmul(x96, 96, x96);
    const x240 = red.sqrnmul(x192, 48, x48);
    const x246 = red.sqrnmul(x240, 6, x6);
    const x247 = red.sqrnmul(x246, 1, x1);

    return x247;
  }

  pm3d4(x1) {
    // Exponent: (p - 3) / 4
    // Bits: 247x1 1x0 1x1
    const {red} = x1;
    const r0 = this.core(x1);
    const r1 = red.sqrn(r0, 1);
    const r2 = red.sqrnmul(r1, 1, x1);

    return r2;
  }

  pm2(x1) {
    // Exponent: p - 2
    // Bits: 247x1 1x0 1x1 1x0 1x1
    const {red} = x1;
    const r0 = this.core(x1);
    const r1 = red.sqrn(r0, 1);
    const r2 = red.sqrnmul(r1, 1, x1);
    const r3 = red.sqrn(r2, 1);
    const r4 = red.sqrnmul(r3, 1, x1);

    return r4;
  }

  pp1d4(x1) {
    // Exponent: (p + 1) / 4
    // Bits: 248x1 1x0
    const {red} = x1;
    const r0 = this.core(x1);
    const r1 = red.sqrnmul(r0, 1, x1);
    const r2 = red.sqrn(r1, 1);

    return r2;
  }
}

/**
 * P25519
 */

class P25519 extends Prime58 {
  constructor() {
    // 2^255 - 19 (= 5 mod 8)
    super('p25519', '7fffffff ffffffff ffffffff ffffffff'
                  + 'ffffffff ffffffff ffffffff ffffffed',
                    '2b832480 4fc1df0b 2b4d0099 3dfbd7a7'
                  + '2f431806 ad2fe478 c4ee1b27 4a0ea0b0');
  }

  imulK(num) {
    // K = 0x13
    let carry = 0;

    for (let i = 0; i < num.length; i++) {
      const w = num.words[i] * 0x13 + carry;

      carry = w >>> 26;

      num.words[i] = w & 0x3ffffff;
    }

    if (carry !== 0) {
      num._alloc(num.length + 1);
      num.words[num.length++] = carry;
    }

    // Note: we shouldn't need to strip here.
    return num;
  }

  core(x1, x2) {
    // Exponent: 2^250 - 1
    // Bits: 250x1
    const {red} = x1;
    const x4 = red.sqrnmul(x2, 2, x2);
    const x5 = red.sqrnmul(x4, 1, x1);
    const x10 = red.sqrnmul(x5, 5, x5);
    const x20 = red.sqrnmul(x10, 10, x10);
    const x40 = red.sqrnmul(x20, 20, x20);
    const x50 = red.sqrnmul(x40, 10, x10);
    const x100 = red.sqrnmul(x50, 50, x50);
    const x200 = red.sqrnmul(x100, 100, x100);
    const x250 = red.sqrnmul(x200, 50, x50);

    return x250;
  }

  pm5d8(x1) {
    // Exponent: (p - 5) / 8
    // Bits: 250x1 1x0 1x1
    const {red} = x1;
    const x2 = red.sqrnmul(x1, 1, x1);
    const r0 = this.core(x1, x2);
    const r1 = red.sqrn(r0, 1);
    const r2 = red.sqrnmul(r1, 1, x1);

    return r2;
  }

  pm2(x1) {
    // Exponent: p - 2
    // Bits: 250x1 1x0 1x1 1x0 2x1
    const {red} = x1;
    const x2 = red.sqrnmul(x1, 1, x1);
    const r0 = this.core(x1, x2);
    const r1 = red.sqrn(r0, 1);
    const r2 = red.sqrnmul(r1, 1, x1);
    const r3 = red.sqrn(r2, 1);
    const r4 = red.sqrnmul(r3, 2, x2);

    return r4;
  }

  pp3d8(x1) {
    // Exponent: (p + 3) / 8
    // Bits: 251x1 1x0
    const {red} = x1;
    const x2 = red.sqrnmul(x1, 1, x1);
    const r0 = this.core(x1, x2);
    const r1 = red.sqrnmul(r0, 1, x1);
    const r2 = red.sqrn(r1, 1);

    return r2;
  }
}

/**
 * P448
 */

class P448 extends Prime34 {
  constructor() {
    // 2^448 - 2^224 - 1 (= 3 mod 4)
    super('p448', 'ffffffff ffffffff ffffffff ffffffff'
                + 'ffffffff ffffffff fffffffe ffffffff'
                + 'ffffffff ffffffff ffffffff ffffffff'
                + 'ffffffff ffffffff');
  }

  imulK(num) {
    // K = 0x100000000000000000000000000000000000000000000000000000001
    // K = 2^224 + 1
    const one = this.one.inject(num);
    return num.iushln(224)._iadd(num, one);
  }

  core(x1, x2) {
    // Exponent: 2^222 - 1
    // Bits: 222x1
    const {red} = x1;
    const x3 = red.sqrnmul(x2, 1, x1);
    const x6 = red.sqrnmul(x3, 3, x3);
    const x9 = red.sqrnmul(x6, 3, x3);
    const x11 = red.sqrnmul(x9, 2, x2);
    const x22 = red.sqrnmul(x11, 11, x11);
    const x44 = red.sqrnmul(x22, 22, x22);
    const x88 = red.sqrnmul(x44, 44, x44);
    const x176 = red.sqrnmul(x88, 88, x88);
    const x220 = red.sqrnmul(x176, 44, x44);
    const x222 = red.sqrnmul(x220, 2, x2);

    return x222;
  }

  pm3d4(x1) {
    // Exponent: (p - 3) / 4
    // Bits: 223x1 1x0 222x1
    const {red} = x1;
    const x2 = red.sqrnmul(x1, 1, x1);
    const x222 = this.core(x1, x2);
    const r0 = red.sqrnmul(x222, 1, x1);
    const r1 = red.sqrn(r0, 1);
    const r2 = red.sqrnmul(r1, 222, x222);

    return r2;
  }

  pm2(x1) {
    // Exponent: p - 2
    // Bits: 223x1 1x0 222x1 1x0 1x1
    const {red} = x1;
    const r0 = this.pm3d4(x1);
    const r1 = red.sqrn(r0, 1);
    const r2 = red.sqrnmul(r1, 1, x1);

    return r2;
  }

  pp1d4(x1) {
    // Exponent: (p + 1) / 4
    // Bits: 224x1 222x0
    const {red} = x1;
    const x2 = red.sqrnmul(x1, 1, x1);
    const r0 = this.core(x1, x2);
    const r1 = red.sqrnmul(r0, 2, x2);
    const r2 = red.sqrn(r1, 222);

    return r2;
  }
}

/**
 * Reduction Engine
 */

class Red {
  constructor(m) {
    let prime = null;

    if (typeof m === 'string') {
      prime = BN._prime(m);
      m = prime.p;
    }

    enforce(BN.isBN(m), 'm', 'bignum');
    nonred(!m.red, 'reduction');
    range(m.sign() > 0, 'reduction');

    this.m = m;
    this.prime = prime;
    this.mb = null;
    this.sm1 = null;
  }

  _verify1(a) {
    range(a.negative === 0, 'red');
    red(a.red != null, 'red');
  }

  _verify2(a, b) {
    range((a.negative | b.negative) === 0, 'red');
    red(a.red != null && a.red === b.red, 'red');
  }

  get mont() {
    return false;
  }

  precompute() {
    // Precompute `sqrt(-1)` for primes congruent to 5 mod 8.
    if (this.sm1 === null && this.m.andln(7) === 5) {
      if (this.prime) {
        this.sm1 = this.prime.sm1.clone()._forceRed(this);
      } else {
        const x = new BN(2).toRed(this);
        const e = this.m.subn(1).iushrn(2);

        // sqrt(-1) = 2^((p - 1) / 4) mod p
        this.sm1 = this.pow(x, e);
      }
    }

    return this;
  }

  convertTo(num) {
    const res = num.mod(this.m);
    res.red = this;
    return res;
  }

  convertFrom(num) {
    const res = num.clone();
    res.red = null;
    return res;
  }

  intTo(a) {
    return a;
  }

  intFrom(a) {
    return a;
  }

  imod(a) {
    if (this.prime)
      return this.prime.ireduce(a)._forceRed(this);

    return a.imod(this.m)._forceRed(this);
  }

  iadd(a, b) {
    this._verify2(a, b);

    a._iadd(a, b);

    if (a.ucmp(this.m) >= 0)
      a._isub(a, this.m);

    return a;
  }

  add(a, b) {
    if (a.length < b.length)
      return this.iadd(b.clone(), a);

    return this.iadd(a.clone(), b);
  }

  iaddn(a, num) {
    this._verify1(a);

    if (num < 0)
      return this.isubn(a, -num);

    if (this.m.length === 1)
      num %= this.m.words[0];

    a._iaddn(num);

    if (a.ucmp(this.m) >= 0)
      a._isub(a, this.m);

    return a;
  }

  addn(a, num) {
    return this.iaddn(a.clone(), num);
  }

  isub(a, b) {
    this._verify2(a, b);

    //  0: a - a mod m == 0
    // -1: a - b mod m == m - (b - a)
    // +1: a - b mod m == a - b
    const cmp = a.ucmp(b);

    if (cmp === 0) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    if (cmp < 0) {
      a._isub(b, a);
      a._isub(this.m, a);
    } else {
      a._isub(a, b);
    }

    return a;
  }

  sub(a, b) {
    return this.isub(a.clone(), b);
  }

  isubn(a, num) {
    this._verify1(a);

    if (num < 0)
      return this.iaddn(a, -num);

    if (this.m.length === 1)
      num %= this.m.words[0];

    //  <: a - b mod m == m - (b - a)
    // >=: a - b mod m == a - b
    if (a.length === 1 && a.words[0] < num) {
      a.words[0] = num - a.words[0];
      a._isub(this.m, a);
    } else {
      a._isubn(num);
    }

    return a;
  }

  subn(a, num) {
    return this.isubn(a.clone(), num);
  }

  imul(a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  }

  mul(a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  }

  imuln(a, num) {
    this._verify1(a);

    if (a.isZero())
      return a;

    if (num === 0) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    const neg = num < 0;

    if (neg)
      num = -num;

    if (this.m.length === 1)
      num %= this.m.words[0];

    a.imuln(num);

    if (num <= 16) {
      // Quick reduction.
      while (a.ucmp(this.m) >= 0)
        a._isub(a, this.m);
    } else {
      this.imod(a);
    }

    if (neg)
      this.ineg(a);

    return a;
  }

  muln(a, num) {
    return this.imuln(a.clone(), num);
  }

  idiv(a, b) {
    return this.div(a, b)._move(a);
  }

  div(a, b) {
    return this.mul(a, this.invert(b));
  }

  idivn(a, num) {
    return this.divn(a, num)._move(a);
  }

  divn(a, num) {
    return this.div(a, this.convertTo(new BN(num)));
  }

  ipow(a, num) {
    return this.pow(a, num)._move(a);
  }

  pow(a, num) {
    this._verify1(a);

    if (num.isNeg())
      a = this.invert(a);

    // Small exponent.
    if (num.length === 1)
      return this.pown(a, num.words[0]);

    // Call out to BigInt.
    if (HAS_BIGINT && !this.prime)
      return this.powInt(a, num);

    // Otherwise, a BN implementation.
    return this.powNum(a, num);
  }

  powNum(a, num) {
    // Sliding window (odd multiples only).
    const one = new BN(1).toRed(this);
    const wnd = new Array(WND_SIZE);
    const a2 = this.sqr(a);

    wnd[0] = a;

    for (let i = 1; i < WND_SIZE; i++)
      wnd[i] = this.mul(wnd[i - 1], a2);

    let i = num.bitLength();
    let r = one;

    while (i >= WND_WIDTH) {
      let width = WND_WIDTH;
      let bits = num.bits(i - width, width);

      if (bits < WND_SIZE) {
        r = this.sqr(r);
        i -= 1;
        continue;
      }

      while ((bits & 1) === 0) {
        width -= 1;
        bits >>= 1;
      }

      if (r === one) {
        r = wnd[bits >> 1].clone();
      } else {
        r = this.sqrn(r, width);
        r = this.mul(r, wnd[bits >> 1]);
      }

      i -= width;
    }

    if (i > 0) {
      const bits = num.bits(0, i);

      while (i--) {
        r = this.sqr(r);

        if ((bits >> i) & 1)
          r = this.mul(r, a);
      }
    }

    return r;
  }

  powInt(a, num) {
    if (this.mb === null)
      this.mb = this.m.toBigInt();

    const x = this.intFrom(a.toBigInt());
    const y = powInt(x, num, this.mb);
    const z = this.intTo(y);

    return BN.fromBigInt(z)._forceRed(this);
  }

  sqrn(a, n) {
    while (n--)
      a = this.sqr(a);

    return a;
  }

  sqrnmul(a, n, b) {
    return this.mul(this.sqrn(a, n), b);
  }

  ipown(a, num) {
    return this.pown(a, num)._move(a);
  }

  pown(a, num) {
    this._verify1(a);

    if (num < 0) {
      a = this.invert(a);
      num = -num;
    }

    if (num === 0)
      return new BN(1).toRed(this);

    if (num === 1)
      return a.clone();

    const bits = countBits(num);

    let r = a;

    for (let i = bits - 2; i >= 0; i--) {
      r = this.sqr(r);

      if ((num >> i) & 1)
        r = this.mul(r, a);
    }

    return r;
  }

  isqr(a) {
    return this.imul(a, a);
  }

  sqr(a) {
    return this.mul(a, a);
  }

  isqrt(x) {
    return this.sqrt(x)._move(x);
  }

  sqrt(x) {
    this._verify1(x);

    // Optimized square root chain.
    if (this.prime)
      return this.prime.sqrt(x);

    // Fast case (p = 3 mod 4).
    if (this.m.andln(3) === 3)
      return this.sqrt3mod4(x);

    // Fast case (p = 5 mod 8).
    if (this.m.andln(7) === 5) {
      if (this.sm1 != null)
        return this.sqrt5mod8sm1(x);
      return this.sqrt5mod8(x);
    }

    // Slow case (Tonelli-Shanks).
    return this.sqrt0(x);
  }

  sqrt3mod4(x) {
    const e = this.m.addn(1).iushrn(2); // (p + 1) / 4
    const b = this.pow(x, e);

    if (!this.sqr(b).eq(x))
      throw new SquareRootError(b);

    return b;
  }

  sqrt5mod8(x) {
    // Atkin's Algorithm.
    const one = new BN(1).toRed(this);
    const e = this.m.ushrn(3); // (p - 5) / 8
    const x2 = this.add(x, x);
    const alpha = this.pow(x2, e);
    const beta = this.mul(x2, this.sqr(alpha));
    const b = this.mul(this.mul(alpha, x), this.isub(beta, one));

    if (!this.sqr(b).eq(x))
      throw new SquareRootError(b);

    return b;
  }

  sqrt5mod8sm1(x) {
    const e = this.m.addn(3).iushrn(3); // (p + 3) / 8
    const b = this.pow(x, e);

    if (this.sqr(b).eq(x))
      return b;

    const c = this.mul(b, this.sm1);

    if (this.sqr(c).eq(x))
      return c;

    throw new SquareRootError(b);
  }

  sqrt0(x) {
    if (this.m.cmpn(1) === 0 || !this.m.isOdd())
      throw new Error('Invalid prime.');

    switch (this.jacobi(x)) {
      case -1:
        throw new SquareRootError(x);
      case 0:
        return x.clone();
      case 1:
        break;
    }

    const one = new BN(1).toRed(this);
    const s = this.m.subn(1);
    const e = s._makeOdd();
    const n = new BN(2).toRed(this);

    while (this.jacobi(n) !== -1)
      this.iadd(n, one);

    let g = this.pow(n, s);
    let b = this.pow(x, s);
    let y = this.pow(x, s.iaddn(1).iushrn(1));
    let k = e;

    for (;;) {
      let t = b;
      let m = 0;

      while (!t.eq(one) && m < k) {
        t = this.sqr(t);
        m += 1;
      }

      if (m === 0)
        break;

      assert(m < k);

      t = this.sqrn(g, k - m - 1);
      g = this.sqr(t);
      y = this.mul(y, t);
      b = this.mul(b, g);
      k = m;
    }

    return y;
  }

  idivsqrt(u, v) {
    return this.divsqrt(u, v)._move(u);
  }

  divsqrt(u, v) {
    this._verify2(u, v);

    // u = 0, v = 0
    if (u.isZero() && v.isZero())
      throw new SquareRootError(v);

    // Optimized inverse square root chain.
    if (this.prime)
      return this.prime.divsqrt(u, v);

    // p = 3 mod 4
    if (this.m.andln(3) === 3)
      return this.divsqrt3mod4(u, v);

    // p = 5 mod 8
    if (this.sm1 != null && this.m.andln(7) === 5)
      return this.divsqrt5mod8(u, v);

    // v = 0
    if (v.isZero())
      throw new SquareRootError(v);

    return this.sqrt(this.div(u, v));
  }

  divsqrt3mod4(u, v) {
    // x = u^3 * v * (u^5 * v^3)^((p - 3) / 4) mod p
    const e = this.m.subn(3).iushrn(2);
    const u2 = this.sqr(u);
    const u3 = this.mul(u2, u);
    const u5 = this.mul(u3, u2);
    const v3 = this.mul(this.sqr(v), v);
    const p = this.pow(this.mul(u5, v3), e);
    const x = this.mul(this.mul(u3, v), p);
    const c = this.mul(v, this.sqr(x));

    if (c.eq(u))
      return x;

    throw new SquareRootError(x);
  }

  divsqrt5mod8(u, v) {
    // x = u * v^3 * (u * v^7)^((p - 5) / 8) mod p
    const e = this.m.subn(5).iushrn(3);
    const v3 = this.mul(this.sqr(v), v);
    const v7 = this.mul(this.sqr(v3), v);
    const p = this.pow(this.mul(u, v7), e);
    const x = this.mul(this.mul(u, v3), p);
    const c = this.mul(v, this.sqr(x));

    if (c.eq(u))
      return x;

    const mc = this.ineg(c);

    if (mc.eq(u))
      return this.mul(x, this.sm1);

    if (mc.eq(this.mul(u, this.sm1)))
      throw new SquareRootError(this.mul(x, this.sm1));

    throw new SquareRootError(x);
  }

  isSquare(a) {
    if (this.m.isOdd())
      return this.jacobi(a) >= 0;

    return this.kronecker(a) >= 0;
  }

  ishl(a, num) {
    this._verify1(a);
    return this.imod(a.iushl(num));
  }

  shl(a, num) {
    return this.ishl(a.clone(), num);
  }

  ishln(a, num) {
    this._verify1(a);

    a.iushln(num);

    if (num <= 4) {
      // Quick reduction.
      while (a.ucmp(this.m) >= 0)
        a._isub(a, this.m);
    } else {
      this.imod(a);
    }

    return a;
  }

  shln(a, num) {
    return this.ishln(a.clone(), num);
  }

  ineg(a) {
    this._verify1(a);

    if (!a.isZero())
      a._isub(this.m, a);

    return a;
  }

  neg(a) {
    return this.ineg(a.clone());
  }

  eq(a, b) {
    this._verify2(a, b);
    return a.ucmp(b) === 0;
  }

  eqn(a, num) {
    this._verify1(a);

    if (this.m.length === 1) {
      num %= this.m.words[0];

      if (num < 0)
        num += this.m.words[0];

      return a.ucmpn(num) === 0;
    }

    if (num < 0) {
      this.m._isubn(-num);

      const cmp = a.ucmp(this.m);

      this.m._iaddn(-num);

      return cmp === 0;
    }

    return a.ucmpn(num) === 0;
  }

  isHigh(a) {
    return !this.isLow(a);
  }

  isLow(a) {
    this._verify1(a);
    return a.ucmp(this.m.ushrn(1)) <= 0;
  }

  isOdd(a) {
    this._verify1(a);
    return a.isOdd();
  }

  isEven(a) {
    this._verify1(a);
    return a.isEven();
  }

  legendre(num) {
    this._verify1(num);

    if (this.m.isEven())
      throw new Error('legendre: `num` must be odd.');

    // Euler's criterion.
    const e = this.m.subn(1).iushrn(1); // (p - 1) / 2
    const symbol = this.pow(num, e);

    if (symbol.isZero())
      return 0;

    const one = new BN(1).toRed(this);

    if (symbol.eq(one))
      return 1;

    if (symbol.eq(this.ineg(one)))
      return -1;

    throw new Error('Invalid prime.');
  }

  jacobi(a) {
    this._verify1(a);
    return a.jacobi(this.m);
  }

  kronecker(a) {
    this._verify1(a);
    return a.kronecker(this.m);
  }

  iinvert(a) {
    return this.invert(a)._move(a);
  }

  invert(a) {
    this._verify1(a);
    return a.invert(this.m)._forceRed(this);
  }

  ifermat(a) {
    return this.fermat(a)._move(a);
  }

  fermat(a) {
    this._verify1(a);

    if (a.isZero() || this.m.cmpn(1) === 0)
      throw new RangeError('Not invertible.');

    // Optimized inversion chain.
    if (this.prime)
      return this.prime.fermat(a);

    // Invert using fermat's little theorem.
    return this.pow(a, this.m.subn(2));
  }

  invertAll(elems) {
    // Montgomery's trick.
    enforce(Array.isArray(elems), 'elems', 'array');

    for (const elem of elems) {
      enforce(BN.isBN(elem), 'elem', 'bignum');

      this._verify1(elem);
    }

    if (this.m.cmpn(1) === 0 || this.m.isEven())
      throw new RangeError('Not invertible.');

    const len = elems.length;
    const invs = new Array(len);

    if (len === 0)
      return invs;

    let acc = new BN(1).toRed(this);

    for (let i = 0; i < len; i++) {
      if (elems[i].isZero()) {
        invs[i] = elems[i].clone();
        continue;
      }

      invs[i] = acc;
      acc = this.mul(acc, elems[i]);
    }

    acc = this.invert(acc);

    for (let i = len - 1; i >= 0; i--) {
      if (elems[i].isZero())
        continue;

      invs[i] = this.mul(acc, invs[i]);
      acc = this.mul(acc, elems[i]);
    }

    return invs;
  }

  [custom]() {
    if (this.prime)
      return `<Red: ${this.prime.name}>`;

    return `<Red: ${this.m.toString(10)}>`;
  }
}

/**
 * Barrett Engine
 */

class Barrett extends Red {
  constructor(m) {
    super(m);

    this.prime = null;
    this.n = this.m.bitLength();

    if ((this.n % 26) !== 0)
      this.n += 26 - (this.n % 26);

    this.k = this.n * 2;
    this.w = this.k / 26;
    this.b = BN.shift(1, this.k).div(this.m);
  }

  convertTo(num) {
    if (num.length > this.w)
      return super.convertTo(num);

    return this.imod(num.clone());
  }

  _shift(q) {
    let i = 0;
    let j = this.w;

    while (j < q.length)
      q.words[i++] = q.words[j++];

    if (i === 0)
      q.words[i++] = 0;

    q.length = i;
  }

  imod(a) {
    const neg = a.negative;

    assert(a.length <= this.w);

    a.negative = 0;

    const q = a.mul(this.b);

    // Shift right by `k` bits.
    this._shift(q);

    a._isub(a, q.mul(this.m));

    if (a.ucmp(this.m) >= 0)
      a._isub(a, this.m);

    if (neg && !a.isZero())
      a._isub(this.m, a);

    a.red = this;

    return a;
  }
}

/**
 * Montgomery Engine
 */

class Mont extends Red {
  constructor(m) {
    super(m);

    // Note that:
    //
    //   mi = (-m^-1 mod (2^(n * 2))) mod r
    //
    // and:
    //
    //   mi = (((2^n)^-1 mod m) * r^-1 - 1) / m
    //
    // are equivalent.
    this.prime = null;
    this.n = this.m.length * 26;
    this.r = BN.shift(1, this.n);
    this.r2 = BN.shift(1, this.n * 2).imod(this.m);
    this.ri = this.r.invert(this.m);
    this.mi = this.r.mul(this.ri).isubn(1).div(this.m);
    this.rib = null;
  }

  get mont() {
    return true;
  }

  convertTo(num) {
    if (num.isNeg() || num.ucmp(this.m) >= 0)
      return this.imod(num.ushln(this.n));

    // Equivalent to: (num * 2^n) mod m
    return this.mul(num, this.r2);
  }

  convertFrom(num) {
    // Equivalent to: num * r^-1 mod m
    const r = this.mul(num, new BN(1));
    r.red = null;
    return r;
  }

  intTo(a) {
    return (a << BigInt(this.n)) % this.mb;
  }

  intFrom(a) {
    if (this.rib === null)
      this.rib = this.ri.toBigInt();

    return (a * this.rib) % this.mb;
  }

  iaddn(a, num) {
    return this.iadd(a, this.convertTo(new BN(num)));
  }

  isubn(a, num) {
    return this.isub(a, this.convertTo(new BN(num)));
  }

  imul(a, b) {
    return this.mul(a, b)._move(a);
  }

  mul(a, b) {
    if (a.isZero() || b.isZero())
      return new BN(0)._forceRed(this);

    const t = a.mul(b);
    const c = t.umaskn(this.n).mul(this.mi).iumaskn(this.n);
    const u = t.iadd(c.mul(this.m)).iushrn(this.n);

    if (u.ucmp(this.m) >= 0)
      u._isub(u, this.m);

    return u._forceRed(this);
  }

  imuln(a, num) {
    this._verify1(a);

    if (a.isZero())
      return a;

    if (num === 0) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    const neg = num < 0;

    if (neg)
      num = -num;

    if (this.m.length === 1)
      num %= this.m.words[0];

    const bits = countBits(num);

    // Potentially compute with additions.
    // This avoids an expensive division.
    if (bits > 5) {
      // Slow case (num > 31).
      this.imul(a, this.convertTo(new BN(num)));
    } else if ((num & (num - 1)) === 0) {
      // Optimize for powers of two.
      for (let i = 0; i < bits - 1; i++)
        this.iadd(a, a);
    } else {
      // Multiply left to right.
      const c = a.clone();

      for (let i = bits - 2; i >= 0; i--) {
        this.iadd(a, a);

        if ((num >> i) & 1)
          this.iadd(a, c);
      }
    }

    if (neg)
      this.ineg(a);

    return a;
  }

  eqn(a, num) {
    this._verify1(a);

    if (num === 0)
      return a.isZero();

    return a.ucmp(this.convertTo(new BN(num))) === 0;
  }

  isLow(a) {
    this._verify1(a);
    return this.convertFrom(a).ucmp(this.m.ushrn(1)) <= 0;
  }

  isOdd(a) {
    this._verify1(a);
    return this.convertFrom(a).isOdd();
  }

  isEven(a) {
    this._verify1(a);
    return this.convertFrom(a).isEven();
  }

  invert(a) {
    this._verify1(a);

    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    return this.imod(a.invert(this.m).mul(this.r2));
  }
}

/*
 * Helpers
 */

function makeError(Error, msg, start) {
  const err = new Error(msg);

  if (Error.captureStackTrace)
    Error.captureStackTrace(err, start);

  return err;
}

function assert(value, message) {
  if (!value) {
    const msg = message || 'Assertion failed.';
    throw makeError(Error, msg, assert);
  }
}

function enforce(value, name, type) {
  if (!value) {
    const msg = `"${name}" must be a(n) ${type}.`;
    throw makeError(TypeError, msg, enforce);
  }
}

function range(value, name) {
  if (!value) {
    const msg = `"${name}" only works with positive numbers.`;
    throw makeError(RangeError, msg, range);
  }
}

function red(value, name) {
  if (!value) {
    const msg = `"${name}" only works with red numbers.`;
    throw makeError(TypeError, msg, red);
  }
}

function nonred(value, name) {
  if (!value) {
    const msg = `"${name}" only works with normal numbers.`;
    throw makeError(TypeError, msg, nonred);
  }
}

function nonzero(value) {
  if (!value) {
    const msg = 'Cannot divide by zero.';
    throw makeError(RangeError, msg, nonzero);
  }
}

class SquareRootError extends Error {
  constructor(result) {
    super();

    this.name = 'SquareRootError';
    this.message = 'X is not a square mod P.';
    this.result = result.fromRed();

    if (Error.captureStackTrace)
      Error.captureStackTrace(this, SquareRootError);
  }
}

function isInteger(num) {
  return Number.isSafeInteger(num);
}

function isSMI(num) {
  return isInteger(num)
      && num >= -0x3ffffff
      && num <= 0x3ffffff;
}

function allocate(ArrayType, size) {
  if (ArrayType.allocUnsafeSlow)
    return ArrayType.allocUnsafeSlow(size);

  return new ArrayType(size);
}

function getBase(base) {
  if (base == null)
    return 10;

  if (typeof base === 'number')
    return base;

  switch (base) {
    case 'bin':
      return 2;
    case 'oct':
      return 8;
    case 'dec':
      return 10;
    case 'hex':
      return 16;
  }

  return 0;
}

/*
 * Internal
 */

function countBits(w) {
  if (Math.clz32)
    return 32 - Math.clz32(w);

  let t = w;
  let r = 0;

  if (t >= 0x1000) {
    r += 13;
    t >>>= 13;
  }

  if (t >= 0x40) {
    r += 7;
    t >>>= 7;
  }

  if (t >= 0x8) {
    r += 4;
    t >>>= 4;
  }

  if (t >= 0x02) {
    r += 2;
    t >>>= 2;
  }

  return r + t;
}

function zeroBits(w) {
  // Shortcut.
  if (w === 0)
    return 26;

  let t = w;
  let r = 0;

  if ((t & 0x1fff) === 0) {
    r += 13;
    t >>>= 13;
  }

  if ((t & 0x7f) === 0) {
    r += 7;
    t >>>= 7;
  }

  if ((t & 0xf) === 0) {
    r += 4;
    t >>>= 4;
  }

  if ((t & 0x3) === 0) {
    r += 2;
    t >>>= 2;
  }

  if ((t & 0x1) === 0)
    r += 1;

  return r;
}

function parseHex(str, start, end) {
  const len = Math.min(str.length, end);

  let r = 0;
  let z = 0;

  for (let i = start; i < len; i++) {
    const c = str.charCodeAt(i) - 48;

    r <<= 4;

    let b;

    if (c >= 49 && c <= 54) {
      // 'a' - 'f'
      b = c - 49 + 0xa;
    } else if (c >= 17 && c <= 22) {
      // 'A' - 'F'
      b = c - 17 + 0xa;
    } else {
      // '0' - '9'
      b = c;
    }

    r |= b;
    z |= b;
  }

  if (z & ~15)
    throw new Error('Invalid string.');

  return r;
}

function parseBase(str, start, end, mul) {
  const len = Math.min(str.length, end);

  let r = 0;

  for (let i = start; i < len; i++) {
    const c = str.charCodeAt(i) - 48;

    r *= mul;

    let b;

    if (c >= 49) {
      // 'a'
      b = c - 49 + 0xa;
    } else if (c >= 17) {
      // 'A'
      b = c - 17 + 0xa;
    } else {
      // '0' - '9'
      b = c;
    }

    if (c < 0 || c > 207 || b >= mul)
      throw new Error('Invalid string.');

    r += b;
  }

  return r;
}

/*
 * Exponentiation (bigint)
 */

function powInt(x, e, m) {
  // Sliding window (odd multiples only).
  const one = BigInt(1);
  const wnd = new Array(WND_SIZE);
  const x2 = (x * x) % m;

  wnd[0] = x;

  for (let i = 1; i < WND_SIZE; i++)
    wnd[i] = (wnd[i - 1] * x2) % m;

  let i = e.bitLength();
  let r = one;

  while (i >= WND_WIDTH) {
    let width = WND_WIDTH;
    let bits = e.bits(i - width, width);

    if (bits < WND_SIZE) {
      r = (r * r) % m;
      i -= 1;
      continue;
    }

    while ((bits & 1) === 0) {
      width -= 1;
      bits >>= 1;
    }

    if (r === one) {
      r = wnd[bits >> 1];
    } else {
      r = sqrn(r, width, m);
      r = (r * wnd[bits >> 1]) % m;
    }

    i -= width;
  }

  if (i > 0) {
    const bits = e.bits(0, i);

    while (i--) {
      r = (r * r) % m;

      if ((bits >> i) & 1)
        r = (r * x) % m;
    }
  }

  return r;
}

function sqrn(x, n, m) {
  for (let i = 0; i < n; i++)
    x = (x * x) % m;
  return x;
}

/*
 * Multiplication
 */

function smallMulTo(self, num, out) {
  const len = self.length + num.length;

  out.negative = self.negative ^ num.negative;
  out._alloc(len);
  out.length = len;

  // Peel one iteration (compiler can't
  // do it, because of code complexity).
  const a = self.words[0];
  const b = num.words[0];
  const r = a * b;
  const lo = r & 0x3ffffff;

  let carry = (r / 0x4000000) | 0;
  let k = 1;

  out.words[0] = lo;

  for (; k < out.length - 1; k++) {
    // Sum all words with the same
    // `i + j = k` and accumulate
    // `ncarry`, note that ncarry
    // could be >= 0x3ffffff.
    let ncarry = carry >>> 26;
    let rword = carry & 0x3ffffff;

    const min = Math.max(0, k - self.length + 1);
    const max = Math.min(k, num.length - 1);

    for (let j = min; j <= max; j++) {
      const i = k - j;
      const a = self.words[i];
      const b = num.words[j];
      const r = a * b + rword;

      ncarry += (r / 0x4000000) | 0;
      rword = r & 0x3ffffff;
    }

    out.words[k] = rword | 0;
    carry = ncarry | 0;
  }

  if (carry !== 0)
    out.words[k] = carry | 0;
  else
    out.length -= 1;

  return out._strip();
}

function bigMulTo(self, num, out) {
  const len = self.length + num.length;

  out.negative = self.negative ^ num.negative;
  out._alloc(len);
  out.length = len;

  let carry = 0;
  let hncarry = 0;
  let k = 0;

  for (; k < out.length - 1; k++) {
    // Sum all words with the same
    // `i + j = k` and accumulate
    // `ncarry`, note that ncarry
    // could be >= 0x3ffffff.
    let ncarry = hncarry;

    hncarry = 0;

    let rword = carry & 0x3ffffff;

    const min = Math.max(0, k - self.length + 1);
    const max = Math.min(k, num.length - 1);

    for (let j = min; j <= max; j++) {
      const i = k - j;
      const a = self.words[i];
      const b = num.words[j];
      const r = a * b;

      let lo = r & 0x3ffffff;

      ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
      lo = (lo + rword) | 0;
      rword = lo & 0x3ffffff;
      ncarry = (ncarry + (lo >>> 26)) | 0;

      hncarry += ncarry >>> 26;
      ncarry &= 0x3ffffff;
    }

    out.words[k] = rword;
    carry = ncarry;
    ncarry = hncarry;
  }

  if (carry !== 0)
    out.words[k] = carry;
  else
    out.length -= 1;

  return out._strip();
}

function jumboMulTo(x, y, out) {
  // v8 has a 2147483519 bit max (~256mb).
  if (!HAS_BIGINT || x.length + y.length > 82595519)
    return bigMulTo(x, y, out);

  const zero = BigInt(0);
  const mask = BigInt(0x3ffffff);
  const shift = BigInt(26);

  let z = x.toBigInt() * y.toBigInt();

  const neg = (z < zero) | 0;

  if (neg)
    z = -z;

  let i = 0;

  while (z > zero) {
    out.words[i++] = Number(z & mask);
    z >>= shift;
  }

  if (i === 0)
    out.words[i++] = 0;

  out.length = i;
  out.negative = neg;

  return out;
}

function comb10MulTo(self, num, out) {
  const a = self.words;
  const b = num.words;
  const o = out.words;
  const a0 = a[0] | 0;
  const al0 = a0 & 0x1fff;
  const ah0 = a0 >>> 13;
  const a1 = a[1] | 0;
  const al1 = a1 & 0x1fff;
  const ah1 = a1 >>> 13;
  const a2 = a[2] | 0;
  const al2 = a2 & 0x1fff;
  const ah2 = a2 >>> 13;
  const a3 = a[3] | 0;
  const al3 = a3 & 0x1fff;
  const ah3 = a3 >>> 13;
  const a4 = a[4] | 0;
  const al4 = a4 & 0x1fff;
  const ah4 = a4 >>> 13;
  const a5 = a[5] | 0;
  const al5 = a5 & 0x1fff;
  const ah5 = a5 >>> 13;
  const a6 = a[6] | 0;
  const al6 = a6 & 0x1fff;
  const ah6 = a6 >>> 13;
  const a7 = a[7] | 0;
  const al7 = a7 & 0x1fff;
  const ah7 = a7 >>> 13;
  const a8 = a[8] | 0;
  const al8 = a8 & 0x1fff;
  const ah8 = a8 >>> 13;
  const a9 = a[9] | 0;
  const al9 = a9 & 0x1fff;
  const ah9 = a9 >>> 13;
  const b0 = b[0] | 0;
  const bl0 = b0 & 0x1fff;
  const bh0 = b0 >>> 13;
  const b1 = b[1] | 0;
  const bl1 = b1 & 0x1fff;
  const bh1 = b1 >>> 13;
  const b2 = b[2] | 0;
  const bl2 = b2 & 0x1fff;
  const bh2 = b2 >>> 13;
  const b3 = b[3] | 0;
  const bl3 = b3 & 0x1fff;
  const bh3 = b3 >>> 13;
  const b4 = b[4] | 0;
  const bl4 = b4 & 0x1fff;
  const bh4 = b4 >>> 13;
  const b5 = b[5] | 0;
  const bl5 = b5 & 0x1fff;
  const bh5 = b5 >>> 13;
  const b6 = b[6] | 0;
  const bl6 = b6 & 0x1fff;
  const bh6 = b6 >>> 13;
  const b7 = b[7] | 0;
  const bl7 = b7 & 0x1fff;
  const bh7 = b7 >>> 13;
  const b8 = b[8] | 0;
  const bl8 = b8 & 0x1fff;
  const bh8 = b8 >>> 13;
  const b9 = b[9] | 0;
  const bl9 = b9 & 0x1fff;
  const bh9 = b9 >>> 13;

  let c = 0;
  let lo, mid, hi;

  out.negative = self.negative ^ num.negative;
  out._alloc(20);
  out.length = 19;

  /* k = 0 */
  lo = Math.imul(al0, bl0);
  mid = Math.imul(al0, bh0);
  mid = (mid + Math.imul(ah0, bl0)) | 0;
  hi = Math.imul(ah0, bh0);

  let w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
  w0 &= 0x3ffffff;

  /* k = 1 */
  lo = Math.imul(al1, bl0);
  mid = Math.imul(al1, bh0);
  mid = (mid + Math.imul(ah1, bl0)) | 0;
  hi = Math.imul(ah1, bh0);
  lo = (lo + Math.imul(al0, bl1)) | 0;
  mid = (mid + Math.imul(al0, bh1)) | 0;
  mid = (mid + Math.imul(ah0, bl1)) | 0;
  hi = (hi + Math.imul(ah0, bh1)) | 0;

  let w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
  w1 &= 0x3ffffff;

  /* k = 2 */
  lo = Math.imul(al2, bl0);
  mid = Math.imul(al2, bh0);
  mid = (mid + Math.imul(ah2, bl0)) | 0;
  hi = Math.imul(ah2, bh0);
  lo = (lo + Math.imul(al1, bl1)) | 0;
  mid = (mid + Math.imul(al1, bh1)) | 0;
  mid = (mid + Math.imul(ah1, bl1)) | 0;
  hi = (hi + Math.imul(ah1, bh1)) | 0;
  lo = (lo + Math.imul(al0, bl2)) | 0;
  mid = (mid + Math.imul(al0, bh2)) | 0;
  mid = (mid + Math.imul(ah0, bl2)) | 0;
  hi = (hi + Math.imul(ah0, bh2)) | 0;

  let w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
  w2 &= 0x3ffffff;

  /* k = 3 */
  lo = Math.imul(al3, bl0);
  mid = Math.imul(al3, bh0);
  mid = (mid + Math.imul(ah3, bl0)) | 0;
  hi = Math.imul(ah3, bh0);
  lo = (lo + Math.imul(al2, bl1)) | 0;
  mid = (mid + Math.imul(al2, bh1)) | 0;
  mid = (mid + Math.imul(ah2, bl1)) | 0;
  hi = (hi + Math.imul(ah2, bh1)) | 0;
  lo = (lo + Math.imul(al1, bl2)) | 0;
  mid = (mid + Math.imul(al1, bh2)) | 0;
  mid = (mid + Math.imul(ah1, bl2)) | 0;
  hi = (hi + Math.imul(ah1, bh2)) | 0;
  lo = (lo + Math.imul(al0, bl3)) | 0;
  mid = (mid + Math.imul(al0, bh3)) | 0;
  mid = (mid + Math.imul(ah0, bl3)) | 0;
  hi = (hi + Math.imul(ah0, bh3)) | 0;

  let w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
  w3 &= 0x3ffffff;

  /* k = 4 */
  lo = Math.imul(al4, bl0);
  mid = Math.imul(al4, bh0);
  mid = (mid + Math.imul(ah4, bl0)) | 0;
  hi = Math.imul(ah4, bh0);
  lo = (lo + Math.imul(al3, bl1)) | 0;
  mid = (mid + Math.imul(al3, bh1)) | 0;
  mid = (mid + Math.imul(ah3, bl1)) | 0;
  hi = (hi + Math.imul(ah3, bh1)) | 0;
  lo = (lo + Math.imul(al2, bl2)) | 0;
  mid = (mid + Math.imul(al2, bh2)) | 0;
  mid = (mid + Math.imul(ah2, bl2)) | 0;
  hi = (hi + Math.imul(ah2, bh2)) | 0;
  lo = (lo + Math.imul(al1, bl3)) | 0;
  mid = (mid + Math.imul(al1, bh3)) | 0;
  mid = (mid + Math.imul(ah1, bl3)) | 0;
  hi = (hi + Math.imul(ah1, bh3)) | 0;
  lo = (lo + Math.imul(al0, bl4)) | 0;
  mid = (mid + Math.imul(al0, bh4)) | 0;
  mid = (mid + Math.imul(ah0, bl4)) | 0;
  hi = (hi + Math.imul(ah0, bh4)) | 0;

  let w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
  w4 &= 0x3ffffff;

  /* k = 5 */
  lo = Math.imul(al5, bl0);
  mid = Math.imul(al5, bh0);
  mid = (mid + Math.imul(ah5, bl0)) | 0;
  hi = Math.imul(ah5, bh0);
  lo = (lo + Math.imul(al4, bl1)) | 0;
  mid = (mid + Math.imul(al4, bh1)) | 0;
  mid = (mid + Math.imul(ah4, bl1)) | 0;
  hi = (hi + Math.imul(ah4, bh1)) | 0;
  lo = (lo + Math.imul(al3, bl2)) | 0;
  mid = (mid + Math.imul(al3, bh2)) | 0;
  mid = (mid + Math.imul(ah3, bl2)) | 0;
  hi = (hi + Math.imul(ah3, bh2)) | 0;
  lo = (lo + Math.imul(al2, bl3)) | 0;
  mid = (mid + Math.imul(al2, bh3)) | 0;
  mid = (mid + Math.imul(ah2, bl3)) | 0;
  hi = (hi + Math.imul(ah2, bh3)) | 0;
  lo = (lo + Math.imul(al1, bl4)) | 0;
  mid = (mid + Math.imul(al1, bh4)) | 0;
  mid = (mid + Math.imul(ah1, bl4)) | 0;
  hi = (hi + Math.imul(ah1, bh4)) | 0;
  lo = (lo + Math.imul(al0, bl5)) | 0;
  mid = (mid + Math.imul(al0, bh5)) | 0;
  mid = (mid + Math.imul(ah0, bl5)) | 0;
  hi = (hi + Math.imul(ah0, bh5)) | 0;

  let w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
  w5 &= 0x3ffffff;

  /* k = 6 */
  lo = Math.imul(al6, bl0);
  mid = Math.imul(al6, bh0);
  mid = (mid + Math.imul(ah6, bl0)) | 0;
  hi = Math.imul(ah6, bh0);
  lo = (lo + Math.imul(al5, bl1)) | 0;
  mid = (mid + Math.imul(al5, bh1)) | 0;
  mid = (mid + Math.imul(ah5, bl1)) | 0;
  hi = (hi + Math.imul(ah5, bh1)) | 0;
  lo = (lo + Math.imul(al4, bl2)) | 0;
  mid = (mid + Math.imul(al4, bh2)) | 0;
  mid = (mid + Math.imul(ah4, bl2)) | 0;
  hi = (hi + Math.imul(ah4, bh2)) | 0;
  lo = (lo + Math.imul(al3, bl3)) | 0;
  mid = (mid + Math.imul(al3, bh3)) | 0;
  mid = (mid + Math.imul(ah3, bl3)) | 0;
  hi = (hi + Math.imul(ah3, bh3)) | 0;
  lo = (lo + Math.imul(al2, bl4)) | 0;
  mid = (mid + Math.imul(al2, bh4)) | 0;
  mid = (mid + Math.imul(ah2, bl4)) | 0;
  hi = (hi + Math.imul(ah2, bh4)) | 0;
  lo = (lo + Math.imul(al1, bl5)) | 0;
  mid = (mid + Math.imul(al1, bh5)) | 0;
  mid = (mid + Math.imul(ah1, bl5)) | 0;
  hi = (hi + Math.imul(ah1, bh5)) | 0;
  lo = (lo + Math.imul(al0, bl6)) | 0;
  mid = (mid + Math.imul(al0, bh6)) | 0;
  mid = (mid + Math.imul(ah0, bl6)) | 0;
  hi = (hi + Math.imul(ah0, bh6)) | 0;

  let w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
  w6 &= 0x3ffffff;

  /* k = 7 */
  lo = Math.imul(al7, bl0);
  mid = Math.imul(al7, bh0);
  mid = (mid + Math.imul(ah7, bl0)) | 0;
  hi = Math.imul(ah7, bh0);
  lo = (lo + Math.imul(al6, bl1)) | 0;
  mid = (mid + Math.imul(al6, bh1)) | 0;
  mid = (mid + Math.imul(ah6, bl1)) | 0;
  hi = (hi + Math.imul(ah6, bh1)) | 0;
  lo = (lo + Math.imul(al5, bl2)) | 0;
  mid = (mid + Math.imul(al5, bh2)) | 0;
  mid = (mid + Math.imul(ah5, bl2)) | 0;
  hi = (hi + Math.imul(ah5, bh2)) | 0;
  lo = (lo + Math.imul(al4, bl3)) | 0;
  mid = (mid + Math.imul(al4, bh3)) | 0;
  mid = (mid + Math.imul(ah4, bl3)) | 0;
  hi = (hi + Math.imul(ah4, bh3)) | 0;
  lo = (lo + Math.imul(al3, bl4)) | 0;
  mid = (mid + Math.imul(al3, bh4)) | 0;
  mid = (mid + Math.imul(ah3, bl4)) | 0;
  hi = (hi + Math.imul(ah3, bh4)) | 0;
  lo = (lo + Math.imul(al2, bl5)) | 0;
  mid = (mid + Math.imul(al2, bh5)) | 0;
  mid = (mid + Math.imul(ah2, bl5)) | 0;
  hi = (hi + Math.imul(ah2, bh5)) | 0;
  lo = (lo + Math.imul(al1, bl6)) | 0;
  mid = (mid + Math.imul(al1, bh6)) | 0;
  mid = (mid + Math.imul(ah1, bl6)) | 0;
  hi = (hi + Math.imul(ah1, bh6)) | 0;
  lo = (lo + Math.imul(al0, bl7)) | 0;
  mid = (mid + Math.imul(al0, bh7)) | 0;
  mid = (mid + Math.imul(ah0, bl7)) | 0;
  hi = (hi + Math.imul(ah0, bh7)) | 0;

  let w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
  w7 &= 0x3ffffff;

  /* k = 8 */
  lo = Math.imul(al8, bl0);
  mid = Math.imul(al8, bh0);
  mid = (mid + Math.imul(ah8, bl0)) | 0;
  hi = Math.imul(ah8, bh0);
  lo = (lo + Math.imul(al7, bl1)) | 0;
  mid = (mid + Math.imul(al7, bh1)) | 0;
  mid = (mid + Math.imul(ah7, bl1)) | 0;
  hi = (hi + Math.imul(ah7, bh1)) | 0;
  lo = (lo + Math.imul(al6, bl2)) | 0;
  mid = (mid + Math.imul(al6, bh2)) | 0;
  mid = (mid + Math.imul(ah6, bl2)) | 0;
  hi = (hi + Math.imul(ah6, bh2)) | 0;
  lo = (lo + Math.imul(al5, bl3)) | 0;
  mid = (mid + Math.imul(al5, bh3)) | 0;
  mid = (mid + Math.imul(ah5, bl3)) | 0;
  hi = (hi + Math.imul(ah5, bh3)) | 0;
  lo = (lo + Math.imul(al4, bl4)) | 0;
  mid = (mid + Math.imul(al4, bh4)) | 0;
  mid = (mid + Math.imul(ah4, bl4)) | 0;
  hi = (hi + Math.imul(ah4, bh4)) | 0;
  lo = (lo + Math.imul(al3, bl5)) | 0;
  mid = (mid + Math.imul(al3, bh5)) | 0;
  mid = (mid + Math.imul(ah3, bl5)) | 0;
  hi = (hi + Math.imul(ah3, bh5)) | 0;
  lo = (lo + Math.imul(al2, bl6)) | 0;
  mid = (mid + Math.imul(al2, bh6)) | 0;
  mid = (mid + Math.imul(ah2, bl6)) | 0;
  hi = (hi + Math.imul(ah2, bh6)) | 0;
  lo = (lo + Math.imul(al1, bl7)) | 0;
  mid = (mid + Math.imul(al1, bh7)) | 0;
  mid = (mid + Math.imul(ah1, bl7)) | 0;
  hi = (hi + Math.imul(ah1, bh7)) | 0;
  lo = (lo + Math.imul(al0, bl8)) | 0;
  mid = (mid + Math.imul(al0, bh8)) | 0;
  mid = (mid + Math.imul(ah0, bl8)) | 0;
  hi = (hi + Math.imul(ah0, bh8)) | 0;

  let w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
  w8 &= 0x3ffffff;

  /* k = 9 */
  lo = Math.imul(al9, bl0);
  mid = Math.imul(al9, bh0);
  mid = (mid + Math.imul(ah9, bl0)) | 0;
  hi = Math.imul(ah9, bh0);
  lo = (lo + Math.imul(al8, bl1)) | 0;
  mid = (mid + Math.imul(al8, bh1)) | 0;
  mid = (mid + Math.imul(ah8, bl1)) | 0;
  hi = (hi + Math.imul(ah8, bh1)) | 0;
  lo = (lo + Math.imul(al7, bl2)) | 0;
  mid = (mid + Math.imul(al7, bh2)) | 0;
  mid = (mid + Math.imul(ah7, bl2)) | 0;
  hi = (hi + Math.imul(ah7, bh2)) | 0;
  lo = (lo + Math.imul(al6, bl3)) | 0;
  mid = (mid + Math.imul(al6, bh3)) | 0;
  mid = (mid + Math.imul(ah6, bl3)) | 0;
  hi = (hi + Math.imul(ah6, bh3)) | 0;
  lo = (lo + Math.imul(al5, bl4)) | 0;
  mid = (mid + Math.imul(al5, bh4)) | 0;
  mid = (mid + Math.imul(ah5, bl4)) | 0;
  hi = (hi + Math.imul(ah5, bh4)) | 0;
  lo = (lo + Math.imul(al4, bl5)) | 0;
  mid = (mid + Math.imul(al4, bh5)) | 0;
  mid = (mid + Math.imul(ah4, bl5)) | 0;
  hi = (hi + Math.imul(ah4, bh5)) | 0;
  lo = (lo + Math.imul(al3, bl6)) | 0;
  mid = (mid + Math.imul(al3, bh6)) | 0;
  mid = (mid + Math.imul(ah3, bl6)) | 0;
  hi = (hi + Math.imul(ah3, bh6)) | 0;
  lo = (lo + Math.imul(al2, bl7)) | 0;
  mid = (mid + Math.imul(al2, bh7)) | 0;
  mid = (mid + Math.imul(ah2, bl7)) | 0;
  hi = (hi + Math.imul(ah2, bh7)) | 0;
  lo = (lo + Math.imul(al1, bl8)) | 0;
  mid = (mid + Math.imul(al1, bh8)) | 0;
  mid = (mid + Math.imul(ah1, bl8)) | 0;
  hi = (hi + Math.imul(ah1, bh8)) | 0;
  lo = (lo + Math.imul(al0, bl9)) | 0;
  mid = (mid + Math.imul(al0, bh9)) | 0;
  mid = (mid + Math.imul(ah0, bl9)) | 0;
  hi = (hi + Math.imul(ah0, bh9)) | 0;

  let w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
  w9 &= 0x3ffffff;

  /* k = 10 */
  lo = Math.imul(al9, bl1);
  mid = Math.imul(al9, bh1);
  mid = (mid + Math.imul(ah9, bl1)) | 0;
  hi = Math.imul(ah9, bh1);
  lo = (lo + Math.imul(al8, bl2)) | 0;
  mid = (mid + Math.imul(al8, bh2)) | 0;
  mid = (mid + Math.imul(ah8, bl2)) | 0;
  hi = (hi + Math.imul(ah8, bh2)) | 0;
  lo = (lo + Math.imul(al7, bl3)) | 0;
  mid = (mid + Math.imul(al7, bh3)) | 0;
  mid = (mid + Math.imul(ah7, bl3)) | 0;
  hi = (hi + Math.imul(ah7, bh3)) | 0;
  lo = (lo + Math.imul(al6, bl4)) | 0;
  mid = (mid + Math.imul(al6, bh4)) | 0;
  mid = (mid + Math.imul(ah6, bl4)) | 0;
  hi = (hi + Math.imul(ah6, bh4)) | 0;
  lo = (lo + Math.imul(al5, bl5)) | 0;
  mid = (mid + Math.imul(al5, bh5)) | 0;
  mid = (mid + Math.imul(ah5, bl5)) | 0;
  hi = (hi + Math.imul(ah5, bh5)) | 0;
  lo = (lo + Math.imul(al4, bl6)) | 0;
  mid = (mid + Math.imul(al4, bh6)) | 0;
  mid = (mid + Math.imul(ah4, bl6)) | 0;
  hi = (hi + Math.imul(ah4, bh6)) | 0;
  lo = (lo + Math.imul(al3, bl7)) | 0;
  mid = (mid + Math.imul(al3, bh7)) | 0;
  mid = (mid + Math.imul(ah3, bl7)) | 0;
  hi = (hi + Math.imul(ah3, bh7)) | 0;
  lo = (lo + Math.imul(al2, bl8)) | 0;
  mid = (mid + Math.imul(al2, bh8)) | 0;
  mid = (mid + Math.imul(ah2, bl8)) | 0;
  hi = (hi + Math.imul(ah2, bh8)) | 0;
  lo = (lo + Math.imul(al1, bl9)) | 0;
  mid = (mid + Math.imul(al1, bh9)) | 0;
  mid = (mid + Math.imul(ah1, bl9)) | 0;
  hi = (hi + Math.imul(ah1, bh9)) | 0;

  let w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
  w10 &= 0x3ffffff;

  /* k = 11 */
  lo = Math.imul(al9, bl2);
  mid = Math.imul(al9, bh2);
  mid = (mid + Math.imul(ah9, bl2)) | 0;
  hi = Math.imul(ah9, bh2);
  lo = (lo + Math.imul(al8, bl3)) | 0;
  mid = (mid + Math.imul(al8, bh3)) | 0;
  mid = (mid + Math.imul(ah8, bl3)) | 0;
  hi = (hi + Math.imul(ah8, bh3)) | 0;
  lo = (lo + Math.imul(al7, bl4)) | 0;
  mid = (mid + Math.imul(al7, bh4)) | 0;
  mid = (mid + Math.imul(ah7, bl4)) | 0;
  hi = (hi + Math.imul(ah7, bh4)) | 0;
  lo = (lo + Math.imul(al6, bl5)) | 0;
  mid = (mid + Math.imul(al6, bh5)) | 0;
  mid = (mid + Math.imul(ah6, bl5)) | 0;
  hi = (hi + Math.imul(ah6, bh5)) | 0;
  lo = (lo + Math.imul(al5, bl6)) | 0;
  mid = (mid + Math.imul(al5, bh6)) | 0;
  mid = (mid + Math.imul(ah5, bl6)) | 0;
  hi = (hi + Math.imul(ah5, bh6)) | 0;
  lo = (lo + Math.imul(al4, bl7)) | 0;
  mid = (mid + Math.imul(al4, bh7)) | 0;
  mid = (mid + Math.imul(ah4, bl7)) | 0;
  hi = (hi + Math.imul(ah4, bh7)) | 0;
  lo = (lo + Math.imul(al3, bl8)) | 0;
  mid = (mid + Math.imul(al3, bh8)) | 0;
  mid = (mid + Math.imul(ah3, bl8)) | 0;
  hi = (hi + Math.imul(ah3, bh8)) | 0;
  lo = (lo + Math.imul(al2, bl9)) | 0;
  mid = (mid + Math.imul(al2, bh9)) | 0;
  mid = (mid + Math.imul(ah2, bl9)) | 0;
  hi = (hi + Math.imul(ah2, bh9)) | 0;

  let w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
  w11 &= 0x3ffffff;

  /* k = 12 */
  lo = Math.imul(al9, bl3);
  mid = Math.imul(al9, bh3);
  mid = (mid + Math.imul(ah9, bl3)) | 0;
  hi = Math.imul(ah9, bh3);
  lo = (lo + Math.imul(al8, bl4)) | 0;
  mid = (mid + Math.imul(al8, bh4)) | 0;
  mid = (mid + Math.imul(ah8, bl4)) | 0;
  hi = (hi + Math.imul(ah8, bh4)) | 0;
  lo = (lo + Math.imul(al7, bl5)) | 0;
  mid = (mid + Math.imul(al7, bh5)) | 0;
  mid = (mid + Math.imul(ah7, bl5)) | 0;
  hi = (hi + Math.imul(ah7, bh5)) | 0;
  lo = (lo + Math.imul(al6, bl6)) | 0;
  mid = (mid + Math.imul(al6, bh6)) | 0;
  mid = (mid + Math.imul(ah6, bl6)) | 0;
  hi = (hi + Math.imul(ah6, bh6)) | 0;
  lo = (lo + Math.imul(al5, bl7)) | 0;
  mid = (mid + Math.imul(al5, bh7)) | 0;
  mid = (mid + Math.imul(ah5, bl7)) | 0;
  hi = (hi + Math.imul(ah5, bh7)) | 0;
  lo = (lo + Math.imul(al4, bl8)) | 0;
  mid = (mid + Math.imul(al4, bh8)) | 0;
  mid = (mid + Math.imul(ah4, bl8)) | 0;
  hi = (hi + Math.imul(ah4, bh8)) | 0;
  lo = (lo + Math.imul(al3, bl9)) | 0;
  mid = (mid + Math.imul(al3, bh9)) | 0;
  mid = (mid + Math.imul(ah3, bl9)) | 0;
  hi = (hi + Math.imul(ah3, bh9)) | 0;

  let w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
  w12 &= 0x3ffffff;

  /* k = 13 */
  lo = Math.imul(al9, bl4);
  mid = Math.imul(al9, bh4);
  mid = (mid + Math.imul(ah9, bl4)) | 0;
  hi = Math.imul(ah9, bh4);
  lo = (lo + Math.imul(al8, bl5)) | 0;
  mid = (mid + Math.imul(al8, bh5)) | 0;
  mid = (mid + Math.imul(ah8, bl5)) | 0;
  hi = (hi + Math.imul(ah8, bh5)) | 0;
  lo = (lo + Math.imul(al7, bl6)) | 0;
  mid = (mid + Math.imul(al7, bh6)) | 0;
  mid = (mid + Math.imul(ah7, bl6)) | 0;
  hi = (hi + Math.imul(ah7, bh6)) | 0;
  lo = (lo + Math.imul(al6, bl7)) | 0;
  mid = (mid + Math.imul(al6, bh7)) | 0;
  mid = (mid + Math.imul(ah6, bl7)) | 0;
  hi = (hi + Math.imul(ah6, bh7)) | 0;
  lo = (lo + Math.imul(al5, bl8)) | 0;
  mid = (mid + Math.imul(al5, bh8)) | 0;
  mid = (mid + Math.imul(ah5, bl8)) | 0;
  hi = (hi + Math.imul(ah5, bh8)) | 0;
  lo = (lo + Math.imul(al4, bl9)) | 0;
  mid = (mid + Math.imul(al4, bh9)) | 0;
  mid = (mid + Math.imul(ah4, bl9)) | 0;
  hi = (hi + Math.imul(ah4, bh9)) | 0;

  let w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
  w13 &= 0x3ffffff;

  /* k = 14 */
  lo = Math.imul(al9, bl5);
  mid = Math.imul(al9, bh5);
  mid = (mid + Math.imul(ah9, bl5)) | 0;
  hi = Math.imul(ah9, bh5);
  lo = (lo + Math.imul(al8, bl6)) | 0;
  mid = (mid + Math.imul(al8, bh6)) | 0;
  mid = (mid + Math.imul(ah8, bl6)) | 0;
  hi = (hi + Math.imul(ah8, bh6)) | 0;
  lo = (lo + Math.imul(al7, bl7)) | 0;
  mid = (mid + Math.imul(al7, bh7)) | 0;
  mid = (mid + Math.imul(ah7, bl7)) | 0;
  hi = (hi + Math.imul(ah7, bh7)) | 0;
  lo = (lo + Math.imul(al6, bl8)) | 0;
  mid = (mid + Math.imul(al6, bh8)) | 0;
  mid = (mid + Math.imul(ah6, bl8)) | 0;
  hi = (hi + Math.imul(ah6, bh8)) | 0;
  lo = (lo + Math.imul(al5, bl9)) | 0;
  mid = (mid + Math.imul(al5, bh9)) | 0;
  mid = (mid + Math.imul(ah5, bl9)) | 0;
  hi = (hi + Math.imul(ah5, bh9)) | 0;

  let w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
  w14 &= 0x3ffffff;

  /* k = 15 */
  lo = Math.imul(al9, bl6);
  mid = Math.imul(al9, bh6);
  mid = (mid + Math.imul(ah9, bl6)) | 0;
  hi = Math.imul(ah9, bh6);
  lo = (lo + Math.imul(al8, bl7)) | 0;
  mid = (mid + Math.imul(al8, bh7)) | 0;
  mid = (mid + Math.imul(ah8, bl7)) | 0;
  hi = (hi + Math.imul(ah8, bh7)) | 0;
  lo = (lo + Math.imul(al7, bl8)) | 0;
  mid = (mid + Math.imul(al7, bh8)) | 0;
  mid = (mid + Math.imul(ah7, bl8)) | 0;
  hi = (hi + Math.imul(ah7, bh8)) | 0;
  lo = (lo + Math.imul(al6, bl9)) | 0;
  mid = (mid + Math.imul(al6, bh9)) | 0;
  mid = (mid + Math.imul(ah6, bl9)) | 0;
  hi = (hi + Math.imul(ah6, bh9)) | 0;

  let w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
  w15 &= 0x3ffffff;

  /* k = 16 */
  lo = Math.imul(al9, bl7);
  mid = Math.imul(al9, bh7);
  mid = (mid + Math.imul(ah9, bl7)) | 0;
  hi = Math.imul(ah9, bh7);
  lo = (lo + Math.imul(al8, bl8)) | 0;
  mid = (mid + Math.imul(al8, bh8)) | 0;
  mid = (mid + Math.imul(ah8, bl8)) | 0;
  hi = (hi + Math.imul(ah8, bh8)) | 0;
  lo = (lo + Math.imul(al7, bl9)) | 0;
  mid = (mid + Math.imul(al7, bh9)) | 0;
  mid = (mid + Math.imul(ah7, bl9)) | 0;
  hi = (hi + Math.imul(ah7, bh9)) | 0;

  let w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
  w16 &= 0x3ffffff;

  /* k = 17 */
  lo = Math.imul(al9, bl8);
  mid = Math.imul(al9, bh8);
  mid = (mid + Math.imul(ah9, bl8)) | 0;
  hi = Math.imul(ah9, bh8);
  lo = (lo + Math.imul(al8, bl9)) | 0;
  mid = (mid + Math.imul(al8, bh9)) | 0;
  mid = (mid + Math.imul(ah8, bl9)) | 0;
  hi = (hi + Math.imul(ah8, bh9)) | 0;

  let w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
  w17 &= 0x3ffffff;

  /* k = 18 */
  lo = Math.imul(al9, bl9);
  mid = Math.imul(al9, bh9);
  mid = (mid + Math.imul(ah9, bl9)) | 0;
  hi = Math.imul(ah9, bh9);

  let w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
  w18 &= 0x3ffffff;

  o[0] = w0;
  o[1] = w1;
  o[2] = w2;
  o[3] = w3;
  o[4] = w4;
  o[5] = w5;
  o[6] = w6;
  o[7] = w7;
  o[8] = w8;
  o[9] = w9;
  o[10] = w10;
  o[11] = w11;
  o[12] = w12;
  o[13] = w13;
  o[14] = w14;
  o[15] = w15;
  o[16] = w16;
  o[17] = w17;
  o[18] = w18;

  if (c !== 0) {
    o[19] = c;
    out.length += 1;
  }

  // Note: we shouldn't need to strip here.
  return out;
}

// Polyfill comb.
if (!Math.imul)
  comb10MulTo = smallMulTo;

/*
 * Expose
 */

BN.Red = Red;

module.exports = BN;
}],
[/* 44 */ 'bcrypto', '/lib/internal/custom-browser.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * custom.js - custom inspect symbol for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */



exports.custom = 'inspect';
}],
[/* 45 */ 'bcrypto', '/lib/random-browser.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * random.js - random for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */



module.exports = __browser_require__(46 /* './js/random' */, module);
}],
[/* 46 */ 'bcrypto', '/lib/js/random.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * random.js - random number generator for bcrypto
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://wiki.openssl.org/index.php/Random_Numbers
 *   https://csrc.nist.gov/projects/random-bit-generation/
 *   http://www.pcg-random.org/posts/bounded-rands.html
 *   https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
 */



const assert = __browser_require__(24 /* '../internal/assert' */, module);

/*
 * Constants
 */

const crypto = global.crypto || global.msCrypto;
const HAS_CRYPTO = crypto && typeof crypto.getRandomValues === 'function';
const randomValues = HAS_CRYPTO ? crypto.getRandomValues.bind(crypto) : null;
const pool = new Uint32Array(16);
const MAX_BYTES = 65536;

let poolPos = 0;

/**
 * Generate pseudo-random bytes.
 * @param {Number} size
 * @returns {Buffer}
 */

function randomBytes(size) {
  assert((size >>> 0) === size);

  const data = Buffer.alloc(size);

  randomFillSync(data, 0, size);

  return data;
}

/**
 * Generate pseudo-random bytes.
 * @param {Buffer} data
 * @param {Number} [off=0]
 * @param {Number} [size=data.length-off]
 * @returns {Buffer}
 */

function randomFill(data, off, size) {
  assert((data != null && data._isBuffer === true));

  if (off == null)
    off = 0;

  assert((off >>> 0) === off);

  if (size == null)
    size = data.length - off;

  assert((size >>> 0) === size);
  assert(off + size <= data.length);

  randomFillSync(data, off, size);

  return data;
}

/**
 * Generate a random uint32.
 * @returns {Number}
 */

function randomInt() {
  if ((poolPos & 15) === 0) {
    getRandomValues(pool);
    poolPos = 0;
  }

  return pool[poolPos++];
}

/**
 * Generate a random uint32 within a range.
 * @param {Number} min - Inclusive.
 * @param {Number} max - Exclusive.
 * @returns {Number}
 */

function randomRange(min, max) {
  assert((min >>> 0) === min);
  assert((max >>> 0) === max);
  assert(max >= min);

  const space = max - min;

  if (space === 0)
    return min;

  const top = -space >>> 0;

  let x, r;

  do {
    x = randomInt();
    r = x % space;
  } while (x - r > top);

  return r + min;
}

/*
 * Helpers
 */

function getRandomValues(array) {
  if (!HAS_CRYPTO)
    throw new Error('Entropy source not available.');

  return randomValues(array);
}

function randomFillSync(data, off, size) {
  assert((data != null && data._isBuffer === true));
  assert(data.buffer instanceof ArrayBuffer);
  assert((data.byteOffset >>> 0) === data.byteOffset);
  assert((data.byteLength >>> 0) === data.byteLength);
  assert((off >>> 0) === off);
  assert((size >>> 0) === size);
  assert(off + size <= data.byteLength);

  if (size > 2 ** 31 - 1)
    throw new RangeError('The value "size" is out of range.');

  const offset = data.byteOffset + off;
  const array = new Uint8Array(data.buffer, offset, size);

  if (array.length > MAX_BYTES) {
    for (let i = 0; i < array.length; i += MAX_BYTES) {
      let j = i + MAX_BYTES;

      if (j > array.length)
        j = array.length;

      getRandomValues(array.subarray(i, j));
    }
  } else {
    if (array.length > 0)
      getRandomValues(array);
  }
}

/*
 * Expose
 */

exports.native = 0;
exports.randomBytes = randomBytes;
exports.randomFill = randomFill;
exports.randomInt = randomInt;
exports.randomRange = randomRange;
}],
[/* 47 */ 'bcrypto', '/lib/hmac-drbg-browser.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * hmac-drbg.js - hmac-drbg for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */



module.exports = __browser_require__(48 /* './js/hmac-drbg' */, module);
}],
[/* 48 */ 'bcrypto', '/lib/js/hmac-drbg.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * hmac-drbg.js - hmac-drbg implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hmac-drbg:
 *   Copyright Fedor Indutny, 2017.
 *   https://github.com/indutny/hmac-drbg
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc6979
 *   https://csrc.nist.gov/publications/detail/sp/800-90a/archive/2012-01-23
 *   https://github.com/indutny/hmac-drbg/blob/master/lib/hmac-drbg.js
 */



const assert = __browser_require__(24 /* '../internal/assert' */, module);

/*
 * Constants
 */

const RESEED_INTERVAL = 0x1000000000000;
const ZERO = Buffer.from([0x00]);
const ONE = Buffer.from([0x01]);

/**
 * HmacDRBG
 */

class HmacDRBG {
  constructor(hash, entropy, nonce, pers) {
    assert(hash && typeof hash.id === 'string');

    this.hash = hash;
    this.minEntropy = hash.id === 'SHA1' ? 10 : 24;

    this.K = Buffer.alloc(hash.size);
    this.V = Buffer.alloc(hash.size);
    this.rounds = 0;

    if (entropy)
      this.init(entropy, nonce, pers);
  }

  init(entropy, nonce, pers) {
    if (nonce == null)
      nonce = Buffer.alloc(0);

    if (pers == null)
      pers = Buffer.alloc(0);

    assert((entropy != null && entropy._isBuffer === true));
    assert((nonce != null && nonce._isBuffer === true));
    assert((pers != null && pers._isBuffer === true));

    for (let i = 0; i < this.V.length; i++) {
      this.K[i] = 0x00;
      this.V[i] = 0x01;
    }

    const seed = Buffer.concat([entropy, nonce, pers]);

    if (seed.length < this.minEntropy)
      throw new Error('Not enough entropy.');

    this.update(seed);
    this.rounds = 1;

    return this;
  }

  reseed(entropy, add) {
    if (add == null)
      add = Buffer.alloc(0);

    assert((entropy != null && entropy._isBuffer === true));
    assert((add != null && add._isBuffer === true));

    if (this.rounds === 0)
      throw new Error('DRBG not initialized.');

    const seed = Buffer.concat([entropy, add]);

    if (seed.length < this.minEntropy)
     throw new Error('Not enough entropy.');

    this.update(seed);
    this.rounds = 1;

    return this;
  }

  generate(len, add) {
    assert((len >>> 0) === len);
    assert(add == null || (add != null && add._isBuffer === true));

    if (this.rounds === 0)
      throw new Error('DRBG not initialized.');

    if (this.rounds > RESEED_INTERVAL)
      throw new Error('Reseed is required.');

    if (add && add.length > 0)
      this.update(add);

    const blocks = Math.ceil(len / this.hash.size);
    const out = Buffer.alloc(blocks * this.hash.size);

    for (let i = 0; i < blocks; i++) {
      this.V = this.mac(this.V);
      this.V.copy(out, i * this.hash.size);
    }

    this.update(add);
    this.rounds += 1;

    return out.slice(0, len);
  }

  randomBytes(size) {
    return this.generate(size);
  }

  /*
   * Helpers
   */

  mac(data) {
    return this.hash.mac(data, this.K);
  }

  hmac() {
    return this.hash.hmac().init(this.K);
  }

  update(seed) {
    assert(seed == null || (seed != null && seed._isBuffer === true));

    const kmac = this.hmac();

    kmac.update(this.V);
    kmac.update(ZERO);

    if (seed)
      kmac.update(seed);

    this.K = kmac.final();
    this.V = this.mac(this.V);

    if (seed && seed.length > 0) {
      const kmac = this.hmac();

      kmac.update(this.V);
      kmac.update(ONE);
      kmac.update(seed);

      this.K = kmac.final();
      this.V = this.mac(this.V);
    }

    return this;
  }
}

/*
 * Static
 */

HmacDRBG.native = 0;

/*
 * Expose
 */

module.exports = HmacDRBG;
}],
[/* 49 */ 'bcrypto', '/lib/internal/primes.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * primes.js - Prime number generation for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Parts of this software are based on indutny/miller-rabin:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/miller-rabin
 *
 * Resources:
 *   https://github.com/golang/go/blob/master/src/crypto/rsa/rsa.go
 *   https://github.com/golang/go/blob/master/src/math/big/prime.go
 *   https://github.com/golang/go/blob/master/src/math/big/int.go
 *   https://github.com/golang/go/blob/master/src/math/big/nat.go
 *   https://github.com/golang/go/blob/master/src/crypto/rand/util.go
 *   https://github.com/indutny/miller-rabin/blob/master/lib/mr.js
 */



const assert = __browser_require__(24 /* '../internal/assert' */, module);
const BN = __browser_require__(42 /* '../bn' */, module);
const random = __browser_require__(45 /* '../random' */, module);

/*
 * Constants
 */

const smallPrimes = new Uint8Array([
   3,  5,  7,
  11, 13, 17,
  19, 23, 29,
  31, 37, 41,
  43, 47, 53
]);

const smallPrimesProduct = new BN('16294579238595022365', 10);

const primeBitMaskLo = 0
  | (1 << 2)
  | (1 << 3)
  | (1 << 5)
  | (1 << 7)
  | (1 << 11)
  | (1 << 13)
  | (1 << 17)
  | (1 << 19)
  | (1 << 23)
  | (1 << 29)
  | (1 << 31);

const primeBitMaskHi = 0
  | (1 << (37 - 32))
  | (1 << (41 - 32))
  | (1 << (43 - 32))
  | (1 << (47 - 32))
  | (1 << (53 - 32))
  | (1 << (59 - 32))
  | (1 << (61 - 32));

const primesA = new BN(3 * 5 * 7 * 11 * 13 * 17 * 19 * 23 * 37);
const primesB = new BN(29 * 31 * 41 * 43 * 47 * 53);

/*
 * Primality
 */

function randomPrime(bits, reps = 20, rng = random) {
  assert((bits >>> 0) === bits);
  assert((reps >>> 0) === reps);
  assert(rng != null);

  if (bits < 2)
    throw new Error('Prime must be at least 2 bits.');

  for (;;) {
    const p = BN.randomBits(rng, bits);

    p.setn(bits - 1, 1);
    p.setn(bits - 2, 1);
    p.setn(0, 1);

    const mod = p.mod(smallPrimesProduct);

next:
    for (let delta = 0; delta < (1 << 20); delta += 2) {
      const m = mod.addn(delta);

      for (let i = 0; i < smallPrimes.length; i++) {
        const prime = smallPrimes[i];

        if (m.modrn(prime) === 0 && (bits > 6 || m.cmpn(prime) !== 0))
          continue next;
      }

      p.iaddn(delta);

      break;
    }

    if (p.bitLength() !== bits)
      continue;

    if (!isProbablePrime(p, reps, rng))
      continue;

    return p;
  }
}

function isProbablePrime(x, reps, rng = random) {
  assert(x instanceof BN);

  if (x.sign() <= 0)
    return false;

  if (x.cmpn(64) < 0) {
    const w = x.word(0);

    if (w > 31)
      return (primeBitMaskHi & (1 << (w - 32))) !== 0;

    return (primeBitMaskLo & (1 << w)) !== 0;
  }

  if (x.isEven())
    return false;

  const ra = x.mod(primesA).toNumber();
  const rb = x.mod(primesB).toNumber();

  if (ra % 3 === 0
      || ra % 5 === 0
      || ra % 7 === 0
      || ra % 11 === 0
      || ra % 13 === 0
      || ra % 17 === 0
      || ra % 19 === 0
      || ra % 23 === 0
      || ra % 37 === 0
      || rb % 29 === 0
      || rb % 31 === 0
      || rb % 41 === 0
      || rb % 43 === 0
      || rb % 47 === 0
      || rb % 53 === 0) {
    return false;
  }

  return x.isPrime(rng, reps);
}

function isSafePrime(x, reps, rng) {
  // Safe Prime (2p + 1).
  if (!isProbablePrime(x, reps, rng))
    return false;

  // Sophie Germain Prime (p).
  const p = x.subn(1).iushrn(1);

  if (!isProbablePrime(p, reps, rng))
    return false;

  return true;
}

/*
 * Expose
 */

exports.randomPrime = randomPrime;
exports.isProbablePrime = isProbablePrime;
exports.isSafePrime = isSafePrime;
}],
[/* 50 */ 'bcrypto', '/lib/internal/asn1.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * asn1.js - asn1 parsing for bcrypto
 * Copyright (c) 2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */



const assert = __browser_require__(51 /* 'assert' */, module);
const BN = __browser_require__(42 /* '../bn' */, module);

/*
 * ASN1
 */

function readSize(data, pos, strict) {
  assert((data != null && data._isBuffer === true));
  assert((pos >>> 0) === pos);
  assert(typeof strict === 'boolean');

  if (pos >= data.length)
    throw new Error('Invalid size.');

  const field = data[pos];
  const bytes = field & 0x7f;

  pos += 1;

  // Definite form.
  if ((field & 0x80) === 0) {
    // Short form.
    return [bytes, pos];
  }

  // Indefinite form.
  if (strict && bytes === 0)
    throw new Error('Indefinite length.');

  // Long form.
  let size = 0;

  for (let i = 0; i < bytes; i++) {
    assert(pos < data.length);

    const ch = data[pos];

    pos += 1;

    if (size >= (1 << 24))
      throw new Error('Length too large.');

    size *= 0x100;
    size += ch;

    if (strict && size === 0)
      throw new Error('Unexpected leading zeroes.');
  }

  if (strict && size < 0x80)
    throw new Error('Non-minimal length.');

  return [size, pos];
}

function readSeq(data, pos, strict = true) {
  assert((data != null && data._isBuffer === true));
  assert((pos >>> 0) === pos);
  assert(typeof strict === 'boolean');

  if (pos >= data.length || data[pos] !== 0x30)
    throw new Error('Invalid sequence tag.');

  pos += 1;

  let size;
  [size, pos] = readSize(data, pos, strict);

  if (strict && pos + size !== data.length)
    throw new Error('Trailing bytes.');

  return pos;
}

function readInt(data, pos, strict = true) {
  assert((data != null && data._isBuffer === true));
  assert((pos >>> 0) === pos);
  assert(typeof strict === 'boolean');

  if (pos >= data.length || data[pos] !== 0x02)
    throw new Error('Invalid integer tag.');

  pos += 1;

  let size;
  [size, pos] = readSize(data, pos, strict);

  if (pos + size > data.length)
    throw new Error('Integer body out of bounds.');

  if (strict) {
    // Zero length integer.
    if (size === 0)
      throw new Error('Zero length integer.');

    // No negatives.
    if (data[pos] & 0x80)
      throw new Error('Integers must be positive.');

    // Allow zero only if it prefixes a high bit.
    if (size > 1) {
      if (data[pos] === 0x00 && (data[pos + 1] & 0x80) === 0x00)
        throw new Error('Unexpected leading zeroes.');
    }
  }

  // Eat leading zeroes.
  while (size > 0 && data[pos] === 0x00) {
    pos += 1;
    size -= 1;
  }

  // No reason to have an integer larger than this.
  if (size > 2048)
    throw new Error('Invalid integer size.');

  const num = BN.decode(data.slice(pos, pos + size));

  pos += size;

  return [num, pos];
}

function readVersion(data, pos, version, strict = true) {
  assert((data != null && data._isBuffer === true));
  assert((pos >>> 0) === pos);
  assert((version & 0xff) === version);
  assert(typeof strict === 'boolean');

  let num;
  [num, pos] = readInt(data, pos, strict);

  if (num.cmpn(version) !== 0)
    throw new Error('Invalid version.');

  return pos;
}

function sizeSize(size) {
  assert((size >>> 0) === size);

  if (size <= 0x7f) // [size]
    return 1;

  if (size <= 0xff) // 0x81 [size]
    return 2;

  assert(size <= 0xffff);

  return 3; // 0x82 [size-hi] [size-lo]
}

function sizeSeq(size) {
  return 1 + sizeSize(size) + size;
}

function sizeInt(num) {
  assert(num instanceof BN);

  // 0x02 [size] [0x00?] [int]
  const bits = num.bitLength();

  let size = (bits + 7) >>> 3;

  if (bits > 0 && (bits & 7) === 0)
    size += num.testn(bits - 1);

  if (bits === 0)
    size = 1;

  return 1 + sizeSize(size) + size;
}

function sizeVersion(version) {
  assert((version & 0xff) === version);
  return 3;
}

function writeSize(data, pos, size) {
  assert((data != null && data._isBuffer === true));
  assert((pos >>> 0) === pos);
  assert((size >>> 0) === size);

  if (size <= 0x7f)  {
    // [size]
    data[pos++] = size;
  } else if (size <= 0xff) {
    // 0x81 [size]
    data[pos++] = 0x81;
    data[pos++] = size;
  } else {
    // 0x82 [size-hi] [size-lo]
    assert(size <= 0xffff);
    data[pos++] = 0x82;
    data[pos++] = size >> 8;
    data[pos++] = size & 0xff;
  }

  assert(pos <= data.length);

  return pos;
}

function writeSeq(data, pos, size) {
  assert((data != null && data._isBuffer === true));
  assert((pos >>> 0) === pos);

  data[pos++] = 0x30;

  return writeSize(data, pos, size);
}

function writeInt(data, pos, num) {
  assert((data != null && data._isBuffer === true));
  assert((pos >>> 0) === pos);
  assert(num instanceof BN);

  // 0x02 [size] [0x00?] [int]
  const bits = num.bitLength();

  let size = (bits + 7) >>> 3;
  let pad = 0;

  if (bits > 0 && (bits & 7) === 0)
    pad = num.testn(bits - 1);

  if (bits === 0)
    size = 1;

  data[pos++] = 0x02;

  pos = writeSize(data, pos, pad + size);

  if (pad)
    data[pos++] = 0x00;

  if (bits !== 0)
    num.encode().copy(data, pos);
  else
    data[pos] = 0x00;

  pos += size;

  assert(pos <= data.length);

  return pos;
}

function writeVersion(data, pos, version) {
  assert((data != null && data._isBuffer === true));
  assert((pos >>> 0) === pos);
  assert((version & 0xff) === version);
  assert(pos + 3 <= data.length);

  data[pos++] = 0x02;
  data[pos++] = 0x01;
  data[pos++] = version;

  return pos;
}

/*
 * Expose
 */

exports.readSize = readSize;
exports.readSeq = readSeq;
exports.readInt = readInt;
exports.readVersion = readVersion;
exports.sizeSize = sizeSize;
exports.sizeSeq = sizeSeq;
exports.sizeInt = sizeInt;
exports.sizeVersion = sizeVersion;
exports.writeSize = writeSize;
exports.writeSeq = writeSeq;
exports.writeInt = writeInt;
exports.writeVersion = writeVersion;
}],
[/* 51 */ 'bpkg', '/lib/builtins/assert.js', function(exports, require, module, __filename, __dirname, __meta) {
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



var util = __browser_require__(52 /* './internal/util' */, module);
var comparisons = __browser_require__(53 /* './internal/comparisons' */, module);
var isDeepEqual = comparisons.isDeepEqual;
var isDeepStrictEqual = comparisons.isDeepStrictEqual;

/*
 * Constants
 */

var kReadableOperator = {
  deepStrictEqual: 'Expected values to be strictly deep-equal:',
  strictEqual: 'Expected values to be strictly equal:',
  strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
  deepEqual: 'Expected values to be loosely deep-equal:',
  equal: 'Expected values to be loosely equal:',
  notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
  notStrictEqual: 'Expected "actual" to be strictly unequal to:',
  // eslint-disable-next-line max-len
  notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
  notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
  notEqual: 'Expected "actual" to be loosely unequal to:',
  notIdentical: 'Values identical but not reference-equal:'
};

var NO_EXCEPTION_SENTINEL = {};

/**
 * AssertionError
 */

function AssertionError(options) {
  if (typeof options !== 'object' || options === null)
    throw new util.ArgError('options', options, 'Object');

  var message = null;
  var operator = 'fail';

  if (options.message != null)
    message = String(options.message);

  if (typeof options.operator === 'string')
    operator = options.operator;

  if (message == null) {
    if (operator === 'fail') {
      message = 'Assertion failed.';
    } else {
      message = kReadableOperator[operator]
              + ' ' + util.stringify(options.actual)
              + ' ' + operator
              + ' ' + util.stringify(options.expected);
    }
  }

  Error.call(this, message);

  var start = AssertionError;

  if (typeof options.stackStartFn === 'function')
    start = options.stackStartFn;

  this.name = 'AssertionError [ERR_ASSERTION]';
  this.code = 'ERR_ASSERTION';
  this.message = message;
  this.generatedMessage = !options.message;
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = operator;

  if (Error.captureStackTrace)
    Error.captureStackTrace(this, start);
}

util.inherits(AssertionError, Error);

/*
 * Assert
 */

var assert = function ok(value, message) {
  innerOk(ok, arguments.length, value, message);
};

assert.AssertionError = AssertionError;

assert.ok = assert;

assert.fail = function fail(actual, expected, message, operator, stackStartFn) {
  var argsLen = arguments.length;
  var internalMessage;

  if (argsLen === 0) {
    internalMessage = 'Failed';
  } else if (argsLen === 1) {
    message = actual;
    actual = undefined;
  } else {
    if (argsLen === 2)
      operator = '!=';
  }

  if (message instanceof Error)
    throw message;

  var errArgs = {
    actual: actual,
    expected: expected,
    operator: operator === undefined ? 'fail' : operator,
    stackStartFn: stackStartFn || fail
  };

  if (message !== undefined)
    errArgs.message = message;

  var err = new AssertionError(errArgs);

  if (internalMessage) {
    err.message = internalMessage;
    err.generatedMessage = true;
  }

  throw err;
};

assert.equal = function equal(actual, expected, message) {
  // eslint-disable-next-line eqeqeq
  if (actual != expected) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: '==',
      stackStartFn: equal
    });
  }
};

assert.notEqual = function notEqual(actual, expected, message) {
  // eslint-disable-next-line eqeqeq
  if (actual == expected) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: '!=',
      stackStartFn: notEqual
    });
  }
};

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!isDeepEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'deepEqual',
      stackStartFn: deepEqual
    });
  }
};

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (isDeepEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notDeepEqual',
      stackStartFn: notDeepEqual
    });
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'deepStrictEqual',
      stackStartFn: deepStrictEqual
    });
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;

function notDeepStrictEqual(actual, expected, message) {
  if (isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notDeepStrictEqual',
      stackStartFn: notDeepStrictEqual
    });
  }
}

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (!util.equals(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'strictEqual',
      stackStartFn: strictEqual
    });
  }
};

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (util.equals(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notStrictEqual',
      stackStartFn: notStrictEqual
    });
  }
};

assert.throws = function throws(promiseFn, error, message) {
  expectsError(throws, getActual(promiseFn), error, message);
};

assert.rejects = function rejects(promiseFn, error, message) {
  return new Promise(function(resolve, reject) {
    waitForActual(promiseFn).then(function(res) {
      try {
        expectsError(rejects, res, error, message);
      } catch (e) {
        reject(e);
        return;
      }
      resolve();
    });
  });
};

assert.doesNotThrow = function doesNotThrow(fn, error, message) {
  expectsNoError(doesNotThrow, getActual(fn), error, message);
};

assert.doesNotReject = function doesNotReject(fn, error, message) {
  return new Promise(function(resolve, reject) {
    waitForActual(fn).then(function(res) {
      try {
        expectsNoError(doesNotReject, res, error, message);
      } catch (e) {
        reject(e);
        return;
      }
      resolve();
    });
  });
};

assert.ifError = function ifError(err) {
  if (err !== null && err !== undefined) {
    var message = 'ifError got unwanted exception: ';

    if (typeof err === 'object' && typeof err.message === 'string') {
      if (err.message.length === 0 && err.constructor)
        message += err.constructor.name;
      else
        message += err.message;
    } else {
      message += util.stringify(err);
    }

    var newErr = new AssertionError({
      actual: err,
      expected: null,
      operator: 'ifError',
      message: message,
      stackStartFn: ifError
    });

    var origStack = err.stack;

    if (typeof origStack === 'string') {
      var tmp2 = origStack.split('\n');
      tmp2.shift();

      var tmp1 = newErr.stack.split('\n');

      for (var i = 0; i < tmp2.length; i++) {
        var pos = tmp1.indexOf(tmp2[i]);
        if (pos !== -1) {
          tmp1 = tmp1.slice(0, pos);
          break;
        }
      }

      newErr.stack = tmp1.join('\n') + '\n' + tmp2.join('\n');
    }

    throw newErr;
  }
};

function strict(value, message) {
  innerOk(strict, arguments.length, value, message);
}

assert.strict = util.assign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});

assert.strict.strict = assert.strict;

/*
 * Helpers
 */

function innerFail(obj) {
  if (obj.message instanceof Error)
    throw obj.message;

  throw new AssertionError(obj);
}

function innerOk(fn, argLen, value, message) {
  if (!value) {
    var generatedMessage = false;

    if (argLen === 0) {
      generatedMessage = true;
      message = 'No value argument passed to `assert.ok()`';
    } else if (message == null) {
      generatedMessage = true;
      message = 'Assertion failed.';
    } else if (message instanceof Error) {
      throw message;
    }

    var err = new AssertionError({
      actual: value,
      expected: true,
      message: message,
      operator: '==',
      stackStartFn: fn
    });

    err.generatedMessage = generatedMessage;

    throw err;
  }
}

function Comparison(obj, keys, actual) {
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];

    if (key in obj) {
      if (actual !== undefined
          && typeof actual[key] === 'string'
          && (obj[key] instanceof RegExp)
          && obj[key].test(actual[key])) {
        this[key] = actual[key];
      } else {
        this[key] = obj[key];
      }
    }
  }
}

function compareExceptionKey(actual, expected, key, message, keys) {
  if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
    if (!message) {
      var a = new Comparison(actual, keys);
      var b = new Comparison(expected, keys, actual);

      var err = new AssertionError({
        actual: a,
        expected: b,
        operator: 'deepStrictEqual',
        stackStartFn: assert.throws
      });

      err.actual = actual;
      err.expected = expected;
      err.operator = 'throws';

      throw err;
    }

    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'throws',
      stackStartFn: assert.throws
    });
  }
}

function expectedException(actual, expected, msg) {
  if (typeof expected !== 'function') {
    if (expected instanceof RegExp)
      return expected.test(actual);

    if (arguments.length === 2)
      throw new util.ArgError('expected', expected, ['Function', 'RegExp']);

    if (typeof actual !== 'object' || actual === null) {
      var err = new AssertionError({
        actual: actual,
        expected: expected,
        message: msg,
        operator: 'deepStrictEqual',
        stackStartFn: assert.throws
      });

      err.operator = 'throws';

      throw err;
    }

    var keys = util.getOwnKeys(expected);

    if (expected instanceof Error)
      keys.push('name', 'message');
    else if (keys.length === 0)
      throw new util.ArgError('error', expected, 'may not be an empty object');

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (typeof actual[key] === 'string'
          && (expected[key] instanceof RegExp)
          && expected[key].test(actual[key])) {
        continue;
      }

      compareExceptionKey(actual, expected, key, msg, keys);
    }

    return true;
  }

  if (expected.prototype !== undefined && (actual instanceof expected))
    return true;

  if (expected.prototype instanceof Error)
    return false;

  return expected.call({}, actual) === true;
}

function getActual(fn) {
  if (typeof fn !== 'function')
    throw new util.ArgError('fn', fn, 'Function');

  try {
    fn();
  } catch (e) {
    return e;
  }

  return NO_EXCEPTION_SENTINEL;
}

function checkIsPromise(obj) {
  return obj !== null
    && typeof obj === 'object'
    && typeof obj.then === 'function'
    && typeof obj.catch === 'function';
}

function waitForActual(promiseFn) {
  return new Promise(function(resolve, reject) {
    try {
      var resultPromise;

      if (typeof promiseFn === 'function') {
        resultPromise = promiseFn();

        if (!checkIsPromise(resultPromise)) {
          throw new util.ArgError('promiseFn',
            resultPromise, 'instance of Promise');
        }
      } else if (checkIsPromise(promiseFn)) {
        resultPromise = promiseFn;
      } else {
        throw new util.ArgError('promiseFn',
          promiseFn, ['Function', 'Promise']);
      }

      resultPromise.then(function() {
        resolve(NO_EXCEPTION_SENTINEL);
      }, resolve);
    } catch (e) {
      resolve(e);
    }
  });
}

function expectsError(stackStartFn, actual, error, message) {
  if (typeof error === 'string') {
    if (arguments.length === 4) {
      throw new util.ArgError('error', error,
        ['Object', 'Error', 'Function', 'RegExp']);
    }

    if (typeof actual === 'object' && actual !== null) {
      if (actual.message === error) {
        throw new util.NodeError(
          'ERR_AMBIGUOUS_ARGUMENT',
          'The error message "' + actual.message
          + '" is identical to the message.'
        );
      }
    } else if (actual === error) {
      throw new util.NodeError(
        'ERR_AMBIGUOUS_ARGUMENT',
        'The error "' + actual + '" is identical to the message.'
      );
    }

    message = error;
    error = undefined;
  } else if (error != null
             && typeof error !== 'object'
             && typeof error !== 'function') {
    throw new util.ArgError('error', error,
      ['Object', 'Error', 'Function', 'RegExp']);
  }

  if (actual === NO_EXCEPTION_SENTINEL) {
    var details = '';

    if (error && error.name)
      details += ' (' + error.name + ')';

    details += message ? ': ' + message : '.';

    var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';

    innerFail({
      actual: undefined,
      expected: error,
      operator: stackStartFn.name,
      message: 'Missing expected ' + fnType + details,
      stackStartFn: stackStartFn
    });
  }

  if (error && expectedException(actual, error, message) === false)
    throw actual;
}

function expectsNoError(stackStartFn, actual, error, message) {
  if (actual === NO_EXCEPTION_SENTINEL)
    return;

  if (typeof error === 'string') {
    message = error;
    error = undefined;
  }

  if (!error || expectedException(actual, error)) {
    var details = message ? ': ' + message : '.';
    var fnType = stackStartFn.name === 'doesNotReject'
      ? 'rejection'
      : 'exception';

    innerFail({
      actual: actual,
      expected: error,
      operator: stackStartFn.name,
      message: 'Got unwanted ' + fnType + details + '\n'
             + 'Actual message: "' + (actual && actual.message) + '"',
      stackStartFn: stackStartFn
    });
  }

  throw actual;
}

/*
 * Expose
 */

module.exports = assert;
}],
[/* 52 */ 'bpkg', '/lib/builtins/internal/util.js', function(exports, require, module, __filename, __dirname, __meta) {
var HAS_ARRAY_BUFFER = typeof ArrayBuffer === 'function';
var HAS_SHARED_ARRAY_BUFFER = typeof SharedArrayBuffer === 'function';
var HAS_BIGINT = typeof BigInt === 'function';
var HAS_SYMBOL = typeof Symbol === 'function';
var HAS_FLOAT32_ARRAY = typeof Float32Array === 'function';
var HAS_FLOAT64_ARRAY = typeof Float64Array === 'function';
var HAS_MAP = typeof Map === 'function';
var HAS_SET = typeof Set === 'function';
var HAS_PROTO = ({ __proto__: { a: 1 } }).a === 1;

function assign(target) {
  if (Object.assign)
    return Object.assign.apply(Object, arguments);

  for (var i = 1; i < arguments.length; i++) {
    var obj = arguments[i];

    if (obj === null || typeof obj !== 'object')
      continue;

    var keys = getOwnKeys(obj);

    for (var j = 0; j < keys.length; j++)
      target[keys[j]] = obj[keys[j]];
  }

  return target;
}

function equals(x, y) {
  if (Object.is)
    return Object.is(x, y);

  if (x === y)
    return x !== 0 || 1 / x === 1 / y;

  return x !== x && y !== y;
}

function filter(arr, func) {
  if (arr.filter)
    return arr.filter(func);

  var out = [];

  for (var i = 0; i < arr.length; i++) {
    if (func(arr[i]))
      out.push(arr[i]);
  }

  return out;
}

function funcName(func) {
  var name;

  try {
    name = func.name;
  } catch (e) {
    ;
  }

  if (typeof name !== 'string' || name.length === 0)
    return 'Function';

  return 'Function: ' + name;
}

function getOwnKeys(obj) {
  if (Object.keys)
    return Object.keys(obj);

  var keys = [];
  var key;

  for (key in obj) {
    if (hasOwnProperty.call(obj, key))
      keys.push(key);
  }

  return keys;
}

function getOwnNonIndexProperties(obj, enumerable) {
  var numeric = (obj.length >>> 0) === obj.length;
  var keys = enumerable ? getOwnKeys(obj) : getOwnPropertyNames(obj);
  var out = [];
  var i, key, symbols;

  for (i = 0; i < keys.length; i++) {
    key = keys[i];

    if (numeric) {
      if (/^\d+$/.test(key) && (key >>> 0) < obj.length)
        continue;
    }

    out.push(key);
  }

  symbols = getOwnPropertySymbols(obj);

  for (i = 0; i < symbols.length; i++) {
    key = symbols[i];
    if (!enumerable || propertyIsEnumerable(obj, key))
      out.push(key);
  }

  return out;
}

function getOwnPropertyNames(obj) {
  if (Object.getOwnPropertyNames)
    return Object.getOwnPropertyNames(obj);

  return getOwnKeys(obj);
}

function getOwnPropertySymbols(obj) {
  if (Object.getOwnPropertySymbols)
    return Object.getOwnPropertySymbols(obj);

  return [];
}

function getPrototypeOf(obj) {
  if (Object.getPrototypeOf)
    return Object.getPrototypeOf(obj);

  if (obj == null)
    return undefined;

  if (HAS_PROTO)
    return obj.__proto__;

  if (obj.constructor)
    return obj.constructor.prototype;

  return undefined;
}

function hasOwnProperty(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

function isAnyArrayBuffer(obj) {
  if (HAS_ARRAY_BUFFER) {
    if (obj instanceof ArrayBuffer)
      return true;
  }

  if (HAS_SHARED_ARRAY_BUFFER) {
    if (obj instanceof SharedArrayBuffer)
      return true;
  }

  return false;
}

function isArray(obj) {
  if (Array.isArray)
    return Array.isArray(obj);

  return obj instanceof Array;
}

function isArrayBufferView(obj) {
  if (!HAS_ARRAY_BUFFER)
    return false;

  if (obj == null)
    return false;

  if (ArrayBuffer.isView)
    return ArrayBuffer.isView(obj);

  return isAnyArrayBuffer(obj.buffer);
}

function isBigIntObject(obj) {
  return HAS_BIGINT && (obj instanceof BigInt);
}

function isBooleanObject(obj) {
  return obj instanceof Boolean;
}

function isBoxedPrimitive(obj) {
  if (obj === null || typeof obj !== 'object')
    return false;

  return isNumberObject(obj)
      || isStringObject(obj)
      || isBooleanObject(obj)
      || isBigIntObject(obj)
      || isSymbolObject(obj);
}

function isDate(obj) {
  return obj instanceof Date;
}

function isFloat32Array(obj) {
  return HAS_FLOAT32_ARRAY && (obj instanceof Float32Array);
}

function isFloat64Array(obj) {
  return HAS_FLOAT64_ARRAY && (obj instanceof Float64Array);
}

function isMap(obj) {
  return HAS_MAP && (obj instanceof Map);
}

function isNaN(n) {
  return n !== n;
}

function isNumberObject(obj) {
  return obj instanceof Number;
}

function isRegExp(obj) {
  return obj instanceof RegExp;
}

function isSet(obj) {
  return HAS_SET && (obj instanceof Set);
}

function isStringObject(obj) {
  return obj instanceof String;
}

function isSymbolObject(obj) {
  return HAS_SYMBOL && (obj instanceof Symbol);
}

function inherits(child, parent) {
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(child, parent);
    Object.setPrototypeOf(child.prototype, parent.prototype);
    return;
  }

  if (HAS_PROTO) {
    child.__proto__ = parent;
    child.prototype.__proto__ = parent.prototype;
    return;
  }

  if (Object.create) {
    child.prototype = Object.create(parent.prototype, {
      constructor: {
        value: child,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return;
  }

  var fn = function() {};
  fn.prototype = parent.prototype;
  // eslint-disable-next-line
  child.prototype = new fn();
  child.prototype.constructor = child;
}

function propertyIsEnumerable(obj, key) {
  if (!Object.getOwnPropertyDescriptor)
    return hasOwnProperty(obj, key);

  var desc = Object.getOwnPropertyDescriptor(obj, key);

  return desc != null && desc.enumerable === true;
}

function stringify(value) {
  switch (typeof value) {
    case 'undefined':
    case 'boolean':
    case 'number':
    case 'symbol':
      return String(value);
    case 'bigint':
      return value + 'n';
    case 'string':
      if (value.length > 20)
        value = value.substring(0, 17) + '...';
      return '"' + value + '"';
    case 'object':
      if (value === null)
        return 'null';
      return '[' + toName(value) + ']';
    case 'function':
      return '[' + funcName(value) + ']';
    default:
      return '[' + (typeof value) + ']';
  }
}

function toName(obj) {
  return toString(obj).slice(8, -1);
}

function toString(obj) {
  if (obj === undefined)
    return '[object Undefined]';

  if (obj === null)
    return '[object Null]';

  return Object.prototype.toString.call(obj);
}

function ArgError(name, value, expect) {
  var msg;

  if (isArray(expect) && expect.length === 1)
    expect = expect[0];

  if (isArray(expect)) {
    var last = expect.pop();

    msg = 'The "' + name + '" argument must be one of type '
        + expect.join(', ') + ', or ' + last + '. '
        + 'Received type ' + (typeof value);
  } else {
    msg = 'The "' + name + '" argument must be of type ' + expect + '. '
        + 'Received type ' + (typeof value);
  }

  TypeError.call(this, msg);

  this.name = 'TypeError [ERR_INVALID_ARG_TYPE]';
  this.code = 'ERR_INVALID_ARG_TYPE';
  this.message = msg;

  if (Error.captureStackTrace)
    Error.captureStackTrace(this, ArgError);
}

inherits(ArgError, TypeError);

function NodeError(code, msg) {
  Error.call(this, msg);

  this.name = 'Error [' + code + ']';
  this.code = code;
  this.message = msg;

  if (Error.captureStackTrace)
    Error.captureStackTrace(this, NodeError);
}

inherits(NodeError, Error);

/*
 * Expose
 */

exports.assign = assign;
exports.equals = equals;
exports.filter = filter;
exports.funcName = funcName;
exports.getOwnKeys = getOwnKeys;
exports.getOwnNonIndexProperties = getOwnNonIndexProperties;
exports.getOwnPropertyNames = getOwnPropertyNames;
exports.getOwnPropertySymbols = getOwnPropertySymbols;
exports.getPrototypeOf = getPrototypeOf;
exports.hasOwnProperty = hasOwnProperty;
exports.isAnyArrayBuffer = isAnyArrayBuffer;
exports.isArray = isArray;
exports.isArrayBufferView = isArrayBufferView;
exports.isBigIntObject = isBigIntObject;
exports.isBooleanObject = isBooleanObject;
exports.isBoxedPrimitive = isBoxedPrimitive;
exports.isDate = isDate;
exports.isFloat32Array = isFloat32Array;
exports.isFloat64Array = isFloat64Array;
exports.isMap = isMap;
exports.isNaN = isNaN;
exports.isNumberObject = isNumberObject;
exports.isRegExp = isRegExp;
exports.isSet = isSet;
exports.isStringObject = isStringObject;
exports.isSymbolObject = isSymbolObject;
exports.inherits = inherits;
exports.propertyIsEnumerable = propertyIsEnumerable;
exports.stringify = stringify;
exports.toName = toName;
exports.toString = toString;
exports.ArgError = ArgError;
exports.NodeError = NodeError;
}],
[/* 53 */ 'bpkg', '/lib/builtins/internal/comparisons.js', function(exports, require, module, __filename, __dirname, __meta) {
var util = __browser_require__(52 /* './util' */, module);

var kStrict = true;
var kLoose = false;

var kNoIterator = 0;
var kIsArray = 1;
var kIsSet = 2;
var kIsMap = 3;

function isDeepEqual(val1, val2) {
  return innerDeepEqual(val1, val2, kLoose);
}

function isDeepStrictEqual(val1, val2) {
  return innerDeepEqual(val1, val2, kStrict);
}

function innerDeepEqual(val1, val2, strict, memos) {
  if (val1 === val2) {
    if (val1 !== 0)
      return true;
    return strict ? util.equals(val1, val2) : true;
  }

  if (strict) {
    if (typeof val1 !== 'object')
      return typeof val1 === 'number' && util.isNaN(val1) && util.isNaN(val2);

    if (typeof val2 !== 'object' || val1 === null || val2 === null)
      return false;

    if (util.getPrototypeOf(val1) !== util.getPrototypeOf(val2))
      return false;
  } else {
    if (val1 === null || typeof val1 !== 'object') {
      if (val2 === null || typeof val2 !== 'object') {
        // eslint-disable-next-line eqeqeq
        return val1 == val2;
      }

      return false;
    }

    if (val2 === null || typeof val2 !== 'object')
      return false;
  }

  var val1Tag = util.toString(val1);
  var val2Tag = util.toString(val2);
  var keys1, keys2;

  if (val1Tag !== val2Tag)
    return false;

  if (util.isArray(val1)) {
    if (val1.length !== val2.length)
      return false;

    keys1 = util.getOwnNonIndexProperties(val1, true);
    keys2 = util.getOwnNonIndexProperties(val2, true);

    if (keys1.length !== keys2.length)
      return false;

    return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
  }

  if (val1Tag === '[object Object]')
    return keyCheck(val1, val2, strict, memos, kNoIterator);

  if (util.isDate(val1)) {
    if (val1.getTime() !== val2.getTime())
      return false;
  } else if (util.isRegExp(val1)) {
    if (!areSimilarRegExps(val1, val2))
      return false;
  } else if (val1 instanceof Error) {
    if (val1.message !== val2.message || val1.name !== val2.name)
      return false;
  } else if (util.isArrayBufferView(val1)) {
    if (!strict && (util.isFloat32Array(val1) || util.isFloat64Array(val1))) {
      if (!areSimilarFloatArrays(val1, val2))
        return false;
    } else if (!areSimilarTypedArrays(val1, val2)) {
      return false;
    }

    keys1 = util.getOwnNonIndexProperties(val1, true);
    keys2 = util.getOwnNonIndexProperties(val2, true);

    if (keys1.length !== keys2.length)
      return false;

    return keyCheck(val1, val2, strict, memos, kNoIterator, keys1);
  } else if (util.isSet(val1)) {
    if (!util.isSet(val2) || val1.size !== val2.size)
      return false;

    return keyCheck(val1, val2, strict, memos, kIsSet);
  } else if (util.isMap(val1)) {
    if (!util.isMap(val2) || val1.size !== val2.size)
      return false;

    return keyCheck(val1, val2, strict, memos, kIsMap);
  } else if (util.isAnyArrayBuffer(val1)) {
    if (!areEqualArrayBuffers(val1, val2))
      return false;
  } else if (util.isBoxedPrimitive(val1)
             && !isEqualBoxedPrimitive(val1, val2)) {
    return false;
  }

  return keyCheck(val1, val2, strict, memos, kNoIterator);
}

function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
  if (arguments.length === 5) {
    aKeys = util.getOwnKeys(val1);
    var bKeys = util.getOwnKeys(val2);

    if (aKeys.length !== bKeys.length)
      return false;
  }

  var i = 0;
  for (; i < aKeys.length; i++) {
    if (!util.hasOwnProperty(val2, aKeys[i]))
      return false;
  }

  if (strict && arguments.length === 5) {
    var symbolKeysA = util.getOwnPropertySymbols(val1);
    var symbolKeysB;

    if (symbolKeysA.length !== 0) {
      var count = 0;
      for (i = 0; i < symbolKeysA.length; i++) {
        var key = symbolKeysA[i];
        if (util.propertyIsEnumerable(val1, key)) {
          if (!util.propertyIsEnumerable(val2, key))
            return false;
          aKeys.push(key);
          count++;
        } else if (util.propertyIsEnumerable(val2, key)) {
          return false;
        }
      }

      symbolKeysB = util.getOwnPropertySymbols(val2);

      if (symbolKeysA.length !== symbolKeysB.length
          && getEnumerables(val2, symbolKeysB).length !== count) {
        return false;
      }
    } else {
      symbolKeysB = util.getOwnPropertySymbols(val2);

      if (symbolKeysB.length !== 0
          && getEnumerables(val2, symbolKeysB).length !== 0) {
        return false;
      }
    }
  }

  if (aKeys.length === 0
      && (iterationType === kNoIterator
        || iterationType === kIsArray && val1.length === 0
        || val1.size === 0)) {
    return true;
  }

  if (memos === undefined) {
    memos = {
      val1: createMap(),
      val2: createMap(),
      position: 0
    };
  } else {
    var val2MemoA = memos.val1.get(val1);

    if (val2MemoA !== undefined) {
      var val2MemoB = memos.val2.get(val2);

      if (val2MemoB !== undefined)
        return val2MemoA === val2MemoB;
    }

    memos.position++;
  }

  memos.val1.set(val1, memos.position);
  memos.val2.set(val2, memos.position);

  var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);

  memos.val1.delete(val1);
  memos.val2.delete(val2);

  return areEq;
}

function getEnumerables(val, keys) {
  return util.filter(keys, function(k) {
    return util.propertyIsEnumerable(val, k);
  });
}

function setHasEqualElement(set, val1, strict, memo) {
  var iter = set.keys();

  // for val2 of set
  for (;;) {
    var result = iter.next();

    if (result.done)
      break;

    var val2 = result.value;

    if (innerDeepEqual(val1, val2, strict, memo)) {
      set.delete(val2);
      return true;
    }
  }

  return false;
}

function setEquiv(a, b, strict, memo) {
  var set = null;
  var iter, result, val;

  iter = a.keys();

  // for val of a
  for (;;) {
    result = iter.next();

    if (result.done)
      break;

    val = result.value;

    if (typeof val === 'object' && val !== null) {
      if (set === null)
        set = new Set();

      set.add(val);
    } else if (!b.has(val)) {
      if (strict)
        return false;

      if (!setMightHaveLoosePrim(a, b, val))
        return false;

      if (set === null)
        set = new Set();

      set.add(val);
    }
  }

  if (set !== null) {
    iter = b.keys();

    // for val of b
    for (;;) {
      result = iter.next();

      if (result.done)
        break;

      val = result.value;

      if (typeof val === 'object' && val !== null) {
        if (!setHasEqualElement(set, val, strict, memo))
          return false;
      } else if (!strict
                 && !a.has(val)
                 && !setHasEqualElement(set, val, strict, memo)) {
        return false;
      }
    }

    return set.size === 0;
  }

  return true;
}

function setMightHaveLoosePrim(a, b, prim) {
  var altValue = findLooseMatchingPrimitives(prim);

  if (altValue != null)
    return altValue;

  return b.has(altValue) && !a.has(altValue);
}

function mapEquiv(a, b, strict, memo) {
  var set = null;
  var iter, result;

  iter = a.entries();

  // for [key1, item1] of a
  for (;;) {
    result = iter.next();

    if (result.done)
      break;

    var key1 = result.value[0];
    var item1 = result.value[1];

    if (typeof key1 === 'object' && key1 !== null) {
      if (set === null)
        set = new Set();
      set.add(key1);
    } else {
      var item2 = b.get(key1);

      if (item2 === undefined
          && !b.has(key1)
          || !innerDeepEqual(item1, item2, strict, memo)) {
        if (strict)
          return false;

        if (!mapMightHaveLoosePrim(a, b, key1, item1, memo))
          return false;

        if (set === null)
          set = new Set();

        set.add(key1);
      }
    }
  }

  if (set !== null) {
    iter = b.entries();

    // for [key, item] of b
    for (;;) {
      result = iter.next();

      if (result.done)
        break;

      var key = result.value[0];
      var item = result.value[1];

      if (typeof key === 'object' && key !== null) {
        if (!mapHasEqualEntry(set, a, key, item, strict, memo))
          return false;
      } else if (!strict
                 && (!a.has(key)
                     || !innerDeepEqual(a.get(key), item, false, memo))
                     && !mapHasEqualEntry(set, a, key, item, false, memo)) {
        return false;
      }
    }

    return set.size === 0;
  }

  return true;
}

function mapMightHaveLoosePrim(a, b, prim, item, memo) {
  var altValue = findLooseMatchingPrimitives(prim);

  if (altValue != null)
    return altValue;

  var curB = b.get(altValue);

  if (curB === undefined
      && !b.has(altValue)
      || !innerDeepEqual(item, curB, false, memo)) {
    return false;
  }

  return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
}

function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
  var iter = set.keys();

  // for key2 of set
  for (;;) {
    var result = iter.next();

    if (result.done)
      break;

    var key2 = result.value;

    if (innerDeepEqual(key1, key2, strict, memo)
        && innerDeepEqual(item1, map.get(key2), strict, memo)) {
      set.delete(key2);
      return true;
    }
  }

  return false;
}

function objEquiv(a, b, strict, keys, memos, iterationType) {
  var i = 0;
  var key;

  if (iterationType === kIsSet) {
    if (!setEquiv(a, b, strict, memos))
      return false;
  } else if (iterationType === kIsMap) {
    if (!mapEquiv(a, b, strict, memos))
      return false;
  } else if (iterationType === kIsArray) {
    for (; i < a.length; i++) {
      if (util.hasOwnProperty(a, i)) {
        if (!util.hasOwnProperty(b, i)
            || !innerDeepEqual(a[i], b[i], strict, memos)) {
          return false;
        }
      } else if (util.hasOwnProperty(b, i)) {
        return false;
      } else {
        var keysA = util.getOwnKeys(a);

        for (; i < keysA.length; i++) {
          key = keysA[i];
          if (!util.hasOwnProperty(b, key)
              || !innerDeepEqual(a[key], b[key], strict, memos)) {
            return false;
          }
        }

        if (keysA.length !== util.getOwnKeys(b).length)
          return false;

        return true;
      }
    }
  }

  for (i = 0; i < keys.length; i++) {
    key = keys[i];
    if (!innerDeepEqual(a[key], b[key], strict, memos))
      return false;
  }

  return true;
}

function findLooseMatchingPrimitives(prim) {
  switch (typeof prim) {
    case 'undefined':
      return null;
    case 'object':
      return undefined;
    case 'symbol':
      return false;
    case 'string':
      prim = Number(prim);
    case 'number':
      if (util.isNaN(prim))
        return false;
  }
  return true;
}

function areSimilarRegExps(a, b) {
  return a.source === b.source && a.flags === b.flags;
}

function areSimilarFloatArrays(a, b) {
  if (a.byteLength !== b.byteLength)
    return false;

  for (var offset = 0; offset < a.byteLength; offset++) {
    if (a[offset] !== b[offset])
      return false;
  }

  return true;
}

function areSimilarTypedArrays(a, b) {
  if (a.byteLength !== b.byteLength)
    return false;

  return bytesEqual(new Uint8Array(a.buffer, a.byteOffset, a.byteLength),
                    new Uint8Array(b.buffer, b.byteOffset, b.byteLength));
}

function areEqualArrayBuffers(buf1, buf2) {
  return buf1.byteLength === buf2.byteLength
      && bytesEqual(new Uint8Array(buf1), new Uint8Array(buf2));
}

function bytesEqual(a, b) {
  if (a.length !== b.length)
    return false;

  for (var i = 0; i < a.length; i++) {
    if (a[i] !== b[i])
      return false;
  }

  return true;
}

function isEqualBoxedPrimitive(val1, val2) {
  if (util.isNumberObject(val1)) {
    return util.isNumberObject(val2)
        && util.equals(val1, val2);
  }

  if (util.isStringObject(val1)) {
    return util.isStringObject(val2)
        && val1.valueOf() === val2.valueOf();
  }

  if (util.isBooleanObject(val1)) {
    return util.isBooleanObject(val2)
        && val1.valueOf() === val2.valueOf();
  }

  if (util.isBigIntObject(val1))
    return util.isBigIntObject(val2)
        && val1.valueOf() === val2.valueOf();

  return util.isSymbolObject(val2)
      && val1.valueOf() === val2.valueOf();
}

function createMap() {
  if (typeof Map === 'function')
    return new Map();

  return new CompareMap();
}

function CompareMap() {
  this.keys = [];
  this.values = [];
}

CompareMap.prototype.get = function(key) {
  var i = this.keys.indexOf(key);
  return i !== -1 ? this.values[i] : undefined;
};

CompareMap.prototype.set = function(key, value) {
  var i = this.keys.indexOf(key);

  if (i === -1) {
    this.keys.push(key);
    this.values.push(value);
    return;
  }

  this.values[i] = value;
};

CompareMap.prototype.delete = function(key) {
  var i = this.keys.indexOf(key);

  if (i === -1)
    return;

  this.keys.splice(i, 1);
  this.values.splice(i, 1);
};

/*
 * Expose
 */

exports.isDeepEqual = isDeepEqual;
exports.isDeepStrictEqual = isDeepStrictEqual;
}],
[/* 54 */ 'bcrypto', '/lib/rsa-browser.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * rsa.js - RSA for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */



module.exports = __browser_require__(55 /* './js/rsa' */, module);
}],
[/* 55 */ 'bcrypto', '/lib/js/rsa.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * rsa.js - RSA for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009 The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Parts of this software are based on indutny/miller-rabin:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/miller-rabin
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/RSA_(cryptosystem)
 *   https://tools.ietf.org/html/rfc3447
 *   https://tools.ietf.org/html/rfc8017
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_ossl.c
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_sign.c
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_oaep.c
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_pss.c
 *   https://github.com/openssl/openssl/blob/master/crypto/rsa/rsa_pk1.c
 *   https://github.com/golang/go/blob/master/src/crypto/rsa/rsa.go
 *   https://github.com/golang/go/blob/master/src/crypto/rsa/pkcs1v15.go
 *   https://github.com/golang/go/blob/master/src/crypto/rsa/pss.go
 *   https://github.com/golang/go/blob/master/src/crypto/subtle/constant_time.go
 *   https://github.com/ARMmbed/mbed-crypto/blob/master/library/rsa.c
 *
 * References:
 *
 *   [RFC8017] PKCS #1: RSA Cryptography Specifications Version 2.2
 *     K. Moriarty, B. Kaliski, J. Jonsson, A. Rusch
 *     https://tools.ietf.org/html/rfc8017
 *
 *   [FIPS186] Federal Information Processing Standards Publication 186-4
 *     National Institute of Standards and Technology
 *     https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf
 */



const assert = __browser_require__(24 /* '../internal/assert' */, module);
const BN = __browser_require__(42 /* '../bn' */, module);
const rng = __browser_require__(45 /* '../random' */, module);
const {randomPrime} = __browser_require__(49 /* '../internal/primes' */, module);
const base64 = __browser_require__(56 /* '../encoding/base64' */, module);
const asn1 = __browser_require__(50 /* '../internal/asn1' */, module);
const safe = __browser_require__(23 /* '../safe' */, module);

const {
  safeEqual,
  safeEqualByte,
  safeSelect,
  safeLTE
} = safe;

/*
 * Constants
 */

const DEFAULT_BITS = 2048;
const DEFAULT_EXP = 65537;
const MIN_BITS = 512;
const MAX_BITS = 16384;
const MIN_EXP = 3;
const MAX_EXP = (2 ** 33) - 1;
const MAX_EXP_BITS = 33;
const SALT_LENGTH_AUTO = 0;
const SALT_LENGTH_HASH = -1;
const PREFIX = Buffer.alloc(8, 0x00);
const EMPTY = Buffer.alloc(0);

/**
 * PKCS1v1.5+ASN.1 DigestInfo prefixes.
 * @see [RFC8017] Page 45, Section 9.2.
 * @see [RFC8017] Page 63, Section B.1.
 * @const {Object}
 */

const digestInfo = {
  __proto__: null,
  BLAKE2B160: Buffer.from('3027300f060b2b060104018d3a0c02010505000414', 'hex'),
  BLAKE2B256: Buffer.from('3033300f060b2b060104018d3a0c02010805000420', 'hex'),
  BLAKE2B384: Buffer.from('3043300f060b2b060104018d3a0c02010c05000430', 'hex'),
  BLAKE2B512: Buffer.from('3053300f060b2b060104018d3a0c02011005000440', 'hex'),
  BLAKE2S128: Buffer.from('3023300f060b2b060104018d3a0c02020405000410', 'hex'),
  BLAKE2S160: Buffer.from('3027300f060b2b060104018d3a0c02020505000414', 'hex'),
  BLAKE2S224: Buffer.from('302f300f060b2b060104018d3a0c0202070500041c', 'hex'),
  BLAKE2S256: Buffer.from('3033300f060b2b060104018d3a0c02020805000420', 'hex'),
  GOST94: Buffer.from('302e300a06062a850302021405000420', 'hex'),
  HASH160: Buffer.from([20]),
  HASH256: Buffer.from([32]),
  KECCAK224: Buffer.from([28]),
  KECCAK256: Buffer.from([32]),
  KECCAK384: Buffer.from([48]),
  KECCAK512: Buffer.from([64]),
  MD2: Buffer.from('3020300c06082a864886f70d020205000410', 'hex'),
  MD4: Buffer.from('3020300c06082a864886f70d020405000410', 'hex'),
  MD5: Buffer.from('3020300c06082a864886f70d020505000410', 'hex'),
  MD5SHA1: Buffer.from([36]),
  RIPEMD160: Buffer.from('3022300a060628cf0603003105000414', 'hex'),
  SHA1: Buffer.from('3021300906052b0e03021a05000414', 'hex'),
  SHA224: Buffer.from('302d300d06096086480165030402040500041c', 'hex'),
  SHA256: Buffer.from('3031300d060960864801650304020105000420', 'hex'),
  SHA384: Buffer.from('3041300d060960864801650304020205000430', 'hex'),
  SHA512: Buffer.from('3051300d060960864801650304020305000440', 'hex'),
  SHA3_224: Buffer.from('302d300d06096086480165030402070500041c', 'hex'),
  SHA3_256: Buffer.from('3031300d060960864801650304020805000420', 'hex'),
  SHA3_384: Buffer.from('3041300d060960864801650304020905000430', 'hex'),
  SHA3_512: Buffer.from('3051300d060960864801650304020a05000440', 'hex'),
  SHAKE128: Buffer.from('3021300d060960864801650304020b05000410', 'hex'),
  SHAKE256: Buffer.from('3031300d060960864801650304020c05000420', 'hex'),
  WHIRLPOOL: Buffer.from('304e300a060628cf0603003705000440', 'hex')
};

/**
 * RSAPublicKey
 */

class RSAPublicKey {
  constructor() {
    this.n = new BN(0);
    this.e = new BN(0);
  }

  bits() {
    return this.n.bitLength();
  }

  size() {
    return this.n.byteLength();
  }

  isSane() {
    return this.n.sign() > 0
        && this.e.sign() > 0
        && this.n.bitLength() <= MAX_BITS
        && this.e.bitLength() <= MAX_EXP_BITS;
  }

  verify() {
    // Sanity checks.
    if (!this.isSane())
      return false;

    // n >= 2^511 and n mod 2 != 0
    if (this.n.bitLength() < MIN_BITS || !this.n.isOdd())
      return false;

    // e >= 3 and e mod 2 != 0
    if (this.e.cmpn(MIN_EXP) < 0 || !this.e.isOdd())
      return false;

    return true;
  }

  encrypt(msg) {
    // [RFC8017] Page 13, Section 5.1.1.
    //           Page 16, Section 5.2.2.
    assert((msg != null && msg._isBuffer === true));

    const {n, e} = this;
    const m = BN.decode(msg);

    if (m.cmp(n) >= 0)
      throw new Error('Invalid RSA message size.');

    // c = m^e mod n
    const c = m.powm(e, n);

    return c.encode('be', n.byteLength());
  }

  encode() {
    const size = asn1.sizeInt(this.n) + asn1.sizeInt(this.e);
    const out = Buffer.alloc(asn1.sizeSeq(size));

    let pos = 0;

    pos = asn1.writeSeq(out, pos, size);
    pos = asn1.writeInt(out, pos, this.n);
    pos = asn1.writeInt(out, pos, this.e);

    assert(pos === out.length);

    return out;
  }

  decode(data) {
    let pos = 0;

    pos = asn1.readSeq(data, pos);

    [this.n, pos] = asn1.readInt(data, pos);
    [this.e, pos] = asn1.readInt(data, pos);

    if (pos !== data.length)
      throw new Error('Trailing bytes.');

    return this;
  }

  static decode(data) {
    return new RSAPublicKey().decode(data);
  }
}

/**
 * RSAPrivateKey
 */

class RSAPrivateKey extends RSAPublicKey {
  constructor() {
    super();
    this.d = new BN(0);
    this.p = new BN(0);
    this.q = new BN(0);
    this.dp = new BN(0);
    this.dq = new BN(0);
    this.qi = new BN(0);
  }

  isSane() {
    return this.n.sign() > 0
        && this.e.sign() > 0
        && this.d.sign() > 0
        && this.p.sign() > 0
        && this.q.sign() > 0
        && this.dp.sign() > 0
        && this.dq.sign() > 0
        && this.qi.sign() > 0
        && this.n.bitLength() <= MAX_BITS
        && this.e.bitLength() <= MAX_EXP_BITS
        && this.d.bitLength() <= MAX_BITS
        && this.p.bitLength() <= MAX_BITS
        && this.q.bitLength() <= MAX_BITS
        && this.dp.bitLength() <= MAX_BITS
        && this.dq.bitLength() <= MAX_BITS
        && this.qi.bitLength() <= MAX_BITS;
  }

  verify() {
    // Sanity checks.
    if (!this.isSane())
      return false;

    // n >= 2^511 and n mod 2 != 0
    if (this.n.bitLength() < MIN_BITS || !this.n.isOdd())
      return false;

    // e >= 3 and e mod 2 != 0
    if (this.e.cmpn(MIN_EXP) < 0 || !this.e.isOdd())
      return false;

    // p >= 3 and p mod 2 != 0
    if (this.p.cmpn(3) < 0 || !this.p.isOdd())
      return false;

    // q >= 3 and q mod 2 != 0
    if (this.q.cmpn(3) < 0 || !this.q.isOdd())
      return false;

    // phi = (p - 1) * (q - 1)
    const pm1 = this.p.subn(1);
    const qm1 = this.q.subn(1);
    const phi = pm1.mul(qm1);

    // d >= 2 and d < phi
    if (this.d.cmpn(2) < 0 || this.d.cmp(phi) >= 0)
      return false;

    // dp != 0 and dp < p - 1
    if (this.dp.sign() === 0 || this.dp.cmp(pm1) >= 0)
      return false;

    // dq != 0 and dq < q - 1
    if (this.dq.sign() === 0 || this.dq.cmp(qm1) >= 0)
      return false;

    // qi <= 2 and qi < p
    if (this.qi.cmpn(2) < 0 || this.qi.cmp(this.p) >= 0)
      return false;

    // p != q
    if (this.p.cmp(this.q) === 0)
      return false;

    // n == p * q
    if (this.p.mul(this.q).cmp(this.n) !== 0)
      return false;

    // lam = lcm(p - 1, q - 1)
    const lam = phi.div(pm1.gcd(qm1));

    // e * d mod lam
    if (this.e.mul(this.d).imod(lam).cmpn(1) !== 0)
      return false;

    // dp == d mod (p - 1)
    if (this.d.mod(pm1).cmp(this.dp) !== 0)
      return false;

    // dq == d mod (q - 1)
    if (this.d.mod(qm1).cmp(this.dq) !== 0)
      return false;

    // q * qi mod p == 1
    if (this.q.mul(this.qi).imod(this.p).cmpn(1) !== 0)
      return false;

    return true;
  }

  decrypt(msg) {
    // [RFC8017] Page 13, Section 5.1.2.
    //           Page 15, Section 5.2.1.
    assert((msg != null && msg._isBuffer === true));

    const {n, e, p, q, dp, dq, qi} = this;

    // Decode message.
    const c = BN.decode(msg);

    // Validate params.
    if (c.cmp(n) >= 0)
      throw new Error('Invalid RSA message size.');

    // Generate blinding factor.
    let b, bi;
    for (;;) {
      // s = random integer in [1,n-1]
      const s = BN.random(rng, 1, n);

      // bi = s^-1 mod n
      try {
        bi = s.invert(n);
      } catch (e) {
        continue;
      }

      // b = s^e mod n
      b = s.powm(e, n);

      break;
    }

    // Blind.
    c.imul(b).imod(n);

    // Leverage Chinese Remainder Theorem.
    //
    // Computation:
    //
    //   mp = c^(d mod p-1) mod p
    //   mq = c^(d mod q-1) mod q
    //   md = (mp - mq) / q mod p
    //   m = (md * q + mq) mod n
    const mp = c.powm(dp, p, true);
    const mq = c.powm(dq, q, true);
    const md = mp.sub(mq).mul(qi).imod(p);
    const m = md.mul(q).iadd(mq).imod(n);

    if (m.powm(e, n).cmp(c) !== 0)
      throw new Error('Invalid RSA private key.');

    // Unblind.
    m.imul(bi).imod(n);

    return m.encode('be', n.byteLength());
  }

  generate(bits, exponent) {
    // [RFC8017] Page 9, Section 3.2.
    // [FIPS186] Page 51, Appendix B.3.1
    //           Page 55, Appendix B.3.3
    //
    // There are two methods for choosing `d`.
    // Implementations differ on whether they
    // use Euler's totient or the Carmichael
    // function.
    //
    // The best explanation of Euler's phi vs.
    // Carmichael's lambda I've seen comes from
    // the crypto stackexchange[1].
    //
    // Note that both functions are _equivalent_
    // when used with RSA, however, Carmichael's
    // may lend itself to some perf benefits.
    //
    // [1] https://crypto.stackexchange.com/a/29595
    assert((bits >>> 0) === bits);
    assert(Number.isSafeInteger(exponent) && exponent >= 0);
    assert(bits >= 64);
    assert(exponent >= 3 && (exponent & 1) !== 0);

    const e = new BN(exponent);

    for (;;) {
      const p = randomPrime((bits >>> 1) + (bits & 1));
      const q = randomPrime(bits >>> 1);

      if (p.cmp(q) === 0)
        continue;

      if (p.cmp(q) < 0)
        p.swap(q);

      if (p.sub(q).bitLength() <= (bits >>> 1) - 99)
        continue;

      const n = p.mul(q);

      if (n.bitLength() !== bits)
        continue;

      // Euler's totient: (p - 1) * (q - 1).
      const pm1 = p.subn(1);
      const qm1 = q.subn(1);
      const phi = pm1.mul(qm1);

      if (e.gcd(phi).cmpn(1) !== 0)
        continue;

      // Carmichael's function: lcm(p - 1, q - 1).
      const lam = phi.div(pm1.gcd(qm1));
      const d = e.invert(lam);

      if (d.bitLength() <= ((bits + 1) >>> 1))
        continue;

      const dp = d.mod(pm1);
      const dq = d.mod(qm1);
      const qi = q.invert(p);

      this.n = n;
      this.e = e;
      this.d = d;
      this.p = p;
      this.q = q;
      this.dp = dp;
      this.dq = dq;
      this.qi = qi;

      return this;
    }
  }

  async _generateSubtle(bits, exponent) {
    assert((bits >>> 0) === bits);
    assert(Number.isSafeInteger(exponent) && exponent >= 0);
    assert(bits >= 64);
    assert(exponent >= 3 && (exponent & 1) !== 0);

    const crypto = global.crypto || global.msCrypto;

    if (!crypto)
      throw new Error('Crypto API not available.');

    const {subtle} = crypto;

    if (!subtle || !subtle.generateKey || !subtle.exportKey)
      throw new Error('Subtle API not available.');

    const e = new BN(exponent);

    const algo = {
      name: 'RSASSA-PKCS1-v1_5',
      modulusLength: bits,
      publicExponent: e.toArrayLike(Uint8Array, 'be', 8),
      hash: { name: 'SHA-256' }
    };

    const ck = await subtle.generateKey(algo, true, ['sign']);
    const jwk = await subtle.exportKey('jwk', ck.privateKey);
    const p = BN.decode(base64.decodeURL(jwk.p));
    const q = BN.decode(base64.decodeURL(jwk.q));

    return this.fromPQE(p, q, e);
  }

  async generateAsync(bits, exponent) {
    try {
      return await this._generateSubtle(bits, exponent);
    } catch (e) {
      return this.generate(bits, exponent);
    }
  }

  fromPQE(p, q, e) {
    assert(p instanceof BN);
    assert(q instanceof BN);
    assert(e instanceof BN);

    if (p.cmp(q) < 0)
      [p, q] = [q, p];

    if (p.cmp(q) === 0)
      throw new Error('Invalid RSA private key.');

    if (p.cmpn(3) < 0 || p.bitLength() > MAX_BITS)
      throw new Error('Invalid RSA private key.');

    if (q.cmpn(3) < 0 || q.bitLength() > MAX_BITS)
      throw new Error('Invalid RSA private key.');

    if (e.cmpn(MIN_EXP) < 0 || e.bitLength() > MAX_EXP_BITS)
      throw new Error('Invalid RSA private key.');

    if (!p.isOdd() || !q.isOdd() || !e.isOdd())
      throw new Error('Invalid RSA private key.');

    const n = p.mul(q);

    assert(n.isOdd());

    if (n.bitLength() < MIN_BITS || n.bitLength() > MAX_BITS)
      throw new Error('Invalid RSA private key.');

    const pm1 = p.subn(1);
    const qm1 = q.subn(1);
    const lam = pm1.lcm(qm1);
    const d = e.invert(lam);
    const dp = d.mod(pm1);
    const dq = d.mod(qm1);
    const qi = q.invert(p);

    this.n = n;
    this.e = e;
    this.d = d;
    this.p = p;
    this.q = q;
    this.dp = dp;
    this.dq = dq;
    this.qi = qi;

    return this;
  }

  fromPQD(p, q, d) {
    assert(p instanceof BN);
    assert(q instanceof BN);
    assert(d instanceof BN);

    if (p.cmpn(3) < 0 || p.bitLength() > MAX_BITS)
      throw new Error('Invalid RSA private key.');

    if (q.cmpn(3) < 0 || q.bitLength() > MAX_BITS)
      throw new Error('Invalid RSA private key.');

    if (!p.isOdd() || !q.isOdd())
      throw new Error('Invalid RSA private key.');

    const pm1 = p.subn(1);
    const qm1 = q.subn(1);
    const phi = pm1.mul(qm1);

    if (d.cmpn(2) < 0 || d.cmp(phi) >= 0)
      throw new Error('Invalid RSA private key.');

    const lam = phi.div(pm1.gcd(qm1));
    const e = d.invert(lam);

    return this.fromPQE(p, q, e);
  }

  fromNED(n, e, d) {
    // Factor an RSA modulus given (n, e, d).
    //
    // This is basically the same logic as the
    // Miller-Rabin primality test[1][2].
    //
    // [1] https://crypto.stackexchange.com/questions/11509
    // [2] https://crypto.stackexchange.com/questions/22374
    assert(n instanceof BN);
    assert(e instanceof BN);
    assert(d instanceof BN);

    if (n.sign() < 0)
      throw new Error('Invalid RSA private key.');

    if (n.bitLength() < MIN_BITS || n.bitLength() > MAX_BITS)
      throw new Error('Invalid RSA private key.');

    if (e.cmpn(MIN_EXP) < 0 || e.bitLength() > MAX_EXP_BITS)
      throw new Error('Invalid RSA private key.');

    if (d.cmpn(2) < 0 || d.bitLength() > MAX_BITS)
      throw new Error('Invalid RSA private key.');

    if (!n.isOdd() || !e.isOdd())
      throw new Error('Invalid RSA private key.');

    const f = e.mul(d).isubn(1);
    const nm1 = n.subn(1);
    const s = f.zeroBits();
    const g = f.ushrn(s);

    for (let i = 0; i < 64; i++) {
      const a = BN.random(rng, 2, nm1);

      let b = a.powm(g, n);

      if (b.cmpn(1) === 0 || b.cmp(nm1) === 0)
        continue;

      for (let j = 1; j < s; j++) {
        const c = b.sqr().imod(n);

        if (c.cmpn(1) === 0) {
          const p = n.gcd(b.subn(1));
          const q = n.gcd(b.addn(1));

          return this.fromPQE(p, q, e);
        }

        if (c.cmp(nm1) === 0)
          break;

        b = c;
      }
    }

    throw new Error('Invalid RSA private key.');
  }

  toPublic() {
    const pub = new RSAPublicKey();

    pub.n = this.n;
    pub.e = this.e;

    return pub;
  }

  encode() {
    let size = 0;

    size += asn1.sizeVersion(0);
    size += asn1.sizeInt(this.n);
    size += asn1.sizeInt(this.e);
    size += asn1.sizeInt(this.d);
    size += asn1.sizeInt(this.p);
    size += asn1.sizeInt(this.q);
    size += asn1.sizeInt(this.dp);
    size += asn1.sizeInt(this.dq);
    size += asn1.sizeInt(this.qi);

    const out = Buffer.alloc(asn1.sizeSeq(size));

    let pos = 0;

    pos = asn1.writeSeq(out, pos, size);
    pos = asn1.writeVersion(out, pos, 0);
    pos = asn1.writeInt(out, pos, this.n);
    pos = asn1.writeInt(out, pos, this.e);
    pos = asn1.writeInt(out, pos, this.d);
    pos = asn1.writeInt(out, pos, this.p);
    pos = asn1.writeInt(out, pos, this.q);
    pos = asn1.writeInt(out, pos, this.dp);
    pos = asn1.writeInt(out, pos, this.dq);
    pos = asn1.writeInt(out, pos, this.qi);

    assert(pos === out.length);

    return out;
  }

  decode(data) {
    let pos = 0;

    pos = asn1.readSeq(data, pos);
    pos = asn1.readVersion(data, pos, 0);

    [this.n, pos] = asn1.readInt(data, pos);
    [this.e, pos] = asn1.readInt(data, pos);
    [this.d, pos] = asn1.readInt(data, pos);
    [this.p, pos] = asn1.readInt(data, pos);
    [this.q, pos] = asn1.readInt(data, pos);
    [this.dp, pos] = asn1.readInt(data, pos);
    [this.dq, pos] = asn1.readInt(data, pos);
    [this.qi, pos] = asn1.readInt(data, pos);

    if (pos !== data.length)
      throw new Error('Trailing bytes.');

    return this;
  }

  static generate(bits, exponent) {
    return new RSAPrivateKey().generate(bits, exponent);
  }

  static async generateAsync(bits, exponent) {
    return new RSAPrivateKey().generateAsync(bits, exponent);
  }

  static fromPQE(p, q, e) {
    return new RSAPrivateKey().fromPQE(p, q, e);
  }

  static fromPQD(p, q, d) {
    return new RSAPrivateKey().fromPQD(p, q, d);
  }

  static fromNED(n, e, d) {
    return new RSAPrivateKey().fromNED(n, e, d);
  }

  static decode(data) {
    return new RSAPrivateKey().decode(data);
  }
}

/**
 * Generate a private key.
 * @param {Number} [bits=2048]
 * @param {Number} [exponent=65537]
 * @returns {Buffer} Private key.
 */

function privateKeyGenerate(bits, exponent) {
  if (bits == null)
    bits = DEFAULT_BITS;

  if (exponent == null)
    exponent = DEFAULT_EXP;

  assert((bits >>> 0) === bits);
  assert(Number.isSafeInteger(exponent) && exponent >= 0);

  if (bits < MIN_BITS || bits > MAX_BITS)
    throw new RangeError(`"bits" ranges from ${MIN_BITS} to ${MAX_BITS}.`);

  if (exponent < MIN_EXP || exponent > MAX_EXP)
    throw new RangeError(`"exponent" ranges from ${MIN_EXP} to ${MAX_EXP}.`);

  if (exponent === 1 || (exponent & 1) === 0)
    throw new RangeError('"exponent" must be odd.');

  const key = RSAPrivateKey.generate(bits, exponent);

  return key.encode();
}

/**
 * Generate a private key.
 * @param {Number} [bits=2048]
 * @param {Number} [exponent=65537]
 * @returns {Buffer} Private key.
 */

async function privateKeyGenerateAsync(bits, exponent) {
  if (bits == null)
    bits = DEFAULT_BITS;

  if (exponent == null)
    exponent = DEFAULT_EXP;

  assert((bits >>> 0) === bits);
  assert(Number.isSafeInteger(exponent) && exponent >= 0);

  if (bits < MIN_BITS || bits > MAX_BITS)
    throw new RangeError(`"bits" ranges from ${MIN_BITS} to ${MAX_BITS}.`);

  if (exponent < MIN_EXP || exponent > MAX_EXP)
    throw new RangeError(`"exponent" ranges from ${MIN_EXP} to ${MAX_EXP}.`);

  if (exponent === 1 || (exponent & 1) === 0)
    throw new RangeError('"exponent" must be odd.');

  const key = await RSAPrivateKey.generateAsync(bits, exponent);

  return key.encode();
}

/**
 * Get a private key's modulus size in bits.
 * @param {Buffer} key
 * @returns {Number}
 */

function privateKeyBits(key) {
  const k = RSAPrivateKey.decode(key);

  if (!k.verify())
    throw new Error('Invalid RSA private key.');

  return k.bits();
}

/**
 * Verify a private key.
 * @param {Buffer} key
 * @returns {Boolean}
 */

function privateKeyVerify(key) {
  // [RFC8017] Page 9, Section 3.2.
  assert((key != null && key._isBuffer === true));

  let k;

  try {
    k = RSAPrivateKey.decode(key);
  } catch (e) {
    return false;
  }

  return k.verify();
}

/**
 * Import a private key from an object.
 * @param {Object} json
 * @returns {Buffer}
 */

function privateKeyImport(json) {
  // [RFC8017] Page 55, Section A.1.2.
  assert(json && typeof json === 'object');

  let k = new RSAPrivateKey();

  if (json.n != null)
    k.n = BN.decode(json.n);

  if (json.e != null)
    k.e = BN.decode(json.e);

  if (json.d != null)
    k.d = BN.decode(json.d);

  if (json.p != null)
    k.p = BN.decode(json.p);

  if (json.q != null)
    k.q = BN.decode(json.q);

  if (json.dp != null)
    k.dp = BN.decode(json.dp);

  if (json.dq != null)
    k.dq = BN.decode(json.dq);

  if (json.qi != null)
    k.qi = BN.decode(json.qi);

  if (!k.verify()) {
    if (!k.p.isZero() && !k.q.isZero()) {
      if (!k.e.isZero())
        k = RSAPrivateKey.fromPQE(k.p, k.q, k.e);
      else
        k = RSAPrivateKey.fromPQD(k.p, k.q, k.d);
    } else {
      k = RSAPrivateKey.fromNED(k.n, k.e, k.d);
    }
  }

  return k.encode();
}

/**
 * Export a private key to an object.
 * @param {Buffer} key
 * @returns {Object}
 */

function privateKeyExport(key) {
  // [RFC8017] Page 55, Section A.1.2.
  const k = RSAPrivateKey.decode(key);

  if (!k.verify())
    throw new Error('Invalid RSA private key.');

  return {
    n: k.n.encode(),
    e: k.e.encode(),
    d: k.d.encode(),
    p: k.p.encode(),
    q: k.q.encode(),
    dp: k.dp.encode(),
    dq: k.dq.encode(),
    qi: k.qi.encode()
  };
}

/**
 * Create a public key from a private key.
 * @param {Buffer} key
 * @returns {Buffer}
 */

function publicKeyCreate(key) {
  const k = RSAPrivateKey.decode(key);

  if (!k.verify())
    throw new Error('Invalid RSA private key.');

  const p = k.toPublic();

  return p.encode();
}

/**
 * Get a public key's modulus size in bits.
 * @param {Buffer} key
 * @returns {Number}
 */

function publicKeyBits(key) {
  const k = RSAPublicKey.decode(key);

  if (!k.verify())
    throw new Error('Invalid RSA public key.');

  return k.bits();
}

/**
 * Verify a public key.
 * @param {Buffer} key
 * @returns {Boolean}
 */

function publicKeyVerify(key) {
  // [RFC8017] Page 8, Section 3.1.
  assert((key != null && key._isBuffer === true));

  let k;

  try {
    k = RSAPublicKey.decode(key);
  } catch (e) {
    return false;
  }

  return k.verify();
}

/**
 * Import a public key from an object.
 * @param {Object} json
 * @returns {Buffer}
 */

function publicKeyImport(json) {
  // [RFC8017] Page 54, Section A.1.1.
  assert(json && typeof json === 'object');

  const k = new RSAPublicKey();

  if (json.n != null)
    k.n = BN.decode(json.n);

  if (json.e != null)
    k.e = BN.decode(json.e);

  if (!k.verify())
    throw new Error('Invalid RSA public key.');

  return k.encode();
}

/**
 * Export a public key to an object.
 * @param {Buffer} key
 * @returns {Object}
 */

function publicKeyExport(key) {
  // [RFC8017] Page 54, Section A.1.1.
  const k = RSAPublicKey.decode(key);

  if (!k.verify())
    throw new Error('Invalid RSA public key.');

  return {
    n: k.n.encode(),
    e: k.e.encode()
  };
}

/**
 * Sign a message (PKCS1v1.5).
 * @param {Object|String|null} hash
 * @param {Buffer} msg
 * @param {Buffer} key - Private key.
 * @returns {Buffer} PKCS#1v1.5-formatted signature.
 */

function sign(hash, msg, key) {
  // [RFC8017] Page 36, Section 8.2.1.
  //           Page 45, Section 9.2.
  if (hash && typeof hash.id === 'string')
    hash = hash.id;

  assert(hash == null || typeof hash === 'string');
  assert((msg != null && msg._isBuffer === true));

  const [prefix, hlen] = getDigestInfo(hash, msg);

  if (!prefix)
    throw new Error('Unknown RSA hash function.');

  if (msg.length !== hlen)
    throw new Error('Invalid RSA message size.');

  const k = RSAPrivateKey.decode(key);

  if (!k.verify())
    throw new Error('Invalid RSA private key.');

  const tlen = prefix.length + hlen;
  const klen = k.size();

  if (klen < tlen + 11)
    throw new Error('Invalid RSA message size.');

  // EM = 0x00 || 0x01 || PS || 0x00 || T
  const em = Buffer.alloc(klen);

  em[0] = 0x00;
  em[1] = 0x01;

  for (let i = 2; i < klen - tlen - 1; i++)
    em[i] = 0xff;

  em[klen - tlen - 1] = 0x00;

  prefix.copy(em, klen - tlen);
  msg.copy(em, klen - hlen);

  return k.decrypt(em);
}

/**
 * Verify a signature (PKCS1v1.5).
 * @param {Object|String|null} hash
 * @param {Buffer} msg
 * @param {Buffer} sig - PKCS#1v1.5-formatted.
 * @param {Buffer} key
 * @returns {Boolean}
 */

function verify(hash, msg, sig, key) {
  if (hash && typeof hash.id === 'string')
    hash = hash.id;

  assert(hash == null || typeof hash === 'string');
  assert((msg != null && msg._isBuffer === true));
  assert((sig != null && sig._isBuffer === true));
  assert((key != null && key._isBuffer === true));

  try {
    return _verify(hash, msg, sig, key);
  } catch (e) {
    return false;
  }
}

/**
 * Verify a signature (PKCS1v1.5).
 * @private
 * @param {String} hash
 * @param {Buffer} msg
 * @param {Buffer} sig - PKCS#1v1.5-formatted.
 * @param {Buffer} key
 * @returns {Boolean}
 */

function _verify(hash, msg, sig, key) {
  // [RFC8017] Page 37, Section 8.2.2.
  //           Page 45, Section 9.2.
  const [prefix, hlen] = getDigestInfo(hash, msg);

  if (!prefix)
    return false;

  if (msg.length !== hlen)
    return false;

  const k = RSAPublicKey.decode(key);

  if (!k.verify())
    return false;

  const klen = k.size();

  if (sig.length !== klen)
    return false;

  const tlen = prefix.length + hlen;

  if (klen < tlen + 11)
    return false;

  const em = k.encrypt(sig);

  // EM = 0x00 || 0x01 || PS || 0x00 || T
  let ok = 1;

  ok &= safeEqualByte(em[0], 0x00);
  ok &= safeEqualByte(em[1], 0x01);

  for (let i = 2; i < klen - tlen - 1; i++)
    ok &= safeEqualByte(em[i], 0xff);

  ok &= safeEqualByte(em[klen - tlen - 1], 0x00);
  ok &= safeEqual(em.slice(klen - tlen, klen - hlen), prefix);
  ok &= safeEqual(em.slice(klen - hlen, klen), msg);

  return ok === 1;
}

/**
 * Encrypt a message with public key (PKCS1v1.5).
 * @param {Buffer} msg
 * @param {Buffer} key
 * @returns {Buffer}
 */

function encrypt(msg, key) {
  // [RFC8017] Page 28, Section 7.2.1.
  assert((msg != null && msg._isBuffer === true));

  const k = RSAPublicKey.decode(key);

  if (!k.verify())
    throw new Error('Invalid RSA public key.');

  const klen = k.size();

  if (msg.length > klen - 11)
    throw new Error('Invalid RSA message size.');

  // EM = 0x00 || 0x02 || PS || 0x00 || M
  const em = Buffer.alloc(klen);
  const mlen = msg.length;
  const plen = klen - mlen - 3;

  em[0] = 0x00;
  em[1] = 0x02;

  rng.randomFill(em, 2, plen);

  for (let i = 2; i < 2 + plen; i++) {
    while (em[i] === 0x00)
      rng.randomFill(em, i, 1);
  }

  em[klen - mlen - 1] = 0x00;

  msg.copy(em, klen - mlen);

  return k.encrypt(em);
}

/**
 * Decrypt a message with private key (PKCS1v1.5).
 * @param {Buffer} msg
 * @param {Buffer} key
 * @returns {Buffer}
 */

function decrypt(msg, key) {
  // [RFC8017] Page 29, Section 7.2.2.
  assert((msg != null && msg._isBuffer === true));

  const k = RSAPrivateKey.decode(key);

  if (!k.verify())
    throw new Error('Invalid RSA private key.');

  const klen = k.size();

  if (klen < 11)
    throw new Error('Invalid RSA private key.');

  if (msg.length !== klen)
    throw new Error('Invalid RSA message size.');

  // EM = 0x00 || 0x02 || PS || 0x00 || M
  const em = k.decrypt(msg);
  const zero = safeEqualByte(em[0], 0x00);
  const two = safeEqualByte(em[1], 0x02);

  let index = 0;
  let looking = 1;

  for (let i = 2; i < em.length; i++) {
    const equals0 = safeEqualByte(em[i], 0x00);

    index = safeSelect(index, i, looking & equals0);
    looking = safeSelect(looking, 0, equals0);
  }

  const validPS = safeLTE(2 + 8, index);
  const valid = zero & two & (looking ^ 1) & validPS;
  const offset = safeSelect(0, index + 1, valid);

  if (valid === 0)
    throw new Error('Invalid RSA ciphertext.');

  return em.slice(offset);
}

/**
 * Sign a message (PSS).
 * @param {Object} hash
 * @param {Buffer} msg
 * @param {Buffer} key - Private key.
 * @param {Number} [saltLen=SALT_LENGTH_HASH]
 * @returns {Buffer} PSS-formatted signature.
 */

function signPSS(hash, msg, key, saltLen) {
  // [RFC8017] Page 33, Section 8.1.1.
  if (saltLen == null)
    saltLen = SALT_LENGTH_HASH;

  assert(hash && typeof hash.id === 'string');
  assert((msg != null && msg._isBuffer === true));
  assert((saltLen | 0) === saltLen);

  if (msg.length !== hash.size)
    throw new Error('Invalid RSA message size.');

  const k = RSAPrivateKey.decode(key);

  if (!k.verify())
    throw new Error('Invalid RSA private key.');

  const bits = k.bits();
  const klen = (bits + 7) >>> 3;
  const emlen = (bits + 6) >>> 3;

  if (saltLen === SALT_LENGTH_AUTO)
    saltLen = emlen - 2 - hash.size;
  else if (saltLen === SALT_LENGTH_HASH)
    saltLen = hash.size;

  if (saltLen < 0 || saltLen > klen)
    throw new Error('Invalid PSS salt length.');

  const salt = rng.randomBytes(saltLen);
  const em = pssEncode(hash, msg, bits - 1, salt);

  // Note that `em` may be one byte less
  // than the modulus size in the case
  // of (bits - 1) mod 8 == 0.
  return k.decrypt(em);
}

/**
 * Verify a signature (PSS).
 * @param {Object} hash
 * @param {Buffer} msg
 * @param {Buffer} sig - PSS-formatted.
 * @param {Buffer} key
 * @param {Number} [saltLen=SALT_LENGTH_HASH]
 * @returns {Boolean}
 */

function verifyPSS(hash, msg, sig, key, saltLen) {
  if (saltLen == null)
    saltLen = SALT_LENGTH_HASH;

  assert(hash && typeof hash.id === 'string');
  assert((msg != null && msg._isBuffer === true));
  assert((sig != null && sig._isBuffer === true));
  assert((key != null && key._isBuffer === true));
  assert((saltLen | 0) === saltLen);

  try {
    return _verifyPSS(hash, msg, sig, key, saltLen);
  } catch (e) {
    return false;
  }
}

/**
 * Verify a signature (PSS).
 * @private
 * @param {Object} hash
 * @param {Buffer} msg
 * @param {Buffer} sig - PSS-formatted.
 * @param {Buffer} key
 * @param {Number} saltLen
 * @returns {Boolean}
 */

function _verifyPSS(hash, msg, sig, key, saltLen) {
  // [RFC8017] Page 34, Section 8.1.2.
  if (msg.length !== hash.size)
    return false;

  const k = RSAPublicKey.decode(key);

  if (!k.verify())
    return false;

  const bits = k.bits();
  const klen = (bits + 7) >>> 3;

  if (sig.length !== klen)
    return false;

  if (saltLen === SALT_LENGTH_AUTO)
    saltLen = 0; // Handled in pssVerify.
  else if (saltLen === SALT_LENGTH_HASH)
    saltLen = hash.size;

  if (saltLen < 0 || saltLen > klen)
    return false;

  let em = k.encrypt(sig);

  // Edge case: the encoding crossed a
  // a byte boundary. Our encryption
  // function pads to the modulus size
  // by default, meaning there's one
  // extra zero byte prepended.
  if (((bits - 1) & 7) === 0) {
    if (em[0] !== 0x00)
      return false;

    em = em.slice(1);
  }

  return pssVerify(hash, msg, em, bits - 1, saltLen);
}

/**
 * Encrypt a message with public key (OAEP).
 * @param {Object} hash
 * @param {Buffer} msg
 * @param {Buffer} key
 * @param {Buffer?} label
 * @returns {Buffer}
 */

function encryptOAEP(hash, msg, key, label) {
  // [RFC8017] Page 22, Section 7.1.1.
  if (label == null)
    label = EMPTY;

  assert(hash && typeof hash.id === 'string');
  assert((msg != null && msg._isBuffer === true));
  assert((label != null && label._isBuffer === true));

  const k = RSAPublicKey.decode(key);

  if (!k.verify())
    throw new Error('Invalid RSA public key.');

  const klen = k.size();
  const mlen = msg.length;
  const hlen = hash.size;

  if (mlen > klen - 2 * hlen - 2)
    throw new Error('Invalid RSA message size.');

  // EM = 0x00 || (seed) || (Hash(L) || PS || 0x01 || M)
  const em = Buffer.alloc(klen);
  const lhash = hash.digest(label);
  const seed = em.slice(1, 1 + hlen);
  const db = em.slice(1 + hlen);
  const dlen = db.length;

  em[0] = 0x00;

  rng.randomFill(seed, 0, seed.length);

  lhash.copy(db, 0);
  db.fill(0x00, hlen, dlen - mlen - 1);
  db[dlen - mlen - 1] = 0x01;
  msg.copy(db, dlen - mlen);

  mgf1xor(hash, db, seed);
  mgf1xor(hash, seed, db);

  return k.encrypt(em);
}

/**
 * Decrypt a message with private key (OAEP).
 * @param {Object} hash
 * @param {Buffer} msg
 * @param {Buffer} key
 * @param {Buffer?} label
 * @returns {Buffer}
 */

function decryptOAEP(hash, msg, key, label) {
  // [RFC8017] Page 25, Section 7.1.2.
  if (label == null)
    label = EMPTY;

  assert(hash && typeof hash.id === 'string');
  assert((msg != null && msg._isBuffer === true));
  assert((label != null && label._isBuffer === true));

  const k = RSAPrivateKey.decode(key);

  if (!k.verify())
    throw new Error('Invalid RSA private key.');

  const klen = k.size();
  const mlen = msg.length;
  const hlen = hash.size;

  if (klen < hlen * 2 + 2)
    throw new Error('Invalid RSA private key size.');

  if (mlen !== klen)
    throw new Error('Invalid RSA message size.');

  // EM = 0x00 || (seed) || (Hash(L) || PS || 0x01 || M)
  const em = k.decrypt(msg);
  const expect = hash.digest(label);
  const zero = safeEqualByte(em[0], 0x00);
  const seed = em.slice(1, hlen + 1);
  const db = em.slice(hlen + 1);

  mgf1xor(hash, seed, db);
  mgf1xor(hash, db, seed);

  const lhash = db.slice(0, hlen);
  const lvalid = safeEqual(lhash, expect);
  const rest = db.slice(hlen);

  let looking = 1;
  let index = 0;
  let invalid = 0;

  for (let i = 0; i < rest.length; i++) {
    const equals0 = safeEqualByte(rest[i], 0x00);
    const equals1 = safeEqualByte(rest[i], 0x01);

    index = safeSelect(index, i, looking & equals1);
    looking = safeSelect(looking, 0, equals1);
    invalid = safeSelect(invalid, 1, looking & (equals0 ^ 1));
  }

  const valid = zero & lvalid & (invalid ^ 1) & (looking ^ 1);

  if (valid === 0)
    throw new Error('Invalid RSA ciphertext.');

  return rest.slice(index + 1);
}

/**
 * "Veil" an RSA ciphertext to hide the key size.
 * @param {Buffer} msg
 * @param {Number} bits
 * @param {Buffer} key
 * @returns {Buffer}
 */

function veil(msg, bits, key) {
  assert((msg != null && msg._isBuffer === true));
  assert((bits >>> 0) === bits);

  const k = RSAPublicKey.decode(key);

  if (!k.verify())
    throw new Error('Invalid RSA public key.');

  if (msg.length !== k.size())
    throw new Error('Invalid RSA ciphertext.');

  if (bits < k.bits())
    throw new Error('Cannot make ciphertext smaller.');

  const bytes = (bits + 7) >>> 3;
  const c = BN.decode(msg);

  if (c.cmp(k.n) >= 0)
    throw new Error('Invalid RSA ciphertext.');

  const vmax = BN.shift(1, bits);
  const rmax = vmax.sub(c).iadd(k.n).isubn(1).div(k.n);

  assert(rmax.sign() > 0);

  let v = vmax;

  while (v.cmp(vmax) >= 0) {
    const r = BN.random(rng, 0, rmax);

    v = c.add(r.mul(k.n));
  }

  assert(v.mod(k.n).cmp(c) === 0);
  assert(v.bitLength() <= bits);

  return v.encode('be', bytes);
}

/**
 * "Unveil" a veiled RSA ciphertext.
 * @param {Buffer} msg
 * @param {Number} bits
 * @param {Buffer} key
 * @returns {Buffer}
 */

function unveil(msg, bits, key) {
  assert((msg != null && msg._isBuffer === true));
  assert((bits >>> 0) === bits);

  const k = RSAPublicKey.decode(key);

  if (!k.verify())
    throw new Error('Invalid RSA public key.');

  const klen = k.size();

  if (msg.length < klen)
    throw new Error('Invalid RSA ciphertext.');

  const v = BN.decode(msg);

  if (bits !== 0 && v.bitLength() > bits)
    throw new Error('Invalid RSA ciphertext.');

  const c = v.imod(k.n);

  return c.encode('be', klen);
}

/*
 * Digest Info
 */

function getDigestInfo(name, msg) {
  // [RFC8017] Page 63, Section B.1.
  assert(name == null || typeof name === 'string');
  assert((msg != null && msg._isBuffer === true));

  if (name == null)
    return [EMPTY, msg.length];

  const prefix = digestInfo[name];

  if (prefix == null)
    return [null, 0];

  if (prefix.length === 1)
    return [EMPTY, prefix[0]];

  return [
    prefix,
    prefix[prefix.length - 1]
  ];
}

/*
 * MGF1
 */

function mgf1xor(hash, out, seed) {
  // [RFC8017] Page 67, Section B.2.1.
  assert(hash && typeof hash.id === 'string');
  assert((out != null && out._isBuffer === true));
  assert((seed != null && seed._isBuffer === true));

  const ctr = Buffer.alloc(4, 0x00);

  let i = 0;

  while (i < out.length) {
    const digest = hash.multi(seed, ctr);

    let j = 0;

    while (i < out.length && j < digest.length)
      out[i++] ^= digest[j++];

    for (j = 3; j >= 0; j--) {
      ctr[j] += 1;

      if (ctr[j] !== 0x00)
        break;
    }
  }
}

/*
 * PSS
 */

function pssEncode(hash, msg, embits, salt) {
  // [RFC8017] Page 42, Section 9.1.1.
  assert(hash && typeof hash.id === 'string');
  assert((msg != null && msg._isBuffer === true));
  assert((embits >>> 0) === embits);
  assert((salt != null && salt._isBuffer === true));

  const hlen = hash.size;
  const slen = salt.length;
  const emlen = (embits + 7) >>> 3;

  if (msg.length !== hlen)
    throw new Error('Invalid RSA message size.');

  if (emlen < hlen + slen + 2)
    throw new Error('Message too long.');

  // EM = (PS || 0x01 || salt) || H || 0xbc
  const em = Buffer.alloc(emlen);
  const db = em.slice(0, emlen - hlen - 1);
  const h = em.slice(emlen - hlen - 1, emlen - 1);
  const h0 = hash.multi(PREFIX, msg, salt);
  const mask = 0xff >>> (8 * emlen - embits);

  db.fill(0x00, 0, emlen - slen - hlen - 2);
  db[emlen - slen - hlen - 2] = 0x01;
  salt.copy(db, emlen - slen - hlen - 1);
  h0.copy(h, 0);
  em[emlen - 1] = 0xbc;

  mgf1xor(hash, db, h);

  db[0] &= mask;

  return em;
}

function pssVerify(hash, msg, em, embits, slen) {
  // [RFC8017] Page 44, Section 9.1.2.
  assert(hash && typeof hash.id === 'string');
  assert((msg != null && msg._isBuffer === true));
  assert((em != null && em._isBuffer === true));
  assert((embits >>> 0) === embits);
  assert((slen >>> 0) === slen);

  const hlen = hash.size;
  const emlen = (embits + 7) >>> 3;

  if (msg.length !== hlen)
    return false;

  if (emlen < hlen + slen + 2)
    return false;

  if (em[emlen - 1] !== 0xbc)
    return false;

  // EM = (PS || 0x01 || salt) || H || 0xbc
  const db = em.slice(0, emlen - hlen - 1);
  const h = em.slice(emlen - hlen - 1, emlen - 1);
  const mask = 0xff >>> (8 * emlen - embits);

  if (em[0] & ~mask)
    return false;

  mgf1xor(hash, db, h);

  db[0] &= mask;

  if (slen === 0) { // Auto
    slen = -1;

    for (let i = 0; i < db.length; i++) {
      if (db[i] === 0x00)
        continue;

      if (db[i] === 0x01) {
        slen = db.length - (i + 1);
        break;
      }

      return false;
    }

    if (slen === -1)
      return false;
  } else {
    const len = db.length - slen - 1;

    for (let i = 0; i < len; i++) {
      if (db[i] !== 0x00)
        return false;
    }

    if (db[len] !== 0x01)
      return false;
  }

  const salt = db.slice(db.length - slen);
  const h0 = hash.multi(PREFIX, msg, salt);

  return h0.equals(h);
}

/*
 * Expose
 */

exports.native = 0;
exports.SALT_LENGTH_AUTO = SALT_LENGTH_AUTO;
exports.SALT_LENGTH_HASH = SALT_LENGTH_HASH;
exports.privateKeyGenerate = privateKeyGenerate;
exports.privateKeyGenerateAsync = privateKeyGenerateAsync;
exports.privateKeyBits = privateKeyBits;
exports.privateKeyVerify = privateKeyVerify;
exports.privateKeyImport = privateKeyImport;
exports.privateKeyExport = privateKeyExport;
exports.publicKeyCreate = publicKeyCreate;
exports.publicKeyBits = publicKeyBits;
exports.publicKeyVerify = publicKeyVerify;
exports.publicKeyImport = publicKeyImport;
exports.publicKeyExport = publicKeyExport;
exports.sign = sign;
exports.verify = verify;
exports.encrypt = encrypt;
exports.decrypt = decrypt;
exports.signPSS = signPSS;
exports.verifyPSS = verifyPSS;
exports.encryptOAEP = encryptOAEP;
exports.decryptOAEP = decryptOAEP;
exports.veil = veil;
exports.unveil = unveil;
}],
[/* 56 */ 'bcrypto', '/lib/encoding/base64-browser.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * base64.js - base64 for bcrypto
 * Copyright (c) 2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */



module.exports = __browser_require__(57 /* '../js/base64' */, module);
}],
[/* 57 */ 'bcrypto', '/lib/js/base64.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * base64.js - base64 for javascript
 * Copyright (c) 2019-2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc4648
 */



const assert = __browser_require__(24 /* '../internal/assert' */, module);

/*
 * Constants
 */

const CHARSET =
  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

const CHARSET_URL =
  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';

const TABLE = [
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, 62, -1, -1, -1, 63,
  52, 53, 54, 55, 56, 57, 58, 59,
  60, 61, -1, -1, -1, -1, -1, -1,
  -1,  0,  1,  2,  3,  4,  5,  6,
   7,  8,  9, 10, 11, 12, 13, 14,
  15, 16, 17, 18, 19, 20, 21, 22,
  23, 24, 25, -1, -1, -1, -1, -1,
  -1, 26, 27, 28, 29, 30, 31, 32,
  33, 34, 35, 36, 37, 38, 39, 40,
  41, 42, 43, 44, 45, 46, 47, 48,
  49, 50, 51, -1, -1, -1, -1, -1
];

const TABLE_URL = [
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, 62, -1, -1,
  52, 53, 54, 55, 56, 57, 58, 59,
  60, 61, -1, -1, -1, -1, -1, -1,
  -1,  0,  1,  2,  3,  4,  5,  6,
   7,  8,  9, 10, 11, 12, 13, 14,
  15, 16, 17, 18, 19, 20, 21, 22,
  23, 24, 25, -1, -1, -1, -1, 63,
  -1, 26, 27, 28, 29, 30, 31, 32,
  33, 34, 35, 36, 37, 38, 39, 40,
  41, 42, 43, 44, 45, 46, 47, 48,
  49, 50, 51, -1, -1, -1, -1, -1
];

/*
 * Encoding
 */

function _encode(data, charset, pad) {
  assert((data != null && data._isBuffer === true));

  let left = data.length;
  let str = '';
  let i = 0;

  while (left >= 3) {
    const c1 = data[i++];
    const c2 = data[i++];
    const c3 = data[i++];

    str += charset[c1 >> 2];
    str += charset[((c1 & 3) << 4) | (c2 >> 4)];
    str += charset[((c2 & 0x0f) << 2) | (c3 >> 6)];
    str += charset[c3 & 0x3f];

    left -= 3;
  }

  switch (left) {
    case 1: {
      const c1 = data[i++];

      str += charset[c1 >> 2];
      str += charset[(c1 & 3) << 4];

      if (pad)
        str += '==';

      break;
    }

    case 2: {
      const c1 = data[i++];
      const c2 = data[i++];

      str += charset[c1 >> 2];
      str += charset[((c1 & 3) << 4) | (c2 >> 4)];
      str += charset[(c2 & 0x0f) << 2];

      if (pad)
        str += '=';

      break;
    }
  }

  return str;
}

/*
 * Decoding
 */

function _decode(str, table, size) {
  assert(typeof str === 'string');

  const data = Buffer.alloc(size);

  let left = str.length;
  let i = 0;
  let j = 0;

  if (left > 0 && str[left - 1] === '=')
    left -= 1;

  if (left > 0 && str[left - 1] === '=')
    left -= 1;

  if ((left & 3) === 1) // Fail early.
    throw new Error('Invalid base64 string.');

  while (left >= 4) {
    const c1 = str.charCodeAt(i++);
    const c2 = str.charCodeAt(i++);
    const c3 = str.charCodeAt(i++);
    const c4 = str.charCodeAt(i++);

    if ((c1 | c2 | c3 | c4) & 0xff80)
      throw new Error('Invalid base64 string.');

    const t1 = table[c1];
    const t2 = table[c2];
    const t3 = table[c3];
    const t4 = table[c4];

    if ((t1 | t2 | t3 | t4) < 0)
      throw new Error('Invalid base64 string.');

    data[j++] = (t1 << 2) | (t2 >> 4);
    data[j++] = (t2 << 4) | (t3 >> 2);
    data[j++] = (t3 << 6) | (t4 >> 0);

    left -= 4;
  }

  switch (left) {
    case 1: {
      throw new Error('Invalid base64 string.');
    }

    case 2: {
      const c1 = str.charCodeAt(i++);
      const c2 = str.charCodeAt(i++);

      if ((c1 | c2) & 0xff80)
        throw new Error('Invalid base64 string.');

      const t1 = table[c1];
      const t2 = table[c2];

      if ((t1 | t2) < 0)
        throw new Error('Invalid base64 string.');

      data[j++] = (t1 << 2) | (t2 >> 4);

      if (t2 & 15)
        throw new Error('Invalid base64 string.');

      break;
    }

    case 3: {
      const c1 = str.charCodeAt(i++);
      const c2 = str.charCodeAt(i++);
      const c3 = str.charCodeAt(i++);

      if ((c1 | c2 | c3) & 0xff80)
        throw new Error('Invalid base64 string.');

      const t1 = table[c1];
      const t2 = table[c2];
      const t3 = table[c3];

      if ((t1 | t2 | t3) < 0)
        throw new Error('Invalid base64 string.');

      data[j++] = (t1 << 2) | (t2 >> 4);
      data[j++] = (t2 << 4) | (t3 >> 2);

      if (t3 & 3)
        throw new Error('Invalid base64 string.');

      break;
    }
  }

  assert(j === size);

  return data;
}

/*
 * Testing
 */

function _test(str, table) {
  assert(typeof str === 'string');

  let len = str.length;

  if (len > 0 && str[len - 1] === '=')
    len -= 1;

  if (len > 0 && str[len - 1] === '=')
    len -= 1;

  if ((len & 3) === 1)
    return false;

  for (let i = 0; i < len; i++) {
    const ch = str.charCodeAt(i);

    if (ch & 0xff80)
      return false;

    if (table[ch] === -1)
      return false;
  }

  switch (len & 3) {
    case 1:
      return false;
    case 2:
      return (table[str.charCodeAt(len - 1)] & 15) === 0;
    case 3:
      return (table[str.charCodeAt(len - 1)] & 3) === 0;
  }

  return true;
}

/*
 * Base64
 */

function encode(data) {
  return _encode(data, CHARSET, true);
}

function decode(str) {
  const size = decodeSize(str);

  if (!checkPadding(str, size))
    throw new Error('Invalid base64 padding.');

  return _decode(str, TABLE, size);
}

function test(str) {
  const size = decodeSize(str);

  if (!checkPadding(str, size))
    return false;

  return _test(str, TABLE);
}

/*
 * Base64-URL
 */

function encodeURL(data) {
  return _encode(data, CHARSET_URL, false);
}

function decodeURL(str) {
  const size = decodeSize(str);

  if (!checkPadding(str, 0))
    throw new Error('Invalid base64 padding.');

  return _decode(str, TABLE_URL, size);
}

function testURL(str) {
  if (!checkPadding(str, 0))
    return false;

  return _test(str, TABLE_URL);
}

/*
 * Helpers
 */

function decodeSize(str) {
  assert(typeof str === 'string');

  let len = str.length;

  if (len > 0 && str[len - 1] === '=')
    len -= 1;

  if (len > 0 && str[len - 1] === '=')
    len -= 1;

  let size = (len >>> 2) * 3;

  const rem = len & 3;

  if (rem)
    size += rem - 1;

  return size;
}

function checkPadding(str, size) {
  assert(typeof str === 'string');

  switch (size % 3) {
    case 0: {
      if (str.length === 0)
        return true;

      if (str.length === 1)
        return str[0] !== '=';

      return str[str.length - 2] !== '='
          && str[str.length - 1] !== '=';
    }

    case 1: {
      return str.length >= 4
          && str[str.length - 2] === '='
          && str[str.length - 1] === '=';
    }

    case 2: {
      return str.length >= 4
          && str[str.length - 2] !== '='
          && str[str.length - 1] === '=';
    }

    default: {
      throw new Error('unreachable');
    }
  }
}

/*
 * Expose
 */

exports.native = 0;
exports.encode = encode;
exports.decode = decode;
exports.test = test;
exports.encodeURL = encodeURL;
exports.decodeURL = decodeURL;
exports.testURL = testURL;
}],
[/* 58 */ 'bcrypto', '/lib/p256-browser.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * p256.js - p256 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */



module.exports = __browser_require__(59 /* './js/p256' */, module);
}],
[/* 59 */ 'bcrypto', '/lib/js/p256.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * p256.js - ECDSA-P256 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */



const ECDSA = __browser_require__(60 /* './ecdsa' */, module);
const SHA256 = __browser_require__(33 /* '../sha256' */, module);

/*
 * Expose
 */

module.exports = new ECDSA('P256', SHA256, SHA256);
}],
[/* 60 */ 'bcrypto', '/lib/js/ecdsa.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * ecdsa.js - ECDSA for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/elliptic:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/elliptic
 *
 * References:
 *
 *   [SEC1] SEC 1: Elliptic Curve Cryptography, Version 2.0
 *     Certicom Research
 *     http://www.secg.org/sec1-v2.pdf
 *
 *   [FIPS186] Suite B Implementer's Guide to FIPS 186-3 (ECDSA)
 *     https://tinyurl.com/fips186-guide
 *
 *   [GECC] Guide to Elliptic Curve Cryptography
 *     D. Hankerson, A. Menezes, and S. Vanstone
 *     https://tinyurl.com/guide-to-ecc
 *
 *   [RFC6979] Deterministic Usage of the Digital Signature
 *             Algorithm (DSA) and Elliptic Curve Digital
 *             Signature Algorithm (ECDSA)
 *     T. Pornin
 *     https://tools.ietf.org/html/rfc6979
 */



const assert = __browser_require__(24 /* '../internal/assert' */, module);
const BN = __browser_require__(42 /* '../bn' */, module);
const rng = __browser_require__(45 /* '../random' */, module);
const asn1 = __browser_require__(50 /* '../internal/asn1' */, module);
const Schnorr = __browser_require__(61 /* './schnorr-legacy' */, module);
const HmacDRBG = __browser_require__(47 /* '../hmac-drbg' */, module);
const elliptic = __browser_require__(65 /* './elliptic' */, module);

/**
 * ECDSA
 */

class ECDSA {
  constructor(name, hash, xof, pre) {
    assert(typeof name === 'string');
    assert(hash);
    assert(xof);

    this.id = name;
    this.type = 'ecdsa';
    this.hash = hash;
    this.xof = xof;
    this.native = 0;

    this._pre = pre || null;
    this._curve = null;
    this._schnorr = null;
  }

  get curve() {
    if (!this._curve) {
      this._curve = elliptic.curve(this.id, this._pre);
      this._curve.precompute(rng);
      this._pre = null;
    }
    return this._curve;
  }

  get schnorr() {
    if (!this._schnorr)
      this._schnorr = new Schnorr(this.curve, this.xof);
    return this._schnorr;
  }

  get size() {
    return this.curve.fieldSize;
  }

  get bits() {
    return this.curve.fieldBits;
  }

  privateKeyGenerate() {
    const a = this.curve.randomScalar(rng);
    return this.curve.encodeScalar(a);
  }

  privateKeyVerify(key) {
    assert((key != null && key._isBuffer === true));

    let a;
    try {
      a = this.curve.decodeScalar(key);
    } catch (e) {
      return false;
    }

    return !a.isZero() && a.cmp(this.curve.n) < 0;
  }

  privateKeyExport(key) {
    const pub = this.publicKeyCreate(key, false);
    const {x, y} = this.publicKeyExport(pub);

    return {
      d: Buffer.from(key),
      x,
      y
    };
  }

  privateKeyImport(json) {
    assert(json && typeof json === 'object');

    const a = BN.decode(json.d, this.curve.endian);

    if (a.isZero() || a.cmp(this.curve.n) >= 0)
      throw new Error('Invalid private key.');

    return this.curve.encodeScalar(a);
  }

  privateKeyTweakAdd(key, tweak) {
    const t = this.curve.decodeScalar(tweak);

    if (t.cmp(this.curve.n) >= 0)
      throw new Error('Invalid scalar.');

    const a = this.curve.decodeScalar(key);

    if (a.isZero() || a.cmp(this.curve.n) >= 0)
      throw new Error('Invalid private key.');

    const k = a.add(t).imod(this.curve.n);

    if (k.isZero())
      throw new Error('Invalid private key.');

    return this.curve.encodeScalar(k);
  }

  privateKeyTweakMul(key, tweak) {
    const t = this.curve.decodeScalar(tweak);

    if (t.isZero() || t.cmp(this.curve.n) >= 0)
      throw new Error('Invalid scalar.');

    const a = this.curve.decodeScalar(key);

    if (a.isZero() || a.cmp(this.curve.n) >= 0)
      throw new Error('Invalid private key.');

    const k = a.mul(t).imod(this.curve.n);

    if (k.isZero())
      throw new Error('Invalid private key.');

    return this.curve.encodeScalar(k);
  }

  privateKeyNegate(key) {
    const a = this.curve.decodeScalar(key);

    if (a.isZero() || a.cmp(this.curve.n) >= 0)
      throw new Error('Invalid private key.');

    const k = a.neg().imod(this.curve.n);

    return this.curve.encodeScalar(k);
  }

  privateKeyInvert(key) {
    const a = this.curve.decodeScalar(key);

    if (a.isZero() || a.cmp(this.curve.n) >= 0)
      throw new Error('Invalid private key.');

    const k = a.invert(this.curve.n);

    return this.curve.encodeScalar(k);
  }

  publicKeyCreate(key, compress) {
    const a = this.curve.decodeScalar(key);

    if (a.isZero() || a.cmp(this.curve.n) >= 0)
      throw new Error('Invalid private key.');

    const A = this.curve.g.mulBlind(a);

    return A.encode(compress);
  }

  publicKeyConvert(key, compress) {
    const A = this.curve.decodePoint(key);
    return A.encode(compress);
  }

  publicKeyFromUniform(bytes, compress) {
    const u = this.curve.decodeUniform(bytes);
    const A = this.curve.pointFromUniform(u);

    return A.encode(compress);
  }

  publicKeyToUniform(key, hint = rng.randomInt()) {
    const A = this.curve.decodePoint(key);
    const u = this.curve.pointToUniform(A, hint);

    return this.curve.encodeUniform(u, hint >>> 8);
  }

  publicKeyFromHash(bytes, compress) {
    const A = this.curve.pointFromHash(bytes);
    return A.encode(compress);
  }

  publicKeyToHash(key) {
    const A = this.curve.decodePoint(key);
    return this.curve.pointToHash(A, 0, rng);
  }

  publicKeyVerify(key) {
    assert((key != null && key._isBuffer === true));

    try {
      this.curve.decodePoint(key);
    } catch (e) {
      return false;
    }

    return true;
  }

  publicKeyExport(key) {
    const {x, y} = this.curve.decodePoint(key);

    return {
      x: this.curve.encodeField(x.fromRed()),
      y: this.curve.encodeField(y.fromRed())
    };
  }

  publicKeyImport(json, compress) {
    assert(json && typeof json === 'object');

    const x = BN.decode(json.x, this.curve.endian);

    if (x.cmp(this.curve.p) >= 0)
      throw new Error('Invalid point.');

    if (json.y != null) {
      const y = BN.decode(json.y, this.curve.endian);

      if (y.cmp(this.curve.p) >= 0)
        throw new Error('Invalid point.');

      const A = this.curve.point(x, y);

      if (!A.validate())
        throw new Error('Invalid point.');

      return A.encode(compress);
    }

    const A = this.curve.pointFromX(x, json.sign);

    return A.encode(compress);
  }

  publicKeyTweakAdd(key, tweak, compress) {
    const t = this.curve.decodeScalar(tweak);

    if (t.cmp(this.curve.n) >= 0)
      throw new Error('Invalid scalar.');

    const A = this.curve.decodePoint(key);
    const T = this.curve.g.jmul(t);
    const P = T.add(A);

    return P.encode(compress);
  }

  publicKeyTweakMul(key, tweak, compress) {
    const t = this.curve.decodeScalar(tweak);

    if (t.isZero() || t.cmp(this.curve.n) >= 0)
      throw new Error('Invalid scalar.');

    const A = this.curve.decodePoint(key);
    const P = A.mul(t);

    return P.encode(compress);
  }

  publicKeyCombine(keys, compress) {
    assert(Array.isArray(keys));

    let P = this.curve.jpoint();

    for (const key of keys) {
      const A = this.curve.decodePoint(key);

      P = P.add(A);
    }

    return P.encode(compress);
  }

  publicKeyNegate(key, compress) {
    const A = this.curve.decodePoint(key);
    const P = A.neg();

    return P.encode(compress);
  }

  signatureNormalize(sig) {
    const [r, s] = this._decodeCompact(sig);

    if (s.cmp(this.curve.nh) > 0)
      s.ineg().imod(this.curve.n);

    return this._encodeCompact(r, s);
  }

  signatureNormalizeDER(sig) {
    const [r, s] = this._decodeDER(sig, false);

    if (s.cmp(this.curve.nh) > 0)
      s.ineg().imod(this.curve.n);

    return this._encodeDER(r, s);
  }

  signatureExport(sig) {
    const [r, s] = this._decodeCompact(sig);
    return this._encodeDER(r, s);
  }

  signatureImport(sig) {
    const [r, s] = this._decodeDER(sig, false);
    return this._encodeCompact(r, s);
  }

  isLowS(sig) {
    assert((sig != null && sig._isBuffer === true));

    let s;
    try {
      [, s] = this._decodeCompact(sig);
    } catch (e) {
      return false;
    }

    return s.cmp(this.curve.nh) <= 0;
  }

  isLowDER(sig) {
    assert((sig != null && sig._isBuffer === true));

    let s;
    try {
      [, s] = this._decodeDER(sig, false);
    } catch (e) {
      return false;
    }

    return s.cmp(this.curve.nh) <= 0;
  }

  sign(msg, key) {
    const [r, s] = this._sign(msg, key);
    return this._encodeCompact(r, s);
  }

  signRecoverable(msg, key) {
    const [r, s, param] = this._sign(msg, key);
    return [this._encodeCompact(r, s), param];
  }

  signDER(msg, key) {
    const [r, s] = this._sign(msg, key);
    return this._encodeDER(r, s);
  }

  signRecoverableDER(msg, key) {
    const [r, s, param] = this._sign(msg, key);
    return [this._encodeDER(r, s), param];
  }

  _sign(msg, key) {
    // ECDSA Signing.
    //
    // [SEC1] Page 44, Section 4.1.3.
    // [GECC] Algorithm 4.29, Page 184, Section 4.4.1.
    // [RFC6979] Page 9, Section 2.4.
    // [RFC6979] Page 10, Section 3.2.
    //
    // Assumptions:
    //
    //   - Let `m` be an integer reduced from bytes.
    //   - Let `a` be a secret non-zero scalar.
    //   - Let `k` be a random non-zero scalar.
    //   - R != O, r != 0, s != 0.
    //
    // Computation:
    //
    //   k = random integer in [1,n-1]
    //   R = G * k
    //   r = x(R) mod n
    //   s = (r * a + m) / k mod n
    //   s = -s mod n, if s > n / 2
    //   S = (r, s)
    //
    // We can blind the scalar arithmetic
    // with a random integer `b` like so:
    //
    //   b = random integer in [1,n-1]
    //   s = (r * (a * b) + m * b) / (k * b) mod n
    //
    // Note that `k` must remain secret,
    // otherwise an attacker can compute:
    //
    //   a = (s * k - m) / r mod n
    //
    // This means that if two signatures
    // share the same `r` value, an attacker
    // can compute:
    //
    //   k = (m1 - m2) / (+-s1 - +-s2) mod n
    //   a = (s1 * k - m1) / r mod n
    //
    // Assuming:
    //
    //   s1 = (r * a + m1) / k mod n
    //   s2 = (r * a + m2) / k mod n
    //
    // To mitigate this, `k` can be generated
    // deterministically using the HMAC-DRBG
    // construction described in [RFC6979].
    const {n, nh} = this.curve;
    const G = this.curve.g;
    const a = this.curve.decodeScalar(key);

    if (a.isZero() || a.cmp(n) >= 0)
      throw new Error('Invalid private key.');

    const m = this._reduce(msg);
    const nonce = this.curve.encodeScalar(m);
    const drbg = new HmacDRBG(this.hash, key, nonce);

    for (;;) {
      const bytes = drbg.generate(this.curve.scalarSize);
      const k = this._truncate(bytes);

      if (k.isZero() || k.cmp(n) >= 0)
        continue;

      const R = G.mulBlind(k);

      if (R.isInfinity())
        continue;

      const x = R.getX();
      const r = x.mod(n);

      if (r.isZero())
        continue;

      const b = this.curve.randomScalar(rng);
      const ki = k.mul(b).fermat(n);
      const ba = a.mul(b).imod(n);
      const bm = m.mul(b).imod(n);
      const sk = r.mul(ba).iadd(bm).imod(n);
      const s = sk.mul(ki).imod(n);

      if (s.isZero())
        continue;

      let param = R.isOdd() | (!x.eq(r) << 1);

      if (s.cmp(nh) > 0) {
        s.ineg().imod(n);
        param ^= 1;
      }

      return [r, s, param];
    }
  }

  verify(msg, sig, key) {
    assert((msg != null && msg._isBuffer === true));
    assert((sig != null && sig._isBuffer === true));
    assert((key != null && key._isBuffer === true));

    let r, s;
    try {
      [r, s] = this._decodeCompact(sig);
    } catch (e) {
      return false;
    }

    try {
      return this._verify(msg, r, s, key);
    } catch (e) {
      return false;
    }
  }

  verifyDER(msg, sig, key) {
    assert((msg != null && msg._isBuffer === true));
    assert((sig != null && sig._isBuffer === true));
    assert((key != null && key._isBuffer === true));

    let r, s;
    try {
      [r, s] = this._decodeDER(sig, false);
    } catch (e) {
      return false;
    }

    try {
      return this._verify(msg, r, s, key);
    } catch (e) {
      return false;
    }
  }

  _verify(msg, r, s, key) {
    // ECDSA Verification.
    //
    // [SEC1] Page 46, Section 4.1.4.
    // [GECC] Algorithm 4.30, Page 184, Section 4.4.1.
    //
    // Assumptions:
    //
    //   - Let `m` be an integer reduced from bytes.
    //   - Let `r` and `s` be signature elements.
    //   - Let `A` be a valid group element.
    //   - r != 0, r < n.
    //   - s != 0, s < n.
    //   - R != O.
    //
    // Computation:
    //
    //   u1 = m / s mod n
    //   u2 = r / s mod n
    //   R = G * u1 + A * u2
    //   r == x(R) mod n
    //
    // Note that the signer can verify their
    // own signatures more efficiently with:
    //
    //   R = G * ((u1 + u2 * a) mod n)
    //
    // Furthermore, we can avoid affinization
    // of `R` by scaling `r` by `z^2` and
    // repeatedly adding `n * z^2` to it up
    // to a certain threshold.
    const {n} = this.curve;
    const G = this.curve.g;
    const m = this._reduce(msg);
    const A = this.curve.decodePoint(key);

    if (r.isZero() || r.cmp(n) >= 0)
      return false;

    if (s.isZero() || s.cmp(n) >= 0)
      return false;

    const si = s.invert(n);
    const u1 = m.mul(si).imod(n);
    const u2 = r.mul(si).imod(n);
    const R = G.jmulAdd(u1, A, u2);

    return R.eqR(r);
  }

  recover(msg, sig, param, compress) {
    assert((msg != null && msg._isBuffer === true));
    assert((sig != null && sig._isBuffer === true));
    assert((param >>> 0) === param);
    assert((param & 3) === param, 'The recovery param is more than two bits.');

    let r, s;
    try {
      [r, s] = this._decodeCompact(sig);
    } catch (e) {
      return null;
    }

    let A;
    try {
      A = this._recover(msg, r, s, param);
    } catch (e) {
      return null;
    }

    return A.encode(compress);
  }

  recoverDER(msg, sig, param, compress) {
    assert((msg != null && msg._isBuffer === true));
    assert((sig != null && sig._isBuffer === true));
    assert((param >>> 0) === param);
    assert((param & 3) === param, 'The recovery param is more than two bits.');

    let r, s;
    try {
      [r, s] = this._decodeDER(sig, false);
    } catch (e) {
      return null;
    }

    let A;
    try {
      A = this._recover(msg, r, s, param);
    } catch (e) {
      return null;
    }

    return A.encode(compress);
  }

  _recover(msg, r, s, param) {
    // ECDSA Public Key Recovery.
    //
    // [SEC1] Page 47, Section 4.1.6.
    //
    // Assumptions:
    //
    //   - Let `m` be an integer reduced from bytes.
    //   - Let `r` and `s` be signature elements.
    //   - Let `i` be an integer in [0,3].
    //   - x^3 + a * x + b is square in F(p).
    //   - If i > 1 then r < (p mod n).
    //   - r != 0, r < n.
    //   - s != 0, s < n.
    //   - A != O.
    //
    // Computation:
    //
    //   x = r + n, if i > 1
    //     = r, otherwise
    //   R' = (x, sqrt(x^3 + a * x + b))
    //   R = -R', if i mod 2 == 1
    //     = +R', otherwise
    //   s1 = m / r mod n
    //   s2 = s / r mod n
    //   A = R * s2 - G * s1
    //
    // Note that this implementation will have
    // trouble on curves where `p / n > 1`.
    const {n, pmodn} = this.curve;
    const G = this.curve.g;
    const m = this._reduce(msg);

    if (r.isZero() || r.cmp(n) >= 0)
      throw new Error('Invalid R value.');

    if (s.isZero() || s.cmp(n) >= 0)
      throw new Error('Invalid S value.');

    const sign = (param & 1) !== 0;
    const high = param >>> 1;

    let x = r;

    if (high) {
      if (this.curve.highOrder)
        throw new Error('Invalid high bit.');

      if (x.cmp(pmodn) >= 0)
        throw new Error('Invalid R value.');

      x = x.add(n);
    }

    const R = this.curve.pointFromX(x, sign);
    const ri = r.invert(n);
    const s1 = m.mul(ri).ineg().imod(n);
    const s2 = s.mul(ri).imod(n);
    const A = G.mulAdd(s1, R, s2);

    if (A.isInfinity())
      throw new Error('Invalid point.');

    return A;
  }

  derive(pub, priv, compress) {
    const A = this.curve.decodePoint(pub);
    const a = this.curve.decodeScalar(priv);

    if (a.isZero() || a.cmp(this.curve.n) >= 0)
      throw new Error('Invalid private key.');

    if (this.curve.h.cmpn(1) > 0) {
      if (A.isSmall())
        throw new Error('Invalid point.');
    }

    const P = A.mulBlind(a, rng);

    return P.encode(compress);
  }

  /*
   * Schnorr
   */

  schnorrSign(msg, key) {
    return this.schnorr.sign(msg, key);
  }

  schnorrVerify(msg, sig, key) {
    return this.schnorr.verify(msg, sig, key);
  }

  schnorrVerifyBatch(batch) {
    return this.schnorr.verifyBatch(batch);
  }

  /*
   * Helpers
   */

  _encodeCompact(r, s) {
    return Buffer.concat([
      this.curve.encodeScalar(r),
      this.curve.encodeScalar(s)
    ]);
  }

  _decodeCompact(sig) {
    assert((sig != null && sig._isBuffer === true));

    const {n} = this.curve;
    const size = this.curve.scalarSize;

    if (sig.length !== size * 2)
      throw new Error('Invalid signature size.');

    const Rraw = sig.slice(0, size);
    const Sraw = sig.slice(size, size * 2);
    const r = this.curve.decodeScalar(Rraw);
    const s = this.curve.decodeScalar(Sraw);

    if (r.cmp(n) >= 0 || s.cmp(n) >= 0)
      throw new Error('Invalid signature.');

    return [r, s];
  }

  _encodeDER(r, s) {
    const size = asn1.sizeInt(r) + asn1.sizeInt(s);
    const out = Buffer.alloc(asn1.sizeSeq(size));

    let pos = 0;

    pos = asn1.writeSeq(out, pos, size);
    pos = asn1.writeInt(out, pos, r);
    pos = asn1.writeInt(out, pos, s);

    assert(pos === out.length);

    return out;
  }

  _decodeDER(sig, strict) {
    assert((sig != null && sig._isBuffer === true));
    assert(typeof strict === 'boolean');

    const {n} = this.curve;

    let pos = 0;
    let r, s;

    pos = asn1.readSeq(sig, pos, strict);
    [r, pos] = asn1.readInt(sig, pos, strict);
    [s, pos] = asn1.readInt(sig, pos, strict);

    if (strict && pos !== sig.length)
      throw new Error('Trailing bytes.');

    if (r.cmp(n) >= 0 || s.cmp(n) >= 0)
      throw new Error('Invalid signature.');

    return [r, s];
  }

  _truncate(msg) {
    // Byte array to integer conversion.
    //
    // [SEC1] Step 5, Page 45, Section 4.1.3.
    // [FIPS186] Page 25, Section B.2.
    //
    // The two sources above disagree on this.
    //
    // FIPS186 simply modulos the entire byte
    // array by the order, whereas SEC1 takes
    // the left-most ceil(log2(n+1)) bits modulo
    // the order (and maybe does other stuff).
    //
    // Instead of trying to decipher all of
    // this nonsense, we simply replicate the
    // OpenSSL behavior (which, in actuality,
    // is more similar to the SEC1 behavior).
    assert((msg != null && msg._isBuffer === true));

    const bits = this.curve.n.bitLength();
    const bytes = (bits + 7) >>> 3;

    if (msg.length > bytes)
      msg = msg.slice(0, bytes);

    const m = BN.decode(msg, this.curve.endian);
    const d = msg.length * 8 - bits;

    if (d > 0)
      m.iushrn(d);

    return m;
  }

  _reduce(msg) {
    return this._truncate(msg).imod(this.curve.n);
  }
}

/*
 * Expose
 */

module.exports = ECDSA;
}],
[/* 61 */ 'bcrypto', '/lib/js/schnorr-legacy.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * schnorr-legacy.js - bip-schnorr for bcrypto
 * Copyright (c) 2019-2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on sipa/bip-schnorr:
 *   Copyright (c) 2018-2019, Pieter Wuille (2-clause BSD License).
 *   https://github.com/sipa/bips/blob/d194620/bip-schnorr/reference.py
 *
 * Parts of this software are based on ElementsProject/secp256k1-zkp:
 *   Copyright (c) 2013, Pieter Wuille.
 *   https://github.com/ElementsProject/secp256k1-zkp
 *
 * Resources:
 *   https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki
 *   https://github.com/sipa/bips/blob/d194620/bip-schnorr/reference.py
 *   https://github.com/sipa/bips/blob/d194620/bip-schnorr/test-vectors.csv
 *   https://github.com/ElementsProject/secp256k1-zkp/tree/11af701/src/modules/schnorrsig
 *   https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/2019-05-15-schnorr.md
 *
 * References:
 *
 *   [SCHNORR] Schnorr Signatures for secp256k1
 *     Pieter Wuille
 *     https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki
 *
 *   [CASH] Schnorr Signature specification
 *     Mark B. Lundeberg
 *     https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/2019-05-15-schnorr.md
 */



const assert = __browser_require__(24 /* '../internal/assert' */, module);
const BatchRNG = __browser_require__(62 /* './batch-rng' */, module);
const BN = __browser_require__(42 /* '../bn' */, module);

/**
 * Schnorr
 */

class Schnorr {
  constructor(curve, hash) {
    this.curve = curve;
    this.hash = hash;
    this.rng = new BatchRNG(this.curve, this.encode.bind(this));
  }

  check() {
    // [SCHNORR] "Footnotes".
    // Must be congruent to 3 mod 4.
    if (this.curve.p.andln(3) !== 3)
      throw new Error(`Schnorr is not supported for ${this.curve.id}.`);
  }

  encode(key) {
    // Extra speedy key reserialization.
    assert((key != null && key._isBuffer === true));

    const {fieldSize} = this.curve;

    if (key.length === 1 + fieldSize)
      return key;

    if (key.length !== 1 + fieldSize * 2)
      throw new Error('Invalid point.');

    const out = Buffer.alloc(1 + fieldSize);

    out[0] = 0x02 | (key[key.length - 1] & 1);
    key.copy(out, 1, 1, 1 + fieldSize);

    return out;
  }

  hashInt(...items) {
    // [SCHNORR] "Specification".
    // eslint-disable-next-line
    const h = new this.hash();

    h.init();

    for (const item of items)
      h.update(item);

    let hash = h.final(this.curve.scalarSize);

    if (hash.length > this.curve.scalarSize)
      hash = hash.slice(0, this.curve.scalarSize);

    const num = BN.decode(hash, this.curve.endian);

    num.iumaskn(this.curve.scalarBits);

    return num.imod(this.curve.n);
  }

  hashNonce(a, m) {
    return this.hashInt(a, m);
  }

  hashChallenge(R, A, m) {
    return this.hashInt(R, this.encode(A), m);
  }

  sign(msg, key) {
    assert((msg != null && msg._isBuffer === true));

    this.check();

    return this._sign(msg, key);
  }

  _sign(msg, key) {
    // Schnorr Signing.
    //
    // [SCHNORR] "Signing".
    // [CASH] "Recommended practices for secure signature generation".
    //
    // Assumptions:
    //
    //   - Let `H` be a cryptographic hash function.
    //   - Let `m` be a 32-byte array.
    //   - Let `a` be a secret non-zero scalar.
    //   - k != 0.
    //
    // Computation:
    //
    //   A = G * a
    //   k = H(a, m) mod n
    //   R = G * k
    //   k = -k mod n, if y(R) is not square
    //   r = x(R)
    //   e = H(r, A, m) mod n
    //   s = (k + e * a) mod n
    //   S = (r, s)
    //
    // Note that `k` must remain secret,
    // otherwise an attacker can compute:
    //
    //   a = (s - k) / e mod n
    const {n} = this.curve;
    const G = this.curve.g;
    const a = this.curve.decodeScalar(key);

    if (a.isZero() || a.cmp(n) >= 0)
      throw new Error('Invalid private key.');

    const A = G.mulBlind(a);
    const k = this.hashNonce(key, msg);

    if (k.isZero())
      throw new Error('Signing failed (k\' = 0).');

    const R = G.mulBlind(k);

    if (!R.isSquare())
      k.ineg().imod(n);

    const Rraw = R.encodeX();
    const Araw = A.encode();
    const e = this.hashChallenge(Rraw, Araw, msg);
    const s = k.add(e.mul(a)).imod(n);

    return Buffer.concat([Rraw, this.curve.encodeScalar(s)]);
  }

  verify(msg, sig, key) {
    assert((msg != null && msg._isBuffer === true));
    assert((sig != null && sig._isBuffer === true));
    assert((key != null && key._isBuffer === true));

    this.check();

    if (sig.length !== this.curve.fieldSize + this.curve.scalarSize)
      return false;

    try {
      return this._verify(msg, sig, key);
    } catch (e) {
      return false;
    }
  }

  _verify(msg, sig, key) {
    // Schnorr Verification.
    //
    // [SCHNORR] "Verification".
    // [CASH] "Signature verification algorithm".
    //
    // Assumptions:
    //
    //   - Let `H` be a cryptographic hash function.
    //   - Let `m` be a 32-byte array.
    //   - Let `r` and `s` be signature elements.
    //   - Let `A` be a valid group element.
    //   - r^3 + a * r + b is square in F(p).
    //   - sqrt(r^3 + a * r + b) is square in F(p).
    //   - r < p, s < n.
    //   - R != O.
    //
    // Computation:
    //
    //   R = (r, sqrt(r^3 + a * r + b))
    //   e = H(r, A, m) mod n
    //   R == G * s - A * e
    //
    // We can skip a square root with:
    //
    //   e = H(r, A, m) mod n
    //   R = G * s - A * e
    //   y(R) is square
    //   x(R) == r
    //
    // We can also avoid affinization by
    // replacing the two assertions with:
    //
    //   (y(R) * z(R) mod p) is square
    //   x(R) == r * z(R)^2 mod p
    //
    // Furthermore, squareness can be calculated
    // with a variable time Jacobi symbol algorithm.
    const {p, n} = this.curve;
    const G = this.curve.g;
    const Rraw = sig.slice(0, this.curve.fieldSize);
    const sraw = sig.slice(this.curve.fieldSize);
    const r = this.curve.decodeField(Rraw);
    const s = this.curve.decodeScalar(sraw);
    const A = this.curve.decodePoint(key);

    if (r.cmp(p) >= 0 || s.cmp(n) >= 0)
      return false;

    const e = this.hashChallenge(Rraw, key, msg);
    const R = G.jmulAdd(s, A, e.ineg().imod(n));

    if (!R.isSquare())
      return false;

    if (!R.eqX(r))
      return false;

    return true;
  }

  verifyBatch(batch) {
    assert(Array.isArray(batch));

    this.check();

    for (const item of batch) {
      assert(Array.isArray(item) && item.length === 3);

      const [msg, sig, key] = item;

      assert((msg != null && msg._isBuffer === true));
      assert((sig != null && sig._isBuffer === true));
      assert((key != null && key._isBuffer === true));

      if (sig.length !== this.curve.fieldSize + this.curve.scalarSize)
        return false;
    }

    try {
      return this._verifyBatch(batch);
    } catch (e) {
      return false;
    }
  }

  _verifyBatch(batch) {
    // Schnorr Batch Verification.
    //
    // [SCHNORR] "Batch Verification".
    //
    // Assumptions:
    //
    //   - Let `H` be a cryptographic hash function.
    //   - Let `m` be a 32-byte array.
    //   - Let `r` and `s` be signature elements.
    //   - Let `A` be a valid group element.
    //   - Let `i` be the batch item index.
    //   - r^3 + a * r + b is square in F(p).
    //   - sqrt(r^3 + a * r + b) is square in F(p).
    //   - r < p, s < n.
    //   - a1 = 1 mod n.
    //
    // Computation:
    //
    //   Ri = (ri, sqrt(ri^3 + a * ri + b))
    //   ei = H(ri, Ai, mi) mod n
    //   ai = random integer in [1,n-1]
    //   lhs = si * ai + ... mod n
    //   rhs = Ri * ai + Ai * (ei * ai mod n) + ...
    //   G * -lhs + rhs == O
    const {n} = this.curve;
    const G = this.curve.g;
    const points = new Array(1 + batch.length * 2);
    const coeffs = new Array(1 + batch.length * 2);
    const sum = new BN(0);

    this.rng.init(batch);

    points[0] = G;
    coeffs[0] = sum;

    for (let i = 0; i < batch.length; i++) {
      const [msg, sig, key] = batch[i];
      const Rraw = sig.slice(0, this.curve.fieldSize);
      const sraw = sig.slice(this.curve.fieldSize);
      const R = this.curve.decodeSquare(Rraw);
      const s = this.curve.decodeScalar(sraw);
      const A = this.curve.decodePoint(key);

      if (s.cmp(n) >= 0)
        return false;

      const e = this.hashChallenge(Rraw, key, msg);
      const a = this.rng.generate(i);
      const ea = e.mul(a).imod(n);

      sum.iadd(s.mul(a)).imod(n);

      points[1 + i * 2 + 0] = R;
      coeffs[1 + i * 2 + 0] = a;
      points[1 + i * 2 + 1] = A;
      coeffs[1 + i * 2 + 1] = ea;
    }

    sum.ineg().imod(n);

    return this.curve.jmulAll(points, coeffs).isInfinity();
  }
}

/*
 * Expose
 */

module.exports = Schnorr;
}],
[/* 62 */ 'bcrypto', '/lib/js/batch-rng.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * batch-rng.js - batch rng for bcrypto
 * Copyright (c) 2019-2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on ElementsProject/secp256k1-zkp:
 *   Copyright (c) 2013, Pieter Wuille.
 *   https://github.com/ElementsProject/secp256k1-zkp
 *
 * Resources:
 *   https://github.com/ElementsProject/secp256k1-zkp/blob/11af701/src/modules/schnorrsig/main_impl.h#L166
 *   https://github.com/ElementsProject/secp256k1-zkp/blob/11af701/src/scalar_4x64_impl.h#L972
 *   https://github.com/ElementsProject/secp256k1-zkp/blob/11af701/src/scalar_8x32_impl.h#L747
 */



const assert = __browser_require__(24 /* '../internal/assert' */, module);
const BN = __browser_require__(42 /* '../bn' */, module);
const ChaCha20 = __browser_require__(63 /* '../chacha20' */, module);
const SHA256 = __browser_require__(33 /* '../sha256' */, module);

/**
 * BatchRNG
 */

class BatchRNG {
  constructor(curve, encode = key => key) {
    this.curve = curve;
    this.encode = encode;
    this.hash = new SHA256();
    this.chacha = new ChaCha20();
    this.key = Buffer.alloc(32, 0x00);
    this.iv = Buffer.alloc(8, 0x00);
    this.cache = [new BN(1), new BN(1)];
  }

  init(batch) {
    assert(Array.isArray(batch));

    this.hash.init();

    for (const [msg, sig, key] of batch) {
      this.hash.update(SHA256.digest(msg));
      this.hash.update(sig);
      this.hash.update(this.encode(key));
    }

    this.key = this.hash.final();
    this.cache[0] = new BN(1);
    this.cache[1] = new BN(1);

    return this;
  }

  encrypt(counter) {
    const size = this.curve.scalarSize * 2;
    const data = Buffer.alloc(size, 0x00);
    const left = data.slice(0, this.curve.scalarSize);
    const right = data.slice(this.curve.scalarSize);

    this.chacha.init(this.key, this.iv, counter);
    this.chacha.encrypt(data);

    return [
      this.curve.decodeScalar(left),
      this.curve.decodeScalar(right)
    ];
  }

  refresh(counter) {
    let overflow = 0;

    for (;;) {
      // First word is always zero.
      this.iv[4] = overflow;
      this.iv[5] = overflow >>> 8;
      this.iv[6] = overflow >>> 16;
      this.iv[7] = overflow >>> 24;

      overflow += 1;

      const [s1, s2] = this.encrypt(counter);

      if (s1.isZero() || s1.cmp(this.curve.n) >= 0)
        continue;

      if (s2.isZero() || s2.cmp(this.curve.n) >= 0)
        continue;

      this.cache[0] = s1;
      this.cache[1] = s2;

      break;
    }
  }

  generate(index) {
    assert((index >>> 0) === index);

    if (index & 1)
      this.refresh(index >>> 1);

    return this.cache[index & 1];
  }
}

/*
 * Expose
 */

module.exports = BatchRNG;
}],
[/* 63 */ 'bcrypto', '/lib/chacha20-browser.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * chacha20.js - chacha20 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */



module.exports = __browser_require__(64 /* './js/chacha20' */, module);
}],
[/* 64 */ 'bcrypto', '/lib/js/chacha20.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * chacha20.js - chacha20 for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources
 *   https://en.wikipedia.org/wiki/Chacha20
 *   https://tools.ietf.org/html/rfc7539#section-2
 *   https://cr.yp.to/chacha.html
 */



const assert = __browser_require__(24 /* '../internal/assert' */, module);

/*
 * Constants
 */

const BIG_ENDIAN = new Int8Array(new Int16Array([1]).buffer)[0] === 0;

/**
 * ChaCha20
 */

class ChaCha20 {
  /**
   * Create a ChaCha20 context.
   * @constructor
   */

  constructor() {
    this.state = new Uint32Array(16);
    this.stream = new Uint32Array(16);
    this.bytes = new Uint8Array(this.stream.buffer);
    this.pos = -1;

    if (BIG_ENDIAN)
      this.bytes = Buffer.alloc(64);
  }

  /**
   * Initialize chacha20 with a key, nonce, and counter.
   * @param {Buffer} key
   * @param {Buffer} nonce
   * @param {Number} counter
   */

  init(key, nonce, counter) {
    if (counter == null)
      counter = 0;

    assert((key != null && key._isBuffer === true));
    assert((nonce != null && nonce._isBuffer === true));
    assert(Number.isSafeInteger(counter));

    if (key.length !== 16 && key.length !== 32)
      throw new RangeError('Invalid key size.');

    if (nonce.length >= 24) {
      key = ChaCha20.derive(key, nonce.slice(0, 16));
      nonce = nonce.slice(16);
    }

    this.state[0] = 0x61707865;
    this.state[1] = key.length < 32 ? 0x3120646e : 0x3320646e;
    this.state[2] = key.length < 32 ? 0x79622d36 : 0x79622d32;
    this.state[3] = 0x6b206574;
    this.state[4] = readU32(key, 0);
    this.state[5] = readU32(key, 4);
    this.state[6] = readU32(key, 8);
    this.state[7] = readU32(key, 12);
    this.state[8] = readU32(key, 16 % key.length);
    this.state[9] = readU32(key, 20 % key.length);
    this.state[10] = readU32(key, 24 % key.length);
    this.state[11] = readU32(key, 28 % key.length);
    this.state[12] = counter >>> 0;

    if (nonce.length === 8) {
      this.state[13] = (counter / 0x100000000) >>> 0;
      this.state[14] = readU32(nonce, 0);
      this.state[15] = readU32(nonce, 4);
    } else if (nonce.length === 12) {
      this.state[13] = readU32(nonce, 0);
      this.state[14] = readU32(nonce, 4);
      this.state[15] = readU32(nonce, 8);
    } else if (nonce.length === 16) {
      this.state[12] = readU32(nonce, 0);
      this.state[13] = readU32(nonce, 4);
      this.state[14] = readU32(nonce, 8);
      this.state[15] = readU32(nonce, 12);
    } else {
      throw new RangeError('Invalid nonce size.');
    }

    this.pos = 0;

    return this;
  }

  /**
   * Encrypt/decrypt data.
   * @param {Buffer} data - Will be mutated.
   * @returns {Buffer}
   */

  encrypt(data) {
    assert((data != null && data._isBuffer === true));

    if (this.pos === -1)
      throw new Error('Context is not initialized.');

    for (let i = 0; i < data.length; i++) {
      if ((this.pos & 63) === 0) {
        this._block();
        this.pos = 0;
      }

      data[i] ^= this.bytes[this.pos++];
    }

    return data;
  }

  /**
   * Stir the stream.
   */

  _block() {
    for (let i = 0; i < 16; i++)
      this.stream[i] = this.state[i];

    for (let i = 0; i < 10; i++) {
      qround(this.stream, 0, 4, 8, 12);
      qround(this.stream, 1, 5, 9, 13);
      qround(this.stream, 2, 6, 10, 14);
      qround(this.stream, 3, 7, 11, 15);
      qround(this.stream, 0, 5, 10, 15);
      qround(this.stream, 1, 6, 11, 12);
      qround(this.stream, 2, 7, 8, 13);
      qround(this.stream, 3, 4, 9, 14);
    }

    for (let i = 0; i < 16; i++)
      this.stream[i] += this.state[i];

    if (BIG_ENDIAN) {
      for (let i = 0; i < 16; i++)
        writeU32(this.bytes, this.stream[i], i * 4);
    }

    this.state[12] += 1;

    if (this.state[12] === 0)
      this.state[13] += 1;
  }

  /**
   * Destroy context.
   */

  destroy() {
    for (let i = 0; i < 16; i++) {
      this.state[i] = 0;
      this.stream[i] = 0;
    }

    if (BIG_ENDIAN) {
      for (let i = 0; i < 64; i++)
        this.bytes[i] = 0;
    }

    this.pos = -1;

    return this;
  }

  /**
   * Derive key with XChaCha20.
   * @param {Buffer} key
   * @param {Buffer} nonce
   * @returns {Buffer}
   */

  static derive(key, nonce) {
    assert((key != null && key._isBuffer === true));
    assert((nonce != null && nonce._isBuffer === true));

    if (key.length !== 16 && key.length !== 32)
      throw new RangeError('Invalid key size.');

    if (nonce.length !== 16)
      throw new RangeError('Invalid nonce size.');

    const state = new Uint32Array(16);

    state[0] = 0x61707865;
    state[1] = key.length < 32 ? 0x3120646e : 0x3320646e;
    state[2] = key.length < 32 ? 0x79622d36 : 0x79622d32;
    state[3] = 0x6b206574;
    state[4] = readU32(key, 0);
    state[5] = readU32(key, 4);
    state[6] = readU32(key, 8);
    state[7] = readU32(key, 12);
    state[8] = readU32(key, 16 % key.length);
    state[9] = readU32(key, 20 % key.length);
    state[10] = readU32(key, 24 % key.length);
    state[11] = readU32(key, 28 % key.length);
    state[12] = readU32(nonce, 0);
    state[13] = readU32(nonce, 4);
    state[14] = readU32(nonce, 8);
    state[15] = readU32(nonce, 12);

    for (let i = 0; i < 10; i++) {
      qround(state, 0, 4, 8, 12);
      qround(state, 1, 5, 9, 13);
      qround(state, 2, 6, 10, 14);
      qround(state, 3, 7, 11, 15);
      qround(state, 0, 5, 10, 15);
      qround(state, 1, 6, 11, 12);
      qround(state, 2, 7, 8, 13);
      qround(state, 3, 4, 9, 14);
    }

    const out = Buffer.alloc(32);

    writeU32(out, state[0], 0);
    writeU32(out, state[1], 4);
    writeU32(out, state[2], 8);
    writeU32(out, state[3], 12);
    writeU32(out, state[12], 16);
    writeU32(out, state[13], 20);
    writeU32(out, state[14], 24);
    writeU32(out, state[15], 28);

    return out;
  }
}

/*
 * Static
 */

ChaCha20.native = 0;

/*
 * Helpers
 */

function qround(x, a, b, c, d) {
  x[a] += x[b];
  x[d] = rotl32(x[d] ^ x[a], 16);

  x[c] += x[d];
  x[b] = rotl32(x[b] ^ x[c], 12);

  x[a] += x[b];
  x[d] = rotl32(x[d] ^ x[a], 8);

  x[c] += x[d];
  x[b] = rotl32(x[b] ^ x[c], 7);
}

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}

function readU32(data, off) {
  return (data[off++]
        + data[off++] * 0x100
        + data[off++] * 0x10000
        + data[off] * 0x1000000);
}

function writeU32(dst, num, off) {
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  num >>>= 8;
  dst[off++] = num;
  return off;
}

/*
 * Expose
 */

module.exports = ChaCha20;
}],
[/* 65 */ 'bcrypto', '/lib/js/elliptic.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * elliptic.js - elliptic curves for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/elliptic:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/elliptic
 *
 * Formulas from DJB and Tanja Lange [EFD].
 *
 * References:
 *
 *   [GECC] Guide to Elliptic Curve Cryptography
 *     D. Hankerson, A. Menezes, and S. Vanstone
 *     https://tinyurl.com/guide-to-ecc
 *
 *   [GLV] Faster Point Multiplication on Elliptic Curves
 *     R. Gallant, R. Lambert, and S. Vanstone
 *     https://link.springer.com/content/pdf/10.1007/3-540-44647-8_11.pdf
 *
 *   [MONT1] Montgomery curves and the Montgomery ladder
 *     Daniel J. Bernstein, Tanja Lange
 *     https://eprint.iacr.org/2017/293.pdf
 *
 *   [SQUARED] Elligator Squared
 *     Mehdi Tibouchi
 *     https://eprint.iacr.org/2014/043.pdf
 *
 *   [SEC1] SEC 1 - Standards for Efficient Cryptography Group
 *     Certicom Research
 *     https://www.secg.org/sec1-v2.pdf
 *
 *   [SEC2] SEC 2: Recommended Elliptic Curve Domain Parameters
 *     Certicom Research
 *     https://www.secg.org/sec2-v2.pdf
 *
 *   [SIDE1] Elliptic Curves and Side-Channel Attacks
 *     Marc Joye
 *     https://pdfs.semanticscholar.org/8d69/9645033e25d74fcfd4cbf07a770d2e943e14.pdf
 *
 *   [BLIND] Side-Channel Analysis on Blinding Regular Scalar Multiplications
 *     B. Feix, M. Roussellet, A. Venelli
 *     https://eprint.iacr.org/2014/191.pdf
 *
 *   [ALT] Alternative Elliptic Curve Representations
 *     R. Struik
 *     https://tools.ietf.org/id/draft-ietf-lwig-curve-representations-02.html
 *
 *   [ARITH1] Arithmetic of Elliptic Curves
 *     Christophe Doche, Tanja Lange
 *     Handbook of Elliptic and Hyperelliptic Curve Cryptography
 *     Page 267, Section 13 (978-1-58488-518-4)
 *     https://hyperelliptic.org/HEHCC/index.html
 *
 *   [ARITH2] The Arithmetic of Elliptic Curves, 2nd Edition
 *     Joseph H. Silverman
 *     http://www.pdmi.ras.ru/~lowdimma/BSD/Silverman-Arithmetic_of_EC.pdf
 *
 *   [EFD] Explicit-Formulas Database
 *     Daniel J. Bernstein, Tanja Lange
 *     https://hyperelliptic.org/EFD/index.html
 *
 *   [SAFE] SafeCurves: choosing safe curves for elliptic-curve cryptography
 *     Daniel J. Bernstein
 *     https://safecurves.cr.yp.to/
 *
 *   [4GLV] Refinement of the Four-Dimensional GLV Method on Elliptic Curves
 *     Hairong Yi, Yuqing Zhu, and Dongdai Lin
 *     http://www.site.uottawa.ca/~cadams/papers/prepro/paper_19_slides.pdf
 *
 *   [SSWU1] Efficient Indifferentiable Hashing into Ordinary Elliptic Curves
 *     E. Brier, J. Coron, T. Icart, D. Madore, H. Randriam, M. Tibouchi
 *     https://eprint.iacr.org/2009/340.pdf
 *
 *   [SSWU2] Rational points on certain hyperelliptic curves over finite fields
 *     Maciej Ulas
 *     https://arxiv.org/abs/0706.1448
 *
 *   [H2EC] Hashing to Elliptic Curves
 *     A. Faz-Hernandez, S. Scott, N. Sullivan, R. S. Wahby, C. A. Wood
 *     https://git.io/JeWz6
 *     https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve
 *
 *   [SVDW1] Construction of Rational Points on Elliptic Curves
 *     A. Shallue, C. E. van de Woestijne
 *     https://works.bepress.com/andrew_shallue/1/download/
 *
 *   [SVDW2] Indifferentiable Hashing to Barreto-Naehrig Curves
 *     Pierre-Alain Fouque, Mehdi Tibouchi
 *     https://www.di.ens.fr/~fouque/pub/latincrypt12.pdf
 *
 *   [SVDW3] Covert ECDH over secp256k1
 *     Pieter Wuille
 *     https://gist.github.com/sipa/29118d3fcfac69f9930d57433316c039
 *
 *   [MONT2] Montgomery Curve (wikipedia)
 *     https://en.wikipedia.org/wiki/Montgomery_curve
 *
 *   [MONT3] Montgomery Curves and their arithmetic
 *     C. Costello, B. Smith
 *     https://eprint.iacr.org/2017/212.pdf
 *
 *   [ELL2] Elliptic-curve points indistinguishable from uniform random strings
 *     D. Bernstein, M. Hamburg, A. Krasnova, T. Lange
 *     https://elligator.cr.yp.to/elligator-20130828.pdf
 *
 *   [RFC7748] Elliptic Curves for Security
 *     A. Langley, M. Hamburg, S. Turner
 *     https://tools.ietf.org/html/rfc7748
 *
 *   [TWISTED] Twisted Edwards Curves
 *     D. Bernstein, P. Birkner, M. Joye, T. Lange, C. Peters
 *     https://eprint.iacr.org/2008/013.pdf
 *
 *   [ELL1] Injective Encodings to Elliptic Curves
 *     P. Fouque, A. Joux, M. Tibouchi
 *     https://eprint.iacr.org/2013/373.pdf
 *
 *   [ISOGENY] Twisting Edwards curves with isogenies
 *     Mike Hamburg
 *     https://www.shiftleft.org/papers/isogeny/isogeny.pdf
 *
 *   [RFC8032] Edwards-Curve Digital Signature Algorithm (EdDSA)
 *     S. Josefsson, SJD AB, I. Liusvaara
 *     https://tools.ietf.org/html/rfc8032
 *
 *   [SCHNORR] Schnorr Signatures for secp256k1
 *     Pieter Wuille
 *     https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki
 *
 *   [BIP340] Schnorr Signatures for secp256k1
 *     Pieter Wuille, Jonas Nick, Tim Ruffing
 *     https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
 *
 *   [JCEN12] Efficient Software Implementation of Public-Key Cryptography
 *            on Sensor Networks Using the MSP430X Microcontroller
 *     C. P. L. Gouvea, L. B. Oliveira, J. Lopez
 *     http://conradoplg.cryptoland.net/files/2010/12/jcen12.pdf
 *
 *   [FIPS186] Federal Information Processing Standards Publication
 *     National Institute of Standards and Technology
 *     https://tinyurl.com/fips-186-3
 *
 *   [RFC5639] Elliptic Curve Cryptography (ECC) Brainpool
 *             Standard Curves and Curve Generation
 *     M. Lochter, BSI, J. Merkle
 *     https://tools.ietf.org/html/rfc5639
 *
 *   [TWISTEQ] Twisted Edwards & Short Weierstrass Equivalence
 *     Christopher Jeffrey
 *     https://gist.github.com/chjj/16ba7fa08d64e8dda269a9fe5b2a8bbc
 *
 *   [ECPM] Elliptic Curve Point Multiplication (wikipedia)
 *     https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication
 */



const {custom} = __browser_require__(44 /* '../internal/custom' */, module);
const BN = __browser_require__(42 /* '../bn' */, module);

/*
 * Constants
 */

const types = {
  AFFINE: 0,
  JACOBIAN: 1,
  PROJECTIVE: 2,
  EXTENDED: 3
};

const jsfIndex = [
  -3, // -1 -1
  -1, // -1 0
  -5, // -1 1
  -7, // 0 -1
  0, // 0 0
  7, // 0 1
  5, // 1 -1
  1, // 1 0
  3  // 1 1
];

const USE_FIXED = false;

let uid = 0;

/**
 * Curve
 */

class Curve {
  constructor(Point, type, conf) {
    this.Point = null;
    this.id = null;
    this.uid = uid++;
    this.ossl = null;
    this.type = 'base';
    this.endian = 'be';
    this.hash = null;
    this.prefix = null;
    this.context = false;
    this.prime = null;
    this.p = null;
    this.red = null;
    this.fieldSize = 0;
    this.fieldBits = 0;
    this.adjustedSize = 0;
    this.signBit = 0;
    this.mask = 0;
    this.n = null;
    this.h = null;
    this.q = null;
    this.z = null;
    this.g = null;
    this.nh = null;
    this.scalarSize = 0;
    this.scalarBits = 0;
    this.zero = null;
    this.one = null;
    this.two = null;
    this.three = null;
    this.four = null;
    this.i2 = null;
    this.i3 = null;
    this.i4 = null;
    this.i6 = null;
    this.torsion = null;
    this.endo = null;
    this.hi = null;
    this._init(Point, type, conf);
  }

  _init(Point, type, conf) {
    assert(typeof Point === 'function');
    assert(typeof type === 'string');
    assert(conf && typeof conf === 'object');
    assert(conf.red == null || (conf.red instanceof BN.Red));
    assert(conf.p != null, 'Must pass a prime.');
    assert(conf.id == null || typeof conf.id === 'string');
    assert(conf.ossl == null || typeof conf.ossl === 'string');
    assert(conf.endian == null || typeof conf.endian === 'string');
    assert(conf.hash == null || typeof conf.hash === 'string');
    assert(conf.prefix == null || typeof conf.prefix === 'string');
    assert(conf.context == null || typeof conf.context === 'boolean');
    assert(conf.prime == null || typeof conf.prime === 'string');
    assert(conf.torsion == null || Array.isArray(conf.torsion));

    // Point class.
    this.Point = Point;

    // Meta.
    this.id = conf.id || null;
    this.ossl = conf.ossl || null;
    this.type = type;
    this.endian = conf.endian || (type === 'short' ? 'be' : 'le');
    this.hash = conf.hash || null;
    this.prefix = conf.prefix ? Buffer.from(conf.prefix, 'binary') : null;
    this.context = conf.context || false;
    this.prime = conf.prime || null;

    // Prime.
    this.p = BN.fromJSON(conf.p);

    // Reduction.
    if (conf.red) {
      this.red = conf.red;
    } else {
      // Use Montgomery when there is no fast reduction for the prime.
      this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
      this.red.precompute();
    }

    // Precalculate encoding length.
    this.fieldSize = this.p.byteLength();
    this.fieldBits = this.p.bitLength();
    this.adjustedSize = this.fieldSize + ((this.fieldBits & 7) === 0);
    this.signBit = this.adjustedSize * 8 - 1;
    this.mask = 0xff;

    if ((this.fieldBits & 7) !== 0)
      this.mask = (1 << (this.fieldBits & 7)) - 1;

    // Curve configuration, optional.
    this.n = BN.fromJSON(conf.n || '0');
    this.h = BN.fromJSON(conf.h || '1');
    this.q = this.n.mul(this.h);
    this.z = BN.fromJSON(conf.z || '0').toRed(this.red);
    this.g = null;
    this.nh = this.n.ushrn(1);
    this.scalarSize = this.n.byteLength();
    this.scalarBits = this.n.bitLength();

    // Useful for many curves.
    this.zero = new BN(0).toRed(this.red);
    this.one = new BN(1).toRed(this.red);
    this.two = new BN(2).toRed(this.red);
    this.three = new BN(3).toRed(this.red);
    this.four = new BN(4).toRed(this.red);

    // Inverses.
    this.i2 = this.two.redInvert();
    this.i3 = this.three.redInvert();
    this.i4 = this.i2.redSqr();
    this.i6 = this.i2.redMul(this.i3);

    // Torsion.
    this.torsion = new Array(this.h.word(0));

    for (let i = 0; i < this.torsion.length; i++)
      this.torsion[i] = this.point();

    // Endomorphism.
    this.endo = null;

    // Cache.
    this.hi = null;

    // Memoize.
    this._scale = memoize(this._scale, this);
    this.isIsomorphic = memoize(this.isIsomorphic, this);
    this.isIsogenous = memoize(this.isIsogenous, this);

    // Sanity checks.
    assert(this.p.sign() > 0 && this.p.isOdd());
    assert(this.n.sign() >= 0);
    assert(this.h.sign() > 0 && this.h.cmpn(255) <= 0);
    assert(this.endian === 'be' || this.endian === 'le');

    return this;
  }

  _finalize(conf) {
    assert(conf && typeof conf === 'object');

    // Create base point.
    this.g = conf.g ? this.pointFromJSON(conf.g) : this.point();

    // Parse small order points.
    if (conf.torsion) {
      assert(conf.torsion.length === this.torsion.length);

      for (let i = 0; i < this.torsion.length; i++)
        this.torsion[i] = this.pointFromJSON(conf.torsion[i]);
    }

    return this;
  }

  _findTorsion() {
    // Find all torsion points by grinding.
    assert(!this.n.isZero());

    const h = this.h.word(0);
    const x = this.one.redNeg();
    const out = [this.point()];
    const set = new Set();

    let len = h;

    while (out.length < len) {
      let p;

      x.redIAdd(this.one);

      try {
        p = this.pointFromX(x.clone());
      } catch (e) {
        continue;
      }

      try {
        p = p.mul(this.n);
      } catch (e) {
        len = 2;
        continue;
      }

      if (p.isInfinity())
        continue;

      p.normalize();

      for (const point of [p, p.neg()]) {
        const key = point.key();

        if (!set.has(key)) {
          out.push(point);
          set.add(key);
        }
      }
    }

    out.sort((a, b) => a.cmp(b));

    while (out.length < h)
      out.push(this.point());

    return out;
  }

  _fixedMul(p, k) {
    // Fixed-base method for point multiplication.
    //
    // [ECPM] "Windowed method".
    // [GECC] Page 95, Section 3.3.
    //
    // Windows are appropriately shifted to avoid any
    // doublings. This reduces a 256 bit multiplication
    // down to 64 additions with a window size of 4.
    assert(p instanceof Point);
    assert(k instanceof BN);
    assert(p.pre && p.pre.windows);

    // Get precomputed windows.
    const {width, points} = p._getWindows(0, 0);

    // Recompute window size.
    const size = 1 << width;

    // Recompute steps.
    const bits = k.bitLength();
    const steps = ((bits + width - 1) / width) >>> 0;

    // Multiply.
    let acc = this.jpoint();

    for (let i = 0; i < steps; i++) {
      const bits = k.bits(i * width, width);

      acc = acc.add(points[i * size + bits]);
    }

    // Adjust sign.
    if (k.isNeg())
      acc = acc.neg();

    return acc;
  }

  _fixedNafMul(p, k) {
    // Fixed-base NAF windowing method for point multiplication.
    //
    // [GECC] Algorithm 3.42, Page 105, Section 3.3.
    assert(p instanceof Point);
    assert(k instanceof BN);
    assert(p.pre && p.pre.doubles);

    // Get precomputed doubles.
    const {step, points} = p._getDoubles(0, 0);

    // Get fixed NAF (in a more windowed form).
    const naf = getFixedNAF(k, 2, k.bitLength() + 1, step);

    // Compute steps.
    const I = ((1 << (step + 1)) - (step % 2 === 0 ? 2 : 1)) / 3;

    // Multiply.
    let a = this.jpoint();
    let b = this.jpoint();

    for (let i = I; i > 0; i--) {
      for (let j = 0; j < naf.length; j++) {
        const nafW = naf[j];

        if (nafW === i)
          b = b.add(points[j]);
        else if (nafW === -i)
          b = b.sub(points[j]);
      }

      a = a.add(b);
    }

    return a;
  }

  _wnafMul(w, p, k) {
    // Window NAF method for point multiplication.
    //
    // [GECC] Algorithm 3.36, Page 100, Section 3.3.
    assert(p instanceof Point);
    assert(k instanceof BN);

    // Precompute window.
    const {width, points} = p._safeNAF(w);

    // Get NAF form.
    const naf = getNAF(k, width, k.bitLength() + 1);

    // Add `this`*(N+1) for every w-NAF index.
    let acc = this.jpoint();

    for (let i = naf.length - 1; i >= 0; i--) {
      const z = naf[i];

      if (i !== naf.length - 1)
        acc = acc.dbl();

      if (z > 0)
        acc = acc.add(points[(z - 1) >> 1]);
      else if (z < 0)
        acc = acc.sub(points[(-z - 1) >> 1]);
    }

    return acc;
  }

  _wnafMulAdd(w, points, coeffs) {
    // Multiple point multiplication, also known
    // as "Shamir's trick" (with interleaved NAFs).
    //
    // [GECC] Algorithm 3.48, Page 109, Section 3.3.3.
    //        Algorithm 3.51, Page 112, Section 3.3.
    //
    // This is particularly useful for signature
    // verifications and mutiplications after an
    // endomorphism split.
    assert((w >>> 0) === w);
    assert(Array.isArray(points));
    assert(Array.isArray(coeffs));
    assert(points.length === coeffs.length);

    const length = points.length;
    const wnd = new Array(length);
    const naf = new Array(length);

    // Check arrays and calculate size.
    let max = 0;

    for (let i = 0; i < length; i++) {
      const point = points[i];
      const coeff = coeffs[i];

      assert(point instanceof Point);
      assert(coeff instanceof BN);

      if (i > 0 && point.type !== points[i - 1].type)
        throw new Error('Cannot mix points.');

      // Avoid sparse arrays.
      wnd[i] = null;
      naf[i] = null;

      // Compute max scalar size.
      max = Math.max(max, coeff.bitLength() + 1);
    }

    // Compute NAFs.
    let ppoint = null;
    let pcoeff = null;
    let len = 0;

    for (let i = 0; i < length; i++) {
      const point = points[i];
      const coeff = coeffs[i];
      const pre = point._getNAF(0);

      // Use precomputation if available.
      if (pre) {
        wnd[len] = pre.points;
        naf[len] = getNAF(coeff, pre.width, max);
        len += 1;
        continue;
      }

      // Save last non-precomputed point.
      if (!ppoint) {
        ppoint = point;
        pcoeff = coeff;
        continue;
      }

      // Compute JSF in NAF form.
      wnd[len] = ppoint._getJNAF(point);
      naf[len] = getJNAF(pcoeff, coeff, max);

      ppoint = null;
      pcoeff = null;

      len += 1;
    }

    // Regular NAF for odd points.
    if (ppoint) {
      const nafw = ppoint._safeNAF(w);

      wnd[len] = nafw.points;
      naf[len] = getNAF(pcoeff, nafw.width, max);

      len += 1;
    }

    // Multiply and add.
    let acc = this.jpoint();

    for (let i = max - 1; i >= 0; i--) {
      if (i !== max - 1)
        acc = acc.dbl();

      for (let j = 0; j < len; j++) {
        const z = naf[j][i];

        if (z > 0)
          acc = acc.add(wnd[j][(z - 1) >> 1]);
        else if (z < 0)
          acc = acc.sub(wnd[j][(-z - 1) >> 1]);
      }
    }

    return acc;
  }

  _endoWnafMulAdd(points, coeffs) {
    throw new Error('Not implemented.');
  }

  _scale(curve, invert) {
    assert(curve instanceof Curve);
    assert(curve.p.eq(this.p));

    switch (curve.type) {
      case 'short':
        return this._scaleShort(curve, invert);
      case 'mont':
        return this._scaleMont(curve, invert);
      case 'edwards':
        return this._scaleEdwards(curve, invert);
      default:
        throw new Error('Not implemented.');
    }
  }

  _scaleShort(curve, invert) {
    throw new Error('Not implemented.');
  }

  _scaleMont(curve, invert) {
    throw new Error('Not implemented.');
  }

  _scaleEdwards(curve, invert) {
    throw new Error('Not implemented.');
  }

  isElliptic() {
    throw new Error('Not implemented.');
  }

  jinv() {
    throw new Error('Not implemented.');
  }

  isComplete() {
    return false;
  }

  precompute(rng) {
    assert(!this.g.isInfinity(), 'Must have base point.');
    assert(!this.n.isZero(), 'Must have order.');

    this.g.precompute(this.n.bitLength(), rng);

    return this;
  }

  scalar(num, base, endian) {
    const k = new BN(num, base, endian);

    assert(!k.red);

    if (this.n.isZero())
      return k;

    return k.imod(this.n);
  }

  field(num, base, endian) {
    const x = BN.cast(num, base, endian);

    if (x.red)
      return x.forceRed(this.red);

    return x.toRed(this.red);
  }

  point(x, y) {
    throw new Error('Not implemented.');
  }

  jpoint(x, y, z) {
    throw new Error('Not implemented.');
  }

  xpoint(x, z) {
    throw new Error('Not implemented.');
  }

  cpoint(xx, xz, yy, yz) {
    assert(xx instanceof BN);
    assert(xz instanceof BN);
    assert(yy instanceof BN);
    assert(yz instanceof BN);

    if (xz.isZero() || yz.isZero())
      return this.point();

    const z = xz.redMul(yz).redInvert();
    const x = xx.redMul(yz).redMul(z);
    const y = yy.redMul(xz).redMul(z);

    return this.point(x, y);
  }

  solveX2(y) {
    throw new Error('Not implemented.');
  }

  solveX(y) {
    return this.solveX2(y).redSqrt();
  }

  solveY2(x) {
    throw new Error('Not implemented.');
  }

  solveY(x) {
    return this.solveY2(x).redSqrt();
  }

  validate(point) {
    throw new Error('Not implemented.');
  }

  pointFromX(x, sign) {
    throw new Error('Not implemented.');
  }

  pointFromY(y, sign) {
    throw new Error('Not implemented.');
  }

  isIsomorphic(curve) {
    throw new Error('Not implemented.');
  }

  isIsogenous(curve) {
    throw new Error('Not implemented.');
  }

  pointFromShort(point) {
    throw new Error('Not implemented.');
  }

  pointFromMont(point, sign) {
    throw new Error('Not implemented.');
  }

  pointFromEdwards(point) {
    throw new Error('Not implemented.');
  }

  pointFromUniform(u) {
    throw new Error('Not implemented.');
  }

  pointToUniform(p) {
    throw new Error('Not implemented.');
  }

  pointFromHash(bytes, pake = false) {
    // [H2EC] "Roadmap".
    assert((bytes != null && bytes._isBuffer === true));
    assert(typeof pake === 'boolean');

    if (bytes.length !== this.fieldSize * 2)
      throw new Error('Invalid hash size.');

    // Random oracle encoding.
    // Ensure a proper distribution.
    const s1 = bytes.slice(0, this.fieldSize);
    const s2 = bytes.slice(this.fieldSize);
    const u1 = this.decodeUniform(s1);
    const u2 = this.decodeUniform(s2);
    const p1 = this.pointFromUniform(u1);
    const p2 = this.pointFromUniform(u2);
    const p3 = p1.add(p2);

    return pake ? p3.mulH() : p3;
  }

  pointToHash(p, subgroup, rng) {
    // [SQUARED] Algorithm 1, Page 8, Section 3.3.
    assert(p instanceof this.Point);
    assert((subgroup >>> 0) === subgroup);

    // Add a random torsion component.
    const i = subgroup % this.torsion.length;
    const p0 = p.add(this.torsion[i]);

    // Average Cost (R = sqrt):
    //
    //   SSWU (~4 iterations) => 8I + 16R
    //   SVDW (~4 iterations) => 12I + 28R
    //   Elligator 1 (~2 iterations) => 6I + 10R
    //   Elligator 2 (~2 iterations) => 4I + 6R
    //   Ristretto (~1 iteration) => 1I + 2R + h*1R
    for (;;) {
      const u1 = this.randomField(rng);
      const p1 = this.pointFromUniform(u1);

      // Avoid 2-torsion points:
      //   Short Weierstrass: ((A / 3) / B, 0)
      //   Montgomery: (0, 0)
      //   Twisted Edwards: (0, -1)
      if (p1.neg().eq(p1))
        continue;

      const p2 = p0.sub(p1);
      const hint = randomInt(rng);

      let u2;
      try {
        u2 = this.pointToUniform(p2, hint & 15);
      } catch (e) {
        if (e.message === 'Invalid point.')
          continue;
        throw e;
      }

      const s1 = this.encodeUniform(u1, hint >>> 8);
      const s2 = this.encodeUniform(u2, hint >>> 16);

      return Buffer.concat([s1, s2]);
    }
  }

  randomScalar(rng) {
    const max = this.n.isZero() ? this.p : this.n;
    return BN.random(rng, 1, max);
  }

  randomField(rng) {
    return BN.random(rng, 1, this.p).toRed(this.red);
  }

  randomPoint(rng) {
    let p;

    for (;;) {
      const x = this.randomField(rng);
      const sign = (randomInt(rng) & 1) !== 0;

      try {
        p = this.pointFromX(x, sign);
      } catch (e) {
        continue;
      }

      assert(p.validate());

      return p.mulH();
    }
  }

  mulAll(points, coeffs) {
    return this.jmulAll(points, coeffs);
  }

  jmulAll(points, coeffs) {
    assert(Array.isArray(points));
    assert(points.length === 0 || (points[0] instanceof Point));

    // Multiply with endomorphism if we're using affine points.
    if (this.endo && points.length > 0 && points[0].type === types.AFFINE)
      return this._endoWnafMulAdd(points, coeffs);

    // Otherwise, a regular Shamir's trick.
    return this._wnafMulAdd(5, points, coeffs);
  }

  mulH(k) {
    assert(k instanceof BN);
    return this.imulH(k.clone());
  }

  imulH(k) {
    assert(k instanceof BN);
    assert(!k.red);

    const word = this.h.word(0);

    // Optimize for powers of two.
    if ((word & (word - 1)) === 0) {
      const bits = this.h.bitLength();
      return k.iushln(bits - 1).imod(this.n);
    }

    return k.imuln(word).imod(this.n);
  }

  normalizeAll(points) {
    assert(Array.isArray(points));

    const len = points.length;
    const z = new Array(len);

    for (let i = 0; i < len; i++) {
      const p = points[i];

      assert(p instanceof Point);
      assert(p.curve === this);

      if (p.type === types.AFFINE) {
        z[i] = this.one;
        continue;
      }

      z[i] = p.z;
    }

    const zi = this.red.invertAll(z);
    const out = new Array(len);

    for (let i = 0; i < len; i++)
      out[i] = points[i].scale(zi[i]);

    return out;
  }

  affinizeAll(points) {
    return this.normalizeAll(points);
  }

  clamp(scalar) {
    // [RFC7748] Page 8, Section 5.
    // [RFC8032] Section 5.1.5 & 5.2.5.
    assert((scalar != null && scalar._isBuffer === true));
    assert(scalar.length === this.scalarSize);
    assert(this.scalarSize <= this.fieldSize);

    let top = (this.fieldBits & 7) || 8;
    let lsb = 0;
    let msb = this.scalarSize - 1;

    // Swap endianness.
    if (this.endian === 'be')
      [lsb, msb] = [msb, lsb];

    // Adjust for low order.
    if (this.scalarSize < this.fieldSize)
      top = 8;

    // Ensure a multiple of the cofactor.
    scalar[lsb] &= -this.h.word(0) & 0xff;

    // Clamp to the prime.
    scalar[msb] &= (1 << top) - 1;

    // Set the high bit.
    scalar[msb] |= 1 << (top - 1);

    return scalar;
  }

  splitHash(bytes) {
    // [RFC8032] Section 5.1.6 & 5.2.6.
    assert((bytes != null && bytes._isBuffer === true));
    assert(bytes.length === this.adjustedSize * 2);
    assert(this.scalarSize <= this.adjustedSize);

    let off = 0;

    if (this.endian === 'be')
      off = this.adjustedSize - this.scalarSize;

    const scalar = bytes.slice(off, off + this.scalarSize);
    const prefix = bytes.slice(this.adjustedSize);

    this.clamp(scalar);

    return [scalar, prefix];
  }

  encodeField(x) {
    // [SEC1] Page 12, Section 2.3.5.
    assert(x instanceof BN);
    assert(!x.red);

    return x.encode(this.endian, this.fieldSize);
  }

  decodeField(bytes) {
    // [SEC1] Page 13, Section 2.3.6.
    assert((bytes != null && bytes._isBuffer === true));

    if (bytes.length !== this.fieldSize)
      throw new Error('Invalid field element size.');

    return BN.decode(bytes, this.endian);
  }

  encodeAdjusted(x) {
    assert(x instanceof BN);
    assert(!x.red);

    return x.encode(this.endian, this.adjustedSize);
  }

  decodeAdjusted(bytes) {
    assert((bytes != null && bytes._isBuffer === true));

    if (bytes.length !== this.adjustedSize)
      throw new Error('Invalid field element size.');

    return BN.decode(bytes, this.endian);
  }

  encodeScalar(k) {
    // [SEC1] Page 13, Section 2.3.7.
    assert(k instanceof BN);
    assert(!k.red);

    return k.encode(this.endian, this.scalarSize);
  }

  decodeScalar(bytes) {
    // [SEC1] Page 14, Section 2.3.8.
    assert((bytes != null && bytes._isBuffer === true));

    if (bytes.length !== this.scalarSize)
      throw new Error('Invalid scalar size.');

    return BN.decode(bytes, this.endian);
  }

  encodeClamped(k) {
    // [RFC7748] Page 8, Section 5.
    // [RFC8032] Section 5.1.5 & 5.2.5.
    return this.clamp(this.encodeScalar(k));
  }

  decodeClamped(bytes) {
    // [RFC7748] Page 8, Section 5.
    // [RFC8032] Section 5.1.5 & 5.2.5.
    assert((bytes != null && bytes._isBuffer === true));

    if (bytes.length !== this.scalarSize)
      throw new Error('Invalid scalar size.');

    const clamped = this.clamp(Buffer.from(bytes));

    return BN.decode(clamped, this.endian);
  }

  encodeUniform(x, bits) {
    assert(x instanceof BN);
    assert((bits >>> 0) === bits);

    const msb = this.endian === 'le' ? this.fieldSize - 1 : 0;
    const bytes = x.fromRed().encode(this.endian, this.fieldSize);

    bytes[msb] |= (bits & ~this.mask) & 0xff;

    return bytes;
  }

  decodeUniform(bytes) {
    assert((bytes != null && bytes._isBuffer === true));

    if (bytes.length !== this.fieldSize)
      throw new Error('Invalid field size.');

    const x = BN.decode(bytes, this.endian);

    x.iumaskn(this.fieldBits);

    return x.toRed(this.red);
  }

  encodePoint(point, compact) {
    assert(point instanceof Point);
    return point.encode(compact);
  }

  decodePoint(bytes) {
    throw new Error('Not implemented.');
  }

  encodeX(point) {
    throw new Error('Not implemented.');
  }

  decodeX(bytes) {
    throw new Error('Not implemented.');
  }

  decodeEven(bytes) {
    throw new Error('Not implemented.');
  }

  decodeSquare(bytes) {
    throw new Error('Not implemented.');
  }

  toShort() {
    throw new Error('Not implemented.');
  }

  toMont(b0) {
    throw new Error('Not implemented.');
  }

  toEdwards(a0) {
    throw new Error('Not implemented.');
  }

  pointToJSON(point, pre) {
    assert(point instanceof Point);
    return point.toJSON(pre);
  }

  pointFromJSON(json) {
    throw new Error('Not implemented.');
  }

  toJSON(pre) {
    let prefix, context;
    let n, z, endo;

    if (this.type === 'edwards') {
      prefix = this.prefix ? this.prefix.toString() : null;
      context = this.context;
    }

    if (!this.n.isZero())
      n = this.n.toJSON();

    if (!this.z.isZero()) {
      z = this.z.fromRed();

      if (this.z.redIsHigh())
        z.isub(this.p);

      z = z.toString(16);
    }

    if (this.endo)
      endo = this.endo.toJSON();

    return {
      id: this.id,
      ossl: this.ossl,
      type: this.type,
      endian: this.endian,
      hash: this.hash,
      prefix,
      context,
      prime: this.prime,
      p: this.p.toJSON(),
      a: undefined,
      b: undefined,
      d: undefined,
      n,
      h: this.h.toString(16),
      s: undefined,
      z,
      c: undefined,
      g: this.g.toJSON(pre),
      endo
    };
  }

  static fromJSON(json) {
    return new this(json);
  }
}

/**
 * Point
 */

class Point {
  constructor(curve, type) {
    assert(curve instanceof Curve);
    assert((type >>> 0) === type);

    this.curve = curve;
    this.type = type;
    this.pre = null;
  }

  _init() {
    throw new Error('Not implemented.');
  }

  _safeNAF(width) {
    assert((width >>> 0) === width);

    if (this.pre && this.pre.naf)
      return this.pre.naf;

    if (width === 0)
      return null;

    const size = 1 << (width - 2);
    const points = new Array(size);
    const p = this.toJ();
    const dbl = size === 1 ? null : p.dbl();

    points[0] = p;

    for (let i = 1; i < size; i++)
      points[i] = points[i - 1].add(dbl);

    return new NAF(width, points);
  }

  _getNAF(width) {
    assert((width >>> 0) === width);

    if (this.pre && this.pre.naf)
      return this.pre.naf;

    if (width === 0)
      return null;

    const odds = this._safeNAF(width).points;
    const points = this.curve.affinizeAll(odds);

    return new NAF(width, points);
  }

  _getWindows(width, bits) {
    assert((width >>> 0) === width);
    assert((bits >>> 0) === bits);

    if (this.pre && this.pre.windows)
      return this.pre.windows;

    if (width === 0)
      return null;

    const size = 1 << width;
    const steps = ((bits + width - 1) / width) >>> 0;
    const wnds = new Array(steps * size);

    let g = this.toJ();

    for (let i = 0; i < steps; i++) {
      wnds[i * size] = this.curve.jpoint();

      for (let j = 1; j < size; j++)
        wnds[i * size + j] = wnds[i * size + j - 1].add(g);

      g = g.dblp(width);
    }

    const points = this.curve.affinizeAll(wnds);

    return new Windows(width, bits, points);
  }

  _getDoubles(step, power) {
    assert((step >>> 0) === step);
    assert((power >>> 0) === power);

    if (this.pre && this.pre.doubles)
      return this.pre.doubles;

    if (step === 0)
      return null;

    const len = Math.ceil(power / step) + 1;
    const dbls = new Array(len);

    let acc = this.toJ();
    let k = 0;

    dbls[k++] = acc;

    for (let i = 0; i < power; i += step) {
      for (let j = 0; j < step; j++)
        acc = acc.dbl();

      dbls[k++] = acc;
    }

    assert(k === len);

    const points = this.curve.affinizeAll(dbls);

    return new Doubles(step, points);
  }

  _getBeta() {
    return null;
  }

  _getBlinding(rng) {
    if (this.pre && this.pre.blinding)
      return this.pre.blinding;

    if (!rng)
      return null;

    if (this.curve.n.isZero())
      return null;

    // Pregenerate a random blinding value:
    //
    //   blind = random integer in [1,n-1]
    //   unblind = G * blind
    //
    // We intend to subtract the blinding value
    // from scalars before multiplication. We
    // can add the unblinding point once the
    // multiplication is complete.
    const blind = this.curve.randomScalar(rng);
    const unblind = this.mul(blind);

    return new Blinding(blind, unblind);
  }

  _hasWindows(k) {
    assert(k instanceof BN);

    if (!this.pre || !this.pre.windows)
      return false;

    const {width, bits} = this.pre.windows;
    const steps = ((bits + width - 1) / width) >>> 0;

    return k.bitLength() <= steps * width;
  }

  _hasDoubles(k) {
    assert(k instanceof BN);

    if (!this.pre || !this.pre.doubles)
      return false;

    const {step, points} = this.pre.doubles;
    const power = k.bitLength() + 1;

    return points.length >= Math.ceil(power / step) + 1;
  }

  _getJNAF(point) {
    assert(point instanceof Point);
    assert(point.type === this.type);

    // Create comb for JSF.
    return [
      this, // 1
      this.add(point), // 3
      this.sub(point), // 5
      point // 7
    ];
  }

  _blind(k, rng) {
    // [SIDE1] Page 5, Section 4.
    // [BLIND] Page 20, Section 7.
    assert(k instanceof BN);
    assert(!k.red);

    // Scalar splitting (requires precomputation).
    //
    // Blind a multiplication by first subtracting
    // a blinding value from the scalar. Example:
    //
    //   b = random integer in [1,n-1]
    //   B = P * b (precomputed)
    //   Q = P * (k - b) + B
    //
    // Note that Joye describes a different method
    // (multiplier randomization) which computes:
    //
    //   B = random point in E
    //   Q = (P + B) * k - B * k
    //
    // Our method is more similar to the "scalar
    // splitting" technique described in the
    // second source above.
    //
    // The blinding value and its corresponding
    // point are randomly generated and computed
    // on boot. As long as an attacker is not
    // able to observe the boot, this should give
    // a decent bit of protection against various
    // channel attacks.
    if (this.pre && this.pre.blinding) {
      const {blind, unblind} = this.pre.blinding;
      const t = k.sub(blind);

      return [this, t, unblind];
    }

    // Randomization is not possible without
    // an RNG. Do a normal multiplication.
    if (!rng)
      return [this, k, null];

    // If we have no precomputed blinding
    // factor, there are two possibilities
    // for randomization:
    //
    // 1. Randomize the multiplier by adding
    //    a random multiple of `n`.
    //
    // 2. Re-scale the point itself by a
    //    random factor.
    //
    // The first option can be accomplished
    // with some like:
    //
    //   a = random integer in [1,n-1]
    //   r = a * n
    //   Q = P * (k + r)
    //
    // The second is accomplished with:
    //
    //   a = random element in F(p)
    //   R = (x * a^2, y * a^3, z * a)
    //   Q = R * k
    //
    // If we have precomputed doubles / naf
    // points, we opt for the first method
    // to avoid randomizing everything.
    if (this.pre) {
      if (this.curve.n.isZero())
        return [this, k, null];

      const a = this.curve.randomScalar(rng);
      const r = a.mul(this.curve.n);
      const t = r.iadd(k);

      return [this, t, null];
    }

    // If there is no precomputation _at all_,
    // we opt for the second method.
    const p = this.randomize(rng);

    return [p, k, null];
  }

  clone() {
    throw new Error('Not implemented.');
  }

  precompute(bits, rng) {
    assert((bits >>> 0) === bits);

    if (!this.pre)
      this.pre = new Precomp();

    if (!this.pre.naf)
      this.pre.naf = this._getNAF(9);

    if (USE_FIXED && !this.pre.windows)
      this.pre.windows = this._getWindows(4, bits);

    if (!this.pre.doubles)
      this.pre.doubles = this._getDoubles(4, bits + 1);

    if (!this.pre.beta)
      this.pre.beta = this._getBeta();

    if (!this.pre.blinding)
      this.pre.blinding = this._getBlinding(rng);

    return this;
  }

  validate() {
    return this.curve.validate(this);
  }

  normalize() {
    return this;
  }

  scale(a) {
    throw new Error('Not implemented.');
  }

  randomize(rng) {
    const z = this.curve.randomField(rng);
    return this.scale(z);
  }

  neg() {
    throw new Error('Not implemented.');
  }

  add(point) {
    throw new Error('Not implemented.');
  }

  sub(point) {
    assert(point instanceof Point);
    return this.add(point.neg());
  }

  dbl() {
    throw new Error('Not implemented.');
  }

  dblp(pow) {
    // Repeated doubling. This can
    // be optimized by child classes.
    assert((pow >>> 0) === pow);

    let r = this;

    for (let i = 0; i < pow; i++)
      r = r.dbl();

    return r;
  }

  diffAddDbl(p, q) {
    throw new Error('Not implemented.');
  }

  getX() {
    throw new Error('Not implemented.');
  }

  getY() {
    throw new Error('Not implemented.');
  }

  eq(point) {
    throw new Error('Not implemented.');
  }

  cmp(point) {
    throw new Error('Not implemented.');
  }

  isInfinity() {
    throw new Error('Not implemented.');
  }

  isOrder2() {
    throw new Error('Not implemented.');
  }

  isOdd() {
    throw new Error('Not implemented.');
  }

  isEven() {
    throw new Error('Not implemented.');
  }

  isSquare() {
    throw new Error('Not implemented.');
  }

  eqX(x) {
    throw new Error('Not implemented.');
  }

  eqR(x) {
    throw new Error('Not implemented.');
  }

  isSmall() {
    // Test whether the point is of small order.
    if (this.isInfinity())
      return false;

    // P * h = O
    return this.jmulH().isInfinity();
  }

  hasTorsion() {
    // Test whether the point is in another subgroup.
    if (this.isInfinity())
      return false;

    // P * n != O
    return !this.jmul(this.curve.n).isInfinity();
  }

  order() {
    // Calculate point order.
    const {h, n} = this.curve;

    let p = this.toJ();
    let q = new BN(1);

    while (!p.isInfinity()) {
      q.iaddn(1);

      if (q.cmp(h) > 0) {
        q = n.clone();
        break;
      }

      p = p.add(this);
    }

    return q;
  }

  mul(k) {
    return this.jmul(k);
  }

  muln(k) {
    return this.jmuln(k);
  }

  mulBlind(k, rng) {
    return this.jmulBlind(k, rng);
  }

  mulAdd(k1, p2, k2) {
    return this.jmulAdd(k1, p2, k2);
  }

  mulH() {
    return this.jmulH();
  }

  div(k) {
    return this.jdiv(k);
  }

  divn(k) {
    return this.jdivn(k);
  }

  divH() {
    return this.jdivH();
  }

  jmul(k) {
    if (USE_FIXED && this._hasWindows(k))
      return this.curve._fixedMul(this, k);

    if (this._hasDoubles(k))
      return this.curve._fixedNafMul(this, k);

    if (this.curve.endo && this.type === types.AFFINE)
      return this.curve._endoWnafMulAdd([this], [k]);

    return this.curve._wnafMul(5, this, k);
  }

  jmuln(k) {
    assert((k | 0) === k);
    return this.jmul(new BN(k));
  }

  jmulBlind(k, rng = null) {
    const [p, t, unblind] = this._blind(k, rng);
    const q = p.jmul(t);

    if (unblind)
      return q.add(unblind);

    return q;
  }

  jmulAdd(k1, p2, k2) {
    if (this.curve.endo && this.type === types.AFFINE)
      return this.curve._endoWnafMulAdd([this, p2], [k1, k2]);

    return this.curve._wnafMulAdd(5, [this, p2], [k1, k2]);
  }

  jmulH() {
    const word = this.curve.h.word(0);

    // Optimize for powers of two.
    if ((word & (word - 1)) === 0) {
      const bits = this.curve.h.bitLength();
      return this.toJ().dblp(bits - 1);
    }

    return this.jmul(this.curve.h);
  }

  jdiv(k) {
    assert(k instanceof BN);
    assert(!k.red);

    return this.jmul(k.invert(this.curve.n));
  }

  jdivn(k) {
    assert(!this.curve.n.isZero());

    if (this.curve.h.cmpn(k) === 0)
      return this.jdivH();

    return this.jdiv(new BN(k));
  }

  jdivH() {
    if (this.curve.n.isZero())
      return this.toJ();

    if (this.curve.h.cmpn(1) === 0)
      return this.toJ();

    if (this.curve.hi === null)
      this.curve.hi = this.curve.h.invert(this.curve.n);

    return this.jmul(this.curve.hi);
  }

  toP() {
    return this.normalize();
  }

  toJ() {
    return this;
  }

  toX() {
    return this;
  }

  key() {
    if (this.isInfinity())
      return `${this.curve.uid}:oo`;

    this.normalize();

    const x = this.getX().toString(16);
    const y = this.getY().toString(16);

    return `${this.curve.uid}:${x},${y}`;
  }

  encode(compact) {
    throw new Error('Not implemented.');
  }

  static decode(curve, bytes) {
    throw new Error('Not implemented.');
  }

  encodeX() {
    throw new Error('Not implemented.');
  }

  static decodeX(curve, bytes) {
    throw new Error('Not implemented.');
  }

  static decodeEven(curve, bytes) {
    throw new Error('Not implemented.');
  }

  static decodeSquare(curve, bytes) {
    throw new Error('Not implemented.');
  }

  toJSON(pre) {
    throw new Error('Not implemented.');
  }

  static fromJSON(curve, json) {
    throw new Error('Not implemented.');
  }

  [custom]() {
    return '<Point>';
  }
}

/**
 * ShortCurve
 */

class ShortCurve extends Curve {
  constructor(conf) {
    super(ShortPoint, 'short', conf);

    this.a = BN.fromJSON(conf.a).toRed(this.red);
    this.b = BN.fromJSON(conf.b).toRed(this.red);
    this.c = BN.fromJSON(conf.c || '0').toRed(this.red);
    this.ai = this.a.isZero() ? this.zero : this.a.redInvert();
    this.zi = this.z.isZero() ? this.zero : this.z.redInvert();

    this.zeroA = this.a.isZero();
    this.threeA = this.a.eq(this.three.redNeg());
    this.redN = this.n.toRed(this.red);
    this.pmodn = this.p.clone();
    this.highOrder = this.n.cmp(this.p) >= 0;
    this.smallGap = false;

    this._finalize(conf);
  }

  _finalize(conf) {
    super._finalize(conf);

    // Precalculate endomorphism.
    if (conf.endo != null)
      this.endo = Endo.fromJSON(this, conf.endo);
    else
      this.endo = this._getEndomorphism();

    if (!this.n.isZero()) {
      this.pmodn = this.p.mod(this.n);

      // Check for Maxwell's trick (see eqR).
      this.smallGap = this.p.div(this.n).cmpn(1) <= 0;
    }

    return this;
  }

  static _isomorphism(curveA, curveB, custom, odd) {
    // Short Weierstrass Isomorphism.
    //
    // [GECC] Page 84, Section 3.1.5.
    // [ARITH1] Page 274, Section 13.1.5.
    // [ALT] Appendix F.3 (Isomorphic Mapping between Weierstrass Curves).
    //
    // Find `u` such that `a * u^4 = a'` and `b * u^6 = b'`.
    //
    // Transformation:
    //
    //   u4 = a' / a
    //   u2 = +-sqrt(u4)
    //   u6 = u4 * u2
    //   a' = a * u4
    //   b' = b * u6
    //
    // Where `u2` is any root that is square.
    //
    // If a = 0, we can do:
    //
    //   a' = 0
    //   b' = b'
    //
    // Where (b' / b)^(1 / 3) is square.
    //
    // If b = 0, we can do:
    //
    //   a' = a'
    //   b' = 0
    //
    // Where sqrt(a' / a) is square.
    assert(curveA instanceof BN);
    assert(curveB instanceof BN);
    assert(custom instanceof BN);
    assert(odd == null || typeof odd === 'boolean');
    assert(!curveA.isZero() || !curveB.isZero());

    if (custom.isZero())
      throw new Error('Invalid coefficient.');

    if (curveA.isZero()) {
      const customB = custom;
      const u6 = customB.redDiv(curveB);
      // Todo: allow index flag.
      const u2 = uncube(u6);

      // Already checked in uncube().
      assert(u2.redJacobi() === 1);

      return [curveA.clone(), customB.clone()];
    }

    if (curveB.isZero()) {
      const customA = custom;
      const u4 = customA.redDiv(curveA);
      const u2 = u4.redSqrt();

      // Todo: allow odd flag.
      if (u2.redJacobi() !== 1)
        u2.redINeg();

      if (u2.redJacobi() !== 1)
        throw new Error('Invalid `a` coefficient.');

      return [customA.clone(), curveB.clone()];
    }

    const customA = custom;
    const u4 = customA.redDiv(curveA);
    const u2 = u4.redSqrt();

    if (odd != null) {
      if (u2.redIsOdd() !== odd)
        u2.redINeg();
    } else {
      if (u2.redJacobi() !== 1)
        u2.redINeg();
    }

    if (u2.redJacobi() !== 1)
      throw new Error('Invalid `a` coefficient.');

    const u6 = u4.redMul(u2);
    const a = curveA.redMul(u4);
    const b = curveB.redMul(u6);

    assert(a.eq(customA));

    return [a, b];
  }

  _short(a0, odd) {
    return ShortCurve._isomorphism(this.a, this.b, a0, odd);
  }

  _mont(b0, odd) {
    // Short Weierstrass->Montgomery Equivalence.
    //
    // [ARITH1] Page 286, Section 13.2.3.c.
    // [SAFE] "Ladders".
    //
    // Transformation:
    //
    //   r = A / (3 * B)
    //   s = +-sqrt(3 * r^2 + a)
    //   A = 3 * r / s
    //   B = 1 / s
    const [r, s] = this._findRS(odd);
    const b = s.redInvert();
    const a = r.redMuln(3).redMul(b);

    if (b0 != null)
      return MontCurve._isomorphism(a, b, b0);

    return [a, b];
  }

  _edwards(a0, odd) {
    // Short Weierstrass->Twisted Edwards Equivalence.
    //
    // [TWISTEQ] Section 1.
    //
    // Transformation:
    //
    //   r = (a' + d') / 6
    //   s = +-sqrt(3 * r^2 + a)
    //   a' = 3 * r + 2 * s
    //   d' = 3 * r - 2 * s
    const [r, s] = this._findRS(odd);
    const r3 = r.redMuln(3);
    const s2 = s.redMuln(2);
    const a = r3.redAdd(s2);
    const d = r3.redSub(s2);

    if (a0 != null)
      return EdwardsCurve._isomorphism(a, d, a0);

    return [a, d];
  }

  _findRS(sign) {
    // Find `r` and `s` for equivalence.
    //
    // [ARITH1] Page 286, Section 13.2.3.c.
    // [SAFE] "Ladders".
    //
    // Computation:
    //
    //   r = solve(r^3 + a * r + b == 0, r)
    //   s = +-sqrt(3 * r^2 + a)
    //
    // Computing `r` is non-trivial. We need
    // to solve `r^3 + a * r + b = 0`, but we
    // don't have a polynomial solver, so we
    // loop over random points until we find
    // one with 2-torsion. Multiplying by the
    // subgroup order should yield a point of
    // ((A / 3) / B, 0) which is a solution.
    assert(sign == null || typeof sign === 'boolean');
    assert(this.h.word(0) >= 4);
    assert(!this.n.isZero());

    const x = this.one.redNeg();

    let p;

    for (;;) {
      x.redIAdd(this.one);

      try {
        p = this.pointFromX(x.clone());
      } catch (e) {
        continue;
      }

      p = p.mul(this.n);

      if (p.isInfinity())
        continue;

      if (!p.y.isZero())
        continue;

      break;
    }

    const r = p.x;
    const r2 = r.redSqr();
    const s = r2.redMuln(3).redIAdd(this.a).redSqrt();

    if (sign != null) {
      if (s.redIsOdd() !== sign)
        s.redINeg();
    }

    return [r, s];
  }

  _scale0(a, b) {
    // We can extract the isomorphism factors with:
    //
    //   u4 = a' / a
    //   u6 = b' / b
    //   u2 = +-sqrt(u4)
    //   u = +-sqrt(u2)
    //   u3 = u2 * u
    //
    // `u2` should be picked such that `u4 * u2 = u6`.
    //
    // If a = 0, we can do:
    //
    //   u6 = b' / b
    //   u2 = u6^(1 / 3)
    //   u = +-sqrt(u2)
    //   u3 = u2 * u
    //
    // Where `u2` is any root that is square.
    //
    // If b = 0, we can do:
    //
    //   u4 = a' / a
    //   u2 = +-sqrt(u4)
    //   u = +-sqrt(u2)
    //   u3 = u2 * u
    //
    // Where `u2` is any root that is square.
    assert(this.a.isZero() === a.isZero());
    assert(this.b.isZero() === b.isZero());

    if (this.a.isZero()) {
      const u6 = this.b.redDiv(this.field(b));
      // Todo: figure out how to check index.
      const u2 = uncube(u6);
      const u = u2.redSqrt();
      const u3 = u2.redMul(u);

      assert(u3.redSqr().eq(u6));
      assert(!u.isZero());

      return [u2, u3];
    }

    if (this.b.isZero()) {
      const u4 = this.a.redDiv(this.field(a));
      const u2 = u4.redSqrt();

      // Todo: figure out how to check oddness.
      if (u2.redJacobi() !== 1)
        u2.redINeg();

      const u = u2.redSqrt();
      const u3 = u2.redMul(u);

      assert(u3.redMul(u).eq(u4));
      assert(!u.isZero());

      return [u2, u3];
    }

    const u4 = this.a.redDiv(this.field(a));
    const u6 = this.b.redDiv(this.field(b));
    const u2 = u4.redSqrt();

    if (!u4.redMul(u2).eq(u6))
      u2.redINeg();

    assert(u4.redMul(u2).eq(u6));

    const u = u2.redSqrt();
    const u3 = u2.redMul(u);

    assert(!u.isZero());

    return [u2, u3];
  }

  _scale1(x, y) {
    // If base points are available, it is much
    // easier, with:
    //
    //   u2 = x' / x
    //   u3 = y' / y
    //   u = +-sqrt(u2)
    //
    // `u` should be picked such that `u2 * u = u3`.
    const u2 = this.g.x.redDiv(this.field(x));
    const u3 = this.g.y.redDiv(this.field(y));
    const u = u2.redSqrt();

    if (!u2.redMul(u).eq(u3))
      u.redINeg();

    assert(u2.redMul(u).eq(u3));
    assert(!u.isZero());

    return [u2, u3];
  }

  _scaleShort(curve) {
    assert(curve instanceof ShortCurve);

    if (this.g.isInfinity() || curve.g.isInfinity())
      return this._scale0(curve.a, curve.b);

    return this._scale1(curve.g.x, curve.g.y);
  }

  _scaleMont(curve) {
    assert(curve instanceof MontCurve);

    if (this.g.isInfinity() || curve.g.isInfinity()) {
      const [a, b] = curve._short();
      return this._scale0(a, b);
    }

    const {x, y} = curve.g;
    const nx = x.redAdd(curve.a3).redMul(curve.bi);
    const ny = y.redMul(curve.bi);

    return this._scale1(nx, ny);
  }

  _scaleEdwards(curve) {
    assert(curve instanceof EdwardsCurve);

    if (this.g.isInfinity() || curve.g.isInfinity()) {
      const [a, b] = curve._short();
      return this._scale0(a, b);
    }

    const {x, y, z} = curve.g;
    const a5 = curve.a.redMuln(5);
    const d5 = curve.d.redMuln(5);
    const dma = curve.d.redSub(curve.a);
    const d5a = d5.redSub(curve.a);
    const da5 = curve.d.redSub(a5);
    const ypz = y.redAdd(z);
    const ymz = y.redSub(z);
    const xx = d5a.redMul(y).redIAdd(da5.redMul(z));
    const xz = ymz.redMuln(12);
    const yy = dma.redMul(ypz).redMul(z);
    const yz = ymz.redMul(x).redIMuln(4);
    const zi = xz.redMul(yz).redInvert();
    const nx = xx.redMul(yz).redMul(zi);
    const ny = yy.redMul(xz).redMul(zi);

    return this._scale1(nx, ny);
  }

  _getEndomorphism(index = 0) {
    // Compute endomorphism.
    //
    // [GECC] Example 3.76, Page 128, Section 3.5.

    // No curve params.
    if (this.n.isZero() || this.g.isInfinity())
      return null;

    // No efficient endomorphism.
    if (!this.zeroA || this.p.modrn(3) !== 1 || this.n.modrn(3) !== 1)
      return null;

    // Solve beta^3 mod p = 1.
    const [b1, b2] = this._getEndoRoots(this.p);

    // Choose the smallest beta by default.
    const beta = [b1, b2][index & 1].toRed(this.red);

    // Solve lambda^3 mod n = 1.
    const [l1, l2] = this._getEndoRoots(this.n);

    // Choose the lambda matching selected beta.
    // Note that P * lambda = (x * beta, y).
    const p = this.point(this.g.x.redMul(beta), this.g.y);

    let lambda;

    if (this.g.mul(l1).eq(p)) {
      lambda = l1;
    } else {
      assert(this.g.mul(l2).eq(p));
      lambda = l2;
    }

    // Get basis vectors.
    const basis = this._getEndoBasis(lambda);

    // Precompute `g1` and `g2`.
    const pre = this._getEndoPrecomp(basis);

    return new Endo(beta, lambda, basis, pre);
  }

  _getEndoRoots(num) {
    // Find roots for x^2 + x + 1 in F.
    //
    // [GECC] Example 3.76, Page 128, Section 3.5.
    // [GLV] Page 192, Section 2 (Endomorphisms).
    //
    // The above document doesn't fully explain how
    // to derive these and only "hints" at it, as
    // mentioned by Hal Finney[1], but we're basically
    // computing two possible cube roots of 1 here.
    //
    // Note that we could also compute[2]:
    //
    //   beta = 2^((p - 1) / 3) mod p
    //   lambda = 3^((n - 1) / 3) mod n
    //
    // As an extension of Fermat's little theorem:
    //
    //   g^(p - 1) mod p == 1
    //
    // It is suspected[3] this is how Hal Finney[4]
    // computed his original endomorphism roots.
    //
    // @indutny's method for computing cube roots
    // of unity[5] appears to be the method described
    // on wikipedia[6][7].
    //
    // Sage produces the same solution:
    //
    //   sage: solve(x^2 + x + 1 == 0, x)
    //   [x == -1/2*I*sqrt(3) - 1/2, x == 1/2*I*sqrt(3) - 1/2]
    //
    // This can be reduced to:
    //
    //   x = (+-sqrt(-3) - 1) / 2
    //
    // [1] https://bitcointalk.org/index.php?topic=3238.msg45565#msg45565
    // [2] https://crypto.stackexchange.com/a/22739
    // [3] https://bitcoin.stackexchange.com/a/35872
    // [4] https://github.com/halfinney/bitcoin/commit/dc411b5
    // [5] https://en.wikipedia.org/wiki/Cube_root_of_unity
    // [6] https://en.wikipedia.org/wiki/Splitting_field#Cubic_example
    // [7] http://mathworld.wolfram.com/SplittingField.html
    const red = num === this.p ? this.red : BN.mont(num);
    const two = new BN(2).toRed(red);
    const three = new BN(3).toRed(red);
    const i2 = two.redInvert();

    // S1 = sqrt(-3) / 2
    const s1 = three.redNeg().redSqrt().redMul(i2);

    // S2 = -S1
    const s2 = s1.redNeg();

    // R1 = S1 - 1 / 2
    const r1 = s1.redSub(i2).fromRed();

    // R2 = S2 - 1 / 2
    const r2 = s2.redSub(i2).fromRed();

    return [r1, r2].sort(BN.cmp);
  }

  _getEndoBasis(lambda) {
    // Compute endomorphic basis.
    //
    // This essentially computes Cornacchia's algorithm
    // for solving x^2 + d * y^2 = m (d = lambda, m = order).
    //
    // https://en.wikipedia.org/wiki/Cornacchia%27s_algorithm
    //
    // [GECC] Algorithm 3.74, Page 127, Section 3.5.
    // [GLV] Page 196, Section 4 (Decomposing K).
    //
    // Balanced length-two representation of a multiplier.
    //
    // 1. Run the extended euclidean algorithm with inputs n
    //    and lambda. The algorithm produces a sequence of
    //    equations si*n + ti*lam = ri where s0=1, t0=0,
    //    r0=n, s1=0, t1=1, r1=lam, and the remainders ri
    //    and are non-negative and strictly decreasing. Let
    //    l be the greatest index for which rl >= sqrt(n).
    const [rl, tl, rl1, tl1, rl2, tl2] = this._egcdSqrt(lambda);

    // 2. Set (a1, b1) <- (rl+1, -tl+1).
    const a1 = rl1;
    const b1 = tl1.neg();

    // 3. If (rl^2 + tl^2) <= (rl+2^2 + tl+2^2)
    //    then set (a2, b2) <- (rl, -tl).
    //    else set (a2, b2) <- (rl+2, -tl+2).
    const lhs = rl.sqr().iadd(tl.sqr());
    const rhs = rl2.sqr().iadd(tl2.sqr());

    let a2, b2;

    if (lhs.cmp(rhs) <= 0) {
      a2 = rl;
      b2 = tl.neg();
    } else {
      a2 = rl2;
      b2 = tl2.neg();
    }

    return [
      new Vector(a1, b1),
      new Vector(a2, b2)
    ];
  }

  _egcdSqrt(lambda) {
    // Extended Euclidean algorithm for integers.
    //
    // [GECC] Algorithm 2.19, Page 40, Section 2.2.
    // [GLV] Page 196, Section 4 (Decomposing K).
    assert(lambda instanceof BN);
    assert(!lambda.red);
    assert(lambda.sign() > 0);
    assert(this.n.sign() > 0);

    // Note that we insert the approximate square
    // root checks as described in algorithm 3.74.
    //
    // Algorithm 2.19 is defined as:
    //
    // 1. u <- a
    //    v <- b
    //
    // 2. x1 <- 1
    //    y1 <- 0
    //    x2 <- 0
    //    y2 <- 1
    //
    // 3. while u != 0 do
    //
    // 3.1. q <- floor(v / u)
    //      r <- v - q * u
    //      x <- x2 - q * x1
    //      y <- y2 - q * y1
    //
    // 3.2. v <- u
    //      u <- r
    //      x2 <- x1
    //      x1 <- x
    //      y2 <- y1
    //      y1 <- y
    //
    // 4. d <- v
    //    x <- x2
    //    y <- y2
    //
    // 5. Return (d, x, y).

    // Start with an approximate square root of n.
    const sqrtn = this.n.ushrn(this.n.bitLength() >>> 1);

    let u = lambda; // r1
    let v = this.n.clone(); // r0
    let x1 = new BN(1); // t1
    let y1 = new BN(0); // t0
    let x2 = new BN(0); // s1
    let y2 = new BN(1); // s0

    // All vectors are roots of: a + b * lambda = 0 (mod n).
    let rl, tl;

    // First vector.
    let rl1, tl1;

    // Inner.
    let i = 0;
    let j = 0;
    let p;

    // Compute EGCD.
    while (!u.isZero() && i < 2) {
      const q = v.quo(u);
      const r = v.sub(q.mul(u));
      const x = x2.sub(q.mul(x1));
      const y = y2.sub(q.mul(y1));

      // Check for r < sqrt(n).
      if (j === 0 && r.cmp(sqrtn) < 0) {
        rl = p;
        tl = x1;
        rl1 = r;
        tl1 = x;
        j = 1; // 1 more round.
      }

      p = r;
      v = u;
      u = r;
      x2 = x1;
      x1 = x;
      y2 = y1;
      y1 = y;

      i += j;
    }

    // Should never happen.
    assert(j !== 0, 'Could not find r < sqrt(n).');

    // Second vector.
    const rl2 = x2;
    const tl2 = x1;

    return [
      rl,
      tl,
      rl1,
      tl1,
      rl2,
      tl2
    ];
  }

  _getEndoPrecomp(basis) {
    // Precompute `g1` and `g2` to avoid round division.
    //
    // [JCEN12] Page 5, Section 4.3.
    //
    // Computation:
    //
    //   d = a1 * b2 - b1 * a2
    //   t = ceil(log2(d+1)) + p
    //   g1 = round((2^t * b2) / d)
    //   g2 = round((2^t * b1) / d)
    //
    // Where:
    //
    //   `p` is the number of precision bits.
    //   `d` is equal to `n` (the curve order).
    //
    // The paper above uses 2 as the value of `p`,
    // whereas libsecp256k1 uses 128 (total=384).
    //
    // We pick precision for `g1` and `g2` such that:
    //
    //   abs(g1) < n
    //   abs(g2) < n
    //
    // This ensures maximum precision for the constants
    // while also ensuring they fit into a fixed number
    // of scalar limbs in more optimized implementations.
    //
    // Furthermore, we attempt to align to a limb width
    // of 64 bits. This allows us to optimize the shift,
    // a la libsecp256k1[1].
    //
    // [1] https://github.com/bitcoin-core/secp256k1/pull/822
    assert(Array.isArray(basis));
    assert(basis.length === 2);
    assert(basis[0] instanceof Vector);
    assert(basis[1] instanceof Vector);

    const [v1, v2] = basis;
    const d = v1.a.mul(v2.b).isub(v1.b.mul(v2.a));
    const bits = d.bitLength();
    const align = bits >= 160;

    assert(d.eq(this.n));

    // Start with a rough estimate.
    let shift = bits + Math.ceil(bits / 2) + 1;
    let g1, g2;

    if (align)
      shift -= shift & 63;

    while (shift > bits) {
      g1 = v2.b.ushln(shift).divRound(d);
      g2 = v1.b.ushln(shift).divRound(d);

      if (g1.ucmp(d) < 0 && g2.ucmp(d) < 0)
        break;

      if (align)
        shift -= 64;
      else
        shift -= 1;
    }

    if (shift <= bits)
      throw new Error('Could not calculate g1 and g2.');

    return [shift, g1, g2];
  }

  _endoSplit(k) {
    // Balanced length-two representation of a multiplier.
    //
    // [GECC] Algorithm 3.74, Page 127, Section 3.5.
    //
    // Also note that it is possible to precompute[1]
    // values in order to avoid the division[2][3][4].
    //
    // This involves precomputing `g1` and `g2 (see
    // above). `c1` and `c2` can then be computed as
    // follows:
    //
    //   t = ceil(log2(n+1)) + p
    //   c1 = (k * g1) >> t
    //   c2 = -((k * g2) >> t)
    //
    // Where `>>` is an _unsigned_ right shift. Also
    // note that the last bit discarded in the shift
    // must be stored. If it is 1, then add 1 to the
    // scalar (absolute addition).
    //
    // It's worth noting that libsecp256k1 uses a
    // different calculation along the lines of:
    //
    //   t = ceil(log2(n+1)) + p
    //   c1 = ((k * g1) >> t) * -b1
    //   c2 = ((k * -g2) >> t) * -b2
    //   k2 = c1 + c2
    //   k1 = k2 * -lambda + k
    //
    // So, in the future, we can consider changing
    // step 4 to:
    //
    //   4. Compute c1 = (k * g1) >> t
    //          and c2 = -((k * g2) >> t).
    //
    //   const [shift, g1, g2] = this.endo.pre;
    //   const c1 = k.mulShift(g1, shift);
    //   const c2 = k.mulShift(g2, shift).ineg();
    //
    // Once we're brave enough, that is.
    //
    // [1] [JCEN12] Page 5, Section 4.3.
    // [2] https://github.com/bitcoin-core/secp256k1/blob/0b70241/src/scalar_impl.h#L259
    // [3] https://github.com/bitcoin-core/secp256k1/pull/21
    // [4] https://github.com/bitcoin-core/secp256k1/pull/127
    assert(k instanceof BN);
    assert(!k.red);
    assert(!this.n.isZero());

    const [v1, v2] = this.endo.basis;

    // 4. Compute c1 = round(b2 * k / n)
    //        and c2 = round(-b1 * k / n).
    const c1 = v2.b.mul(k).divRound(this.n);
    const c2 = v1.b.neg().mul(k).divRound(this.n);

    // 5. Compute k1 = k - c1 * a1 - c2 * a2
    //        and k2 = -c1 * b1 - c2 * b2.
    const p1 = c1.mul(v1.a);
    const p2 = c2.mul(v2.a);
    const q1 = c1.ineg().mul(v1.b);
    const q2 = c2.mul(v2.b);

    // Calculate answer.
    const k1 = k.sub(p1).isub(p2);
    const k2 = q1.isub(q2);

    // 6. Return (k1, k2).
    return [k1, k2];
  }

  _endoBeta(point) {
    assert(point instanceof ShortPoint);
    return [point, point._getBeta()];
  }

  _endoWnafMulAdd(points, coeffs) {
    // Point multiplication with efficiently computable endomorphisms.
    //
    // [GECC] Algorithm 3.77, Page 129, Section 3.5.
    // [GLV] Page 193, Section 3 (Using Efficient Endomorphisms).
    //
    // Note it may be possible to do this 4-dimensionally [4GLV].
    assert(Array.isArray(points));
    assert(Array.isArray(coeffs));
    assert(points.length === coeffs.length);
    assert(this.endo != null);

    const len = points.length;
    const npoints = new Array(len * 2);
    const ncoeffs = new Array(len * 2);

    for (let i = 0; i < len; i++) {
      const [p1, p2] = this._endoBeta(points[i]);
      const [k1, k2] = this._endoSplit(coeffs[i]);

      npoints[i * 2 + 0] = p1;
      ncoeffs[i * 2 + 0] = k1;
      npoints[i * 2 + 1] = p2;
      ncoeffs[i * 2 + 1] = k2;
    }

    return this._wnafMulAdd(5, npoints, ncoeffs);
  }

  _sswu(u) {
    // Simplified Shallue-Woestijne-Ulas Method.
    //
    // Distribution: 3/8.
    //
    // [SSWU1] Page 15-16, Section 7. Appendix G.
    // [SSWU2] Page 5, Theorem 2.3.
    // [H2EC] "Simplified Shallue-van de Woestijne-Ulas Method".
    //
    // Assumptions:
    //
    //   - a != 0, b != 0.
    //   - Let z be a non-square in F(p).
    //   - z != -1.
    //   - The polynomial g(x) - z is irreducible over F(p).
    //   - g(b / (z * a)) is square in F(p).
    //   - u != 0, u != +-sqrt(-1 / z).
    //
    // Map:
    //
    //   g(x) = x^3 + a * x + b
    //   t1 = 1 / (z^2 * u^4 + z * u^2)
    //   x1 = (-b / a) * (1 + t1)
    //   x1 = b / (z * a), if t1 = 0
    //   x2 = z * u^2 * x1
    //   x = x1, if g(x1) is square
    //     = x2, otherwise
    //   y = sign(u) * abs(sqrt(g(x)))
    const {b, z, ai, zi, one} = this;
    const z2 = z.redSqr();
    const ba = b.redNeg().redMul(ai);
    const bza = b.redMul(zi).redMul(ai);
    const u2 = u.redSqr();
    const u4 = u2.redSqr();
    const t0 = z2.redMul(u4).redIAdd(z.redMul(u2));
    const t1 = t0.isZero() ? t0 : t0.redInvert();
    const x1 = t1.isZero() ? bza : ba.redMul(one.redAdd(t1));
    const x2 = z.redMul(u2).redMul(x1);
    const y1 = this.solveY2(x1);
    const y2 = this.solveY2(x2);
    const alpha = y1.redIsSquare() | 0;
    const x = [x1, x2][alpha ^ 1];
    const y = [y1, y2][alpha ^ 1].redSqrt();

    if (y.redIsOdd() !== u.redIsOdd())
      y.redINeg();

    return this.point(x, y);
  }

  _sswui(p, hint) {
    // Inverting the Map (Simplified Shallue-Woestijne-Ulas).
    //
    // Assumptions:
    //
    //   - a^2 * x^2 - 2 * a * b * x - 3 * b^2 is square in F(p).
    //   - If r < 3 then x != -b / a.
    //
    // Unlike SVDW, the preimages here are evenly
    // distributed (more or less). SSWU covers ~3/8
    // of the curve points. Each preimage has a 1/2
    // chance of mapping to either x1 or x2.
    //
    // Assuming the point is within that set, each
    // point has a 1/4 chance of inverting to any
    // of the preimages. This means we can simply
    // randomly select a preimage if one exists.
    //
    // However, the [SVDW2] sampling method seems
    // slighly faster in practice for [SQUARED].
    //
    // Map:
    //
    //   c = sqrt(a^2 * x^2 - 2 * a * b * x - 3 * b^2)
    //   u1 = -(a * x + b - c) / (2 * (a * x + b) * z)
    //   u2 = -(a * x + b + c) / (2 * (a * x + b) * z)
    //   u3 = -(a * x + b - c) / (2 * b * z)
    //   u4 = -(a * x + b + c) / (2 * b * z)
    //   r = random integer in [1,4]
    //   u = sign(y) * abs(sqrt(ur))
    const {a, b, z} = this;
    const {x, y} = p;
    const r = hint & 3;
    const a2x2 = a.redSqr().redMul(x.redSqr());
    const abx2 = a.redMul(b).redMul(x).redIMuln(2);
    const b23 = b.redSqr().redMuln(3);
    const axb = a.redMul(x).redIAdd(b);
    const c = a2x2.redISub(abx2).redISub(b23).redSqrt();
    const n0 = axb.redSub(c).redINeg();
    const n1 = axb.redAdd(c).redINeg();
    const d0 = axb.redMul(z).redIMuln(2);
    const d1 = b.redMul(z).redIMuln(2);
    const n = [n0, n1][r & 1]; // r = 1 or 3
    const d = [d0, d1][r >>> 1]; // r = 2 or 3
    const u = n.redDivSqrt(d);

    if (u.redIsOdd() !== y.redIsOdd())
      u.redINeg();

    return u;
  }

  _svdwf(u) {
    // Shallue-van de Woestijne Method.
    //
    // Distribution: 9/16.
    //
    // [SVDW1] Section 5.
    // [SVDW2] Page 8, Section 3.
    //         Page 15, Section 6, Algorithm 1.
    // [H2EC] "Shallue-van de Woestijne Method".
    //
    // Assumptions:
    //
    //   - p = 1 (mod 3).
    //   - a = 0, b != 0.
    //   - Let z be a unique element in F(p).
    //   - g((sqrt(-3 * z^2) - z) / 2) is square in F(p).
    //   - u != 0, u != +-sqrt(-g(z)).
    //
    // Map:
    //
    //   g(x) = x^3 + b
    //   c = sqrt(-3 * z^2)
    //   t1 = u^2 + g(z)
    //   t2 = 1 / (u^2 * t1)
    //   t3 = u^4 * t2 * c
    //   x1 = (c - z) / 2 - t3
    //   x2 = t3 - (c + z) / 2
    //   x3 = z - t1^3 * t2 / (3 * z^2)
    //   x = x1, if g(x1) is square
    //     = x2, if g(x2) is square
    //     = x3, otherwise
    //   y = sign(u) * abs(sqrt(g(x)))
    const {c, z, zi, i2, i3} = this;
    const gz = this.solveY2(z);
    const z3 = i3.redMul(zi.redSqr());
    const u2 = u.redSqr();
    const u4 = u2.redSqr();
    const t1 = u2.redAdd(gz);
    const u2t1 = u2.redMul(t1);
    const t2 = u2t1.isZero() ? u2t1 : u2t1.redInvert();
    const t3 = u4.redMul(t2).redMul(c);
    const t4 = t1.redSqr().redMul(t1);
    const x1 = c.redSub(z).redMul(i2).redISub(t3);
    const x2 = t3.redSub(c.redAdd(z).redMul(i2));
    const x3 = z.redSub(t4.redMul(t2).redMul(z3));
    const y1 = this.solveY2(x1);
    const y2 = this.solveY2(x2);
    const y3 = this.solveY2(x3);
    const alpha = y1.redJacobi() | 1;
    const beta = y2.redJacobi() | 1;
    const i = mod((alpha - 1) * beta, 3);
    const x = [x1, x2, x3][i];
    const y = [y1, y2, y3][i];

    return [x, y];
  }

  _svdw(u) {
    const [x, yy] = this._svdwf(u);
    const y = yy.redSqrt();

    if (y.redIsOdd() !== u.redIsOdd())
      y.redINeg();

    return this.point(x, y);
  }

  _svdwi(p, hint) {
    // Inverting the Map (Shallue-van de Woestijne).
    //
    // [SQUARED] Algorithm 1, Page 8, Section 3.3.
    // [SVDW2] Page 12, Section 5.
    // [SVDW3] "Inverting the map".
    //
    // Assumptions:
    //
    //   - If r = 1 then x != -(c + z) / 2.
    //   - If r = 2 then x != (c - z) / 2.
    //   - If r > 2 then (t0 - t1 + t2) is square in F(p).
    //   - f(f^-1(x)) = x where f is the map function.
    //
    // We use the sampling method from [SVDW2],
    // _not_ [SQUARED]. This seems to have a
    // better distribution in practice.
    //
    // Note that [SVDW3] also appears to be
    // incorrect in terms of distribution.
    //
    // The distribution of f(u), assuming u is
    // random, is (1/2, 1/4, 1/4).
    //
    // To mirror this, f^-1(x) should simply
    // pick (1/2, 1/4, 1/8, 1/8).
    //
    // To anyone running the forward map, our
    // strings will appear to be random.
    //
    // Map:
    //
    //   g(x) = x^3 + b
    //   c = sqrt(-3 * z^2)
    //   t0 = 9 * (x^2 * z^2 + z^4)
    //   t1 = 18 * x * z^3
    //   t2 = 12 * g(z) * (x - z)
    //   t3 = sqrt(t0 - t1 + t2)
    //   t4 = t3 * z
    //   u1 = g(z) * (c - 2 * x - z) / (c + 2 * x + z)
    //   u2 = g(z) * (c + 2 * x + z) / (c - 2 * x - z)
    //   u3 = (3 * (z^3 - x * z^2) - 2 * g(z) + t4) / 2
    //   u4 = (3 * (z^3 - x * z^2) - 2 * g(z) - t4) / 2
    //   r = random integer in [1,4]
    //   u = sign(y) * abs(sqrt(ur))
    const {b, c, z, zero, two} = this;
    const {x, y} = p;
    const r = hint & 3;
    const z2 = z.redSqr();
    const z3 = z2.redMul(z);
    const z4 = z2.redSqr();
    const gz = z3.redAdd(b);
    const gz2 = gz.redMuln(2);
    const xx = x.redSqr();
    const x2z = x.redMuln(2).redIAdd(z);
    const xz2 = x.redMul(z2);
    const c0 = c.redSub(x2z);
    const c1 = c.redAdd(x2z);
    const t0 = xx.redMul(z2).redIAdd(z4).redIMuln(9);
    const t1 = x.redMul(z3).redIMuln(18);
    const t2 = gz.redMul(x.redSub(z)).redIMuln(12);
    const t3 = r >= 2 ? t0.redISub(t1).redIAdd(t2).redSqrt() : zero;
    const t4 = t3.redMul(z);
    const t5 = z3.redISub(xz2).redIMuln(3).redISub(gz2);
    const n0 = gz.redMul(c0);
    const n1 = gz.redMul(c1);
    const n2 = t5.redAdd(t4);
    const n3 = t5.redSub(t4);
    const d2 = two;
    const n = [n0, n1, n2, n3][r];
    const d = [c1, c0, d2, d2][r];
    const u = n.redDivSqrt(d);
    const [x0] = this._svdwf(u);

    if (!x0.eq(x))
      throw new Error('Invalid point.');

    if (u.redIsOdd() !== y.redIsOdd())
      u.redINeg();

    return u;
  }

  isElliptic() {
    const {a, b} = this;
    const a2 = a.redSqr();
    const a3 = a2.redMul(a);
    const b2 = b.redSqr();
    const d = b2.redMuln(27).redIAdd(a3.redMuln(4));

    // 4 * a^3 + 27 * b^2 != 0
    return !d.isZero();
  }

  jinv() {
    // [ARITH1] Page 71, Section 4.4.
    // http://mathworld.wolfram.com/j-Invariant.html
    const {a, b} = this;
    const a2 = a.redSqr();
    const a3 = a2.redMul(a);
    const b2 = b.redSqr();
    const t0 = a3.redMuln(4);
    const lhs = t0.redMuln(1728);
    const rhs = b2.redMuln(27).redIAdd(t0);

    if (rhs.isZero())
      throw new Error('Curve is not elliptic.');

    // (1728 * 4 * a^3) / (4 * a^3 + 27 * b^2)
    return lhs.redDiv(rhs).fromRed();
  }

  point(x, y) {
    return new ShortPoint(this, x, y);
  }

  jpoint(x, y, z) {
    return new JPoint(this, x, y, z);
  }

  solveX(y) {
    assert(y instanceof BN);

    if (!this.a.isZero())
      throw new Error('Not implemented.');

    // x^3 = y^2 - b
    const y2 = y.redSqr();
    const x3 = y2.redSub(this.b);

    return cubeRoots(x3);
  }

  solveY2(x) {
    // [GECC] Page 89, Section 3.2.2.
    // https://hyperelliptic.org/EFD/g1p/auto-shortw.html
    assert(x instanceof BN);

    // y^2 = x^3 + a * x + b
    const x3 = x.redSqr().redMul(x);
    const y2 = x3.redIAdd(this.b);

    if (!this.zeroA) {
      // Save some cycles for a = -3.
      if (this.threeA)
        y2.redIAdd(x.redMuln(-3));
      else
        y2.redIAdd(this.a.redMul(x));
    }

    return y2;
  }

  validate(point) {
    assert(point instanceof ShortPoint);

    if (point.inf)
      return true;

    const {x, y} = point;
    const y2 = this.solveY2(x);

    return y.redSqr().eq(y2);
  }

  pointFromX(x, sign = null) {
    assert(x instanceof BN);
    assert(sign == null || typeof sign === 'boolean');

    if (!x.red)
      x = x.toRed(this.red);

    const y = this.solveY(x);

    if (sign != null) {
      if (this.h.cmpn(1) > 0) {
        if (y.isZero() && sign)
          throw new Error('Invalid point.');
      }

      if (y.redIsOdd() !== sign)
        y.redINeg();
    }

    return this.point(x, y);
  }

  pointFromY(y, index = 0) {
    assert(y instanceof BN);
    assert((index >>> 0) === index);

    if (!y.red)
      y = y.toRed(this.red);

    const coords = this.solveX(y);

    if (index >= coords.length)
      throw new Error('Invalid X coordinate index.');

    const x = coords[index];

    return this.point(x, y);
  }

  isIsomorphic(curve) {
    // [GECC] Page 84, Section 3.1.5.
    // [ARITH1] Page 286, Section 13.2.3.c.
    assert(curve instanceof Curve);

    if (!curve.p.eq(this.p))
      return false;

    let u2, u3;
    try {
      [u2, u3] = this._scale(curve);
    } catch (e) {
      return false;
    }

    // E(a,b) <-> E(au^4,bu^6)
    if (curve.type === 'short') {
      // a' = a * u^4, b' = b * u^6
      const a = this.field(curve.a).redMul(u2.redSqr());
      const b = this.field(curve.b).redMul(u3.redSqr());

      return this.a.eq(a) && this.b.eq(b);
    }

    // E(a,b) <-> M(A,B)
    if (curve.type === 'mont') {
      // (A / (3 * B))^3 + a * (A / (3 * B)) + b = 0
      const {a3, bi} = curve;
      const x = this.field(a3.redMul(bi)).redMul(u2);
      const y2 = this.solveY2(x);

      return y2.isZero();
    }

    // E(a,b) <-> E(a,d)
    if (curve.type === 'edwards') {
      // ((a' + d') / 6)^3 + a * ((a' + d') / 6) + b = 0
      const x = this.field(curve.ad6).redMul(u2);
      const y2 = this.solveY2(x);

      return y2.isZero();
    }

    return false;
  }

  isIsogenous(curve) {
    assert(curve instanceof Curve);
    return false;
  }

  pointFromShort(point) {
    // [GECC] Page 84, Section 3.1.5.
    // [ALT] Appendix F.3 (Isomorphic Mapping between Weierstrass Curves).
    assert(point instanceof ShortPoint);

    if (this.isIsomorphic(point.curve)) {
      // Isomorphic maps for E(a,b)<->E(au^4,bu^6):
      //
      //   x' = x * u^2
      //   y' = y * u^3
      //
      // Where a * u^4 = a' and b * u^6 = b'.
      if (point.isInfinity())
        return this.point();

      const [u2, u3] = this._scale(point.curve);
      const x = this.field(point.x);
      const y = this.field(point.y);
      const nx = x.redMul(u2);
      const ny = y.redMul(u3);

      return this.point(nx, ny);
    }

    throw new Error('Not implemented.');
  }

  pointFromMont(point) {
    // [ALT] Appendix E.2 (Switching between Alternative Representations).
    // [MONT2] "Equivalence with Weierstrass curves"
    assert(point instanceof MontPoint);

    if (this.isIsomorphic(point.curve)) {
      // Equivalence for M(A,B)->E(a,b):
      //
      //   x = (u + A / 3) / B
      //   y = v / B
      //
      // Undefined if ((u^3 + A * u^2 + u) / B) is not square.
      if (point.isInfinity())
        return this.point();

      const {a3, bi} = point.curve;
      const [u2, u3] = this._scale(point.curve);
      const nx = point.x.redAdd(a3).redMul(bi);
      const ny = point.y.redMul(bi);

      return this.point(this.field(nx).redMul(u2),
                        this.field(ny).redMul(u3));
    }

    throw new Error('Not implemented.');
  }

  pointFromEdwards(point) {
    // [TWISTEQ] Section 2.
    assert(point instanceof EdwardsPoint);

    if (this.isIsomorphic(point.curve)) {
      // Equivalence for E(a,d)->E(a',b'):
      //
      //   x' = ((5 * d - a) * y + d - 5 * a) / (12 * (y - 1))
      //   y' = (d - a) * (y + 1) / (4 * x * (y - 1))
      //
      // Undefined for x = 0 or y = 1.
      //
      // Exceptional Cases:
      //   - (0, 1) -> O
      //   - (0, -1) -> ((a + d) / 6, 0)
      //
      // Unexceptional Cases:
      //   - (sqrt(1 / a), 0) -> ((5 * a - d) / 12, (a - d) / 4 * sqrt(a))
      const {a, d, ad6} = point.curve;
      const [u2, u3] = this._scale(point.curve);

      if (point.isInfinity())
        return this.point();

      if (point.x.isZero()) {
        const x = this.field(ad6).redMul(u2);
        return this.point(x, this.zero);
      }

      const {x, y, z} = point;
      const a5 = a.redMuln(5);
      const d5 = d.redMuln(5);
      const dma = d.redSub(a);
      const d5a = d5.redSub(a);
      const da5 = d.redSub(a5);
      const ypz = y.redAdd(z);
      const ymz = y.redSub(z);
      const xx = d5a.redMul(y).redIAdd(da5.redMul(z));
      const xz = ymz.redMuln(12);
      const yy = dma.redMul(ypz).redMul(z);
      const yz = ymz.redMul(x).redIMuln(4);

      return this.cpoint(this.field(xx).redMul(u2),
                         this.field(xz),
                         this.field(yy).redMul(u3),
                         this.field(yz));
    }

    throw new Error('Not implemented.');
  }

  pointFromUniform(u) {
    assert(u instanceof BN);

    // z = 0 or b = 0
    if (this.z.isZero() || this.b.isZero())
      throw new Error('Not implemented.');

    // a != 0, b != 0
    if (!this.a.isZero())
      return this._sswu(u);

    // p = 1 mod 3, a = 0, b != 0
    if (!this.c.isZero())
      return this._svdw(u);

    throw new Error('Not implemented.');
  }

  pointToUniform(p, hint) {
    // Convert a short weierstrass point to a field
    // element by inverting either the SSWU or SVDW
    // map.
    //
    // Hint Layout:
    //
    //   [00000000] [0000] [0000]
    //        |        |      |
    //        |        |      +-- preimage index
    //        |        +--- subgroup
    //        +-- bits to OR with uniform bytes
    assert(p instanceof ShortPoint);
    assert((hint >>> 0) === hint);

    // z = 0 or b = 0
    if (this.z.isZero() || this.b.isZero())
      throw new Error('Not implemented.');

    // P = O
    if (p.isInfinity())
      throw new Error('Invalid point.');

    // Add a random torsion component.
    const i = ((hint >>> 4) & 15) % this.torsion.length;
    const q = p.add(this.torsion[i]);

    return wrapErrors(() => {
      // a != 0, b != 0
      if (!this.a.isZero())
        return this._sswui(q, hint);

      // p = 1 mod 3, a = 0, b != 0
      if (!this.c.isZero())
        return this._svdwi(q, hint);

      throw new Error('Not implemented.');
    });
  }

  mulAll(points, coeffs) {
    return super.mulAll(points, coeffs).toP();
  }

  affinizeAll(points) {
    const out = this.normalizeAll(points);

    for (let i = 0; i < out.length; i++)
      out[i] = out[i].toP();

    return out;
  }

  decodePoint(bytes) {
    return ShortPoint.decode(this, bytes);
  }

  encodeX(point) {
    assert(point instanceof Point);
    return point.encodeX();
  }

  decodeEven(bytes) {
    return ShortPoint.decodeEven(this, bytes);
  }

  decodeSquare(bytes) {
    return ShortPoint.decodeSquare(this, bytes);
  }

  toShort(a0, odd, sign = null) {
    const [a, b] = this._short(a0, odd);

    const curve = new ShortCurve({
      red: this.red,
      prime: this.prime,
      p: this.p,
      a: a,
      b: b,
      n: this.n,
      h: this.h
    });

    if (sign != null) {
      const [, u3] = curve._scale(this);

      if (u3.redIsOdd() !== sign)
        u3.redINeg();
    }

    if (!this.g.isInfinity())
      curve.g = curve.pointFromShort(this.g);

    for (let i = 0; i < this.h.word(0); i++)
      curve.torsion[i] = curve.pointFromShort(this.torsion[i]);

    return curve;
  }

  toMont(b0, odd, sign = null) {
    const [a, b] = this._mont(b0, odd);

    const curve = new MontCurve({
      red: this.red,
      prime: this.prime,
      p: this.p,
      a: a,
      b: b,
      n: this.n,
      h: this.h
    });

    if (sign != null) {
      const [, u3] = this._scale(curve);

      if (u3.redIsOdd() !== sign)
        u3.redINeg();
    }

    if (!this.g.isInfinity())
      curve.g = curve.pointFromShort(this.g);

    for (let i = 0; i < this.h.word(0); i++)
      curve.torsion[i] = curve.pointFromShort(this.torsion[i]);

    return curve;
  }

  toEdwards(a0, odd, sign = null) {
    const [a, d] = this._edwards(a0, odd);

    const curve = new EdwardsCurve({
      red: this.red,
      prime: this.prime,
      p: this.p,
      a: a,
      d: d,
      n: this.n,
      h: this.h
    });

    if (sign != null) {
      const [, u3] = this._scale(curve);

      if (u3.redIsOdd() !== sign)
        u3.redINeg();
    }

    if (!this.g.isInfinity()) {
      curve.g = curve.pointFromShort(this.g);
      curve.g.normalize();
    }

    if (curve.isComplete()) {
      for (let i = 0; i < this.h.word(0); i++) {
        curve.torsion[i] = curve.pointFromShort(this.torsion[i]);
        curve.torsion[i].normalize();
      }
    }

    return curve;
  }

  pointFromJSON(json) {
    return ShortPoint.fromJSON(this, json);
  }

  toJSON(pre) {
    const json = super.toJSON(pre);

    json.a = this.a.fromRed().toJSON();
    json.b = this.b.fromRed().toJSON();

    if (!this.c.isZero())
      json.c = this.c.fromRed().toJSON();

    return json;
  }
}

/**
 * ShortPoint
 */

class ShortPoint extends Point {
  constructor(curve, x, y) {
    assert(curve instanceof ShortCurve);

    super(curve, types.AFFINE);

    this.x = this.curve.zero;
    this.y = this.curve.zero;
    this.inf = true;

    if (x != null)
      this._init(x, y);
  }

  _init(x, y) {
    assert(x instanceof BN);
    assert(y instanceof BN);

    this.x = x;
    this.y = y;

    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);

    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);

    this.inf = false;
  }

  _getBeta() {
    if (!this.curve.endo)
      return null;

    if (this.pre && this.pre.beta)
      return this.pre.beta;

    // Augment the point with our beta value.
    // This is the counterpart to `k2` after
    // the endomorphism split of `k`.
    //
    // Note that if we have precomputation,
    // we have to clone and update all of the
    // precomputed points below.
    const xb = this.x.redMul(this.curve.endo.beta);
    const beta = this.curve.point(xb, this.y);

    if (this.pre) {
      beta.pre = this.pre.map((point) => {
        const xb = point.x.redMul(this.curve.endo.beta);
        return this.curve.point(xb, point.y);
      });

      this.pre.beta = beta;
    }

    return beta;
  }

  _getJNAF(point) {
    assert(point instanceof ShortPoint);

    if (this.inf || point.inf)
      return super._getJNAF(point);

    // Create comb for JSF.
    const comb = [
      this, // 1
      null, // 3
      null, // 5
      point // 7
    ];

    // Try to avoid Jacobian points, if possible.
    if (this.y.eq(point.y)) {
      comb[1] = this.add(point);
      comb[2] = this.toJ().sub(point);
    } else if (this.y.eq(point.y.redNeg())) {
      comb[1] = this.toJ().add(point);
      comb[2] = this.sub(point);
    } else {
      comb[1] = this.toJ().add(point);
      comb[2] = this.toJ().sub(point);
    }

    return comb;
  }

  clone() {
    if (this.inf)
      return this.curve.point();

    return this.curve.point(this.x, this.y);
  }

  scale(a) {
    return this.toJ().scale(a);
  }

  neg() {
    // P = O
    if (this.inf)
      return this;

    // -(X1, Y1) = (X1, -Y1)
    return this.curve.point(this.x, this.y.redNeg());
  }

  add(p) {
    // [GECC] Page 80, Section 3.1.2.
    //
    // Addition Law:
    //
    //   l = (y1 - y2) / (x1 - x2)
    //   x3 = l^2 - x1 - x2
    //   y3 = l * (x1 - x3) - y1
    //
    // 1I + 2M + 1S + 6A
    assert(p instanceof ShortPoint);

    // O + P = P
    if (this.inf)
      return p;

    // P + O = P
    if (p.inf)
      return this;

    // P + P, P + -P
    if (this.x.eq(p.x)) {
      // P + -P = O
      if (!this.y.eq(p.y))
        return this.curve.point();

      // P + P = 2P
      return this.dbl();
    }

    // X1 != X2, Y1 = Y2
    if (this.y.eq(p.y)) {
      // X3 = -X1 - X2
      const nx = this.x.redNeg().redISub(p.x);

      // Y3 = -Y1
      const ny = this.y.redNeg();

      // Skip the inverse.
      return this.curve.point(nx, ny);
    }

    // H = X1 - X2
    const h = this.x.redSub(p.x);

    // R = Y1 - Y2
    const r = this.y.redSub(p.y);

    // L = R / H
    const l = r.redDiv(h);

    // X3 = L^2 - X1 - X2
    const nx = l.redSqr().redISub(this.x).redISub(p.x);

    // Y3 = L * (X1 - X3) - Y1
    const ny = l.redMul(this.x.redSub(nx)).redISub(this.y);

    return this.curve.point(nx, ny);
  }

  dbl() {
    // [GECC] Page 80, Section 3.1.2.
    //
    // Addition Law (doubling):
    //
    //   l = (3 * x1^2 + a) / (2 * y1)
    //   x3 = l^2 - 2 * x1
    //   y3 = l * (x1 - x3) - y1
    //
    // 1I + 2M + 2S + 3A + 2*2 + 1*3

    // P = O
    if (this.inf)
      return this;

    // Y1 = 0
    if (this.y.isZero())
      return this.curve.point();

    // XX = X1^2
    const xx = this.x.redSqr();

    // M = 3 * XX + a
    const m = xx.redIMuln(3).redIAdd(this.curve.a);

    // Z = 2 * Y1
    const z = this.y.redMuln(2);

    // L = M / Z
    const l = m.redDiv(z);

    // X3 = L^2 - 2 * X1
    const nx = l.redSqr().redISub(this.x).redISub(this.x);

    // Y3 = L * (X1 - X3) - Y1
    const ny = l.redMul(this.x.redSub(nx)).redISub(this.y);

    return this.curve.point(nx, ny);
  }

  dblp(pow) {
    return this.toJ().dblp(pow).toP();
  }

  getX() {
    if (this.inf)
      throw new Error('Invalid point.');

    return this.x.fromRed();
  }

  getY() {
    if (this.inf)
      throw new Error('Invalid point.');

    return this.y.fromRed();
  }

  eq(p) {
    assert(p instanceof ShortPoint);

    // P = Q
    if (this === p)
      return true;

    // P = O
    if (this.inf)
      return p.inf;

    // Q = O
    if (p.inf)
      return false;

    // X1 = X2, Y1 = Y2
    return this.x.eq(p.x)
        && this.y.eq(p.y);
  }

  cmp(point) {
    assert(point instanceof ShortPoint);

    if (this.inf && !point.inf)
      return -1;

    if (!this.inf && point.inf)
      return 1;

    if (this.inf && point.inf)
      return 0;

    return this.order().cmp(point.order())
        || this.getX().cmp(point.getX())
        || this.getY().cmp(point.getY());
  }

  isInfinity() {
    // Infinity cannot be represented in
    // the affine space, except by a flag.
    return this.inf;
  }

  isOrder2() {
    if (this.inf)
      return false;

    return this.y.isZero();
  }

  isOdd() {
    if (this.inf)
      return false;

    return this.y.redIsOdd();
  }

  isEven() {
    if (this.inf)
      return false;

    return this.y.redIsEven();
  }

  isSquare() {
    if (this.inf)
      return false;

    return this.y.redJacobi() !== -1;
  }

  eqX(x) {
    assert(x instanceof BN);
    assert(!x.red);

    if (this.inf)
      return false;

    return this.getX().eq(x);
  }

  eqR(x) {
    assert(x instanceof BN);
    assert(!x.red);
    assert(!this.curve.n.isZero());

    if (this.inf)
      return false;

    return this.getX().imod(this.curve.n).eq(x);
  }

  mul(k) {
    return super.mul(k).toP();
  }

  muln(k) {
    return super.muln(k).toP();
  }

  mulBlind(k, rng) {
    return super.mulBlind(k, rng).toP();
  }

  mulAdd(k1, p2, k2) {
    return super.mulAdd(k1, p2, k2).toP();
  }

  mulH() {
    return super.mulH().toP();
  }

  div(k) {
    return super.div(k).toP();
  }

  divn(k) {
    return super.divn(k).toP();
  }

  divH() {
    return super.divH().toP();
  }

  toP() {
    return this;
  }

  toJ() {
    // (X3, Y3, Z3) = (1, 1, 0)
    if (this.inf)
      return this.curve.jpoint();

    // (X3, Y3, Z3) = (X1, Y1, 1)
    return this.curve.jpoint(this.x, this.y, this.curve.one);
  }

  encode(compact) {
    // [SEC1] Page 10, Section 2.3.3.
    if (compact == null)
      compact = true;

    assert(typeof compact === 'boolean');

    const {fieldSize} = this.curve;

    // We do not serialize points at infinity.
    if (this.inf)
      throw new Error('Invalid point.');

    // Compressed form (0x02 = even, 0x03 = odd).
    if (compact) {
      const p = Buffer.alloc(1 + fieldSize);
      const x = this.curve.encodeField(this.getX());

      p[0] = 0x02 | this.y.redIsOdd();
      x.copy(p, 1);

      return p;
    }

    // Uncompressed form (0x04).
    const p = Buffer.alloc(1 + fieldSize * 2);
    const x = this.curve.encodeField(this.getX());
    const y = this.curve.encodeField(this.getY());

    p[0] = 0x04;
    x.copy(p, 1);
    y.copy(p, 1 + fieldSize);

    return p;
  }

  static decode(curve, bytes) {
    // [SEC1] Page 11, Section 2.3.4.
    assert(curve instanceof ShortCurve);
    assert((bytes != null && bytes._isBuffer === true));

    const len = curve.fieldSize;

    if (bytes.length < 1 + len)
      throw new Error('Not a point.');

    // Point forms:
    //
    //   0x00 -> Infinity (openssl, unsupported)
    //   0x02 -> Compressed Even
    //   0x03 -> Compressed Odd
    //   0x04 -> Uncompressed
    //   0x06 -> Hybrid Even (openssl)
    //   0x07 -> Hybrid Odd (openssl)
    //
    // Note that openssl supports serializing points
    // at infinity as {0}. We choose not to support it
    // because it's strange and not terribly useful.
    const form = bytes[0];

    switch (form) {
      case 0x02:
      case 0x03: {
        if (bytes.length !== 1 + len)
          throw new Error('Invalid point size for compressed.');

        const x = curve.decodeField(bytes.slice(1, 1 + len));

        if (x.cmp(curve.p) >= 0)
          throw new Error('Invalid point.');

        const p = curve.pointFromX(x, form === 0x03);

        assert(!p.isInfinity());

        return p;
      }

      case 0x04:
      case 0x06:
      case 0x07: {
        if (bytes.length !== 1 + len * 2)
          throw new Error('Invalid point size for uncompressed.');

        const x = curve.decodeField(bytes.slice(1, 1 + len));
        const y = curve.decodeField(bytes.slice(1 + len, 1 + 2 * len));

        // [GECC] Algorithm 4.3, Page 180, Section 4.
        if (x.cmp(curve.p) >= 0 || y.cmp(curve.p) >= 0)
          throw new Error('Invalid point.');

        // OpenSSL hybrid encoding.
        if (form !== 0x04 && form !== (0x06 | y.isOdd()))
          throw new Error('Invalid hybrid encoding.');

        const p = curve.point(x, y);

        if (!p.validate())
          throw new Error('Invalid point.');

        assert(!p.isInfinity());

        return p;
      }

      default: {
        throw new Error('Unknown point format.');
      }
    }
  }

  encodeX() {
    // [SCHNORR] "Specification".
    // [BIP340] "Specification".
    return this.curve.encodeField(this.getX());
  }

  static decodeEven(curve, bytes) {
    // [BIP340] "Specification".
    assert(curve instanceof ShortCurve);

    const x = curve.decodeField(bytes);

    if (x.cmp(curve.p) >= 0)
      throw new Error('Invalid point.');

    return curve.pointFromX(x, false);
  }

  static decodeSquare(curve, bytes) {
    // [SCHNORR] "Specification".
    assert(curve instanceof ShortCurve);

    const x = curve.decodeField(bytes);

    if (x.cmp(curve.p) >= 0)
      throw new Error('Invalid point.');

    return curve.pointFromX(x);
  }

  toJSON(pre) {
    if (this.inf)
      return [];

    const x = this.getX().toJSON();
    const y = this.getY().toJSON();

    if (pre === true && this.pre)
      return [x, y, this.pre.toJSON()];

    return [x, y];
  }

  toPretty() {
    if (this.inf)
      return [];

    const size = this.curve.fieldSize * 2;
    const x = toPretty(this.getX(), size);
    const y = toPretty(this.getY(), size);

    return [x, y];
  }

  static fromJSON(curve, json) {
    assert(curve instanceof ShortCurve);
    assert(Array.isArray(json));
    assert(json.length === 0
        || json.length === 2
        || json.length === 3);

    if (json.length === 0)
      return curve.point();

    const x = BN.fromJSON(json[0]);
    const y = BN.fromJSON(json[1]);
    const point = curve.point(x, y);

    if (json.length > 2 && json[2] != null)
      point.pre = Precomp.fromJSON(point, json[2]);

    return point;
  }

  [custom]() {
    if (this.inf)
      return '<ShortPoint: Infinity>';

    return '<ShortPoint:'
         + ' x=' + this.x.fromRed().toString(16, 2)
         + ' y=' + this.y.fromRed().toString(16, 2)
         + '>';
  }
}

/**
 * JPoint
 */

class JPoint extends Point {
  constructor(curve, x, y, z) {
    assert(curve instanceof ShortCurve);

    super(curve, types.JACOBIAN);

    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = this.curve.zero;
    this.zOne = false;

    if (x != null)
      this._init(x, y, z);
  }

  _init(x, y, z) {
    assert(x instanceof BN);
    assert(y instanceof BN);
    assert(z == null || (z instanceof BN));

    this.x = x;
    this.y = y;
    this.z = z || this.curve.one;

    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);

    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);

    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);

    this.zOne = this.z.eq(this.curve.one);
  }

  clone() {
    return this.curve.jpoint(this.x, this.y, this.z);
  }

  validate() {
    // [GECC] Example 3.20, Page 88, Section 3.
    const {a, b} = this.curve;

    // P = O
    if (this.isInfinity())
      return true;

    // Z1 = 1
    if (this.zOne)
      return this.curve.validate(this.toP());

    // y^2 = x^3 + a * x * z^4 + b * z^6
    const lhs = this.y.redSqr();
    const x3 = this.x.redSqr().redMul(this.x);
    const z2 = this.z.redSqr();
    const z4 = z2.redSqr();
    const z6 = z4.redMul(z2);
    const rhs = x3.redIAdd(b.redMul(z6));

    if (!this.curve.zeroA) {
      // Save some cycles for a = -3.
      if (this.curve.threeA)
        rhs.redIAdd(z4.redIMuln(-3).redMul(this.x));
      else
        rhs.redIAdd(a.redMul(z4).redMul(this.x));
    }

    return lhs.eq(rhs);
  }

  normalize() {
    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#scaling-z
    // 1I + 3M + 1S

    // Z = 1
    if (this.zOne)
      return this;

    // P = O
    if (this.isInfinity())
      return this;

    // A = 1 / Z1
    const a = this.z.redInvert();

    // AA = A^2
    const aa = a.redSqr();

    // X3 = X1 * AA
    this.x = this.x.redMul(aa);

    // Y3 = Y1 * AA * A
    this.y = this.y.redMul(aa).redMul(a);

    // Z3 = 1
    this.z = this.curve.one;
    this.zOne = true;

    return this;
  }

  scale(a) {
    assert(a instanceof BN);

    // P = O
    if (this.isInfinity())
      return this.curve.jpoint();

    // AA = A^2
    const aa = a.redSqr();

    // X3 = X1 * AA
    const nx = this.x.redMul(aa);

    // Y3 = Y1 * AA * A
    const ny = this.y.redMul(aa).redMul(a);

    // Z3 = Z1 * A
    const nz = this.z.redMul(a);

    return this.curve.jpoint(nx, ny, nz);
  }

  neg() {
    // -(X1, Y1, Z1) = (X1, -Y1, Z1)
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  }

  add(p) {
    assert(p instanceof Point);

    if (p.type === types.AFFINE)
      return this._mixedAdd(p);

    return this._add(p);
  }

  _add(p) {
    assert(p instanceof JPoint);

    // O + P = P
    if (this.isInfinity())
      return p;

    // P + O = P
    if (p.isInfinity())
      return this;

    // Z1 = 1
    if (this.zOne)
      return p._addJA(this);

    // Z2 = 1
    if (p.zOne)
      return this._addJA(p);

    return this._addJJ(p);
  }

  _mixedAdd(p) {
    assert(p instanceof ShortPoint);

    // O + P = P
    if (this.isInfinity())
      return p.toJ();

    // P + O = P
    if (p.isInfinity())
      return this;

    return this._addJA(p);
  }

  _addJJ(p) {
    // No assumptions.
    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#addition-add-1998-cmo-2
    // 12M + 4S + 6A + 1*2 (implemented as: 12M + 4S + 7A)

    // Z1Z1 = Z1^2
    const z1z1 = this.z.redSqr();

    // Z2Z2 = Z2^2
    const z2z2 = p.z.redSqr();

    // U1 = X1 * Z2Z2
    const u1 = this.x.redMul(z2z2);

    // U2 = X2 * Z1Z1
    const u2 = p.x.redMul(z1z1);

    // S1 = Y1 * Z2 * Z2Z2
    const s1 = this.y.redMul(p.z).redMul(z2z2);

    // S2 = Y2 * Z1 * Z1Z1
    const s2 = p.y.redMul(this.z).redMul(z1z1);

    // H = U2 - U1
    const h = u2.redISub(u1);

    // r = S2 - S1
    const r = s2.redISub(s1);

    // H = 0
    if (h.isZero()) {
      if (!r.isZero())
        return this.curve.jpoint();

      return this.dbl();
    }

    // HH = H^2
    const hh = h.redSqr();

    // HHH = H * HH
    const hhh = h.redMul(hh);

    // V = U1 * HH
    const v = u1.redMul(hh);

    // X3 = r^2 - HHH - 2 * V
    const nx = r.redSqr().redISub(hhh).redISub(v).redISub(v);

    // Y3 = r * (V - X3) - S1 * HHH
    const ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(hhh));

    // Z3 = Z1 * Z2 * H
    const nz = this.z.redMul(p.z).redMul(h);

    return this.curve.jpoint(nx, ny, nz);
  }

  _addJA(p) {
    // Assumes Z2 = 1.
    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#addition-madd
    // 8M + 3S + 6A + 5*2 (implemented as: 8M + 3S + 7A + 4*2)

    // Z1Z1 = Z1^2
    const z1z1 = this.z.redSqr();

    // U2 = X2 * Z1Z1
    const u2 = p.x.redMul(z1z1);

    // S2 = Y2 * Z1 * Z1Z1
    const s2 = p.y.redMul(this.z).redMul(z1z1);

    // H = U2 - X1
    const h = u2.redISub(this.x);

    // r = 2 * (S2 - Y1)
    const r = s2.redISub(this.y).redIMuln(2);

    // H = 0
    if (h.isZero()) {
      if (!r.isZero())
        return this.curve.jpoint();

      return this.dbl();
    }

    // I = (2 * H)^2
    const i = h.redMuln(2).redSqr();

    // J = H * I
    const j = h.redMul(i);

    // V = X1 * I
    const v = this.x.redMul(i);

    // X3 = r^2 - J - 2 * V
    const nx = r.redSqr().redISub(j).redISub(v).redISub(v);

    // Y3 = r * (V - X3) - 2 * Y1 * J
    const ny = r.redMul(v.redISub(nx)).redISub(this.y.redMul(j).redIMuln(2));

    // Z3 = 2 * Z1 * H
    const nz = this.z.redMul(h).redIMuln(2);

    return this.curve.jpoint(nx, ny, nz);
  }

  dbl() {
    // P = O
    if (this.isInfinity())
      return this;

    // Y1 = 0
    if (this.y.isZero())
      return this.curve.jpoint();

    // a = 0
    if (this.curve.zeroA)
      return this._dbl0();

    // a = -3
    if (this.curve.threeA)
      return this._dbl3();

    return this._dblJ();
  }

  _dblJ() {
    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#doubling-dbl-1998-cmo-2
    // 3M + 6S + 4A + 1*a + 2*2 + 1*3 + 1*4 + 1*8
    // (implemented as: 3M + 6S + 5A + 1*a + 1*2 + 1*3 + 1*4 + 1*8)

    // XX = X1^2
    const xx = this.x.redSqr();

    // YY = Y1^2
    const yy = this.y.redSqr();

    // ZZ = Z1^2
    const zz = this.z.redSqr();

    // S = 4 * X1 * YY
    const s = this.x.redMul(yy).redIMuln(4);

    // M = 3 * XX + a * ZZ^2
    const m = xx.redIMuln(3).redIAdd(this.curve.a.redMul(zz.redSqr()));

    // T = M^2 - 2 * S
    const t = m.redSqr().redISub(s).redISub(s);

    // X3 = T
    const nx = t;

    // Y3 = M * (S - T) - 8 * YY^2
    const ny = m.redMul(s.redISub(t)).redISub(yy.redSqr().redIMuln(8));

    // Z3 = 2 * Y1 * Z1
    const nz = this.y.redMul(this.z).redIMuln(2);

    return this.curve.jpoint(nx, ny, nz);
  }

  _dbl0() {
    // Assumes a = 0.
    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l
    // 2M + 5S + 6A + 3*2 + 1*3 + 1*8
    // (implemented as: 2M + 5S + 7A + 2*2 + 1*3 + 1*8)

    // A = X1^2
    const a = this.x.redSqr();

    // B = Y1^2
    const b = this.y.redSqr();

    // C = B^2
    const c = b.redSqr();

    // + XB2 = (X1 + B)^2
    const xb2 = b.redIAdd(this.x).redSqr();

    // D = 2 * ((X1 + B)^2 - A - C)
    const d = xb2.redISub(a).redISub(c).redIMuln(2);

    // E = 3 * A
    const e = a.redIMuln(3);

    // F = E^2
    const f = e.redSqr();

    // X3 = F - 2 * D
    const nx = f.redISub(d).redISub(d);

    // Y3 = E * (D - X3) - 8 * C
    const ny = e.redMul(d.redISub(nx)).redISub(c.redIMuln(8));

    // Z3 = 2 * Y1 * Z1
    const nz = this.y.redMul(this.z).redIMuln(2);

    return this.curve.jpoint(nx, ny, nz);
  }

  _dbl3() {
    // Assumes a = -3.
    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S + 8A + 1*3 + 1*4 + 2*8
    // (implemented as: 3M + 5S + 8A + 1*2 + 1*3 + 1*4 + 1*8)

    // delta = Z1^2
    const delta = this.z.redSqr();

    // gamma = Y1^2
    const gamma = this.y.redSqr();

    // beta = X1 * gamma
    const beta = this.x.redMul(gamma);

    // + xmdelta = X1 - delta
    const xmdelta = this.x.redSub(delta);

    // + xpdelta = X1 + delta
    const xpdelta = this.x.redAdd(delta);

    // alpha = 3 * (X1 - delta) * (X1 + delta)
    const alpha = xmdelta.redMul(xpdelta).redIMuln(3);

    // + beta4 = 4 * beta
    const beta4 = beta.redIMuln(4);

    // + beta8 = 2 * beta4
    const beta8 = beta4.redMuln(2);

    // + gamma28 = 8 * gamma^2
    const gamma28 = gamma.redSqr().redIMuln(8);

    // X3 = alpha^2 - 8 * beta
    const nx = alpha.redSqr().redISub(beta8);

    // Z3 = (Y1 + Z1)^2 - gamma - delta
    const nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);

    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    const ny = alpha.redMul(beta4.redISub(nx)).redISub(gamma28);

    return this.curve.jpoint(nx, ny, nz);
  }

  getX() {
    if (this.isInfinity())
      throw new Error('Invalid point.');

    this.normalize();

    return this.x.fromRed();
  }

  getY() {
    if (this.isInfinity())
      throw new Error('Invalid point.');

    this.normalize();

    return this.y.fromRed();
  }

  eq(p) {
    assert(p instanceof JPoint);

    // P = Q
    if (this === p)
      return true;

    // P = O
    if (this.isInfinity())
      return p.isInfinity();

    // Q = O
    if (p.isInfinity())
      return false;

    // Z1 = Z2
    if (this.z.eq(p.z)) {
      return this.x.eq(p.x)
          && this.y.eq(p.y);
    }

    // X1 * Z2^2 = X2 * Z1^2
    const zz1 = this.z.redSqr();
    const zz2 = p.z.redSqr();
    const x1 = this.x.redMul(zz2);
    const x2 = p.x.redMul(zz1);

    if (!x1.eq(x2))
      return false;

    // Y1 * Z2^3 = Y2 * Z1^3
    const zzz1 = zz1.redMul(this.z);
    const zzz2 = zz2.redMul(p.z);
    const y1 = this.y.redMul(zzz2);
    const y2 = p.y.redMul(zzz1);

    return y1.eq(y2);
  }

  cmp(point) {
    assert(point instanceof JPoint);

    const inf1 = this.isInfinity();
    const inf2 = point.isInfinity();

    if (inf1 && !inf2)
      return -1;

    if (!inf1 && inf2)
      return 1;

    if (inf1 && inf2)
      return 0;

    return this.order().cmp(point.order())
        || this.getX().cmp(point.getX())
        || this.getY().cmp(point.getY());
  }

  isInfinity() {
    // Z1 = 0
    return this.z.isZero();
  }

  isOrder2() {
    if (this.isInfinity())
      return false;

    return this.y.isZero();
  }

  isOdd() {
    if (this.isInfinity())
      return false;

    this.normalize();

    return this.y.redIsOdd();
  }

  isEven() {
    if (this.isInfinity())
      return false;

    this.normalize();

    return this.y.redIsEven();
  }

  isSquare() {
    if (this.isInfinity())
      return false;

    return this.y.redMul(this.z).redJacobi() !== -1;
  }

  eqX(x) {
    // Verify that integer `x` is equal to field
    // element `x` by scaling it by our z coordinate.
    // This optimization is mentioned in and used for
    // bip-schnorr[1]. This avoids having to affinize
    // the resulting point during verification.
    //
    // [1] [SCHNORR] "Optimizations".
    assert(x instanceof BN);
    assert(!x.red);

    if (this.isInfinity())
      return false;

    const zz = this.z.redSqr();
    const rx = x.toRed(this.curve.red).redMul(zz);

    return this.x.eq(rx);
  }

  eqR(x) {
    // Similar to the optimization above, this
    // optimization, suggested by Maxwell[1],
    // compares an integer to an X coordinate
    // by scaling it.
    //
    // Since a signature's R value is modulo N
    // in ECDSA, we may be dealing with an R
    // value greater than N in actuality.
    //
    // If the equality check fails, we can
    // scale N itself by Z and add it to the
    // X field element.
    //
    // [1] https://github.com/bitcoin-core/secp256k1/commit/ce7eb6f
    assert(x instanceof BN);
    assert(!x.red);

    if (!this.curve.smallGap)
      return this.toP().eqR(x);

    if (this.isInfinity())
      return false;

    if (x.cmp(this.curve.p) >= 0)
      return false;

    const zz = this.z.redSqr();
    const rx = x.toRed(this.curve.red).redMul(zz);

    if (this.x.eq(rx))
      return true;

    if (this.curve.highOrder)
      return false;

    if (x.cmp(this.curve.pmodn) >= 0)
      return false;

    const rn = this.curve.redN.redMul(zz);

    rx.redIAdd(rn);

    return this.x.eq(rx);
  }

  toP() {
    // P = O
    if (this.isInfinity())
      return this.curve.point();

    this.normalize();

    // (X3, Y3) = (X1 / Z1^2, Y1 / Z1^3)
    return this.curve.point(this.x, this.y);
  }

  toJ() {
    return this;
  }

  encode(compact) {
    return this.toP().encode(compact);
  }

  static decode(curve, bytes) {
    return ShortPoint.decode(curve, bytes).toJ();
  }

  encodeX() {
    return this.toP().encodeX();
  }

  static decodeEven(curve, bytes) {
    return ShortPoint.decodeEven(curve, bytes).toJ();
  }

  static decodeSquare(curve, bytes) {
    return ShortPoint.decodeSquare(curve, bytes).toJ();
  }

  toJSON(pre) {
    return this.toP().toJSON(pre);
  }

  toPretty() {
    return this.toP().toPretty();
  }

  static fromJSON(curve, json) {
    return ShortPoint.fromJSON(curve, json).toJ();
  }

  [custom]() {
    if (this.isInfinity())
      return '<JPoint: Infinity>';

    return '<JPoint:'
         + ' x=' + this.x.fromRed().toString(16, 2)
         + ' y=' + this.y.fromRed().toString(16, 2)
         + ' z=' + this.z.fromRed().toString(16, 2)
         + '>';
  }
}

/**
 * MontCurve
 */

class MontCurve extends Curve {
  constructor(conf) {
    super(MontPoint, 'mont', conf);

    this.a = BN.fromJSON(conf.a).toRed(this.red);
    this.b = BN.fromJSON(conf.b).toRed(this.red);

    this.bi = this.b.redInvert();
    this.a2 = this.a.redAdd(this.two);
    this.a24 = this.a2.redMul(this.i4);
    this.a3 = this.a.redMul(this.i3);
    this.a0 = this.a.redMul(this.bi);
    this.b0 = this.bi.redSqr();

    this._finalize(conf);
  }

  static _isomorphism(curveA, curveB, customB) {
    // Montgomery Isomorphism.
    //
    // [MONT3] Page 3, Section 2.1.
    //
    // Transformation:
    //
    //   A' = A
    //   B' = B'
    //
    // Where (B / B') is square.
    assert(curveA instanceof BN);
    assert(curveB instanceof BN);
    assert(customB instanceof BN);

    const a = curveA.clone();
    const b = customB.clone();
    const c = curveB.redDiv(customB);

    if (c.redJacobi() !== 1)
      throw new Error('Invalid `b` coefficient.');

    return [a, b];
  }

  _short(a0, odd) {
    // Montgomery->Short Weierstrass Equivalence.
    //
    // [MONT2] "Equivalence with Weierstrass curves".
    //
    // Transformation:
    //
    //   a = (3 - A^2) / (3 * B^2)
    //   b = (2 * A^3 - 9 * A) / (27 * B^3)
    const {a, b, three} = this;
    const a2 = a.redSqr();
    const a3 = a2.redMul(a);
    const b2 = b.redSqr();
    const b3 = b2.redMul(b);
    const n0 = three.redSub(a2);
    const d0 = b2.redMuln(3);
    const n1 = a3.redMuln(2).redISub(a.redMuln(9));
    const d1 = b3.redMuln(27);
    const wa = n0.redDiv(d0);
    const wb = n1.redDiv(d1);

    if (a0 != null)
      return ShortCurve._isomorphism(wa, wb, a0, odd);

    return [wa, wb];
  }

  _mont(b0) {
    return MontCurve._isomorphism(this.a, this.b, b0);
  }

  _edwards(a0, invert = false) {
    // Montgomery->Twisted Edwards Transformation.
    //
    // [MONT1] Page 11, Section 4.3.5.
    // [TWISTED] Theorem 3.2, Page 4, Section 3.
    //
    // Equivalence:
    //
    //   a = (A + 2) / B
    //   d = (A - 2) / B
    //
    // Isomorphism:
    //
    //   a = a'
    //   d = a' * (A - 2) / (A + 2)
    //
    // Where ((A + 2) / (B * a')) is square.
    //
    // If `d` is square, we can usually find
    // a complete curve by using the `invert`
    // option. This will create an isomorphism
    // chain of: M(A,B)->E(a,d)->E(d,a).
    //
    // The equivalence between E(a,d) and
    // E(d,a) is:
    //
    //   (x, y) = (x, 1 / y)
    //
    // Meaning our map to E(d,a) is:
    //
    //   x = u / v
    //   y = 1 / ((u - 1) / (u + 1))
    //     = (u + 1) / (u - 1)
    assert(typeof invert === 'boolean');

    const {two, bi} = this;
    const a = this.a.redAdd(two).redMul(bi);
    const d = this.a.redSub(two).redMul(bi);

    if (invert)
      a.swap(d);

    if (a0 != null)
      return EdwardsCurve._isomorphism(a, d, a0);

    return [a, d];
  }

  _scaleShort(curve) {
    assert(curve instanceof ShortCurve);

    const [u2, u3] = curve._scale(this);

    return [this.field(u2.redInvert()),
            this.field(u3.redInvert())];
  }

  _scaleMont(curve) {
    // We can extract the isomorphism factor with:
    //
    //   c = +-sqrt(B / B')
    //
    // If base points are available, we can do:
    //
    //   c = v' / v
    assert(curve instanceof MontCurve);

    if (this.g.isInfinity() || curve.g.isInfinity())
      return this.field(curve.b).redDivSqrt(this.b);

    return this.g.y.redDiv(this.field(curve.g.y));
  }

  _scaleEdwards(curve, invert) {
    // We _could_ do something like:
    //
    //   B = 4 / (a - d)
    //   c = +-sqrt(B / B')
    //
    // Which can be reduced to:
    //
    //   c = +-sqrt(4 / ((a - d) * B'))
    //
    // If base points are available:
    //
    //   v = u' / x
    //   c = v' / v
    //
    // Which can be reduced to:
    //
    //   c = v' * x / u'
    //
    // However, the way our maps are
    // written, we can re-use the Edwards
    // isomorphism factor when going the
    // other direction.
    assert(curve instanceof EdwardsCurve);

    const c = curve._scale(this, invert);

    return this.field(c);
  }

  _solveY0(x) {
    assert(x instanceof BN);

    // y^2 = x^3 + A * x^2 + B * x
    const a = this.a0;
    const b = this.b0;
    const x2 = x.redSqr();
    const x3 = x2.redMul(x);
    const y2 = x3.redIAdd(a.redMul(x2)).redIAdd(b.redMul(x));

    return y2;
  }

  _elligator2(u) {
    // Elligator 2.
    //
    // Distribution: 1/2.
    //
    // [ELL2] Page 11, Section 5.2.
    // [H2EC] "Elligator 2 Method".
    //        "Mappings for Montgomery curves".
    // [SAFE] "Indistinguishability from uniform random strings".
    //
    // Assumptions:
    //
    //   - y^2 = x^3 + A * x^2 + B * x.
    //   - A != 0, B != 0.
    //   - A^2 - 4 * B is non-zero and non-square in F(p).
    //   - Let z be a non-square in F(p).
    //   - u != +-sqrt(-1 / z).
    //
    // Note that Elligator 2 is defined over the form:
    //
    //   y'^2 = x'^3 + A' * x'^2 + B' * x'
    //
    // Instead of:
    //
    //   B * y^2 = x^3 + A * x^2 + x
    //
    // Where:
    //
    //   A' = A / B
    //   B' = 1 / B^2
    //   x' = x / B
    //   y' = y / B
    //
    // And:
    //
    //   x = B * x'
    //   y = B * y'
    //
    // This is presumably the result of Elligator 2
    // being designed in long Weierstrass form. If
    // we want to support B != 1, we need to do the
    // conversion.
    //
    // Map:
    //
    //   g(x) = x^3 + A * x^2 + B * x
    //   x1 = -A / (1 + z * u^2)
    //   x1 = -A, if x1 = 0
    //   x2 = -x1 - A
    //   x = x1, if g(x1) is square
    //     = x2, otherwise
    //   y = sign(u) * abs(sqrt(g(x)))
    const lhs = this.a0.redNeg();
    const rhs = this.one.redAdd(this.z.redMul(u.redSqr()));

    if (rhs.isZero())
      rhs.inject(this.one);

    const x1 = lhs.redMul(rhs.redInvert());
    const x2 = x1.redNeg().redISub(this.a0);
    const y1 = this._solveY0(x1);
    const y2 = this._solveY0(x2);
    const alpha = y1.redIsSquare() | 0;
    const x0 = [x1, x2][alpha ^ 1];
    const y0 = [y1, y2][alpha ^ 1].redSqrt();

    if (y0.redIsOdd() !== u.redIsOdd())
      y0.redINeg();

    const x = this.b.redMul(x0);
    const y = this.b.redMul(y0);

    return this.point(x, y);
  }

  _invert2(p, hint) {
    // Inverting the Map (Elligator 2).
    //
    // [ELL2] Page 12, Section 5.3.
    //
    // Assumptions:
    //
    //   - -z * x * (x + A) is square in F(p).
    //   - If r = 1 then x != 0.
    //   - If r = 2 then x != -A.
    //
    // Map:
    //
    //   u1 = -(x + A) / (x * z)
    //   u2 = -x / ((x + A) * z)
    //   r = random integer in [1,2]
    //   u = sign(y) * abs(sqrt(ur))
    //
    // Note that `0 / 0` can only occur if A = 0
    // (this violates the assumptions of Elligator 2).
    const {x, y} = p;
    const r = hint & 1;
    const x0 = x.redMul(this.bi);
    const y0 = y.redMul(this.bi);
    const n = x0.redAdd(this.a0);
    const d = x0;
    const lhs = [n, d][r].redINeg();
    const rhs = [d, n][r].redMul(this.z);
    const u = lhs.redDivSqrt(rhs);

    if (u.redIsOdd() !== y0.redIsOdd())
      u.redINeg();

    return u;
  }

  isElliptic() {
    const a2 = this.a.redSqr();
    const d = this.b.redMul(a2.redSub(this.four));

    // B * (A^2 - 4) != 0
    return !d.isZero();
  }

  jinv() {
    // [MONT3] Page 3, Section 2.
    const {a, three, four} = this;
    const a2 = a.redSqr();
    const t0 = a2.redSub(three);
    const lhs = t0.redPown(3).redIMuln(256);
    const rhs = a2.redSub(four);

    if (rhs.isZero())
      throw new Error('Curve is not elliptic.');

    // (256 * (A^2 - 3)^3) / (A^2 - 4)
    return lhs.redDiv(rhs).fromRed();
  }

  point(x, y) {
    return new MontPoint(this, x, y);
  }

  jpoint(x, y, z) {
    assert(x == null && y == null && z == null);
    return this.point();
  }

  xpoint(x, z) {
    return new XPoint(this, x, z);
  }

  solveY2(x) {
    // [MONT3] Page 3, Section 2.
    // https://hyperelliptic.org/EFD/g1p/auto-montgom.html
    assert(x instanceof BN);

    // B * y^2 = x^3 + A * x^2 + x
    const x2 = x.redSqr();
    const x3 = x2.redMul(x);
    const by2 = x3.redIAdd(this.a.redMul(x2)).redIAdd(x);
    const y2 = by2.redMul(this.bi);

    return y2;
  }

  validate(point) {
    assert(point instanceof MontPoint);

    if (point.isInfinity())
      return true;

    const {x, y} = point;
    const y2 = this.solveY2(x);

    return y.redSqr().eq(y2);
  }

  pointFromX(x, sign = null) {
    assert(x instanceof BN);
    assert(sign == null || typeof sign === 'boolean');

    if (!x.red)
      x = x.toRed(this.red);

    const y = this.solveY(x);

    if (sign != null) {
      if (y.isZero() && sign)
        throw new Error('Invalid point.');

      if (y.redIsOdd() !== sign)
        y.redINeg();
    }

    return this.point(x, y);
  }

  isIsomorphic(curve, invert) {
    // [MONT3] Page 3, Section 2.1.
    assert(curve instanceof Curve);

    if (!curve.p.eq(this.p))
      return false;

    // M(A,B) <-> M(A,B')
    if (curve.type === 'mont') {
      const a = this.field(curve.a);
      const b = this.field(curve.b);

      // A' = A
      if (!this.a.eq(a))
        return false;

      // B' != 0
      if (this.b.isZero())
        return false;

      // jacobi(B / B') = 1
      const c = b.redDiv(this.b);

      return c.redJacobi() === 1;
    }

    return curve.isIsomorphic(this, invert);
  }

  isIsogenous(curve) {
    assert(curve instanceof Curve);

    if (curve.type === 'mont')
      return false;

    return curve.isIsogenous(this);
  }

  pointFromShort(point) {
    // [ALT] Appendix E.2 (Switching between Alternative Representations).
    // [MONT2] "Equivalence with Weierstrass curves"
    assert(point instanceof ShortPoint);

    if (this.isIsomorphic(point.curve)) {
      // Equivalence for E(a,b)->M(A,B):
      //
      //   u = B * x - A / 3
      //   v = B * y
      //
      // Undefined if ((u^3 + A * u^2 + u) / B) is not square.
      if (point.isInfinity())
        return this.point();

      const {a3, b} = this;
      const [u2, u3] = this._scale(point.curve);
      const x = this.field(point.x).redMul(u2);
      const y = this.field(point.y).redMul(u3);
      const u = b.redMul(x).redISub(a3);
      const v = b.redMul(y);

      return this.point(u, v);
    }

    throw new Error('Not implemented.');
  }

  pointFromMont(point) {
    // [MONT3] Page 3, Section 2.1.
    assert(point instanceof MontPoint);

    if (this.isIsomorphic(point.curve)) {
      // Isomorphic maps for M(A,B)<->M(A,B'):
      //
      //   u' = u
      //   v' = +-sqrt(B / B') * v
      //
      // Undefined if (B / B') is not square.
      if (point.isInfinity())
        return this.point();

      const c = this._scale(point.curve);
      const u = this.field(point.x);
      const v = this.field(point.y);
      const nu = u;
      const nv = c.redMul(v);

      return this.point(nu, nv);
    }

    throw new Error('Not implemented.');
  }

  pointFromEdwards(point) {
    // [RFC7748] Section 4.1 & 4.2.
    // [MONT3] Page 6, Section 2.5.
    // [TWISTED] Theorem 3.2, Page 4, Section 3.
    assert(point instanceof EdwardsPoint);
    assert(point.curve.p.eq(this.p));

    // Edwards `x`, `y`, `z`.
    const x = this.field(point.x);
    const y = this.field(point.y);
    const z = this.field(point.z);

    if (this.isIsogenous(point.curve)) {
      // 4-isogeny maps for E(1,d)->M(2-4d,1):
      //
      //   u = y^2 / x^2
      //   v = (2 - x^2 - y^2) * y / x^3
      //
      // Undefined for x = 0.
      //
      // Exceptional Cases:
      //   - (0, 1) -> O
      //   - (0, -1) -> (0, 0)
      //
      // Unexceptional Cases:
      //   - (+-1, 0) -> (0, 0)
      if (point.isInfinity())
        return this.point();

      if (point.x.isZero())
        return this.point(this.zero, this.zero);

      const c = z.redSqr().redIMuln(2);
      const uu = y.redSqr();
      const uz = x.redSqr();
      const vv = c.redISub(uz).redISub(uu).redMul(y);
      const vz = uz.redMul(x);

      return this.cpoint(uu, uz, vv, vz);
    }

    if (this.isIsomorphic(point.curve, true)) {
      // Isomorphic maps for E(d,a)->M(A,B):
      //
      //   u = (y + 1) / (y - 1)
      //   v = +-sqrt((A - 2) / (B * a)) * u / x
      //
      // Undefined for x = 0 or y = 1.
      //
      // Exceptional Cases:
      //   - (0, 1) -> O
      //   - (0, -1) -> (0, 0)
      //
      // Unexceptional Cases:
      //   - (+-sqrt(1 / a), 0) -> (-1, +-sqrt((A - 2) / B))
      if (point.isInfinity())
        return this.point();

      if (point.x.isZero())
        return this.point(this.zero, this.zero);

      const c = this._scale(point.curve, true);
      const uu = y.redAdd(z);
      const uz = y.redSub(z);
      const vv = c.redMul(z).redMul(uu);
      const vz = x.redMul(uz);

      return this.cpoint(uu, uz, vv, vz);
    }

    if (this.isIsomorphic(point.curve, false)) {
      // Isomorphic maps for E(a,d)->M(A,B):
      //
      //   u = (1 + y) / (1 - y)
      //   v = +-sqrt((A + 2) / (B * a)) * u / x
      //
      // Undefined for x = 0 or y = 1.
      //
      // Exceptional Cases:
      //   - (0, 1) -> O
      //   - (0, -1) -> (0, 0)
      //
      // Unexceptional Cases:
      //   - (+-sqrt(1 / a), 0) -> (1, +-sqrt((A + 2) / B))
      if (point.isInfinity())
        return this.point();

      if (point.x.isZero())
        return this.point(this.zero, this.zero);

      const c = this._scale(point.curve, false);
      const uu = z.redAdd(y);
      const uz = z.redSub(y);
      const vv = c.redMul(z).redMul(uu);
      const vz = x.redMul(uz);

      return this.cpoint(uu, uz, vv, vz);
    }

    throw new Error('Not implemented.');
  }

  pointFromUniform(u) {
    assert(u instanceof BN);

    // z = 0 or A = 0
    if (this.z.isZero() || this.a.isZero())
      throw new Error('Not implemented.');

    return this._elligator2(u);
  }

  pointToUniform(p, hint) {
    // Convert a montgomery point to a field
    // element by inverting the elligator2 map.
    //
    // Hint Layout:
    //
    //   [00000000] [0000] [0000]
    //        |        |      |
    //        |        |      +-- preimage index
    //        |        +--- subgroup
    //        +-- bits to OR with uniform bytes
    assert(p instanceof MontPoint);
    assert((hint >>> 0) === hint);

    // z = 0 or A = 0
    if (this.z.isZero() || this.a.isZero())
      throw new Error('Not implemented.');

    // P = O
    if (p.isInfinity())
      throw new Error('Invalid point.');

    // Add a random torsion component.
    const i = ((hint >>> 4) & 15) % this.torsion.length;
    const q = p.add(this.torsion[i]);

    return wrapErrors(() => {
      return this._invert2(q, hint);
    });
  }

  decodePoint(bytes, sign) {
    return MontPoint.decode(this, bytes, sign);
  }

  encodeX(point) {
    assert(point instanceof XPoint);
    return point.encode();
  }

  decodeX(bytes) {
    return XPoint.decode(this, bytes);
  }

  toShort(a0, odd, sign = null) {
    const [a, b] = this._short(a0, odd);

    const curve = new ShortCurve({
      red: this.red,
      prime: this.prime,
      p: this.p,
      a: a,
      b: b,
      n: this.n,
      h: this.h
    });

    if (sign != null) {
      const [, u3] = curve._scale(this);

      if (u3.redIsOdd() !== sign)
        u3.redINeg();
    }

    if (!this.g.isInfinity())
      curve.g = curve.pointFromMont(this.g);

    for (let i = 0; i < this.h.word(0); i++)
      curve.torsion[i] = curve.pointFromMont(this.torsion[i]);

    return curve;
  }

  toMont(b0, sign = null) {
    const [a, b] = this._mont(b0);

    const curve = new MontCurve({
      red: this.red,
      prime: this.prime,
      p: this.p,
      a: a,
      b: b,
      n: this.n,
      h: this.h,
      z: this.z
    });

    if (sign != null) {
      const c = curve._scale(this);

      if (c.redIsOdd() !== sign)
        c.redINeg();
    }

    if (!this.g.isInfinity())
      curve.g = curve.pointFromMont(this.g);

    for (let i = 0; i < this.h.word(0); i++)
      curve.torsion[i] = curve.pointFromMont(this.torsion[i]);

    return curve;
  }

  toEdwards(a0, invert, sign = null) {
    const [a, d] = this._edwards(a0, invert);

    const curve = new EdwardsCurve({
      red: this.red,
      prime: this.prime,
      p: this.p,
      a: a,
      d: d,
      n: this.n,
      h: this.h,
      z: this.z
    });

    if (sign != null) {
      const c = curve._scale(this, invert);

      if (c.redIsOdd() !== sign)
        c.redINeg();
    }

    if (!this.g.isInfinity()) {
      curve.g = curve.pointFromMont(this.g);
      curve.g.normalize();
    }

    if (curve.isComplete()) {
      for (let i = 0; i < this.h.word(0); i++) {
        curve.torsion[i] = curve.pointFromMont(this.torsion[i]);
        curve.torsion[i].normalize();
      }
    }

    return curve;
  }

  pointFromJSON(json) {
    return MontPoint.fromJSON(this, json);
  }

  toJSON(pre) {
    const json = super.toJSON(pre);
    json.a = this.a.fromRed().toJSON();
    json.b = this.b.fromRed().toJSON();
    return json;
  }
}

/**
 * MontPoint
 */

class MontPoint extends Point {
  constructor(curve, x, y) {
    assert(curve instanceof MontCurve);

    super(curve, types.AFFINE);

    this.x = this.curve.zero;
    this.y = this.curve.zero;
    this.inf = true;

    if (x != null)
      this._init(x, y);
  }

  _init(x, y) {
    assert(x instanceof BN);
    assert(y instanceof BN);

    this.x = x;
    this.y = y;

    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);

    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);

    this.inf = false;
  }

  clone() {
    if (this.inf)
      return this.curve.point();

    return this.curve.point(this.x, this.y);
  }

  scale(a) {
    return this.clone();
  }

  randomize(rng) {
    return this.clone();
  }

  neg() {
    // P = O
    if (this.inf)
      return this;

    // -(X1, Y1) = (X1, -Y1)
    return this.curve.point(this.x, this.y.redNeg());
  }

  add(p) {
    // [MONT1] Page 8, Section 4.3.2.
    //
    // Addition Law:
    //
    //   l = (y2 - y1) / (x2 - x1)
    //   x3 = b * l^2 - a - x1 - x2
    //   y3 = l * (x1 - x3) - y1
    //
    // 1I + 2M + 1S + 7A + 1*b
    assert(p instanceof MontPoint);

    // O + P = P
    if (this.inf)
      return p;

    // P + O = P
    if (p.inf)
      return this;

    // P + P, P + -P
    if (this.x.eq(p.x)) {
      // P + -P = O
      if (!this.y.eq(p.y))
        return this.curve.point();

      // P + P = 2P
      return this.dbl();
    }

    // H = X2 - X1
    const h = p.x.redSub(this.x);

    // R = Y2 - Y1
    const r = p.y.redSub(this.y);

    // L = R / H
    const l = r.redDiv(h);

    // K = b * L^2
    const k = this.curve.b.redMul(l.redSqr());

    // X3 = K - a - X1 - X2
    const nx = k.redISub(this.curve.a).redISub(this.x).redISub(p.x);

    // Y3 = L * (X1 - X3) - Y1
    const ny = l.redMul(this.x.redSub(nx)).redISub(this.y);

    return this.curve.point(nx, ny);
  }

  dbl() {
    // [MONT1] Page 8, Section 4.3.2.
    //
    // Addition Law (doubling):
    //
    //   l = (3 * x1^2 + 2 * a * x1 + 1) / (2 * b * y1)
    //   x3 = b * l^2 - a - 2 * x1
    //   y3 = l * (x1 - x3) - y1
    //
    // 1I + 3M + 2S + 7A + 1*a + 1*b + 1*b + 2*2 + 1*3

    // P = O
    if (this.inf)
      return this;

    // Y1 = 0
    if (this.y.isZero())
      return this.curve.point();

    // M1 = 3 * X1^2
    const m1 = this.x.redSqr().redIMuln(3);

    // M2 = 2 * a * X1
    const m2 = this.curve.a.redMul(this.x).redIMuln(2);

    // M = M1 + M2 + 1
    const m = m1.redIAdd(m2).redIAdd(this.curve.one);

    // Z = 2 * b * Y1
    const z = this.curve.b.redMul(this.y).redIMuln(2);

    // L = M / Z
    const l = m.redDiv(z);

    // K = b * L^2
    const k = this.curve.b.redMul(l.redSqr());

    // X3 = K - a - 2 * X1
    const nx = k.redISub(this.curve.a).redISub(this.x).redISub(this.x);

    // Y3 = L * (X1 - X3) - Y1
    const ny = l.redMul(this.x.redSub(nx)).redISub(this.y);

    return this.curve.point(nx, ny);
  }

  getX() {
    if (this.inf)
      throw new Error('Invalid point.');

    return this.x.fromRed();
  }

  getY() {
    if (this.inf)
      throw new Error('Invalid point.');

    return this.y.fromRed();
  }

  eq(p) {
    assert(p instanceof MontPoint);

    // P = Q
    if (this === p)
      return true;

    // P = O
    if (this.inf)
      return p.inf;

    // Q = O
    if (p.inf)
      return false;

    // X1 = X2, Y1 = Y2
    return this.x.eq(p.x)
        && this.y.eq(p.y);
  }

  cmp(point) {
    assert(point instanceof MontPoint);

    if (this.inf && !point.inf)
      return -1;

    if (!this.inf && point.inf)
      return 1;

    if (this.inf && point.inf)
      return 0;

    return this.order().cmp(point.order())
        || this.getX().cmp(point.getX())
        || this.getY().cmp(point.getY());
  }

  isInfinity() {
    // Infinity cannot be represented in
    // the affine space, except by a flag.
    return this.inf;
  }

  isOrder2() {
    if (this.inf)
      return false;

    return this.y.isZero();
  }

  isOdd() {
    if (this.inf)
      return false;

    return this.y.redIsOdd();
  }

  isEven() {
    if (this.inf)
      return false;

    return this.y.redIsEven();
  }

  toP() {
    return this;
  }

  toJ() {
    return this;
  }

  toX() {
    // (X3, Z3) = (1, 0)
    if (this.inf)
      return this.curve.xpoint();

    // (X3, Z3) = (X1, 1)
    return this.curve.xpoint(this.x, this.curve.one);
  }

  encode() {
    return this.toX().encode();
  }

  static decode(curve, bytes, sign) {
    assert(curve instanceof MontCurve);
    return curve.decodeX(bytes).toP(sign);
  }

  toJSON(pre) {
    if (this.inf)
      return [];

    const x = this.getX().toJSON();
    const y = this.getY().toJSON();

    return [x, y];
  }

  toPretty() {
    if (this.inf)
      return [];

    const size = this.curve.fieldSize * 2;
    const x = toPretty(this.getX(), size);
    const y = toPretty(this.getY(), size);

    return [x, y];
  }

  static fromJSON(curve, json) {
    assert(curve instanceof MontCurve);
    assert(Array.isArray(json));
    assert(json.length === 0
        || json.length === 2
        || json.length === 3);

    if (json.length === 0)
      return curve.point();

    const x = BN.fromJSON(json[0]);
    const y = BN.fromJSON(json[1]);

    return curve.point(x, y);
  }

  [custom]() {
    if (this.inf)
      return '<MontPoint: Infinity>';

    return '<MontPoint:'
         + ' x=' + this.x.fromRed().toString(16, 2)
         + ' y=' + this.y.fromRed().toString(16, 2)
         + '>';
  }
}

/**
 * XPoint
 */

class XPoint extends Point {
  constructor(curve, x, z) {
    assert(curve instanceof MontCurve);

    super(curve, types.PROJECTIVE);

    this.x = this.curve.one;
    this.z = this.curve.zero;

    if (x != null)
      this._init(x, z);
  }

  _init(x, z) {
    assert(x instanceof BN);
    assert(z == null || (z instanceof BN));

    this.x = x;
    this.z = z || this.curve.one;

    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);

    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }

  clone() {
    return this.curve.xpoint(this.x, this.z);
  }

  precompute(power, rng) {
    // No-op.
    return this;
  }

  validate() {
    if (this.isInfinity())
      return true;

    // B * y^2 * z = x^3 + A * x^2 * z + x * z^2
    const {x, z} = this;
    const x2 = x.redSqr();
    const x3 = x2.redMul(x);
    const z2 = z.redSqr();
    const ax2 = this.curve.a.redMul(x2).redMul(z);
    const by2 = x3.redIAdd(ax2).redIAdd(x.redMul(z2));
    const y2 = by2.redMul(this.curve.bi);

    // sqrt(y^2 * z^4) = y * z^2
    return y2.redMul(z).redJacobi() !== -1;
  }

  normalize() {
    // https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#scaling-scale
    // 1I + 1M

    // P = O
    if (this.isInfinity())
      return this;

    // Z1 = 1
    if (this.z.eq(this.curve.one))
      return this;

    // X3 = X1 / Z1
    this.x = this.x.redDiv(this.z);

    // Z3 = 1
    this.z = this.curve.one;

    return this;
  }

  scale(a) {
    assert(a instanceof BN);

    // P = O
    if (this.isInfinity())
      return this.curve.xpoint();

    // X3 = X1 * A
    const nx = this.x.redMul(a);

    // Y3 = Y1 * A
    const nz = this.z.redMul(a);

    return this.curve.xpoint(nx, nz);
  }

  neg() {
    // -(X1, Z1) = (X1, Z1)
    return this;
  }

  dbl() {
    // https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
    // 2M + 2S + 4A + 1*a24

    // A = X1 + Z1
    const a = this.x.redAdd(this.z);

    // AA = A^2
    const aa = a.redSqr();

    // B = X1 - Z1
    const b = this.x.redSub(this.z);

    // BB = B^2
    const bb = b.redSqr();

    // C = AA - BB
    const c = aa.redSub(bb);

    // X3 = AA * BB
    const nx = aa.redMul(bb);

    // Z3 = C * (BB + a24 * C)
    const nz = c.redMul(bb.redIAdd(this.curve.a24.redMul(c)));

    return this.curve.xpoint(nx, nz);
  }

  diffAddDbl(p2, p3) {
    // https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#ladder-ladd-1987-m-3
    // 6M + 4S + 8A + 1*a24
    assert(p2 instanceof XPoint);
    assert(p3 instanceof XPoint);

    // A = X2 + Z2
    const a = p2.x.redAdd(p2.z);

    // AA = A^2
    const aa = a.redSqr();

    // B = X2 - Z2
    const b = p2.x.redSub(p2.z);

    // BB = B^2
    const bb = b.redSqr();

    // E = AA - BB
    const e = aa.redSub(bb);

    // C = X3 + Z3
    const c = p3.x.redAdd(p3.z);

    // D = X3 - Z3
    const d = p3.x.redSub(p3.z);

    // DA = D * A
    const da = d.redMul(a);

    // CB = C * B
    const cb = c.redMul(b);

    // X5 = Z1 * (DA + CB)^2
    const x5 = this.z.redMul(da.redAdd(cb).redSqr());

    // Z5 = X1 * (DA - CB)^2
    const z5 = this.x.redMul(da.redISub(cb).redSqr());

    // X4 = AA * BB
    const x4 = aa.redMul(bb);

    // Z4 = E * (BB + a24 * E)
    const z4 = e.redMul(bb.redIAdd(this.curve.a24.redMul(e)));

    return [
      this.curve.xpoint(x4, z4),
      this.curve.xpoint(x5, z5)
    ];
  }

  getX() {
    if (this.isInfinity())
      throw new Error('Invalid point.');

    this.normalize();

    return this.x.fromRed();
  }

  getY(sign) {
    return this.toP(sign).getY();
  }

  eq(p) {
    assert(p instanceof XPoint);

    // P = Q
    if (this === p)
      return true;

    // P = O
    if (this.isInfinity())
      return p.isInfinity();

    // Q = O
    if (p.isInfinity())
      return false;

    // Z1 = Z2
    if (this.z.eq(p.z))
      return this.x.eq(p.x);

    // X1 * Z2 = X2 * Z1
    const x1 = this.x.redMul(p.z);
    const x2 = p.x.redMul(this.z);

    return x1.eq(x2);
  }

  cmp(point) {
    assert(point instanceof XPoint);

    const inf1 = this.isInfinity();
    const inf2 = point.isInfinity();

    if (inf1 && !inf2)
      return -1;

    if (!inf1 && inf2)
      return 1;

    if (inf1 && inf2)
      return 0;

    return this.order().cmp(point.order())
        || this.getX().cmp(point.getX());
  }

  isInfinity() {
    // Z1 = 0
    return this.z.isZero();
  }

  isOrder2() {
    if (this.isInfinity())
      return false;

    return this.x.isZero();
  }

  isOdd() {
    return false;
  }

  isEven() {
    return false;
  }

  hasTorsion() {
    if (this.isInfinity())
      return false;

    // X1 = 0, Z1 != 0 (edge case)
    if (this.x.isZero())
      return true;

    return super.hasTorsion();
  }

  order() {
    try {
      return this.toP().order();
    } catch (e) {
      return new BN(1);
    }
  }

  jmul(k) {
    // Multiply with the Montgomery Ladder.
    //
    // [MONT3] Algorithm 4, Page 12, Section 4.2.
    //
    // Note that any clamping is meant to
    // be done _outside_ of this function.
    assert(k instanceof BN);
    assert(!k.red);

    const bits = k.bitLength();

    let a = this.curve.xpoint();
    let b = this;

    for (let i = bits - 1; i >= 0; i--) {
      const bit = k.bit(i);

      if (bit === 0)
        [a, b] = this.diffAddDbl(a, b);
      else
        [b, a] = this.diffAddDbl(b, a);
    }

    return a;
  }

  jmulBlind(k, rng) {
    if (!rng)
      return this.jmul(k);

    // Randomize if available.
    return this.randomize(rng).jmul(k);
  }

  jmulAdd(k1, p2, k2) {
    throw new Error('Not implemented.');
  }

  toP(sign = null) {
    assert(sign == null || typeof sign === 'boolean');

    if (this.isInfinity())
      return this.curve.point();

    this.normalize();

    return this.curve.pointFromX(this.x, sign);
  }

  toJ() {
    return this;
  }

  toX() {
    return this;
  }

  key() {
    if (this.isInfinity())
      return `${this.curve.uid}:oo`;

    this.normalize();

    const x = this.getX().toString(16);

    return `${this.curve.uid}:${x}`;
  }

  encode() {
    // [RFC7748] Section 5.
    return this.curve.encodeField(this.getX());
  }

  static decode(curve, bytes) {
    assert(curve instanceof MontCurve);

    // [RFC7748] Section 5.
    const x = curve.decodeField(bytes);

    // We're supposed to ignore the hi bit
    // on montgomery points... I think. If
    // we don't, the X25519 test vectors
    // break, which is pretty convincing
    // evidence. This is a no-op for X448.
    x.iumaskn(curve.fieldBits);

    // Note: montgomery points are meant to be
    // reduced by the prime and do not have to
    // be explicitly validated in order to do
    // the montgomery ladder.
    const p = curve.xpoint(x, curve.one);

    assert(!p.isInfinity());

    return p;
  }

  toJSON(pre) {
    return this.toP().toJSON(pre);
  }

  toPretty() {
    return this.toP().toPretty();
  }

  static fromJSON(curve, json) {
    return MontPoint.fromJSON(curve, json).toX();
  }

  [custom]() {
    if (this.isInfinity())
      return '<XPoint: Infinity>';

    return '<XPoint:'
        + ' x=' + this.x.fromRed().toString(16, 2)
        + ' z=' + this.z.fromRed().toString(16, 2)
        + '>';
  }
}

/**
 * EdwardsCurve
 */

class EdwardsCurve extends Curve {
  constructor(conf) {
    super(EdwardsPoint, 'edwards', conf);

    this.a = BN.fromJSON(conf.a).toRed(this.red);
    this.d = BN.fromJSON(conf.d).toRed(this.red);
    this.s = BN.fromJSON(conf.s || '0').toRed(this.red);
    this.si = this.s.isZero() ? this.zero : this.s.redInvert();

    this.k = this.d.redMuln(2);
    this.smi = -this.d.redNeg().word(0);
    this.ad6 = this.a.redAdd(this.d).redMul(this.i6);

    this.twisted = !this.a.eq(this.one);
    this.oneA = this.a.eq(this.one);
    this.mOneA = this.a.eq(this.one.redNeg());
    this.smallD = this.prime != null && this.d.redNeg().length === 1;
    this.alt = null;

    this._finalize(conf);
  }

  static _isomorphism(curveA, curveD, customA) {
    // Twisted Edwards Isomorphism.
    //
    // [TWISTED] Definition 2.1, Page 3, Section 2.
    //
    // Transformation:
    //
    //   a' = a'
    //   d' = a' * d / a
    //
    // Where (a / a') is square.
    assert(curveA instanceof BN);
    assert(curveD instanceof BN);
    assert(customA instanceof BN);

    const a = customA.clone();
    const d = customA.redMul(curveD).redDiv(curveA);
    const c = curveA.redDiv(customA);

    if (c.redJacobi() !== 1)
      throw new Error('Invalid `a` coefficient.');

    return [a, d];
  }

  _short(a0, odd) {
    // Twisted Edwards->Short Weierstrass Equivalence.
    //
    // [TWISTEQ] Section 2.
    //
    // Transformation:
    //
    //   a' = -(a^2 + 14 * a * d + d^2) / 48
    //   b' = (33 * (a^2 * d + a * d^2) - a^3 - d^3) / 864
    const {a, d} = this;
    const a2 = a.redSqr();
    const a3 = a2.redMul(a);
    const d2 = d.redSqr();
    const d3 = d2.redMul(d);
    const ad14 = a.redMul(d).redIMuln(14);
    const a2d = a2.redMul(d);
    const ad2 = a.redMul(d2);
    const t0 = a2d.redIAdd(ad2).redIMuln(33);
    const wa = a2.redAdd(ad14).redIAdd(d2).redDivn(-48);
    const wb = t0.redISub(a3).redISub(d3).redDivn(864);

    if (a0 != null)
      return ShortCurve._isomorphism(wa, wb, a0, odd);

    return [wa, wb];
  }

  _mont(b0, invert = false) {
    // Twisted Edwards->Montgomery Transformation.
    //
    // [TWISTED] Theorem 3.2, Page 4, Section 3.
    //
    // Equivalence:
    //
    //   A = 2 * (a + d) / (a - d)
    //   B = 4 / (a - d)
    //
    // Isomorphism:
    //
    //   A = 2 * (a + d) / (a - d)
    //   B = B'
    //
    // Where ((4 / (a - d)) / B') is square.
    //
    // If `4 / (a - d)` is non-square, we can
    // usually force B=1 by using the `invert`
    // option. This will create an isomorphism
    // chain of: E(a,d)->E(d,a)->M(-A,-B).
    //
    // The equivalence between E(a,d) and E(d,a)
    // is:
    //
    //   (x, y) = (x, 1 / y)
    //
    // Meaning our map to M(-A,-B) is:
    //
    //   u = (1 + 1 / y) / (1 - 1 / y)
    //     = (y + 1) / (y - 1)
    //   v = u / x
    assert(typeof invert === 'boolean');

    let apd, amd;

    if (invert) {
      apd = this.d.redAdd(this.a);
      amd = this.d.redSub(this.a);
    } else {
      apd = this.a.redAdd(this.d);
      amd = this.a.redSub(this.d);
    }

    const z = amd.redInvert();
    const a = apd.redMuln(2).redMul(z);
    const b = z.redMuln(4);

    if (b0 != null)
      return MontCurve._isomorphism(a, b, b0);

    return [a, b];
  }

  _edwards(a0) {
    return EdwardsCurve._isomorphism(this.a, this.d, a0);
  }

  _scaleShort(curve) {
    assert(curve instanceof ShortCurve);

    const [u2, u3] = curve._scale(this);

    return [this.field(u2.redInvert()),
            this.field(u3.redInvert())];
  }

  _scaleMont(curve, invert = false) {
    // Calculate isomorphism factor between
    // Twisted Edwards and Montgomery with:
    //
    //   a = (A + 2) / B
    //   c = +-sqrt(a / a')
    //
    // Which can be reduced to:
    //
    //   c = +-sqrt((A + 2) / (B * a'))
    //
    // If base points are available, we can do:
    //
    //   x = u / v
    //   c = x' / x
    //
    // Which can be reduced to:
    //
    //   c = v * x' / u
    //
    // We can now calculate the Edwards `x` with:
    //
    //   x' = c * u / v
    //
    // And likewise, the Montgomery `v`:
    //
    //   v = c * u / x'
    assert(curve instanceof MontCurve);
    assert(typeof invert === 'boolean');

    if (this.g.isInfinity() || curve.g.isInfinity()) {
      const [a] = curve._edwards(null, invert);

      return this.field(a).redDivSqrt(this.a);
    }

    const x = curve.g.x.redDiv(curve.g.y);

    return this.g.x.redDiv(this.field(x));
  }

  _scaleEdwards(curve) {
    // We can extract the isomorphism factor with:
    //
    //   c = +-sqrt(a / a')
    //
    // If base points are available, we can do:
    //
    //   c = x' / x
    assert(curve instanceof EdwardsCurve);

    if (this.g.isInfinity() || curve.g.isInfinity())
      return this.field(curve.a).redDivSqrt(this.a);

    return this.g.x.redDiv(this.field(curve.g.x));
  }

  _mulA(num) {
    assert(num instanceof BN);

    // n * a = n
    if (this.oneA)
      return num.clone();

    // n * a = -n
    if (this.mOneA)
      return num.redNeg();

    return this.a.redMul(num);
  }

  _mulD(num) {
    assert(num instanceof BN);

    // -d < 0x4000000
    if (this.smallD)
      return num.redMuln(this.smi);

    return this.d.redMul(num);
  }

  _elligator1(t) {
    // Elligator 1.
    //
    // Distribution: 1/2.
    //
    // [ELL1] Page 6, Section 3.
    //        Page 15, Appendix A.
    // [ELL2] Page 7, Section 3.2.
    //
    // Assumptions:
    //
    //   - Let p be a prime power congruent to 3 mod 4.
    //   - Let s be a nonzero element of F(p).
    //   - Let c = 2 / s^2.
    //   - Let r = c + 1 / c.
    //   - Let d = -(c + 1)^2 / (c - 1)^2.
    //   - (s^2 - 2) * (s^2 + 2) != 0.
    //   - c * (c - 1) * (c + 1) != 0.
    //   - r != 0.
    //   - d is not square.
    //   - x^2 + y^2 = 1 + d * x^2 * y^2.
    //   - u * v * X * Y * x * (Y + 1) != 0.
    //   - Y^2 = X^5 + (r^2 - 2) * X^3 + X.
    //
    // Elligator 1, as devised by Fouque et al,
    // takes place on the hyperelliptic curve of:
    //
    //   y^2 = x^5 + (r^2 - 2) * x^3 + x
    //
    // Not only must our Edwards curve be complete,
    // with a prime congruent to 3 mod 4, and a = 1,
    // our curve must be isomorphic to a hyperelliptic
    // curve of the above form. Roughly one half of
    // all Edwards curves are isomorphic to a curve
    // of said form.
    //
    // We can derive the isomorphism with:
    //
    //   c = (d +- 2 * sqrt(-d) - 1) / (d + 1)
    //   s = +-sqrt(2 / c)
    //   r = c + 1 / c
    //
    // Note that even if your curve is an Elligator 1
    // curve, Elligator 2 is probably still preferable,
    // as it has nearly the same properties (i.e. the
    // same distribution), and is much less complex.
    //
    // Map:
    //
    //   f(a) = a^((p - 1) / 2)
    //   u = (1 - t) / (1 + t)
    //   v = u^5 + (r^2 - 2) * u^3 + u
    //   X = f(v) * u
    //   Y = (f(v) * v)^((p + 1) / 4) * f(v) * f(u^2 + 1 / c^2)
    //   Y = 1, if u = 0
    //   x = (c - 1) * s * X * (1 + X) / Y
    //   y = (r * X - (1 + X)^2) / (r * X + (1 + X)^2)
    //
    // When t = +-1, we create the hyperelliptic
    // 2-torsion point of (0, 0). This needs to be
    // mapped to (0, -1) in Edwards form, but the x
    // denominator becomes zero. As far as I can
    // tell, this is the only exceptional case.
    //
    // The only other exceptional case initially
    // appears to be when the y denominator sums to
    // zero (when t = sqrt(4 / r + 1)), however, the
    // hyperelliptic `X` is negated by the sign of
    // `v`, making this impossible.
    const {s, si, i2, one, two} = this;
    const c = si.redSqr().redIMuln(2);
    const ci = s.redSqr().redMul(i2);
    const ci2 = ci.redSqr();
    const r = c.redAdd(ci);
    const r2 = r.redSqr().redISub(two);
    const cm1 = c.redSub(one);
    const uu = one.redSub(t);
    const uz = one.redAdd(t);
    const u = uz.isZero() ? uz : uu.redDiv(uz);
    const u2 = u.redSqr();
    const u3 = u2.redMul(u);
    const u5 = u3.redMul(u2);
    const v = u5.redAdd(r2.redMul(u3)).redIAdd(u);
    const f0 = this.field(v.redJacobi());
    const f1 = this.field(u2.redAdd(ci2).redJacobi());
    const f2 = f0.redMul(f1);
    const X = f0.redMul(u);
    const Y = f0.redMul(v).redSqrt().redMul(f2);
    const X1 = one.redAdd(X);
    const rX = r.redMul(X);
    const X12 = X1.redSqr();
    const xx = cm1.redMul(s).redMul(X).redMul(X1);
    const xz = u.isZero() ? this.one : Y;
    const yy = rX.redSub(X12);
    const yz = rX.redAdd(X12);

    return this.cpoint(xx, xz, yy, yz);
  }

  _invert1(p, hint) {
    // Inverting the Map (Elligator 1).
    //
    // [ELL1] Page 6, Section 3.
    //        Page 15, Appendix A.
    // [ELL2] Page 7, Section 3.3.
    //
    // Assumptions:
    //
    //   - y + 1 != 0.
    //   - (1 + n * r)^2 - 1 is square in F(p).
    //   - If n * r = -2 then x = 2 * s * (c - 1) * f(c) / r.
    //   - Y = (c - 1) * s * X * (1 + X) / x.
    //
    // Map:
    //
    //   f(a) = a^((p - 1) / 2)
    //   n = (y - 1) / (2 * (y + 1))
    //   X = -(1 + n * r) + ((1 + n * r)^2 - 1)^((p + 1) / 4)
    //   z = f((c - 1) * s * X * (1 + X) * x * (X^2 + 1 / c^2))
    //   u = z * X
    //   t = (1 - u) / (1 + u)
    const {s, si, i2, one} = this;
    const {x, y, z} = p;
    const sign = hint & 1;
    const c = si.redSqr().redIMuln(2);
    const ci = s.redSqr().redMul(i2);
    const ci2 = ci.redSqr();
    const r = c.redAdd(ci);
    const cm1 = c.redSub(one);
    const nn = y.redSub(z);
    const nz = y.redAdd(z).redIMuln(2);
    const n = nz.isZero() ? nz : nn.redDiv(nz);
    const nr1 = one.redAdd(n.redMul(r));
    const w2 = nr1.redSqr().redISub(one);
    const w = w2.redSqrt();
    const X = w.redSub(nr1);
    const X1 = one.redAdd(X);
    const YY = cm1.redMul(s).redMul(X).redMul(X1);
    const Y = YY.redMul(x.redMul(z));
    const X2 = X.redSqr().redIAdd(ci2);
    const Z = this.field(Y.redMul(X2).redJacobi());
    const u = Z.redMul(X);
    const tt = one.redSub(u);
    const tz = one.redAdd(u);
    const t = tz.isZero() ? tz : tt.redDiv(tz);

    if (t.redIsOdd() !== Boolean(sign))
      t.redINeg();

    return t;
  }

  _alt() {
    if (!this.alt)
      this.alt = this.toMont();

    return this.alt;
  }

  isElliptic() {
    const ad = this.a.redMul(this.d);
    const amd = this.a.redSub(this.d);

    // a * d * (a - d) != 0
    return !ad.redMul(amd).isZero();
  }

  jinv() {
    // [TWISTED] Definition 2.1, Page 3, Section 2.
    const {a, d} = this;
    const ad = a.redMul(d);
    const amd4 = a.redSub(d).redPown(4);
    const a2 = a.redSqr();
    const d2 = d.redSqr();
    const t0 = a2.redAdd(ad.redMuln(14)).redIAdd(d2);
    const lhs = t0.redPown(3).redIMuln(16);
    const rhs = ad.redMul(amd4);

    if (rhs.isZero())
      throw new Error('Curve is not elliptic.');

    // 16 * (a^2 + 14 * a * d + d^2)^3 / (a * d * (a - d)^4)
    return lhs.redDiv(rhs).fromRed();
  }

  isComplete() {
    return this.a.redJacobi() === 1
        && this.d.redJacobi() === -1;
  }

  point(x, y, z, t) {
    return new EdwardsPoint(this, x, y, z, t);
  }

  jpoint(x, y, z) {
    assert(x == null && y == null && z == null);
    return this.point();
  }

  cpoint(xx, xz, yy, yz) {
    assert(xx instanceof BN);
    assert(xz instanceof BN);
    assert(yy instanceof BN);
    assert(yz instanceof BN);

    const x = xx.redMul(yz);
    const y = yy.redMul(xz);
    const z = xz.redMul(yz);
    const t = xx.redMul(yy);

    return this.point(x, y, z, t);
  }

  solveX2(y) {
    // [RFC8032] Section 5.1.3 & 5.2.3.
    assert(y instanceof BN);

    // x^2 = (y^2 - 1) / (d * y^2 - a)
    const y2 = y.redSqr();
    const rhs = this._mulD(y2).redISub(this.a);
    const lhs = y2.redISub(this.one);
    const x2 = lhs.redDiv(rhs);

    return x2;
  }

  solveX(y) {
    // Optimize with inverse square root trick.
    //
    // Note that `0 / 0` can only occur if
    // `a == d` (i.e. the curve is singular).
    const y2 = y.redSqr();
    const rhs = this._mulD(y2).redISub(this.a);
    const lhs = y2.redISub(this.one);

    return lhs.redDivSqrt(rhs);
  }

  solveY2(x) {
    assert(x instanceof BN);

    // y^2 = (a * x^2 - 1) / (d * x^2 - 1)
    const x2 = x.redSqr();
    const lhs = this._mulA(x2).redISub(this.one);
    const rhs = this._mulD(x2).redISub(this.one);
    const y2 = lhs.redDiv(rhs);

    return y2;
  }

  solveY(x) {
    // Optimize with inverse square root trick.
    //
    // Note that `0 / 0` can only occur if
    // `a == d` (i.e. the curve is singular).
    const x2 = x.redSqr();
    const lhs = this._mulA(x2).redISub(this.one);
    const rhs = this._mulD(x2).redISub(this.one);

    return lhs.redDivSqrt(rhs);
  }

  validate(point) {
    // [TWISTED] Definition 2.1, Page 3, Section 2.
    //           Page 11, Section 6.
    assert(point instanceof EdwardsPoint);

    // Z1 = 1
    if (point.zOne) {
      // a * x^2 + y^2 = 1 + d * x^2 * y^2
      const x2 = point.x.redSqr();
      const y2 = point.y.redSqr();
      const dxy = this._mulD(x2).redMul(y2);
      const lhs = this._mulA(x2).redIAdd(y2);
      const rhs = this.one.redAdd(dxy);
      const tz = point.t;
      const xy = point.x.redMul(point.y);

      return lhs.eq(rhs) && tz.eq(xy);
    }

    // (a * x^2 + y^2) * z^2 = z^4 + d * x^2 * y^2
    const x2 = point.x.redSqr();
    const y2 = point.y.redSqr();
    const z2 = point.z.redSqr();
    const z4 = z2.redSqr();
    const dxy = this._mulD(x2).redMul(y2);
    const lhs = this._mulA(x2).redIAdd(y2).redMul(z2);
    const rhs = z4.redIAdd(dxy);
    const tz = point.t.redMul(point.z);
    const xy = point.x.redMul(point.y);

    return lhs.eq(rhs) && tz.eq(xy);
  }

  pointFromX(x, sign = null) {
    assert(x instanceof BN);
    assert(sign == null || typeof sign === 'boolean');

    if (!x.red)
      x = x.toRed(this.red);

    const y = this.solveY(x);

    if (sign != null) {
      if (y.isZero() && sign)
        throw new Error('Invalid point.');

      if (y.redIsOdd() !== sign)
        y.redINeg();
    }

    return this.point(x, y);
  }

  pointFromY(y, sign = null) {
    assert(y instanceof BN);
    assert(sign == null || typeof sign === 'boolean');

    if (!y.red)
      y = y.toRed(this.red);

    const x = this.solveX(y);

    if (sign != null) {
      if (x.isZero() && sign)
        throw new Error('Invalid point.');

      if (x.redIsOdd() !== sign)
        x.redINeg();
    }

    return this.point(x, y);
  }

  isIsomorphic(curve, invert = false) {
    // [TWISTED] Theorem 3.2, Page 4, Section 3.
    //           Definition 2.1, Page 3, Section 2.
    assert(curve instanceof Curve);
    assert(typeof invert === 'boolean');

    if (!curve.p.eq(this.p))
      return false;

    // E(a,d) <-> E(a,b)
    if (curve.type === 'short')
      return curve.isIsomorphic(this);

    // E(a,d) <-> M(A,B)
    // E(a,d) <-> M(-A,-B)
    if (curve.type === 'mont') {
      // A * (a - d) = 2 * (a + d)
      const a = this.field(curve.a);

      let apd, amd;

      if (invert) {
        apd = this.d.redAdd(this.a);
        amd = this.d.redSub(this.a);
      } else {
        apd = this.a.redAdd(this.d);
        amd = this.a.redSub(this.d);
      }

      return a.redMul(amd).eq(apd.redIMuln(2));
    }

    // E(a,d) <-> E(a',a'd/a)
    if (curve.type === 'edwards') {
      // a' * d = a * d'
      const a = this.field(curve.a);
      const d = this.field(curve.d);

      return this.a.redMul(d).eq(a.redMul(this.d));
    }

    return false;
  }

  isIsogenous(curve) {
    // Check for the 4-isogenies described by Hamburg:
    // https://moderncrypto.org/mail-archive/curves/2016/000806.html
    assert(curve instanceof Curve);

    if (!curve.p.eq(this.p))
      return false;

    // E(1,d) <-> M(2-4d,1)
    if (curve.type === 'mont') {
      if (!this.a.eq(this.one))
        return false;

      const a = this.field(curve.a);
      const b = this.field(curve.b);
      const d24 = this.two.redSub(this.d.redMuln(4));

      return a.eq(d24) && b.eq(this.one);
    }

    // E(a,d) <-> E(-a,d-a)
    if (curve.type === 'edwards') {
      const a = this.field(curve.a);
      const d = this.field(curve.d);

      return a.eq(this.a.redNeg())
          && d.eq(this.d.redSub(this.a));
    }

    return false;
  }

  pointFromShort(point) {
    // [TWISTEQ] Section 1.
    assert(point instanceof ShortPoint);

    if (this.isIsomorphic(point.curve)) {
      // Equivalence for E(a,b)->E(a',d'):
      //
      //   x' = (6 * x - a' - d') / (6 * y)
      //   y' = (12 * x - 5 * a' + d') / (12 * x + a' - 5 * d')
      //
      // Undefined for x = (5 * d' - a') / 12 or y = 0.
      //
      // Exceptional Cases:
      //   - O -> (0, 1)
      //   - ((a' + d') / 6, 0) -> (0, -1)
      //   - ((5 * d' - a') / 12, (d' - a') / 4 * sqrt(d')) -> (sqrt(1/d'), oo)
      //
      // Unexceptional Cases:
      //   - ((5 * a' - d') / 12, (a' - d') / 4 * sqrt(a')) -> (sqrt(1/a'), 0)
      if (point.isInfinity())
        return this.point();

      if (point.y.isZero())
        return this.point(this.zero, this.one.redNeg());

      const {a, d} = this;
      const [u2, u3] = this._scale(point.curve);
      const a5 = a.redMuln(5);
      const d5 = d.redMuln(5);
      const x = this.field(point.x).redMul(u2);
      const y = this.field(point.y).redMul(u3);
      const x6 = x.redMuln(6);
      const x12 = x.redMuln(12);
      const xx = x6.redSub(a).redISub(d);
      const xz = y.redMuln(6);
      const yy = x12.redSub(a5).redIAdd(d);
      const yz = x12.redAdd(a).redISub(d5);

      return this.cpoint(xx, xz, yy, yz);
    }

    throw new Error('Not implemented.');
  }

  pointFromMont(point) {
    // [RFC7748] Section 4.1 & 4.2.
    // [MONT3] Page 6, Section 2.5.
    // [TWISTED] Theorem 3.2, Page 4, Section 3.
    assert(point instanceof MontPoint);
    assert(point.curve.p.eq(this.p));

    // Montgomery `u`, `v`.
    const u = this.field(point.x);
    const v = this.field(point.y);

    if (this.isIsogenous(point.curve)) {
      // 4-isogeny maps for M(2-4d,1)->E(1,d):
      //
      //   x = 4 * v * (u^2 - 1) / (u^4 - 2 * u^2 + 4 * v^2 + 1)
      //   y = -(u^5 - 2 * u^3 - 4 * u * v^2 + u) /
      //        (u^5 - 2 * u^2 * v^2 - 2 * u^3 - 2 * v^2 + u)
      //
      // Undefined for u = 0 and v = 0.
      //
      // Exceptional Cases:
      //   - O -> (0, 1)
      //   - (0, 0) -> (0, 1)
      //
      // Unexceptional Cases:
      //   - (-1, +-sqrt(A - 2)) -> (0, 1)
      //   - (1, +-sqrt(A + 2)) -> (0, -1)
      //
      // The point (1, v) is invalid on Curve448.
      if (point.isInfinity())
        return this.point();

      if (point.x.isZero())
        return this.point();

      const u2 = u.redSqr();
      const u3 = u2.redMul(u);
      const u4 = u3.redMul(u);
      const u5 = u4.redMul(u);
      const v2 = v.redSqr();
      const a = v.redMuln(4);
      const b = u2.redSub(this.one);
      const c = u2.redMuln(2);
      const d = v2.redMuln(4);
      const e = u3.redIMuln(2);
      const f = u.redMul(v2).redIMuln(4);
      const g = u2.redMul(v2).redIMuln(2);
      const h = v2.redIMuln(2);
      const xx = a.redMul(b);
      const xz = u4.redISub(c).redIAdd(d).redIAdd(this.one);
      const yy = u5.redSub(e).redISub(f).redIAdd(u).redINeg();
      const yz = u5.redISub(g).redISub(e).redISub(h).redIAdd(u);

      return this.cpoint(xx, xz, yy, yz).divn(4);
    }

    if (this.isIsomorphic(point.curve, true)) {
      // Isomorphic maps for M(-A,-B)->E(a,d):
      //
      //   x = +-sqrt((A - 2) / (B * a)) * u / v
      //   y = (u + 1) / (u - 1)
      //
      // Undefined for u = 1 or v = 0.
      //
      // Exceptional Cases:
      //   - O -> (0, 1)
      //   - (0, 0) -> (0, -1)
      //   - (1, +-sqrt((A + 2) / B)) -> (+-sqrt(1 / d), oo)
      //
      // Unexceptional Cases:
      //   - (-1, +-sqrt((A - 2) / B)) -> (+-sqrt(1 / a), 0)
      //
      // The point (1, v) is invalid on Curve448.
      if (point.isInfinity())
        return this.point();

      if (point.x.isZero())
        return this.point(this.zero, this.one.redNeg());

      const c = this._scale(point.curve, true);
      const xx = c.redMul(u);
      const xz = v;
      const yy = u.redAdd(this.one);
      const yz = u.redSub(this.one);

      return this.cpoint(xx, xz, yy, yz);
    }

    if (this.isIsomorphic(point.curve, false)) {
      // Isomorphic maps for M(A,B)->E(a,d):
      //
      //   x = +-sqrt((A + 2) / (B * a)) * u / v
      //   y = (u - 1) / (u + 1)
      //
      // Undefined for u = -1 or v = 0.
      //
      // Exceptional Cases:
      //   - O -> (0, 1)
      //   - (0, 0) -> (0, -1)
      //   - (-1, +-sqrt((A - 2) / B)) -> (+-sqrt(1 / d), oo)
      //
      // Unexceptional Cases:
      //   - (1, +-sqrt((A + 2) / B)) -> (+-sqrt(1 / a), 0)
      //
      // The point (-1, v) is invalid on Curve25519.
      if (point.isInfinity())
        return this.point();

      if (point.x.isZero())
        return this.point(this.zero, this.one.redNeg());

      const c = this._scale(point.curve, false);
      const xx = c.redMul(u);
      const xz = v;
      const yy = u.redSub(this.one);
      const yz = u.redAdd(this.one);

      return this.cpoint(xx, xz, yy, yz);
    }

    throw new Error('Not implemented.');
  }

  pointFromEdwards(point) {
    // [TWISTED] Definition 2.1, Page 3, Section 2.
    // [ISOGENY] Page 2, Section 2.
    assert(point instanceof EdwardsPoint);
    assert(point.curve.p.eq(this.p));

    // Edwards `x`, `y`, `z`, `t`.
    const a = this.field(point.curve.a);
    const x = this.field(point.x);
    const y = this.field(point.y);
    const z = this.field(point.z);
    const t = this.field(point.t);

    if (this.isIsogenous(point.curve)) {
      // 4-isogeny maps for E(a,d)<->E(-a,d-a):
      //
      //   x' = (2 * x * y) / (y^2 - a * x^2)
      //   y' = (y^2 + a * x^2) / (2 - y^2 - a * x^2)
      //
      // Undefined for y^2 - a * x^2 = 0
      //            or y^2 + a * x^2 = 2.
      const xy = x.redMul(y);
      const x2 = x.redSqr();
      const y2 = y.redSqr();
      const z2 = z.redSqr();
      const ax2 = a.redMul(x2);
      const xx = xy.redIMuln(2);
      const xz = y2.redSub(ax2);
      const yy = y2.redAdd(ax2);
      const yz = z2.redIMuln(2).redISub(yy);
      const p = this.cpoint(xx, xz, yy, yz);

      return !this.twisted ? p.divn(4) : p;
    }

    if (this.isIsomorphic(point.curve)) {
      // Isomorphic maps for E(a,d)<->E(a',a'd/a):
      //
      //   x' = +-sqrt(a / a') * x
      //   y' = y
      //
      // Undefined when (a / a') is not square.
      const c = this._scale(point.curve);
      const nx = c.redMul(x);
      const ny = y;
      const nz = z;
      const nt = c.redMul(t);

      return this.point(nx, ny, nz, nt);
    }

    throw new Error('Not implemented.');
  }

  pointFromUniform(u, curve = null) {
    assert(u instanceof BN);
    assert(u.red === this.red);
    assert(curve == null || (curve instanceof MontCurve));

    if (!curve)
      curve = this._alt();

    const u0 = curve.field(u);
    const p0 = curve.pointFromUniform(u0);

    return this.pointFromMont(p0);
  }

  pointToUniform(p, hint, curve = null) {
    // Convert an edwards point to a field
    // element by inverting the elligator2 map.
    //
    // Hint Layout:
    //
    //   [00000000] [0000] [0000]
    //        |        |      |
    //        |        |      +-- preimage index
    //        |        +--- subgroup
    //        +-- bits to OR with uniform bytes
    assert(p instanceof EdwardsPoint);
    assert((hint >>> 0) === hint);
    assert(curve == null || (curve instanceof MontCurve));

    if (!curve)
      curve = this._alt();

    // Add a random torsion component.
    const i = ((hint >> 4) & 15) % this.torsion.length;
    const q = p.add(this.torsion[i]);

    // Convert and invert.
    const p0 = curve.pointFromEdwards(q);
    const u0 = curve.pointToUniform(p0, hint & 15);

    return this.field(u0);
  }

  pointFromHash(bytes, pake, curve = null) {
    assert(curve == null || (curve instanceof MontCurve));

    if (!curve)
      curve = this._alt();

    const p0 = curve.pointFromHash(bytes, pake);

    return this.pointFromMont(p0);
  }

  pointToHash(p, subgroup, rng, curve = null) {
    assert(p instanceof EdwardsPoint);
    assert((subgroup >>> 0) === subgroup);
    assert(curve == null || (curve instanceof MontCurve));

    if (!curve)
      curve = this._alt();

    // Add a random torsion component.
    const i = subgroup % this.torsion.length;
    const q = p.add(this.torsion[i]);

    // Convert and invert.
    const p0 = curve.pointFromEdwards(q);

    return curve.pointToHash(p0, 0, rng);
  }

  decodePoint(bytes) {
    return EdwardsPoint.decode(this, bytes);
  }

  toShort(a0, odd, sign = null) {
    const [a, b] = this._short(a0, odd);

    const curve = new ShortCurve({
      red: this.red,
      prime: this.prime,
      p: this.p,
      a: a,
      b: b,
      n: this.n,
      h: this.h
    });

    if (sign != null) {
      const [, u3] = curve._scale(this);

      if (u3.redIsOdd() !== sign)
        u3.redINeg();
    }

    if (!this.g.isInfinity())
      curve.g = curve.pointFromEdwards(this.g);

    for (let i = 0; i < this.h.word(0); i++)
      curve.torsion[i] = curve.pointFromEdwards(this.torsion[i]);

    return curve;
  }

  toMont(b0, invert, sign = null) {
    const [a, b] = this._mont(b0, invert);

    const curve = new MontCurve({
      red: this.red,
      prime: this.prime,
      p: this.p,
      a: a,
      b: b,
      n: this.n,
      h: this.h,
      z: this.z
    });

    if (sign != null) {
      const c = this._scale(curve, invert);

      if (c.redIsOdd() !== sign)
        c.redINeg();
    }

    if (!this.g.isInfinity())
      curve.g = curve.pointFromEdwards(this.g);

    for (let i = 0; i < this.h.word(0); i++)
      curve.torsion[i] = curve.pointFromEdwards(this.torsion[i]);

    return curve;
  }

  toEdwards(a0, sign = null) {
    const [a, d] = this._edwards(a0);

    const curve = new EdwardsCurve({
      red: this.red,
      prime: this.prime,
      p: this.p,
      a: a,
      d: d,
      n: this.n,
      h: this.h,
      z: this.z
    });

    if (sign != null) {
      const c = curve._scale(this);

      if (c.redIsOdd() !== sign)
        c.redINeg();
    }

    if (!this.g.isInfinity()) {
      curve.g = curve.pointFromEdwards(this.g);
      curve.g.normalize();
    }

    if (curve.isComplete()) {
      for (let i = 0; i < this.h.word(0); i++) {
        curve.torsion[i] = curve.pointFromEdwards(this.torsion[i]);
        curve.torsion[i].normalize();
      }
    }

    return curve;
  }

  pointFromJSON(json) {
    return EdwardsPoint.fromJSON(this, json);
  }

  toJSON(pre) {
    const json = super.toJSON(pre);

    json.a = this.a.fromRed().toJSON();
    json.d = this.d.fromRed().toJSON();

    if (!this.s.isZero())
      json.s = this.s.fromRed().toJSON();

    return json;
  }
}

/**
 * EdwardsPoint
 */

class EdwardsPoint extends Point {
  constructor(curve, x, y, z, t) {
    assert(curve instanceof EdwardsCurve);

    super(curve, types.EXTENDED);

    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;

    if (x != null)
      this._init(x, y, z, t);
  }

  _init(x, y, z, t) {
    assert(x instanceof BN);
    assert(y instanceof BN);
    assert(z == null || (z instanceof BN));
    assert(t == null || (t instanceof BN));

    this.x = x;
    this.y = y;
    this.z = z || this.curve.one;
    this.t = t || null;

    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);

    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);

    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);

    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);

    this.zOne = this.z.eq(this.curve.one);

    this._check();

    if (!this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redDiv(this.z);
    }
  }

  _check() {
    // In order to achieve complete
    // addition formulas, `a` must
    // be a square (always the case
    // for a=1), and `d` must be a
    // non-square.
    //
    // If this is not the case, the
    // addition formulas may have
    // exceptional cases where Z3=0.
    //
    // In particular, this can occur
    // when: Q*h = -P*h and Q != -P.
    //
    // This is assuming 4-torsion is
    // involved (the 4-torsion point
    // is _not_ representable when
    // `d` is square).
    if (this.z.isZero())
      throw new Error('Invalid point.');
  }

  clone() {
    return this.curve.point(this.x, this.y, this.z, this.t);
  }

  normalize() {
    // https://hyperelliptic.org/EFD/g1p/auto-edwards-projective.html#scaling-z
    // 1I + 2M (+ 1M if extended)

    // Z1 = 1
    if (this.zOne)
      return this;

    // A = 1 / Z1
    const a = this.z.redInvert();

    // X3 = X1 * A
    this.x = this.x.redMul(a);

    // Y3 = Y1 * A
    this.y = this.y.redMul(a);

    // T3 = T1 * A
    this.t = this.t.redMul(a);

    // Z3 = 1
    this.z = this.curve.one;
    this.zOne = true;

    return this;
  }

  scale(a) {
    assert(a instanceof BN);

    // X3 = X1 * A
    const nx = this.x.redMul(a);

    // Y3 = Y1 * A
    const ny = this.y.redMul(a);

    // Z3 = Z1 * A
    const nz = this.z.redMul(a);

    // T3 = T1 * A
    const nt = this.t.redMul(a);

    return this.curve.point(nx, ny, nz, nt);
  }

  neg() {
    // -(X1, Y1, Z1, T1) = (-X1, Y1, Z1, -T1)
    const nx = this.x.redNeg();
    const ny = this.y;
    const nz = this.z;
    const nt = this.t.redNeg();

    return this.curve.point(nx, ny, nz, nt);
  }

  add(p) {
    assert(p instanceof EdwardsPoint);

    // P = O
    if (this.isInfinity())
      return p;

    // Q = O
    if (p.isInfinity())
      return this;

    // Z1 = 1
    if (this.zOne)
      return p._add(this);

    return this._add(p);
  }

  _add(p) {
    // a = -1
    if (this.curve.mOneA)
      return this._addM1(p);

    return this._addA(p);
  }

  _addM1(p) {
    // Assumes a = -1.
    //
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-3
    // 8M + 8A + 1*k + 1*2
    //
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-madd-2008-hwcd-3
    // 7M + 8A + 1*k + 1*2

    // A = (Y1 - X1) * (Y2 - X2)
    const a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));

    // B = (Y1 + X1) * (Y2 + X2)
    const b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));

    // C = T1 * k * T2
    const c = this.t.redMul(this.curve.k).redMul(p.t);

    // D = Z1 * 2 * Z2
    const d = p.zOne ? this.z.redAdd(this.z) : this.z.redMul(p.z).redIMuln(2);

    // E = B - A
    const e = b.redSub(a);

    // F = D - C
    const f = d.redSub(c);

    // G = D + C
    const g = d.redIAdd(c);

    // H = B + A
    const h = b.redIAdd(a);

    // X3 = E * F
    const nx = e.redMul(f);

    // Y3 = G * H
    const ny = g.redMul(h);

    // T3 = E * H
    const nt = e.redMul(h);

    // Z3 = F * G
    const nz = f.redMul(g);

    return this.curve.point(nx, ny, nz, nt);
  }

  _addA(p) {
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // 9M + 7A + 1*a + 1*d
    //
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-madd-2008-hwcd
    // 8M + 7A + 1*a + 1*d

    // A = X1 * X2
    const a = this.x.redMul(p.x);

    // B = Y1 * Y2
    const b = this.y.redMul(p.y);

    // C = T1 * d * T2
    const c = this.curve._mulD(this.t).redMul(p.t);

    // D = Z1 * Z2
    const d = p.zOne ? this.z.clone() : this.z.redMul(p.z);

    // + XYXY = (X1 + Y1) * (X2 + Y2)
    const xyxy = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y));

    // E = (X1 + Y1) * (X2 + Y2) - A - B
    const e = xyxy.redISub(a).redISub(b);

    // F = D - C
    const f = d.redSub(c);

    // G = D + C
    const g = d.redIAdd(c);

    // H = B - a * A
    const h = b.redISub(this.curve._mulA(a));

    // X3 = E * F
    const nx = e.redMul(f);

    // Y3 = G * H
    const ny = g.redMul(h);

    // T3 = E * H
    const nt = e.redMul(h);

    // Z3 = F * G
    const nz = f.redMul(g);

    return this.curve.point(nx, ny, nz, nt);
  }

  dbl() {
    // P = O
    if (this.isInfinity())
      return this;

    return this._dbl();
  }

  _dbl() {
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // 4M + 4S + 6A + 1*a + 1*2
    //
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-mdbl-2008-hwcd
    // 3M + 4S + 7A + 1*a + 1*2

    // A = X1^2
    const a = this.x.redSqr();

    // B = Y1^2
    const b = this.y.redSqr();

    // C = 2 * Z1^2
    const c = this.zOne ? this.curve.two : this.z.redSqr().redIMuln(2);

    // D = a * A
    const d = this.curve._mulA(a);

    // E = (X1 + Y1)^2 - A - B
    const e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);

    // G = D + B
    const g = d.redAdd(b);

    // F = G - C
    const f = g.redSub(c);

    // H = D - B
    const h = d.redISub(b);

    // X3 = E * F
    const nx = e.redMul(f);

    // Y3 = G * H
    const ny = g.redMul(h);

    // T3 = E * H
    const nt = e.redMul(h);

    // Z3 = F * G
    const nz = f.redMul(g);

    return this.curve.point(nx, ny, nz, nt);
  }

  getX() {
    this.normalize();
    return this.x.fromRed();
  }

  getY() {
    this.normalize();
    return this.y.fromRed();
  }

  eq(p) {
    assert(p instanceof EdwardsPoint);
    assert(!this.z.isZero());
    assert(!p.z.isZero());

    // P = Q
    if (this === p)
      return true;

    // Z1 = Z2
    if (this.z.eq(p.z)) {
      return this.x.eq(p.x)
          && this.y.eq(p.y);
    }

    // X1 * Z2 = X2 * Z1
    const x1 = this.x.redMul(p.z);
    const x2 = p.x.redMul(this.z);

    if (!x1.eq(x2))
      return false;

    const y1 = this.y.redMul(p.z);
    const y2 = p.y.redMul(this.z);

    return y1.eq(y2);
  }

  cmp(point) {
    assert(point instanceof EdwardsPoint);

    return this.order().cmp(point.order())
        || this.getY().cmp(point.getY())
        || this.getX().cmp(point.getX());
  }

  isInfinity() {
    assert(!this.z.isZero());

    // X1 = 0
    if (!this.x.isZero())
      return false;

    // Y1 = Z1
    return this.y.eq(this.z);
  }

  isOrder2() {
    if (this.isInfinity())
      return false;

    return this.x.isZero();
  }

  isOdd() {
    this.normalize();
    return this.x.redIsOdd();
  }

  isEven() {
    this.normalize();
    return this.x.redIsEven();
  }

  toP() {
    return this.normalize();
  }

  toJ() {
    return this;
  }

  encode() {
    // [RFC8032] Section 5.1.2.
    const y = this.getY();

    // Note: `x` normalized from `getY()` call.
    y.setn(this.curve.signBit, this.x.redIsOdd());

    return this.curve.encodeAdjusted(y);
  }

  static decode(curve, bytes) {
    // [RFC8032] Section 5.1.3.
    assert(curve instanceof EdwardsCurve);

    const y = curve.decodeAdjusted(bytes);
    const sign = y.testn(curve.signBit) !== 0;

    y.setn(curve.signBit, 0);

    if (y.cmp(curve.p) >= 0)
      throw new Error('Invalid point.');

    return curve.pointFromY(y, sign);
  }

  toJSON(pre) {
    if (this.isInfinity())
      return [];

    const x = this.getX().toJSON();
    const y = this.getY().toJSON();

    if (pre === true && this.pre)
      return [x, y, this.pre.toJSON()];

    return [x, y];
  }

  toPretty() {
    const size = this.curve.fieldSize * 2;
    const x = toPretty(this.getX(), size);
    const y = toPretty(this.getY(), size);

    return [x, y];
  }

  static fromJSON(curve, json) {
    assert(curve instanceof EdwardsCurve);
    assert(Array.isArray(json));
    assert(json.length === 0
        || json.length === 2
        || json.length === 3);

    if (json.length === 0)
      return curve.point();

    const x = BN.fromJSON(json[0]);
    const y = BN.fromJSON(json[1]);
    const point = curve.point(x, y);

    if (json.length > 2 && json[2] != null)
      point.pre = Precomp.fromJSON(point, json[2]);

    return point;
  }

  [custom]() {
    if (this.isInfinity())
      return '<EdwardsPoint: Infinity>';

    return '<EdwardsPoint:'
        + ' x=' + this.x.fromRed().toString(16, 2)
        + ' y=' + this.y.fromRed().toString(16, 2)
        + ' z=' + this.z.fromRed().toString(16, 2)
        + '>';
  }
}

/**
 * Precomp
 */

class Precomp {
  constructor() {
    this.naf = null;
    this.windows = null;
    this.doubles = null;
    this.blinding = null;
    this.beta = null;
  }

  map(func) {
    assert(typeof func === 'function');

    const out = new this.constructor();

    if (this.naf)
      out.naf = this.naf.map(func);

    if (this.doubles)
      out.doubles = this.doubles.map(func);

    return out;
  }

  toJSON() {
    return {
      naf: this.naf ? this.naf.toJSON() : null,
      windows: this.windows ? this.windows.toJSON() : null,
      doubles: this.doubles ? this.doubles.toJSON() : null,
      blinding: this.blinding ? this.blinding.toJSON() : undefined
    };
  }

  fromJSON(point, json) {
    assert(point instanceof Point);
    assert(json && typeof json === 'object');

    if (json.naf != null)
      this.naf = NAF.fromJSON(point, json.naf);

    if (json.windows != null)
      this.windows = Windows.fromJSON(point, json.windows);

    if (json.doubles != null)
      this.doubles = Doubles.fromJSON(point, json.doubles);

    if (json.blinding != null)
      this.blinding = Blinding.fromJSON(point, json.blinding);

    return this;
  }

  static fromJSON(point, json) {
    return new this().fromJSON(point, json);
  }
}

/**
 * NAF
 */

class NAF {
  constructor(width, points) {
    this.width = width;
    this.points = points;
  }

  map(func) {
    assert(typeof func === 'function');

    const {width} = this;
    const points = [];

    for (const point of this.points)
      points.push(func(point));

    return new this.constructor(width, points);
  }

  toJSON() {
    return {
      width: this.width,
      points: this.points.slice(1).map((point) => {
        return point.toJSON();
      })
    };
  }

  static fromJSON(point, json) {
    assert(point instanceof Point);
    assert(json && typeof json === 'object');
    assert((json.width >>> 0) === json.width);
    assert(Array.isArray(json.points));

    const {curve} = point;
    const {width} = json;
    const points = [point];

    for (const item of json.points)
      points.push(curve.pointFromJSON(item));

    return new this(width, points);
  }
}

/**
 * Windows
 */

class Windows {
  constructor(width, bits, points) {
    this.width = width;
    this.bits = bits;
    this.points = points;
  }

  toJSON() {
    return {
      width: this.width,
      bits: this.bits,
      points: this.points.slice(1).map((point) => {
        return point.toJSON();
      })
    };
  }

  static fromJSON(point, json) {
    assert(point instanceof Point);
    assert(json && typeof json === 'object');
    assert((json.width >>> 0) === json.width);
    assert((json.bits >>> 0) === json.bits);
    assert(Array.isArray(json.points));

    const {curve} = point;
    const {width, bits} = json;
    const points = [point];

    for (const item of json.points)
      points.push(curve.pointFromJSON(item));

    return new this(width, bits, points);
  }
}

/**
 * Doubles
 */

class Doubles {
  constructor(step, points) {
    this.step = step;
    this.points = points;
  }

  map(func) {
    assert(typeof func === 'function');

    const {step} = this;
    const points = [];

    for (const point of this.points)
      points.push(func(point));

    return new this.constructor(step, points);
  }

  toJSON() {
    return {
      step: this.step,
      points: this.points.slice(1).map((point) => {
        return point.toJSON();
      })
    };
  }

  static fromJSON(point, json) {
    assert(point instanceof Point);
    assert(json && typeof json === 'object');
    assert((json.step >>> 0) === json.step);
    assert(Array.isArray(json.points));

    const {curve} = point;
    const {step} = json;
    const points = [point];

    for (const item of json.points)
      points.push(curve.pointFromJSON(item));

    return new this(step, points);
  }
}

/**
 * Blinding
 */

class Blinding {
  constructor(blind, unblind) {
    this.blind = blind;
    this.unblind = unblind;
  }

  toJSON() {
    return {
      blind: this.blind.toJSON(),
      unblind: this.unblind.toJSON()
    };
  }

  static fromJSON(point, json) {
    assert(point instanceof Point);
    assert(json && typeof json === 'object');

    const {curve} = point;
    const blind = BN.fromJSON(json.blind);
    const unblind = curve.pointFromJSON(json.unblind);

    return new this(blind, unblind);
  }
}

/**
 * Endo
 */

class Endo {
  constructor(beta, lambda, basis, pre) {
    this.beta = beta;
    this.lambda = lambda;
    this.basis = basis;
    this.pre = pre;
  }

  toJSON() {
    return {
      beta: this.beta.fromRed().toJSON(),
      lambda: this.lambda.toJSON(),
      basis: [
        this.basis[0].toJSON(),
        this.basis[1].toJSON()
      ],
      pre: [
        this.pre[0],
        this.pre[1].toJSON(),
        this.pre[2].toJSON()
      ]
    };
  }

  static fromJSON(curve, json) {
    assert(curve instanceof Curve);
    assert(json && typeof json === 'object');
    assert(Array.isArray(json.basis));
    assert(Array.isArray(json.pre));
    assert(json.basis.length === 2);
    assert(json.pre.length === 3);
    assert((json.pre[0] >>> 0) === json.pre[0]);

    const beta = BN.fromJSON(json.beta).toRed(curve.red);
    const lambda = BN.fromJSON(json.lambda);

    const basis = [
      Vector.fromJSON(json.basis[0]),
      Vector.fromJSON(json.basis[1])
    ];

    const pre = [
      json.pre[0],
      BN.fromJSON(json.pre[1]),
      BN.fromJSON(json.pre[2])
    ];

    return new this(beta, lambda, basis, pre);
  }
}

/**
 * Vector
 */

class Vector {
  constructor(a, b) {
    this.a = a;
    this.b = b;
  }

  toJSON() {
    return {
      a: this.a.toJSON(),
      b: this.b.toJSON()
    };
  }

  static fromJSON(json) {
    assert(json && typeof json === 'object');

    const a = BN.fromJSON(json.a);
    const b = BN.fromJSON(json.b);

    return new this(a, b);
  }
}

/**
 * P192
 * https://tinyurl.com/fips-186-2 (page 29)
 * https://tinyurl.com/fips-186-3 (page 88)
 */

class P192 extends ShortCurve {
  constructor(pre) {
    super({
      id: 'P192',
      ossl: 'prime192v1',
      type: 'short',
      endian: 'be',
      hash: 'SHA256',
      prime: 'p192',
      // 2^192 - 2^64 - 1 (= 3 mod 4)
      p: ['ffffffff ffffffff ffffffff fffffffe',
          'ffffffff ffffffff'],
      // -3 mod p
      a: ['ffffffff ffffffff ffffffff fffffffe',
          'ffffffff fffffffc'],
      b: ['64210519 e59c80e7 0fa7e9ab 72243049',
          'feb8deec c146b9b1'],
      n: ['ffffffff ffffffff ffffffff 99def836',
          '146bc9b1 b4d22831'],
      h: '1',
      // Icart
      z: '-5',
      g: [
        ['188da80e b03090f6 7cbf20eb 43a18800',
         'f4ff0afd 82ff1012'],
        ['07192b95 ffc8da78 631011ed 6b24cdd5',
         '73f977a1 1e794811'],
        pre
      ]
    });
  }
}

/**
 * P224
 * https://tinyurl.com/fips-186-2 (page 30)
 * https://tinyurl.com/fips-186-3 (page 88)
 */

class P224 extends ShortCurve {
  constructor(pre) {
    super({
      id: 'P224',
      ossl: 'secp224r1',
      type: 'short',
      endian: 'be',
      hash: 'SHA256',
      prime: 'p224',
      // 2^224 - 2^96 + 1 (1 mod 16)
      p: ['ffffffff ffffffff ffffffff ffffffff',
          '00000000 00000000 00000001'],
      // -3 mod p
      a: ['ffffffff ffffffff ffffffff fffffffe',
          'ffffffff ffffffff fffffffe'],
      b: ['b4050a85 0c04b3ab f5413256 5044b0b7',
          'd7bfd8ba 270b3943 2355ffb4'],
      n: ['ffffffff ffffffff ffffffff ffff16a2',
          'e0b8f03e 13dd2945 5c5c2a3d'],
      h: '1',
      // SSWU
      z: '1f',
      g: [
        ['b70e0cbd 6bb4bf7f 321390b9 4a03c1d3',
         '56c21122 343280d6 115c1d21'],
        ['bd376388 b5f723fb 4c22dfe6 cd4375a0',
         '5a074764 44d58199 85007e34'],
        pre
      ]
    });
  }
}

/**
 * P256
 * https://tinyurl.com/fips-186-2 (page 31)
 * https://tinyurl.com/fips-186-3 (page 89)
 */

class P256 extends ShortCurve {
  constructor(pre) {
    super({
      id: 'P256',
      ossl: 'prime256v1',
      type: 'short',
      endian: 'be',
      hash: 'SHA256',
      prime: null,
      // 2^256 - 2^224 + 2^192 + 2^96 - 1 (= 3 mod 4)
      p: ['ffffffff 00000001 00000000 00000000',
          '00000000 ffffffff ffffffff ffffffff'],
      // -3 mod p
      a: ['ffffffff 00000001 00000000 00000000',
          '00000000 ffffffff ffffffff fffffffc'],
      b: ['5ac635d8 aa3a93e7 b3ebbd55 769886bc',
          '651d06b0 cc53b0f6 3bce3c3e 27d2604b'],
      n: ['ffffffff 00000000 ffffffff ffffffff',
          'bce6faad a7179e84 f3b9cac2 fc632551'],
      h: '1',
      // SSWU
      z: '-a',
      g: [
        ['6b17d1f2 e12c4247 f8bce6e5 63a440f2',
         '77037d81 2deb33a0 f4a13945 d898c296'],
        ['4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16',
         '2bce3357 6b315ece cbb64068 37bf51f5'],
        pre
      ]
    });
  }
}

/**
 * P384
 * https://tinyurl.com/fips-186-2 (page 32)
 * https://tinyurl.com/fips-186-3 (page 89)
 */

class P384 extends ShortCurve {
  constructor(pre) {
    super({
      id: 'P384',
      ossl: 'secp384r1',
      type: 'short',
      endian: 'be',
      hash: 'SHA384',
      prime: null,
      // 2^384 - 2^128 - 2^96 + 2^32 - 1 (= 3 mod 4)
      p: ['ffffffff ffffffff ffffffff ffffffff',
          'ffffffff ffffffff ffffffff fffffffe',
          'ffffffff 00000000 00000000 ffffffff'],
      // -3 mod p
      a: ['ffffffff ffffffff ffffffff ffffffff',
          'ffffffff ffffffff ffffffff fffffffe',
          'ffffffff 00000000 00000000 fffffffc'],
      b: ['b3312fa7 e23ee7e4 988e056b e3f82d19',
          '181d9c6e fe814112 0314088f 5013875a',
          'c656398d 8a2ed19d 2a85c8ed d3ec2aef'],
      n: ['ffffffff ffffffff ffffffff ffffffff',
          'ffffffff ffffffff c7634d81 f4372ddf',
          '581a0db2 48b0a77a ecec196a ccc52973'],
      h: '1',
      // Icart
      z: '-c',
      g: [
        ['aa87ca22 be8b0537 8eb1c71e f320ad74',
         '6e1d3b62 8ba79b98 59f741e0 82542a38',
         '5502f25d bf55296c 3a545e38 72760ab7'],
        ['3617de4a 96262c6f 5d9e98bf 9292dc29',
         'f8f41dbd 289a147c e9da3113 b5f0b8c0',
         '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'],
        pre
      ]
    });
  }
}

/**
 * P521
 * https://tinyurl.com/fips-186-2 (page 33)
 * https://tinyurl.com/fips-186-3 (page 90)
 */

class P521 extends ShortCurve {
  constructor(pre) {
    super({
      id: 'P521',
      ossl: 'secp521r1',
      type: 'short',
      endian: 'be',
      hash: 'SHA512',
      prime: 'p521',
      // 2^521 - 1 (= 3 mod 4)
      p: ['000001ff ffffffff ffffffff ffffffff',
          'ffffffff ffffffff ffffffff ffffffff',
          'ffffffff ffffffff ffffffff ffffffff',
          'ffffffff ffffffff ffffffff ffffffff',
          'ffffffff'],
      // -3 mod p
      a: ['000001ff ffffffff ffffffff ffffffff',
          'ffffffff ffffffff ffffffff ffffffff',
          'ffffffff ffffffff ffffffff ffffffff',
          'ffffffff ffffffff ffffffff ffffffff',
          'fffffffc'],
      b: ['00000051 953eb961 8e1c9a1f 929a21a0',
          'b68540ee a2da725b 99b315f3 b8b48991',
          '8ef109e1 56193951 ec7e937b 1652c0bd',
          '3bb1bf07 3573df88 3d2c34f1 ef451fd4',
          '6b503f00'],
      n: ['000001ff ffffffff ffffffff ffffffff',
          'ffffffff ffffffff ffffffff ffffffff',
          'fffffffa 51868783 bf2f966b 7fcc0148',
          'f709a5d0 3bb5c9b8 899c47ae bb6fb71e',
          '91386409'],
      h: '1',
      // SSWU
      z: '-4',
      g: [
        ['000000c6 858e06b7 0404e9cd 9e3ecb66',
         '2395b442 9c648139 053fb521 f828af60',
         '6b4d3dba a14b5e77 efe75928 fe1dc127',
         'a2ffa8de 3348b3c1 856a429b f97e7e31',
         'c2e5bd66'],
        ['00000118 39296a78 9a3bc004 5c8a5fb4',
         '2c7d1bd9 98f54449 579b4468 17afbd17',
         '273e662c 97ee7299 5ef42640 c550b901',
         '3fad0761 353c7086 a272c240 88be9476',
         '9fd16650'],
        pre
      ]
    });
  }
}

/**
 * SECP256K1
 * https://www.secg.org/SEC2-Ver-1.0.pdf (page 15, section 2.7.1)
 * https://www.secg.org/sec2-v2.pdf (page 9, section 2.4.1)
 */

class SECP256K1 extends ShortCurve {
  constructor(pre) {
    super({
      id: 'SECP256K1',
      ossl: 'secp256k1',
      type: 'short',
      endian: 'be',
      hash: 'SHA256',
      prime: 'k256',
      // 2^256 - 2^32 - 977 (= 3 mod 4)
      p: ['ffffffff ffffffff ffffffff ffffffff',
          'ffffffff ffffffff fffffffe fffffc2f'],
      a: '0',
      b: '7',
      n: ['ffffffff ffffffff ffffffff fffffffe',
          'baaedce6 af48a03b bfd25e8c d0364141'],
      h: '1',
      // SVDW
      z: '1',
      // sqrt(-3)
      c: ['0a2d2ba9 3507f1df 233770c2 a797962c',
          'c61f6d15 da14ecd4 7d8d27ae 1cd5f852'],
      g: [
        ['79be667e f9dcbbac 55a06295 ce870b07',
         '029bfcdb 2dce28d9 59f2815b 16f81798'],
        ['483ada77 26a3c465 5da4fbfc 0e1108a8',
         'fd17b448 a6855419 9c47d08f fb10d4b8'],
        pre
      ],
      // Precomputed endomorphism.
      endo: {
        beta: ['7ae96a2b 657c0710 6e64479e ac3434e9',
               '9cf04975 12f58995 c1396c28 719501ee'],
        lambda: ['5363ad4c c05c30e0 a5261c02 8812645a',
                 '122e22ea 20816678 df02967c 1b23bd72'],
        basis: [
          {
            a: '3086d221a7d46bcde86c90e49284eb15',
            b: '-e4437ed6010e88286f547fa90abfe4c3'
          },
          {
            a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
            b: '3086d221a7d46bcde86c90e49284eb15'
          }
        ],
        pre: [
          384,
          ['3086d221 a7d46bcd e86c90e4 9284eb15',
           '3daa8a14 71e8ca7f e893209a 45dbb031'],
          ['-',
           'e4437ed6 010e8828 6f547fa9 0abfe4c4',
           '221208ac 9df506c6 1571b4ae 8ac47f71']
        ]
      }
    });
  }
}

/**
 * BRAINPOOLP256
 * https://tools.ietf.org/html/rfc5639#section-3.4
 */

class BRAINPOOLP256 extends ShortCurve {
  constructor(pre) {
    super({
      id: 'BRAINPOOLP256',
      ossl: 'brainpoolP256r1',
      type: 'short',
      endian: 'be',
      hash: 'SHA256',
      prime: null,
      // (= 3 mod 4)
      p: ['a9fb57db a1eea9bc 3e660a90 9d838d72',
          '6e3bf623 d5262028 2013481d 1f6e5377'],
      a: ['7d5a0975 fc2c3057 eef67530 417affe7',
          'fb8055c1 26dc5c6c e94a4b44 f330b5d9'],
      b: ['26dc5c6c e94a4b44 f330b5d9 bbd77cbf',
          '95841629 5cf7e1ce 6bccdc18 ff8c07b6'],
      n: ['a9fb57db a1eea9bc 3e660a90 9d838d71',
          '8c397aa3 b561a6f7 901e0e82 974856a7'],
      h: '1',
      // Icart
      z: '-2',
      g: [
        ['8bd2aeb9 cb7e57cb 2c4b482f fc81b7af',
         'b9de27e1 e3bd23c2 3a4453bd 9ace3262'],
        ['547ef835 c3dac4fd 97f8461a 14611dc9',
         'c2774513 2ded8e54 5c1d54c7 2f046997'],
        pre
      ]
    });
  }
}

/**
 * BRAINPOOLP384
 * https://tools.ietf.org/html/rfc5639#section-3.6
 */

class BRAINPOOLP384 extends ShortCurve {
  constructor(pre) {
    super({
      id: 'BRAINPOOLP384',
      ossl: 'brainpoolP384r1',
      type: 'short',
      endian: 'be',
      hash: 'SHA384',
      prime: null,
      // (= 3 mod 4)
      p: ['8cb91e82 a3386d28 0f5d6f7e 50e641df',
          '152f7109 ed5456b4 12b1da19 7fb71123',
          'acd3a729 901d1a71 87470013 3107ec53'],
      a: ['7bc382c6 3d8c150c 3c72080a ce05afa0',
          'c2bea28e 4fb22787 139165ef ba91f90f',
          '8aa5814a 503ad4eb 04a8c7dd 22ce2826'],
      b: ['04a8c7dd 22ce2826 8b39b554 16f0447c',
          '2fb77de1 07dcd2a6 2e880ea5 3eeb62d5',
          '7cb43902 95dbc994 3ab78696 fa504c11'],
      n: ['8cb91e82 a3386d28 0f5d6f7e 50e641df',
          '152f7109 ed5456b3 1f166e6c ac0425a7',
          'cf3ab6af 6b7fc310 3b883202 e9046565'],
      h: '1',
      // SSWU
      z: '-5',
      g: [
        ['1d1c64f0 68cf45ff a2a63a81 b7c13f6b',
         '8847a3e7 7ef14fe3 db7fcafe 0cbd10e8',
         'e826e034 36d646aa ef87b2e2 47d4af1e'],
        ['8abe1d75 20f9c2a4 5cb1eb8e 95cfd552',
         '62b70b29 feec5864 e19c054f f9912928',
         '0e464621 77918111 42820341 263c5315'],
        pre
      ]
    });
  }
}

/**
 * BRAINPOOLP512
 * https://tools.ietf.org/html/rfc5639#section-3.7
 */

class BRAINPOOLP512 extends ShortCurve {
  constructor(pre) {
    super({
      id: 'BRAINPOOLP512',
      ossl: 'brainpoolP512r1',
      type: 'short',
      endian: 'be',
      hash: 'SHA512',
      prime: null,
      // (= 3 mod 4)
      p: ['aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07',
          'cb308db3 b3c9d20e d6639cca 70330871',
          '7d4d9b00 9bc66842 aecda12a e6a380e6',
          '2881ff2f 2d82c685 28aa6056 583a48f3'],
      a: ['7830a331 8b603b89 e2327145 ac234cc5',
          '94cbdd8d 3df91610 a83441ca ea9863bc',
          '2ded5d5a a8253aa1 0a2ef1c9 8b9ac8b5',
          '7f1117a7 2bf2c7b9 e7c1ac4d 77fc94ca'],
      b: ['3df91610 a83441ca ea9863bc 2ded5d5a',
          'a8253aa1 0a2ef1c9 8b9ac8b5 7f1117a7',
          '2bf2c7b9 e7c1ac4d 77fc94ca dc083e67',
          '984050b7 5ebae5dd 2809bd63 8016f723'],
      n: ['aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07',
          'cb308db3 b3c9d20e d6639cca 70330870',
          '553e5c41 4ca92619 41866119 7fac1047',
          '1db1d381 085ddadd b5879682 9ca90069'],
      h: '1',
      // Icart
      z: '7',
      g: [
        ['81aee4bd d82ed964 5a21322e 9c4c6a93',
         '85ed9f70 b5d916c1 b43b62ee f4d0098e',
         'ff3b1f78 e2d0d48d 50d1687b 93b97d5f',
         '7c6d5047 406a5e68 8b352209 bcb9f822'],
        ['7dde385d 566332ec c0eabfa9 cf7822fd',
         'f209f700 24a57b1a a000c55b 881f8111',
         'b2dcde49 4a5f485e 5bca4bd8 8a2763ae',
         'd1ca2b2f a8f05406 78cd1e0f 3ad80892'],
        pre
      ]
    });
  }
}

/**
 * X25519
 * https://tools.ietf.org/html/rfc7748#section-4.1
 */

class X25519 extends MontCurve {
  constructor() {
    super({
      id: 'X25519',
      ossl: 'X25519',
      type: 'mont',
      endian: 'le',
      hash: 'SHA512',
      prime: 'p25519',
      // 2^255 - 19 (= 5 mod 8)
      p: ['7fffffff ffffffff ffffffff ffffffff',
          'ffffffff ffffffff ffffffff ffffffed'],
      // 486662
      a: '76d06',
      b: '1',
      n: ['10000000 00000000 00000000 00000000',
          '14def9de a2f79cd6 5812631a 5cf5d3ed'],
      h: '8',
      // Elligator 2
      z: '2',
      g: [
        ['00000000 00000000 00000000 00000000',
         '00000000 00000000 00000000 00000009'],
        // See: https://www.rfc-editor.org/errata/eid4730
        ['5f51e65e 475f794b 1fe122d3 88b72eb3',
         '6dc2b281 92839e4d d6163a5d 81312c14']
      ],
      torsion: [
        [],
        [
          ['00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000'],
          ['00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000']
        ],
        [
          ['00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000001'],
          ['6be4f497 f9a9c2af c21fa77a d7f4a6ef',
           '635a11c7 284a9363 e9a248ef 9c884415']
        ],
        [
          ['00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000001'],
          ['141b0b68 06563d50 3de05885 280b5910',
           '9ca5ee38 d7b56c9c 165db710 6377bbd8']
        ],
        [
          ['57119fd0 dd4e22d8 868e1c58 c45c4404',
           '5bef839c 55b1d0b1 248c50a3 bc959c5f'],
          ['68c59389 3d458e64 31c6ca00 45fb5015',
           '20a44346 8eaa68dd 0f103842 048065b7']
        ],
        [
          ['57119fd0 dd4e22d8 868e1c58 c45c4404',
           '5bef839c 55b1d0b1 248c50a3 bc959c5f'],
          ['173a6c76 c2ba719b ce3935ff ba04afea',
           'df5bbcb9 71559722 f0efc7bd fb7f9a36']
        ],
        [
          ['00b8495f 16056286 fdb1329c eb8d09da',
           '6ac49ff1 fae35616 aeb8413b 7c7aebe0'],
          ['3931c129 569e83a5 29482c14 e628b457',
           '933bfc29 ed801b4d 68871483 92507b1a']
        ],
        [
          ['00b8495f 16056286 fdb1329c eb8d09da',
           '6ac49ff1 fae35616 aeb8413b 7c7aebe0'],
          ['46ce3ed6 a9617c5a d6b7d3eb 19d74ba8',
           '6cc403d6 127fe4b2 9778eb7c 6daf84d3']
        ]
      ]
    });
  }
}

/**
 * X448
 * https://tools.ietf.org/html/rfc7748#section-4.2
 */

class X448 extends MontCurve {
  constructor() {
    super({
      id: 'X448',
      ossl: 'X448',
      type: 'mont',
      endian: 'le',
      hash: 'SHAKE256',
      prime: 'p448',
      // 2^448 - 2^224 - 1 (= 3 mod 4)
      p: ['ffffffff ffffffff ffffffff ffffffff',
          'ffffffff ffffffff fffffffe ffffffff',
          'ffffffff ffffffff ffffffff ffffffff',
          'ffffffff ffffffff'],
      // 156326
      a: '262a6',
      b: '1',
      n: ['3fffffff ffffffff ffffffff ffffffff',
          'ffffffff ffffffff ffffffff 7cca23e9',
          'c44edb49 aed63690 216cc272 8dc58f55',
          '2378c292 ab5844f3'],
      h: '4',
      // Elligator 2
      z: '-1',
      g: [
        ['00000000 00000000 00000000 00000000',
         '00000000 00000000 00000000 00000000',
         '00000000 00000000 00000000 00000000',
         '00000000 00000005'],
        ['7d235d12 95f5b1f6 6c98ab6e 58326fce',
         'cbae5d34 f55545d0 60f75dc2 8df3f6ed',
         'b8027e23 46430d21 1312c4b1 50677af7',
         '6fd7223d 457b5b1a']
      ],
      torsion: [
        [],
        [
          ['00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000000'],
          ['00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000000']
        ],
        [
          ['ffffffff ffffffff ffffffff ffffffff',
           'ffffffff ffffffff fffffffe ffffffff',
           'ffffffff ffffffff ffffffff ffffffff',
           'ffffffff fffffffe'],
          ['ba4d3a08 29b6112f 8812e51b a0bb2abe',
           'bc1cb08e b48e5569 36ba50fd d2e7d68a',
           'f8cb3216 0522425b 3f990812 abbe635a',
           'd37a21e1 7551b193']
        ],
        [
          ['ffffffff ffffffff ffffffff ffffffff',
           'ffffffff ffffffff fffffffe ffffffff',
           'ffffffff ffffffff ffffffff ffffffff',
           'ffffffff fffffffe'],
          ['45b2c5f7 d649eed0 77ed1ae4 5f44d541',
           '43e34f71 4b71aa96 c945af01 2d182975',
           '0734cde9 faddbda4 c066f7ed 54419ca5',
           '2c85de1e 8aae4e6c']
        ]
      ]
    });
  }
}

/**
 * MONT448
 * Isomorphic to Ed448-Goldilocks.
 */

class MONT448 extends MontCurve {
  constructor() {
    super({
      id: 'MONT448',
      ossl: null,
      type: 'mont',
      endian: 'le',
      hash: 'SHAKE256',
      prime: 'p448',
      // 2^448 - 2^224 - 1 (= 3 mod 4)
      p: ['ffffffff ffffffff ffffffff ffffffff',
          'ffffffff ffffffff fffffffe ffffffff',
          'ffffffff ffffffff ffffffff ffffffff',
          'ffffffff ffffffff'],
      // -78160 / -39082 mod p
      a: ['b2cf97d2 d43459a9 31ed36b1 fc4e3cb5',
          '5d93f8d2 22746997 60ccffc6 49961ed6',
          'c5b05fca c24864ed 6fb59697 931b78da',
          '84ddecd8 ca2b5cfb'],
      b: '1',
      n: ['3fffffff ffffffff ffffffff ffffffff',
          'ffffffff ffffffff ffffffff 7cca23e9',
          'c44edb49 aed63690 216cc272 8dc58f55',
          '2378c292 ab5844f3'],
      h: '4',
      // Elligator 2
      z: '-1',
      g: [
        ['ac0d24cc c6c75cb0 eb71f81e 7a6edf51',
         '48e88aee 009a2a24 e795687e c28e125a',
         '3e6730a6 0d46367b aa7fe99d 152128dc',
         '41321bc7 7817f059'],
        ['5a4437f6 80c0d0db 9b061276 d5d0ffcc',
         'e786ff33 b6a53d30 98746425 82e66f09',
         '4433dae7 7244a6e2 6b11e905 7228f483',
         '556c41a5 913f55fe']
      ],
      torsion: [
        [],
        [
          ['00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000000'],
          ['00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000000']
        ],
        [
          ['ffffffff ffffffff ffffffff ffffffff',
           'ffffffff ffffffff fffffffe ffffffff',
           'ffffffff ffffffff ffffffff ffffffff',
           'ffffffff fffffffe'],
          ['bec92fd0 6da2acf2 b4e261e8 7cef0d34',
           '22e75c18 3c589857 b71924e5 73c2f9ce',
           'e18da5f2 466e2f39 3c2eedf0 f105a60a',
           'b40c717d 4f1e1fd7']
        ],
        [
          ['ffffffff ffffffff ffffffff ffffffff',
           'ffffffff ffffffff fffffffe ffffffff',
           'ffffffff ffffffff ffffffff ffffffff',
           'ffffffff fffffffe'],
          ['4136d02f 925d530d 4b1d9e17 8310f2cb',
           'dd18a3e7 c3a767a8 48e6db19 8c3d0631',
           '1e725a0d b991d0c6 c3d1120f 0efa59f5',
           '4bf38e82 b0e1e028']
        ]
      ]
    });
  }
}

/**
 * ED25519
 * https://tools.ietf.org/html/rfc8032#section-5.1
 */

class ED25519 extends EdwardsCurve {
  constructor(pre) {
    super({
      id: 'ED25519',
      ossl: 'ED25519',
      type: 'edwards',
      endian: 'le',
      hash: 'SHA512',
      prefix: 'SigEd25519 no Ed25519 collisions',
      context: false,
      prime: 'p25519',
      // 2^255 - 19 (= 5 mod 8)
      p: ['7fffffff ffffffff ffffffff ffffffff',
          'ffffffff ffffffff ffffffff ffffffed'],
      a: '-1',
      // -121665 / 121666 mod p
      d: ['52036cee 2b6ffe73 8cc74079 7779e898',
          '00700a4d 4141d8ab 75eb4dca 135978a3'],
      n: ['10000000 00000000 00000000 00000000',
          '14def9de a2f79cd6 5812631a 5cf5d3ed'],
      h: '8',
      // Elligator 2
      z: '2',
      g: [
        ['216936d3 cd6e53fe c0a4e231 fdd6dc5c',
         '692cc760 9525a7b2 c9562d60 8f25d51a'],
        // 4/5
        ['66666666 66666666 66666666 66666666',
         '66666666 66666666 66666666 66666658'],
        pre
      ],
      torsion: [
        [
          ['00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000'],
          ['00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000001']
        ],
        [
          ['00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000'],
          ['7fffffff ffffffff ffffffff ffffffff',
           'ffffffff ffffffff ffffffff ffffffec']
        ],
        [
          ['2b832480 4fc1df0b 2b4d0099 3dfbd7a7',
           '2f431806 ad2fe478 c4ee1b27 4a0ea0b0'],
          ['00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000']
        ],
        [
          ['547cdb7f b03e20f4 d4b2ff66 c2042858',
           'd0bce7f9 52d01b87 3b11e4d8 b5f15f3d'],
          ['00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000']
        ],
        [
          ['1fd5b9a0 06394a28 e9339932 38de4abb',
           '5c193c70 13e5e238 dea14646 c545d14a'],
          ['05fc536d 880238b1 3933c6d3 05acdfd5',
           'f098eff2 89f4c345 b027b2c2 8f95e826']
        ],
        [
          ['602a465f f9c6b5d7 16cc66cd c721b544',
           'a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3'],
          ['05fc536d 880238b1 3933c6d3 05acdfd5',
           'f098eff2 89f4c345 b027b2c2 8f95e826']
        ],
        [
          ['1fd5b9a0 06394a28 e9339932 38de4abb',
           '5c193c70 13e5e238 dea14646 c545d14a'],
          ['7a03ac92 77fdc74e c6cc392c fa53202a',
           '0f67100d 760b3cba 4fd84d3d 706a17c7']
        ],
        [
          ['602a465f f9c6b5d7 16cc66cd c721b544',
           'a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3'],
          ['7a03ac92 77fdc74e c6cc392c fa53202a',
           '0f67100d 760b3cba 4fd84d3d 706a17c7']
        ]
      ]
    });
  }
}

/**
 * ISO448
 * https://tools.ietf.org/html/rfc7748#section-4.2
 * https://git.zx2c4.com/goldilocks/tree/_aux/ristretto/ristretto.sage#n658
 */

class ISO448 extends EdwardsCurve {
  constructor(pre) {
    super({
      id: 'ISO448',
      ossl: null,
      type: 'edwards',
      endian: 'le',
      hash: 'SHAKE256',
      prefix: 'SigEd448',
      context: true,
      prime: 'p448',
      // 2^448 - 2^224 - 1 (= 3 mod 4)
      p: ['ffffffff ffffffff ffffffff ffffffff',
          'ffffffff ffffffff fffffffe ffffffff',
          'ffffffff ffffffff ffffffff ffffffff',
          'ffffffff ffffffff'],
      a: '1',
      // 39082 / 39081 mod p
      d: ['d78b4bdc 7f0daf19 f24f38c2 9373a2cc',
          'ad461572 42a50f37 809b1da3 412a12e7',
          '9ccc9c81 264cfe9a d0809970 58fb61c4',
          '243cc32d baa156b9'],
      n: ['3fffffff ffffffff ffffffff ffffffff',
          'ffffffff ffffffff ffffffff 7cca23e9',
          'c44edb49 aed63690 216cc272 8dc58f55',
          '2378c292 ab5844f3'],
      h: '4',
      // Elligator 2
      z: '-1',
      g: [
        ['79a70b2b 70400553 ae7c9df4 16c792c6',
         '1128751a c9296924 0c25a07d 728bdc93',
         'e21f7787 ed697224 9de732f3 8496cd11',
         '69871309 3e9c04fc'],
        // Note: the RFC has this wrong.
        ['7fffffff ffffffff ffffffff ffffffff',
         'ffffffff ffffffff ffffffff 80000000',
         '00000000 00000000 00000000 00000000',
         '00000000 00000001'],
        pre
      ],
      torsion: [
        [
          ['00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000000'],
          ['00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000001']
        ],
        [
          ['00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000000'],
          ['ffffffff ffffffff ffffffff ffffffff',
           'ffffffff ffffffff fffffffe ffffffff',
           'ffffffff ffffffff ffffffff ffffffff',
           'ffffffff fffffffe']
        ],
        [
          ['00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000001'],
          ['00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000000']
        ],
        [
          ['ffffffff ffffffff ffffffff ffffffff',
           'ffffffff ffffffff fffffffe ffffffff',
           'ffffffff ffffffff ffffffff ffffffff',
           'ffffffff fffffffe'],
          ['00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000000']
        ]
      ]
    });
  }
}

/**
 * ED448
 * https://tools.ietf.org/html/rfc8032#section-5.2
 */

class ED448 extends EdwardsCurve {
  constructor(pre) {
    super({
      id: 'ED448',
      ossl: 'ED448',
      type: 'edwards',
      endian: 'le',
      hash: 'SHAKE256',
      prefix: 'SigEd448',
      context: true,
      prime: 'p448',
      // 2^448 - 2^224 - 1 (= 3 mod 4)
      p: ['ffffffff ffffffff ffffffff ffffffff',
          'ffffffff ffffffff fffffffe ffffffff',
          'ffffffff ffffffff ffffffff ffffffff',
          'ffffffff ffffffff'],
      a: '1',
      // -39081 mod p
      d: ['ffffffff ffffffff ffffffff ffffffff',
          'ffffffff ffffffff fffffffe ffffffff',
          'ffffffff ffffffff ffffffff ffffffff',
          'ffffffff ffff6756'],
      n: ['3fffffff ffffffff ffffffff ffffffff',
          'ffffffff ffffffff ffffffff 7cca23e9',
          'c44edb49 aed63690 216cc272 8dc58f55',
          '2378c292 ab5844f3'],
      h: '4',
      // Elligator 2
      z: '-1',
      g: [
        ['4f1970c6 6bed0ded 221d15a6 22bf36da',
         '9e146570 470f1767 ea6de324 a3d3a464',
         '12ae1af7 2ab66511 433b80e1 8b00938e',
         '2626a82b c70cc05e'],
        ['693f4671 6eb6bc24 88762037 56c9c762',
         '4bea7373 6ca39840 87789c1e 05a0c2d7',
         '3ad3ff1c e67c39c4 fdbd132c 4ed7c8ad',
         '9808795b f230fa14'],
        pre
      ],
      torsion: [
        [
          ['00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000000'],
          ['00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000001']
        ],
        [
          ['00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000000'],
          ['ffffffff ffffffff ffffffff ffffffff',
           'ffffffff ffffffff fffffffe ffffffff',
           'ffffffff ffffffff ffffffff ffffffff',
           'ffffffff fffffffe']
        ],
        [
          ['00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000001'],
          ['00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000000']
        ],
        [
          ['ffffffff ffffffff ffffffff ffffffff',
           'ffffffff ffffffff fffffffe ffffffff',
           'ffffffff ffffffff ffffffff ffffffff',
           'ffffffff fffffffe'],
          ['00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000000 00000000 00000000',
           '00000000 00000000']
        ]
      ]
    });
  }
}

/*
 * Curve Registry
 */

const curves = {
  __proto__: null,
  P192,
  P224,
  P256,
  P384,
  P521,
  SECP256K1,
  BRAINPOOLP256,
  BRAINPOOLP384,
  BRAINPOOLP512,
  X25519,
  X448,
  MONT448,
  ED25519,
  ISO448,
  ED448
};

const cache = {
  __proto__: null,
  P192: null,
  P224: null,
  P256: null,
  P384: null,
  P521: null,
  SECP256K1: null,
  BRAINPOOLP256: null,
  BRAINPOOLP384: null,
  BRAINPOOLP512: null,
  X25519: null,
  X448: null,
  MONT448: null,
  ED25519: null,
  ISO448: null,
  ED448: null
};

function curve(name, ...args) {
  assert(typeof name === 'string');

  const key = name.toUpperCase();

  let curve = cache[key];

  if (!curve) {
    const Curve = curves[key];

    if (!Curve)
      throw new Error(`Curve not found: "${name}".`);

    curve = new Curve(...args);
    cache[key] = curve;
  }

  return curve;
}

function register(name, Curve) {
  assert(typeof name === 'string');
  assert(typeof Curve === 'function');

  const key = name.toUpperCase();

  if (curves[key])
    throw new Error(`Curve already registered: "${name}".`);

  curves[key] = Curve;
  cache[key] = null;
}

/*
 * Scalar Recoding
 */

function getNAF(k, width, max) {
  // Computing the width-w NAF of a positive integer.
  //
  // [GECC] Algorithm 3.35, Page 100, Section 3.3.
  //
  // The above document describes a rather abstract
  // method of recoding. The more optimal method
  // below was ported from libsecp256k1.
  assert(k instanceof BN);
  assert(!k.red);
  assert((width >>> 0) === width);
  assert((max >>> 0) === max);

  const naf = new Array(max);
  const bits = k.bitLength() + 1;
  const sign = k.sign() | 1;

  assert(bits <= max);

  for (let i = 0; i < max; i++)
    naf[i] = 0;

  let i = 0;
  let carry = 0;
  let word;

  while (i < bits) {
    if (k.bit(i) === carry) {
      i += 1;
      continue;
    }

    word = k.bits(i, width) + carry;
    carry = (word >> (width - 1)) & 1;
    word -= carry << width;

    naf[i] = sign * word;

    i += width;
  }

  assert(carry === 0);

  return naf;
}

function getFixedNAF(k, width, max, step) {
  assert((step >>> 0) === step);

  // Recode to NAF.
  const naf = getNAF(k, width, max);

  // Translate into more windowed form.
  const len = Math.ceil(naf.length / step);
  const repr = new Array(len);

  let i = 0;

  for (let j = 0; j < naf.length; j += step) {
    let nafW = 0;

    for (let k = j + step - 1; k >= j; k--)
      nafW = (nafW << 1) + naf[k];

    repr[i++] = nafW;
  }

  assert(i === len);

  return repr;
}

function getJSF(k1, k2, max) {
  // Joint sparse form.
  //
  // [GECC] Algorithm 3.50, Page 111, Section 3.3.
  assert(k1 instanceof BN);
  assert(k2 instanceof BN);
  assert(!k1.red);
  assert(!k2.red);
  assert((max >>> 0) === max);

  const jsf = [new Array(max), new Array(max)];
  const bits = Math.max(k1.bitLength(), k2.bitLength()) + 1;
  const s1 = k1.sign() | 1;
  const s2 = k2.sign() | 1;

  assert(bits <= max);

  let d1 = 0;
  let d2 = 0;

  for (let i = 0; i < bits; i++) {
    const b1 = k1.bits(i, 3);
    const b2 = k2.bits(i, 3);

    // First phase.
    let m14 = ((b1 & 3) + d1) & 3;
    let m24 = ((b2 & 3) + d2) & 3;
    let u1 = 0;
    let u2 = 0;

    if (m14 === 3)
      m14 = -1;

    if (m24 === 3)
      m24 = -1;

    if (m14 & 1) {
      const m8 = ((b1 & 7) + d1) & 7;

      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }

    if (m24 & 1) {
      const m8 = ((b2 & 7) + d2) & 7;

      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }

    jsf[0][i] = u1 * s1;
    jsf[1][i] = u2 * s2;

    // Second phase.
    if (2 * d1 === 1 + u1)
      d1 = 1 - d1;

    if (2 * d2 === 1 + u2)
      d2 = 1 - d2;
  }

  for (let i = bits; i < max; i++) {
    jsf[0][i] = 0;
    jsf[1][i] = 0;
  }

  return jsf;
}

function getJNAF(c1, c2, max) {
  const jsf = getJSF(c1, c2, max);
  const naf = new Array(max);

  // JSF -> NAF conversion.
  for (let i = 0; i < max; i++) {
    const ja = jsf[0][i];
    const jb = jsf[1][i];

    naf[i] = jsfIndex[(ja + 1) * 3 + (jb + 1)];
  }

  return naf;
}

/*
 * Helpers
 */

function assert(val, msg) {
  if (!val) {
    const err = new Error(msg || 'Assertion failed');

    if (Error.captureStackTrace)
      Error.captureStackTrace(err, assert);

    throw err;
  }
}

function wrapErrors(fn) {
  assert(typeof fn === 'function');

  try {
    return fn();
  } catch (e) {
    if (e.message === 'X is not a square mod P.'
        || e.message === 'Not invertible.') {
      throw new Error('Invalid point.');
    }
    throw e;
  }
}

function mod(x, y) {
  // Euclidean modulo.
  let r = x % y;

  if (r < 0) {
    if (y < 0)
      r -= y;
    else
      r += y;
  }

  return r;
}

function cubeRoot(x) {
  assert(x instanceof BN);
  assert(x.red);

  const p = x.red.m;

  if (p.cmpn(3) <= 0)
    return x.clone();

  // p = 2 mod 3
  if (p.modrn(3) === 2) {
    // e = (2 * p - 1) / 3
    const e = p.ushln(1).isubn(1).idivn(3);
    return x.redPow(e);
  }

  const mod9 = p.modrn(9);

  // p = 4 mod 9
  if (mod9 === 4) {
    // e = (2 * p + 1) / 9
    const e = p.ushln(1).iaddn(1).idivn(9);
    const r = x.redPow(e);
    const c = r.redSqr().redMul(r);

    if (!c.eq(x))
      throw new Error('X is not a cube mod P.');

    return r;
  }

  // p = 7 mod 9
  if (mod9 === 7) {
    // e = (p + 2) / 9
    const e = p.addn(2).idivn(9);
    const r = x.redPow(e);
    const c = r.redSqr().redMul(r);

    if (!c.eq(x))
      throw new Error('X is not a cube mod P.');

    return r;
  }

  throw new Error('Not implemented.');
}

function cubeRoots(x) {
  const r0 = cubeRoot(x);

  // p = 1 mod 3
  if (x.red.m.modrn(3) === 1) {
    // Multiply by roots of unity to find other roots.
    const two = new BN(2).toRed(x.red);
    const three = new BN(3).toRed(x.red);
    const i2 = two.redInvert();
    const s1 = three.redNeg().redSqrt().redMul(i2);
    const s2 = s1.redNeg();
    const u1 = s1.redSub(i2);
    const u2 = s2.redSub(i2);
    const r1 = r0.redMul(u1);
    const r2 = r0.redMul(u2);

    return [r0, r1, r2];
  }

  // p = 2 mod 3 guarantees 1 cube root per element.
  return [r0];
}

function uncube(x) {
  // Find a cube root which is also a quadratic residue.
  for (const root of cubeRoots(x)) {
    if (root.redJacobi() >= 0)
      return root;
  }

  throw new Error('X^(1/3) is not a square mod P.');
}

function randomInt(rng) {
  return BN.randomBits(rng, 32).toNumber();
}

function memoize(method, self) {
  const cache = new WeakMap();

  return function memoized(curve, invert) {
    const i = invert & 1;
    const item = cache.get(curve);

    if (item && item[i] !== null)
      return item[i];

    const result = method.call(self, curve, invert);

    if (!cache.has(curve))
      cache.set(curve, [null, null]);

    cache.get(curve)[i] = result;

    return result;
  };
}

function toPretty(x, size) {
  assert(x instanceof BN);
  assert((size >>> 0) === size);

  if (size & 7)
    size += 8 - (size & 7);

  const str = x.toString(16, size);
  const chunks = [];
  const out = [];

  assert((str.length & 7) === 0);

  for (let i = 0; i < str.length; i += 8)
    chunks.push(str.slice(i, i + 8));

  for (let i = 0; i < chunks.length; i += 4)
    out.push(chunks.slice(i, i + 4).join(' '));

  return out;
}

/*
 * Expose
 */

exports.Curve = Curve;
exports.Point = Point;
exports.ShortCurve = ShortCurve;
exports.ShortPoint = ShortPoint;
exports.JPoint = JPoint;
exports.MontCurve = MontCurve;
exports.MontPoint = MontPoint;
exports.XPoint = XPoint;
exports.EdwardsCurve = EdwardsCurve;
exports.EdwardsPoint = EdwardsPoint;
exports.curves = curves;
exports.curve = curve;
exports.register = register;
}],
[/* 66 */ 'bcrypto', '/lib/p384-browser.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * p384.js - p384 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */



module.exports = __browser_require__(67 /* './js/p384' */, module);
}],
[/* 67 */ 'bcrypto', '/lib/js/p384.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * p384.js - ECDSA-P384 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */



const ECDSA = __browser_require__(60 /* './ecdsa' */, module);
const SHA384 = __browser_require__(34 /* '../sha384' */, module);

/*
 * Expose
 */

module.exports = new ECDSA('P384', SHA384, SHA384);
}],
[/* 68 */ 'bcrypto', '/lib/ed25519-browser.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * ed25519.js - ed25519 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */



module.exports = __browser_require__(69 /* './js/ed25519' */, module);
}],
[/* 69 */ 'bcrypto', '/lib/js/ed25519.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * ed25519.js - ed25519 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/EdDSA#Ed25519
 *   https://ed25519.cr.yp.to/ed25519-20110926.pdf
 *   https://tools.ietf.org/html/rfc8032#section-5.1
 */



const EDDSA = __browser_require__(70 /* './eddsa' */, module);
const SHA512 = __browser_require__(37 /* '../sha512' */, module);
const pre = __browser_require__(71 /* './precomputed/ed25519.json' */, module);

/*
 * Expose
 */

module.exports = new EDDSA('ED25519', 'X25519', null, SHA512, pre);
}],
[/* 70 */ 'bcrypto', '/lib/js/eddsa.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * eddsa.js - EdDSA for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/elliptic:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/elliptic
 *
 * References:
 *
 *   [EDDSA] High-speed high-security signatures
 *     D. J. Bernstein, N. Duif, T. Lange, P. Schwabe, B. Yang
 *     https://ed25519.cr.yp.to/ed25519-20110926.pdf
 *
 *   [RFC8032] Edwards-Curve Digital Signature Algorithm (EdDSA)
 *     S. Josefsson, I. Liusvaara
 *     https://tools.ietf.org/html/rfc8032
 *
 * Implementation Notes:
 *
 *   - In contrast to the ECDSA backend, we allow points at
 *     infinity (in all functions).
 *
 *   - Mike Hamburg's Ed448-Goldilocks rejects both infinity as
 *     well as the torsion point (0, -1). We do not replicate
 *     this behavior.
 *
 *   - For Ed25519, we do "cofactor-less" verification by default.
 *     This means torsion components will affect the result of the
 *     verification.
 *
 *   - For Ed448, we do cofactor verification by default to mimic
 *     OpenSSL and Mike Hamburg's Ed448-Goldilocks implementation.
 *
 *   - `verifySingle`/`verifyBatch` do cofactor verification. Do
 *     not use `verifyBatch` expecting the same results as the
 *     regular `verify` call[1]. This will not be the case for
 *     Ed25519.
 *
 *   - All functions are completely unaware of points of small
 *     order and torsion components (in other words, points will
 *     not be explicitly checked for this, anywhere).
 *
 *   - `deriveWithScalar` and `exchangeWithScalar` automatically
 *     clamp scalars before multiplying (meaning torsion components
 *     are removed from the result and points of small order will
 *     be normalized to infinity).
 *
 *   - The HD function, `publicKeyTweakMul`, _does not_ clamp
 *     automatically. It is possible to end up with a torsion
 *     component in the resulting point (assuming the input
 *     point had one).
 *
 *   - Ed448-Goldilocks is 4-isogenous to Curve448. This means
 *     that when converting to Curve448, small order points will
 *     be normalized to (0, 0). When converting back to Ed448,
 *     any small order points will be normalized to infinity,
 *     and any torsion components will be removed completely.
 *     Also note that when converting back, the implementation
 *     needs to divide the point by 4. This is a major perf hit,
 *     so treat `x448.publicKeyConvert` as if it were a point
 *     multiplication.
 *
 *   - Elligators should not be used with Edwards curves. As
 *     Tibouchi notes[2], regular public keys will map to
 *     _distinguishable_ field elements as they are always in
 *     the primary subgroup. Either the Ristretto Elligator[3],
 *     or a prime order curve with an Elligator Squared[2]
 *     construction are suitable alternatives here.
 *
 *   - These notes also spell out why you should avoid using
 *     Edwards curves on a blockchain[4].
 *
 *   [1] https://moderncrypto.org/mail-archive/curves/2016/000836.html
 *   [2] https://eprint.iacr.org/2014/043.pdf
 *   [3] https://ristretto.group/formulas/elligator.html
 *   [4] https://src.getmonero.org/2017/05/17/disclosure-of-a-major-bug-in-cryptonote-based-currencies.html
 */



const assert = __browser_require__(24 /* '../internal/assert' */, module);
const BatchRNG = __browser_require__(62 /* './batch-rng' */, module);
const BN = __browser_require__(42 /* '../bn' */, module);
const elliptic = __browser_require__(65 /* './elliptic' */, module);
const rng = __browser_require__(45 /* '../random' */, module);

/*
 * EDDSA
 */

class EDDSA {
  constructor(id, mid, eid, hash, pre) {
    assert(typeof id === 'string');
    assert(!mid || typeof mid === 'string');
    assert(!eid || typeof eid === 'string');
    assert(hash);

    this.id = id;
    this.type = 'eddsa';
    this.mid = mid || null;
    this.eid = eid || null;
    this.hash = hash;
    this.native = 0;

    this._pre = pre || null;
    this._curve = null;
    this._mont = null;
    this._iso = null;
    this._rng = null;
  }

  get curve() {
    if (!this._curve) {
      this._curve = elliptic.curve(this.id, this._pre);
      this._curve.precompute(rng);
      this._pre = null;
    }
    return this._curve;
  }

  get mont() {
    if (this.mid && !this._mont)
      this._mont = elliptic.curve(this.mid);
    return this._mont;
  }

  get iso() {
    if (!this.eid)
      return this.mont;

    if (!this._iso)
      this._iso = elliptic.curve(this.eid);

    return this._iso;
  }

  get rng() {
    if (!this._rng)
      this._rng = new BatchRNG(this.curve);

    return this._rng;
  }

  get size() {
    return this.curve.adjustedSize;
  }

  get bits() {
    return this.curve.fieldBits;
  }

  hashNonce(prefix, msg, ph, ctx) {
    const hash = new Hash(this);

    hash.init(ph, ctx);
    hash.update(prefix);
    hash.update(msg);

    return hash.final();
  }

  hashChallenge(R, A, m, ph, ctx) {
    const hash = new Hash(this);

    hash.init(ph, ctx);
    hash.update(R);
    hash.update(A);
    hash.update(m);

    return hash.final();
  }

  privateKeyGenerate() {
    return rng.randomBytes(this.curve.adjustedSize);
  }

  scalarGenerate() {
    const scalar = rng.randomBytes(this.curve.scalarSize);
    return this.curve.clamp(scalar);
  }

  privateKeyExpand(secret) {
    assert((secret != null && secret._isBuffer === true));
    assert(secret.length === this.curve.adjustedSize);

    const hash = this.hash.digest(secret, this.curve.adjustedSize * 2);

    return this.curve.splitHash(hash);
  }

  privateKeyConvert(secret) {
    const [key] = this.privateKeyExpand(secret);
    return key;
  }

  privateKeyVerify(secret) {
    assert((secret != null && secret._isBuffer === true));
    return secret.length === this.curve.adjustedSize;
  }

  scalarVerify(scalar) {
    assert((scalar != null && scalar._isBuffer === true));
    return scalar.length === this.curve.scalarSize;
  }

  scalarIsZero(scalar) {
    assert((scalar != null && scalar._isBuffer === true));

    let k;
    try {
      k = this.curve.decodeScalar(scalar).imod(this.curve.n);
    } catch (e) {
      return false;
    }

    return k.isZero();
  }

  scalarClamp(scalar) {
    assert((scalar != null && scalar._isBuffer === true));
    assert(scalar.length === this.curve.scalarSize);

    return this.curve.clamp(Buffer.from(scalar));
  }

  privateKeyExport(secret) {
    const pub = this.publicKeyCreate(secret);
    const {x, y} = this.publicKeyExport(pub);

    return {
      d: Buffer.from(secret),
      x,
      y
    };
  }

  privateKeyImport(json) {
    assert(json && typeof json === 'object');
    assert((json.d != null && json.d._isBuffer === true));

    if (json.d.length !== this.curve.adjustedSize)
      throw new Error('Invalid private key.');

    return Buffer.from(json.d);
  }

  scalarTweakAdd(scalar, tweak) {
    const a = this.curve.decodeScalar(scalar);
    const t = this.curve.decodeScalar(tweak);
    const k = a.add(t).imod(this.curve.n);

    return this.curve.encodeScalar(k);
  }

  scalarTweakMul(scalar, tweak) {
    const a = this.curve.decodeScalar(scalar);
    const t = this.curve.decodeScalar(tweak);
    const k = a.mul(t).imod(this.curve.n);

    return this.curve.encodeScalar(k);
  }

  scalarReduce(scalar) {
    const a = this.curve.decodeScalar(scalar);
    const k = a.imod(this.curve.n);

    return this.curve.encodeScalar(k);
  }

  scalarNegate(scalar) {
    const a = this.curve.decodeScalar(scalar).imod(this.curve.n);
    const k = a.neg().imod(this.curve.n);

    return this.curve.encodeScalar(k);
  }

  scalarInvert(scalar) {
    const a = this.curve.decodeScalar(scalar).imod(this.curve.n);

    if (a.isZero())
      return this.curve.encodeScalar(a);

    const k = a.invert(this.curve.n);

    return this.curve.encodeScalar(k);
  }

  publicKeyCreate(secret) {
    const key = this.privateKeyConvert(secret);
    return this.publicKeyFromScalar(key);
  }

  publicKeyFromScalar(scalar) {
    const a = this.curve.decodeScalar(scalar).imod(this.curve.n);
    const A = this.curve.g.mulBlind(a);

    return A.encode();
  }

  publicKeyConvert(key) {
    if (!this.mont)
      throw new Error('No equivalent montgomery curve.');

    const A = this.curve.decodePoint(key);
    const P = this.mont.pointFromEdwards(A);

    return P.encode();
  }

  publicKeyFromUniform(bytes) {
    const u = this.curve.decodeUniform(bytes);
    const A = this.curve.pointFromUniform(u, this.iso);

    return A.encode();
  }

  publicKeyToUniform(key, hint = rng.randomInt()) {
    const A = this.curve.decodePoint(key);
    const u = this.curve.pointToUniform(A, hint, this.iso);

    return this.curve.encodeUniform(u, hint >>> 8);
  }

  publicKeyFromHash(bytes, pake = false) {
    const A = this.curve.pointFromHash(bytes, pake, this.iso);
    return A.encode();
  }

  publicKeyToHash(key, subgroup = rng.randomInt()) {
    const A = this.curve.decodePoint(key);
    return this.curve.pointToHash(A, subgroup, rng, this.iso);
  }

  publicKeyVerify(key) {
    assert((key != null && key._isBuffer === true));

    try {
      this.curve.decodePoint(key);
    } catch (e) {
      return false;
    }

    return true;
  }

  publicKeyIsInfinity(key) {
    assert((key != null && key._isBuffer === true));

    let A;
    try {
      A = this.curve.decodePoint(key);
    } catch (e) {
      return false;
    }

    return A.isInfinity();
  }

  publicKeyIsSmall(key) {
    assert((key != null && key._isBuffer === true));

    let A;
    try {
      A = this.curve.decodePoint(key);
    } catch (e) {
      return false;
    }

    return A.isSmall();
  }

  publicKeyHasTorsion(key) {
    assert((key != null && key._isBuffer === true));

    let A;
    try {
      A = this.curve.decodePoint(key);
    } catch (e) {
      return false;
    }

    return A.hasTorsion();
  }

  publicKeyExport(key) {
    const {x, y} = this.curve.decodePoint(key);

    return {
      x: this.curve.encodeField(x.fromRed()),
      y: this.curve.encodeField(y.fromRed())
    };
  }

  publicKeyImport(json) {
    assert(json && typeof json === 'object');

    let x = null;
    let y = null;
    let A;

    if (json.x != null) {
      x = BN.decode(json.x, this.curve.endian);

      if (x.cmp(this.curve.p) >= 0)
        throw new Error('Invalid point.');
    }

    if (json.y != null) {
      y = BN.decode(json.y, this.curve.endian);

      if (y.cmp(this.curve.p) >= 0)
        throw new Error('Invalid point.');
    }

    if (x && y) {
      A = this.curve.point(x, y);

      if (!A.validate())
        throw new Error('Invalid point.');
    } else if (x) {
      A = this.curve.pointFromX(x, json.sign);
    } else if (y) {
      A = this.curve.pointFromY(y, json.sign);
    } else {
      throw new Error('Invalid point.');
    }

    return A.encode();
  }

  publicKeyTweakAdd(key, tweak) {
    const t = this.curve.decodeScalar(tweak).imod(this.curve.n);
    const A = this.curve.decodePoint(key);
    const T = this.curve.g.mul(t);
    const P = T.add(A);

    return P.encode();
  }

  publicKeyTweakMul(key, tweak) {
    const t = this.curve.decodeScalar(tweak);
    const A = this.curve.decodePoint(key);
    const P = A.mul(t);

    return P.encode();
  }

  publicKeyCombine(keys) {
    assert(Array.isArray(keys));

    let P = this.curve.point();

    for (const key of keys) {
      const A = this.curve.decodePoint(key);

      P = P.add(A);
    }

    return P.encode();
  }

  publicKeyNegate(key) {
    const A = this.curve.decodePoint(key);
    const P = A.neg();

    return P.encode();
  }

  sign(msg, secret, ph, ctx) {
    const [key, prefix] = this.privateKeyExpand(secret);
    return this.signWithScalar(msg, key, prefix, ph, ctx);
  }

  signWithScalar(msg, scalar, prefix, ph, ctx) {
    // EdDSA Signing.
    //
    // [EDDSA] Page 12, Section 4.
    // [RFC8032] Page 8, Section 3.3.
    //
    // Assumptions:
    //
    //   - Let `H` be a cryptographic hash function.
    //   - Let `m` be a byte array of arbitrary size.
    //   - Let `a` be a secret scalar.
    //   - Let `w` be a secret byte array.
    //
    // Computation:
    //
    //   k = H(w, m) mod n
    //   R = G * k
    //   A = G * a
    //   e = H(R, A, m) mod n
    //   s = (k + e * a) mod n
    //   S = (R, s)
    //
    // Note that `k` must remain secret,
    // otherwise an attacker can compute:
    //
    //   a = (s - k) / e mod n
    //
    // The same is true of `w` as `k`
    // can be re-derived as `H(w, m)`.
    if (ctx == null)
      ctx = Buffer.alloc(0);

    assert((msg != null && msg._isBuffer === true));
    assert((prefix != null && prefix._isBuffer === true));
    assert(prefix.length === this.curve.adjustedSize);

    const {n} = this.curve;
    const G = this.curve.g;
    const k = this.hashNonce(prefix, msg, ph, ctx);
    const Rraw = G.mulBlind(k).encode();
    const a = this.curve.decodeScalar(scalar);
    const Araw = G.mulBlind(a).encode();
    const e = this.hashChallenge(Rraw, Araw, msg, ph, ctx);
    const s = k.add(e.mul(a)).imod(n);

    return Buffer.concat([Rraw, this.curve.encodeAdjusted(s)]);
  }

  signTweakAdd(msg, secret, tweak, ph, ctx) {
    const [key_, prefix_] = this.privateKeyExpand(secret);
    const key = this.scalarTweakAdd(key_, tweak);
    const expanded = this.hash.multi(prefix_, tweak, null,
                                     this.curve.adjustedSize * 2);
    const prefix = expanded.slice(0, this.curve.adjustedSize);

    return this.signWithScalar(msg, key, prefix, ph, ctx);
  }

  signTweakMul(msg, secret, tweak, ph, ctx) {
    const [key_, prefix_] = this.privateKeyExpand(secret);
    const key = this.scalarTweakMul(key_, tweak);
    const expanded = this.hash.multi(prefix_, tweak, null,
                                     this.curve.adjustedSize * 2);
    const prefix = expanded.slice(0, this.curve.adjustedSize);

    return this.signWithScalar(msg, key, prefix, ph, ctx);
  }

  verify(msg, sig, key, ph, ctx) {
    if (ctx == null)
      ctx = Buffer.alloc(0);

    assert((msg != null && msg._isBuffer === true));
    assert((sig != null && sig._isBuffer === true));
    assert((key != null && key._isBuffer === true));
    assert(ph == null || typeof ph === 'boolean');
    assert((ctx != null && ctx._isBuffer === true));

    if (sig.length !== this.curve.adjustedSize * 2)
      return false;

    if (key.length !== this.curve.adjustedSize)
      return false;

    try {
      return this._verify(msg, sig, key, ph, ctx);
    } catch (e) {
      return false;
    }
  }

  _verify(msg, sig, key, ph, ctx) {
    // EdDSA Verification.
    //
    // [EDDSA] Page 15, Section 5.
    // [RFC8032] Page 8, Section 3.4.
    //
    // Assumptions:
    //
    //   - Let `H` be a cryptographic hash function.
    //   - Let `m` be a byte array of arbitrary size.
    //   - Let `R` and `s` be signature elements.
    //   - Let `A` be a valid group element.
    //   - s < n.
    //
    // Computation:
    //
    //   e = H(R, A, m) mod n
    //   G * s == R + A * e
    //
    // Alternatively, we can compute:
    //
    //   R == G * s - A * e
    //
    // This allows us to make use of a
    // multi-exponentiation algorithm.
    const {n} = this.curve;
    const G = this.curve.g;
    const Rraw = sig.slice(0, this.curve.adjustedSize);
    const sraw = sig.slice(this.curve.adjustedSize);
    const R = this.curve.decodePoint(Rraw);
    const s = this.curve.decodeAdjusted(sraw);
    const A = this.curve.decodePoint(key);

    if (s.cmp(n) >= 0)
      return false;

    const e = this.hashChallenge(Rraw, key, msg, ph, ctx);

    return G.mulAdd(s, A.neg(), e).eq(R);
  }

  verifySingle(msg, sig, key, ph, ctx) {
    if (ctx == null)
      ctx = Buffer.alloc(0);

    assert((msg != null && msg._isBuffer === true));
    assert((sig != null && sig._isBuffer === true));
    assert((key != null && key._isBuffer === true));
    assert(ph == null || typeof ph === 'boolean');
    assert((ctx != null && ctx._isBuffer === true));

    if (sig.length !== this.curve.adjustedSize * 2)
      return false;

    if (key.length !== this.curve.adjustedSize)
      return false;

    try {
      return this._verifySingle(msg, sig, key, ph, ctx);
    } catch (e) {
      return false;
    }
  }

  _verifySingle(msg, sig, key, ph, ctx) {
    // EdDSA Verification (with cofactor multiplication).
    //
    // [EDDSA] Page 15, Section 5.
    // [RFC8032] Page 8, Section 3.4.
    //
    // Assumptions:
    //
    //   - Let `H` be a cryptographic hash function.
    //   - Let `m` be a byte array of arbitrary size.
    //   - Let `R` and `s` be signature elements.
    //   - Let `A` be a valid group element.
    //   - s < n.
    //
    // Computation:
    //
    //   e = H(R, A, m) mod n
    //   (G * s) * h == (R + A * e) * h
    //
    // Alternatively, we can compute:
    //
    //   R * h == G * (s * h) - (A * h) * e
    //
    // This allows us to make use of a
    // multi-exponentiation algorithm.
    const {n} = this.curve;
    const G = this.curve.g;
    const Rraw = sig.slice(0, this.curve.adjustedSize);
    const sraw = sig.slice(this.curve.adjustedSize);
    const R = this.curve.decodePoint(Rraw);
    const s = this.curve.decodeAdjusted(sraw);
    const A = this.curve.decodePoint(key);

    if (s.cmp(n) >= 0)
      return false;

    const e = this.hashChallenge(Rraw, key, msg, ph, ctx);
    const sh = this.curve.imulH(s);
    const Ah = A.mulH();
    const Rh = R.mulH();

    return G.mulAdd(sh, Ah.neg(), e).eq(Rh);
  }

  verifyBatch(batch, ph, ctx) {
    if (ctx == null)
      ctx = Buffer.alloc(0);

    assert(Array.isArray(batch));
    assert(ph == null || typeof ph === 'boolean');
    assert((ctx != null && ctx._isBuffer === true));

    for (const item of batch) {
      assert(Array.isArray(item) && item.length === 3);

      const [msg, sig, key] = item;

      assert((msg != null && msg._isBuffer === true));
      assert((sig != null && sig._isBuffer === true));
      assert((key != null && key._isBuffer === true));

      if (sig.length !== this.curve.adjustedSize * 2)
        return false;

      if (key.length !== this.curve.adjustedSize)
        return false;
    }

    try {
      return this._verifyBatch(batch, ph, ctx);
    } catch (e) {
      return false;
    }
  }

  _verifyBatch(batch, ph, ctx) {
    // EdDSA Batch Verification.
    //
    // [EDDSA] Page 16, Section 5.
    //
    // Assumptions:
    //
    //   - Let `H` be a cryptographic hash function.
    //   - Let `R` and `s` be signature elements.
    //   - Let `A` be a valid group element.
    //   - Let `i` be the batch item index.
    //   - s < n.
    //   - a1 = 1 mod n.
    //
    // Computation:
    //
    //   ei = H(Ri, Ai, mi) mod n
    //   ai = random integer in [1,n-1]
    //   lhs = (si * ai + ...) * h mod n
    //   rhs = (Ri * h) * ai + (Ai * h) * (ei * ai mod n) + ...
    //   G * -lhs + rhs == O
    const {n} = this.curve;
    const G = this.curve.g;
    const points = new Array(1 + batch.length * 2);
    const coeffs = new Array(1 + batch.length * 2);
    const sum = new BN(0);

    this.rng.init(batch);

    points[0] = G;
    coeffs[0] = sum;

    for (let i = 0; i < batch.length; i++) {
      const [msg, sig, key] = batch[i];
      const Rraw = sig.slice(0, this.curve.adjustedSize);
      const sraw = sig.slice(this.curve.adjustedSize);
      const R = this.curve.decodePoint(Rraw);
      const s = this.curve.decodeAdjusted(sraw);
      const A = this.curve.decodePoint(key);

      if (s.cmp(n) >= 0)
        return false;

      const e = this.hashChallenge(Rraw, key, msg, ph, ctx);
      const a = this.rng.generate(i);
      const ea = e.mul(a).imod(n);

      sum.iadd(s.mul(a)).imod(n);

      points[1 + i * 2 + 0] = R.mulH();
      coeffs[1 + i * 2 + 0] = a;
      points[1 + i * 2 + 1] = A.mulH();
      coeffs[1 + i * 2 + 1] = ea;
    }

    this.curve.imulH(sum.ineg());

    return this.curve.mulAll(points, coeffs).isInfinity();
  }

  derive(pub, secret) {
    const scalar = this.privateKeyConvert(secret);
    return this.deriveWithScalar(pub, scalar);
  }

  deriveWithScalar(pub, scalar) {
    const A = this.curve.decodePoint(pub);
    const a = this.curve.decodeClamped(scalar);
    const P = A.mulBlind(a, rng);

    if (P.isInfinity())
      throw new Error('Invalid point.');

    return P.encode();
  }
}

/*
 * Hash
 */

class Hash {
  constructor(eddsa) {
    this.curve = eddsa.curve;
    // eslint-disable-next-line
    this.hash = new eddsa.hash();
  }

  init(ph, ctx) {
    assert(ph == null || typeof ph === 'boolean');
    assert((ctx != null && ctx._isBuffer === true));

    if (ctx.length > 255)
      ctx = ctx.slice(0, 255);

    this.hash.init();

    if (this.curve.context || ph != null || ctx.length > 0) {
      if (this.curve.prefix)
        this.hash.update(this.curve.prefix);

      this.hash.update(byte(ph));
      this.hash.update(byte(ctx.length));
      this.hash.update(ctx);
    }

    return this;
  }

  update(data) {
    this.hash.update(data);
    return this;
  }

  final() {
    const hash = this.hash.final(this.curve.adjustedSize * 2);
    const num = BN.decode(hash, this.curve.endian);

    return num.imod(this.curve.n);
  }
}

/*
 * Helpers
 */

function byte(ch) {
  const buf = Buffer.alloc(1);
  buf[0] = ch & 0xff;
  return buf;
}

/*
 * Expose
 */

module.exports = EDDSA;
}],
[/* 71 */ 'bcrypto', '/lib/js/precomputed/ed25519.json', function(exports, require, module, __filename, __dirname, __meta) {
module.exports = {
  "naf": {
    "width": 9,
    "points": [
      [
        "67ae9c4a22928f491ff4ae743edac83a6343981981624886ac62485fd3f8e25c",
        "1267b1d177ee69aba126a18e60269ef79f16ec176724030402c3684878f5b4d4"
      ],
      [
        "49fda73eade3587bfcef7cf7d12da5de5c2819f93e1be1a591409cc0322ef233",
        "5f4825b298feae6fe02c6e148992466631282eca89430b5d10d21f83d676c8ed"
      ],
      [
        "14568685fcf4bd4ee9e3ee194b1d810783e809f3bbf1ce955855981af50e4107",
        "31c563e32b47d52f87ce6468dd36ad41f0882b46f7abf23d12c4c4b59f4062b8"
      ],
      [
        "357cc970c80071651bf336e06f9422b886d80e5c2e4e0294d3e023065185715c",
        "7f3d23c2c2dd0df4b2befce956f2d2fd1f789013236e4430c74e44845522f1c0"
      ],
      [
        "14e528b1154be417b6cf078dd6712438d381a5b2c593d552ff2fd2c1207cf3cb",
        "2d9082313f21ab975a6f7ce340ff0fce1258591c3c9c58d4308f2dc36a033713"
      ],
      [
        "107427e0d5f366ccdb33adf0282d304f8843e3e88d22b7b83780e073b7c05fed",
        "12dbb00ded538b7478466022d2da89b83740cfb2289a272387efe1aeea401f80"
      ],
      [
        "4f162deaec2ec435dc5ac6f95d20419ed9631374770189cb90617f3e66a18dc1",
        "12cbfb2d04ff22f55162f70164d29331ace5af18a19a9aa1946d4cc4ad2e5cdf"
      ],
      [
        "7dc52d5a7db816e9b850741ea2fd72918d94985b85a20b4dc5597853a876df6a",
        "6f6d2bca60003ef9f24ac245cc919fb717b188723b34f901cd6cfe9bec97be04"
      ],
      [
        "1d81f74a5ba45c7022e8c140d763b9c1b0e281a5304696e74f791a3a04a94472",
        "3f185a93d95a4347227c5bb6ddd65cf42e1830823f435f3083fe6102691d55b9"
      ],
      [
        "6f0ac78e5eb90e87958588f9d47541edf252cb1dde3d073cc45e3e7ef9365716",
        "6628d116b7975ae5f323e5ddf4f8cc35ae06d5c5c7d8a56effc66051336d289e"
      ],
      [
        "2188ac423c67db5625915e05222a391bcaf91f05d9b7cc2cab5798b2d2e14d95",
        "23240c559c57b79a4df69a23fc46e50504277b1fa49369ab663d79782b33c0ee"
      ],
      [
        "794241471ed9ceb009384b370cb8790fca98552ecb822dc06b19362c36353455",
        "71e918c03cdfca7207772e8d18ee8f9d92d79a0a83f378912362bc68d311dcd0"
      ],
      [
        "163bc180c22dfc5da23c5c052107bba93a88b4360aa1d4e729611d8f5a7f8079",
        "631107a6ba83f7458194b9766a0a54f638ca20daf800384dbae1498677501939"
      ],
      [
        "39a32a30f3eb1da0eb7e3903b8ace3da3890b24b61a3a9e79db663b5db0f7a5d",
        "4d4c54675dc1f1c9a1af9ca0010045dc803c16af345823136dd203715d67c491"
      ],
      [
        "38085391a0e2831f59c33fcce7591515784d359925f11ff958e0e4658efac0e9",
        "42918001a829f49b5634e34ab7fac21b30e24660669ed91955cc31944a19e62a"
      ],
      [
        "5e3573b049d6135ffbbbbd9a480617434f2455b4a591f719e91153eeb75a32a1",
        "54bc665420c789da1105d53983c1a0fc33bcc2690cd9b37d6566e21a85892871"
      ],
      [
        "7ed068b25b82c05fdc0e46bd80a357f3acd2f5c3b9330bc8d474e5b28270f6eb",
        "01da83a187da8ccca704d46557a462551d70df7f943a681c3b97b1db6a21b7d3"
      ],
      [
        "05ca3370e7516f6686111b72650aab4c5484407f14b515ade03951c6a14a0aa3",
        "6f407fc537b95277966e7f0f5e64b86904bf7baee091cee6011a3611834c6903"
      ],
      [
        "624cb312b698bbd6dbca79b8d2b53cb5d8b3ab33c19306e87c18211f095ab9c3",
        "5b3336b2751e97c793731ac9b9a2243b6229f6d0bbea6b619395d0e5200bd8a3"
      ],
      [
        "1ddf6ece608fe2901b34b7e4f47cfcb75e947e293c704d8121b11a31a051b5f9",
        "5e2dc58e9a48a749ce5296d229cfb34f96a147a8246d2e9844d52b52112ea94e"
      ],
      [
        "396b384f3d61cfc060308fbb1c941ebc9418e2d9abd81316e08d625f48c0e101",
        "7223e5f7b66d1ca24962bac273a7aa6618cc60cb8a64a8837e0261107e7ad644"
      ],
      [
        "53cc3dca3410277fb38d75e4ac0dde8e77a99c817170dbc9696cffe7890fbd50",
        "2592a3aafce64d7c69f4de468d5d5aa19845f5ca08f64a0a40e37d23ececbbe1"
      ],
      [
        "34705fe600f5aed77b29d3eacdffcd45d886904156d43dc550bb7fc889cc1368",
        "299153c141a8950ffbcc8e9352993e642fa39a476200dd4acf42e158dbe3b01e"
      ],
      [
        "5969255bd089181b991fce96b1792ba330a14f8a0b061f8118c9c336b8504618",
        "680a805fa0ae93c2a12b193517fb1147d355547e4ab18a9d6ca21575bbb4d7a4"
      ],
      [
        "27d1d57fa8808d3d452df14bda4248b37902752163b1fd499a92456c59918ecb",
        "0a42f1c0f4c5d7de9e82904f0b4ff63988d31fedb8aad9d8ae009c7a1dff09c3"
      ],
      [
        "0811d14bfdfdcf2144edd9cf55bce584a9ba17aec3eac8aaa82987ad703d9b8a",
        "42bea70d46f3ee0df0ec77d24c5495ea56ada2e0415920470c4746b68306376e"
      ],
      [
        "4de090761b863cb0f0650297f154a8e66d00c5119c38e5dd05303d905d527a4a",
        "5eef0efd105361ce198a30e09e7e7edffbe3d70189e63ca68cf6057b9772baa8"
      ],
      [
        "1d45517858ce45556aaee056ebab7e0ef3dc9ae3740aed570f3e76bfb4fc4817",
        "0b5a9d8fe8b7ccb04c0a5ef77798a3ec6e1bc1138604eb05e83844f0d4c5c699"
      ],
      [
        "4285edbe9117f30aae1ef5ee419eb1d472106c6b3d7f3ce3701e39324b0eeafc",
        "503aa6104a682bcf2c0a60c84f4c22b50b0caa0fed8db87dedc7173eae04bdbd"
      ],
      [
        "3ef830cbeff9b79039b1b6bd9bb52bbcfa56d008d91b9703ea1c80351f8687d6",
        "62349ff5d8dbd216a874769eec152ef9734bea9240eed623992c7553dc8ee4c8"
      ],
      [
        "649a996e6d4d3b60ccb526939ed8929134107e03e2fd4648eaa2fa9830822c1a",
        "1648311b942fe95d492a1ace5e5235c1aea860d036d2475cc8964cd1acedee9c"
      ],
      [
        "3a95596d97770d050d1ecc075d58a74f5fe6b4b8222740534ba22c8be73f9d56",
        "15a80cdcc03317a830fa4a7461de6bac136993e0a797f83b405c161a34c98fd7"
      ],
      [
        "2d265d3fe1c88903ca93685209418deec5af886bf0d9fdb3f499d831cbb76ce1",
        "08376fb0663d3aa220948612b519af4a6a1f956622b15a305fb2e60a84210b3c"
      ],
      [
        "642cb15498d8c6b25803f3e56b98e2ea185ac808cbeab5eb0a610ed5babb9385",
        "21b5ca5020a9e5a2334c0bee15193ea16c909963ffa6e1d93df4b239abeaeb3e"
      ],
      [
        "38e576301ff6cdd0822a19c6d610d445d3967e2bada903abb6220f68c6e79bef",
        "458fe689e31a24952d2817dda4349109c1b26ef31699fa36c4f8389eeb60eac0"
      ],
      [
        "372bec78d75011a0ef2233cd08790a7f15c1ec1e3a78cac8d6652678641780db",
        "32e9e47cf2f48612ed3e2c2006ea0c0c8476d3562aa88cefb67ec97abdb538e8"
      ],
      [
        "1aa3756aabcc3eb65afee34e0a15dd67bfb9fb199eb131f4cc6a3ca9ec4d1c77",
        "42333e27831add6eb49af80e17347c63c26dd684758096ee3dbdbe03a49159ae"
      ],
      [
        "38db16447d79d3590c4a36e20286beadfbae91a4eed2e5e7dd4f975ac0537dc5",
        "1c48ccaed60ec12ce862ea71165bba7df1739845df2a857f4ef0a0f714f96daa"
      ],
      [
        "176b78984cddfddef90bae619c6a98e951d9a7ac7d6af218ae7e76b273212fb7",
        "7b5b93eda77443f366e2a127abe12212aad8536767ec1c5861143f777db85852"
      ],
      [
        "042d154bf7b4a7bd73897ae528c6bc552ea58d74f8109e8e4052d3e9d38bb0f6",
        "42d1831323e279f9f7ee9e3470ba20ca7edc3245eca5d8ffa182de120a71fc90"
      ],
      [
        "1f8d28dd4f286a8d0687b626b01204434bf5874a9550d6e375116490c154e108",
        "1ce82e2360367e06f41757fd45239f9bc2c61609139446b09b55a9c43da98bb8"
      ],
      [
        "613eb914c015076e9ae8356bf508c289e50b1c87d9e2546f6e406362e248e5e5",
        "3edbaafcd8c41ef4aa18b254137d201a2ef0ca4ca28807156bc949e920b97353"
      ],
      [
        "27bf43826bf0310b4b3e3a405eff790a1d77a8d48b04891246cff8e193cb03a9",
        "16a24d749cc1d234fbe8af9cfd782c3aaa5869d6db0afa7b4d4c67037514f2ea"
      ],
      [
        "769a6a59746d7bead417bdd9c3b5f5ae1dbd924083ffd9e88df7714f57a675c2",
        "22dc1267cfb2b41c590abb7dc3df45619af688d0421f2bdfb50748335ec5da25"
      ],
      [
        "795734ee4fcc24194219d25d41a2889cdb942f765848e9df63bff0b158c7224d",
        "756420ab5c71127d39d2e79907634a177af0e483e08484ea4d7b76f7100669b5"
      ],
      [
        "644d12fc5e7fcac5aeb5911d8240971a99fc59fdd2903f46958e6896aefbcf46",
        "173450789fcd40172e8124fea56f7aedad2ee13fa8fc5209cc8cb572175216dc"
      ],
      [
        "5deca767ef17b9e8d4f351f5c8ad1fcc50e97a2ed687516bf5210679fd6c1110",
        "4ddf2207da12f700708089989da016f3307ce5721c9e27c952599d67898aa396"
      ],
      [
        "296dcb24cb3185d037a94bef93c97cacd09fc7050ba8472da59d4a689d9d2848",
        "0b17dc85a4acf73833fab728f15abccac97cd09e57975bd996d3e1dd8b060f7b"
      ],
      [
        "408a3f1af2e77dfe94f8e225b40dfc146abb1002db7bcf15fde61c1a6cf1b93f",
        "4f01ec38854c15a879e7c7924f048e2ec951dcdf04a614088b68fbcc0954e1c8"
      ],
      [
        "07d2d9234970cdc9483e0a7c5ec52c49077c440e0a993a1e624f90b8fafbbf07",
        "6ac2190030c210ae3e07b9239f6ee7affba263866ee7831a564c511f703f2295"
      ],
      [
        "2982d553002082320aa899b9b6887e40dedf11868fa931689795d93d58452873",
        "215e16ca447978624cad0ea6bf45aada4eca914425ee275db2a26e980dc349b6"
      ],
      [
        "1d8649515cb49e136d2895b6276569e5c711fe1a343eeb5a3daaa8d0e7b42d1a",
        "5b21e2f2978f343a3e9ec3316cdc111af3b55f34afa5fc3fcbf6c26c1bb7fb6c"
      ],
      [
        "5460df4d607147939cdbc04dbdcbdffd37c5eafdd501b50a67213a23ee724a97",
        "69dfc7004263ccb52487d34ab134b80bb3030273999739cb9cdc16d71b9abcd8"
      ],
      [
        "24623476f0af9f42ca15a0697ad23abeaf5ed9dc4d2b44f7e8175486598125bb",
        "6aebe4a1a22d9e31194dcde6d33ff3af77dda15c22b2ecba9329849b8c042687"
      ],
      [
        "64e507a02bfd8a8413117bac253b17f94b2911681ebc07c92da0de6a651dd538",
        "513ac992d72b463da110afb612fbae36590248a0507d845ee95fab2d1caa03a4"
      ],
      [
        "47f3bd11324f6bee230a22a5bb06a3ccddbc0473b810689efaeef894a654bf0e",
        "7e05db9b3ff886bf32608dfc8d14eaa91e2e2ef230e7c75618060e4285c492be"
      ],
      [
        "4a6d22703a7045d02d656015ea2d168385d42963a739a895e4fd87b3e55c5e0f",
        "4c58d7a8c6ded0451798e51f16ffa5b637a87aa5defb119ba868d8cccf61776d"
      ],
      [
        "3e22af70a548097244d7798964598172a90391f84c59b04cea7af283ba368eb5",
        "689d8b7cda23b8dea197c5119fbbbd81dd4b59a36cc283dbe292b5b6519a2968"
      ],
      [
        "61a6ba2ca42d9d557b3a2ff0867c1b8bb8fc40192d31ff637431a302bc065a10",
        "63d805f5a79f845ea2915a25cf0a8cab2e0255212a1bd3c8852b25579b63721d"
      ],
      [
        "03d963eeae48556e88305f91c478efcfd2168c346b9ba185884ec8621e8cb414",
        "74b75cc839a944ad8c639719d20fd9d48d2099ef24c8633eabec7a9ec1e7e183"
      ],
      [
        "0f04da69e0202f7b44c58b103c88de09a0599951fedb17e7f2152d6b93a58ae9",
        "1fbc1c9cd03c4cfd46e8e90019debf86e8036587eade038346f91070c800b8c4"
      ],
      [
        "797899e488353ed0c6666aff11913b33be0190833766e809b2a68cbc671a9cfe",
        "5dd70a33ff94a84b3fe660f7070e6179e86b5c846689265bf985ce424b8909cc"
      ],
      [
        "735b64bb872606510e4e7d57833eb7ffdc4aa0dbaa242439806be68379f77cdd",
        "384aaaee3ca7ba2436fcb65910859ca5ec30c10af11df7d777d287bc1a2bce2c"
      ],
      [
        "6f6ea532a62cf4766f55a0a72a86b55e73fe9d3328ee94bfc271e122f99dc1ac",
        "61d8203ef6da5d0b584541c02331c7f58617cf8d4f26d11776236ce8b113ac10"
      ],
      [
        "5d99a2a3d4aed730b827b68ed836a9910dce4e7b93faf456981ad6cd85748773",
        "7eeacf5680fb6108a8b7edb45f7134644111b08e17c236469685af5a79474b9e"
      ],
      [
        "31d0b4bb57bd7b69363c064a49bf3c3b9d7635bcc287e7b3059d3d99fd8382e8",
        "1592e581034e13d47d02b8966f5359097e652391be8fb1e803f4219a22aba2c0"
      ],
      [
        "424cf5c498bbbe8fa7e5c3247049cc3f45946d0e5f38c44a36a6c84b60a84aa0",
        "34acd712d334a2315dc8fd00c5c9b7c5c9f29bca27380a018882a5ab4a0fcb43"
      ],
      [
        "33a6ae0522936ba774837aa7959972f9804e3ef02ae84c8039be6595598be247",
        "37022798cc08be9b4ded34c1c5062ab3a26081d375cadf517972fb48135a6602"
      ],
      [
        "5939635b72aeba595b5f6e376d11a3e07d4b1153ab4d0a7ab267b8bcc47cc3cb",
        "382162eb33db2322cbe01a38fa4d13720b6d8edfaf8116a628725ef4293a6c27"
      ],
      [
        "3649e78d2ae9fb0ee86b691c27386efce4f3e383790e3cfee2bd59c2e85c4036",
        "09b0d9e0dd82e697b9be9d61ce0d1410e281122b483125c48f7942b22f5d5be4"
      ],
      [
        "62c7585d1677b7619d8200175346ec99118416d8fdf0103730d165934e96a973",
        "5fef7955ee07304429995433a468d68dec4ecf6b08bbe8cd06869080094044de"
      ],
      [
        "0c94537d311e17f5b0c58989b5be7e40c88b978a8c074a1e9bb07a713f77f6d3",
        "6deaaa5001bcbbbe9ae436fe42f7042ce74fbf83c14058427fad4587ed33c4e2"
      ],
      [
        "6f5c6894a8d3877312e608c11809c15dffec3df551711095c8cfc810533e1b3e",
        "74eadab9389b40d6ac6cc0d6e333d628ced60a9ef7617751c20630d23477af7b"
      ],
      [
        "4e16e88e171f9a07e11f97bba65c0fe5483501f255343afb3335ed47fbcee08f",
        "41bcd7dd328871247cb7995bc6bd2e1961e94b0fb12e5fb2f264f9ad2cf47d4c"
      ],
      [
        "65d8484cef146e6c232fb262c2ac8200a52c63ccec26ff6f038aa5c74982c741",
        "67283346bbae9391952b141e57ca8e3a36f0363d3b81b1c0f2b3c30a92c74235"
      ],
      [
        "1c588485b64be8cb99bf97f065e75a82138ea2e035ba90b63745354e9cf729f8",
        "7c9a18d6ebf5465a197989cfb9b5b2a66a5402f46c4708ac04187c6b157a0d77"
      ],
      [
        "2c80c4ad0aebcafab7e9d2519a329f8a1c7df21cb6b1acec7403c0204d6dce71",
        "7f8e62983160756e35356df95d44467e621c7274372997ca74a9fb760b4db36f"
      ],
      [
        "1e1e5fc87fa2c49e2c44d5718e3d73c73a91a64ac1374652080bd9004291b9c6",
        "153828e90ed8d94c0f86e0eb54ccb31073cd29ed62c34cd9f2dbc5d98872e597"
      ],
      [
        "0ce0488a30ed446d445efb1bd21ba32ec3d05d538e6393bc0e58e0849ad57129",
        "7278074ac66ac779136f4d6a334b27633645dea0fc98d137e3dbd4015d12b5a1"
      ],
      [
        "01a6b81f7285f293f19ba019b009aed8280ce285af42fab91e87fb0bbfa6dea4",
        "60f910dc7c9a82e7836f36acfe7ec26b9babfa8bf26b2945b3c1a43b0c19b4dc"
      ],
      [
        "79b4ce3c6990023859646690c9ea800174902acfa1aad7ff34eca032dbde7150",
        "53a1053d3fc6c749bf8a928854f392d09fa851ba963ca661bffbe74f012ba45b"
      ],
      [
        "220ee355b5c39c1901ed34c0f50f7778ad1bedcd7259ae167c16514ffe333498",
        "05fd9374986e1e06035dbfada0117035b96b159354262f2b2695af1256d6aa2a"
      ],
      [
        "1e2f97d2cb4a19ca40403b364253da71f65d2d4665894267e3c6a9db8b4a3a18",
        "22804fb035acb519210ff99ed7a974a725d896a77933789b4dd45a37dea3466d"
      ],
      [
        "35b8699fa20987876ac3b3086965b05f8cc809d71cab45e017c68ac96e24ed5b",
        "155079de21981778dc438353bf2c6a65967a1a33ebb74c866fb42f4e3cce3e39"
      ],
      [
        "3cb40c55f5f19c52958e8c4ecd9c459b1d3268b3971b2286d3e58d1fc6b6a6bd",
        "379e1f1f59df05c74485615b87441ba6203f0cdddc6873a883d4cc6dd1b75921"
      ],
      [
        "6ad916290e0d003ce5c961679f77704dcd768589d7cb728c60f56852031803bf",
        "1e602b4a6725832a56944234f84c4f85f79911b55beef903549089925f2ccbea"
      ],
      [
        "7c0162492ae668160aa56a60e8bd43ec088555f750d2223cc37362dead5de123",
        "34e60b446eae100d4c3abc6cb02e4ca559457fb5a9030a290a2568fa4cbf118f"
      ],
      [
        "354c25bf7b3e83dd0c5e1f39b82e3567edeb5337634056c1091cd6a016caacdf",
        "7abb271ef121630f85a9a1049b3ad78d5b889f533b37a713b8801de46770fc3a"
      ],
      [
        "1e581a4bcf7504f33f4342b2097504d13f9b5a27f4790a6cdde1242209862850",
        "2164d56564360fd2b5dba2f2c6ef1045ab448c3b60b2f2196c2f74625fc39e07"
      ],
      [
        "533b56f18283ee79b9a180b887c298961bd9aaa6fa3ef97fcb0d5688e694bc3d",
        "6011366753812df2bce83634a92dbac18dd1cffdbf9a97fa1b1d5b49e0026764"
      ],
      [
        "4b508b94e6e2e6cd260a20664ea7d727ad20587b63ebe826032e0d20cdc6627b",
        "1e8ecd6ff5aabae78172a0214d07a5013992d133af58afa74049de726df2a6c4"
      ],
      [
        "3398c0c0219f5ac87a8c73fcd17b89311d120a53f5231cb761030c194fed4265",
        "025b234a1dc8662c068c4ba903939c2f79f3f7a3ae64e5edbf667b13599142d9"
      ],
      [
        "5941a17b04cd3465031cb6745cb94eed24e1ff8d38a6e832f1637ae8e89c78e6",
        "5309792c546b6cda458be331957763b5adb5d535d54a4a61023678faa2ee02ee"
      ],
      [
        "2cb490d2c0047fcbaffe1df26640bee73c158af6fec91343d606ce9d124a20c9",
        "2e2952ebf089200aebfa3947f241e2fe85797afebdc1ea06d9d26de1b446a964"
      ],
      [
        "79305236b583232a91c63c7d9ca3750be7ee21711e4d6d257c39ae398212bde1",
        "6f9ecdfa953e302c2014fd8512405e4be0d48302acd15e93936e8dba7d01053b"
      ],
      [
        "57d9fcb884b94664f35387fa6665cd9bc8136f90d804d77416ea99c3c653ee63",
        "14197e65f0a3599c0b9fcef75b5fbb93580d1b2457b59fb70ce7b9bac88d0fbc"
      ],
      [
        "6d99df2c28c9fa1e38acddefd3e0931109143d873f3330377a9926bdacdd6523",
        "2f21987905f397f092fc56c5ccd301a1e6afa3c4611627e25017b2e68d07c150"
      ],
      [
        "749d19591f1755bd481fa12a288166aac42911654c8c551395b265116269ceb9",
        "7ec145aa7558d0342cd87b1750933cb6f3717e727a86a1cc1f2b0c274213688d"
      ],
      [
        "340f7f5ae19292957902635a5786d14fa38036b324ae759da501e32b8c4073f1",
        "64e231a413f1379a26f4e8223ff91fe2ccd865549571d3c6c28871964b40a0ea"
      ],
      [
        "4aa33e00bf6e92cac4e84384e5dde0727394233afd5d24d357a8afeb94b08109",
        "3385bb4fbc441937ee01b671d506227a654fd6c1c532cf5221710c6c56ec7e21"
      ],
      [
        "34b2ffca05f01088de266306c5cc122661e9308eab16929774e58565afc0e4eb",
        "7662faf0f70e82c062c2b835fc6da3353d3cb20b80611ffa6ef2982cf62fa605"
      ],
      [
        "820fcb51326f1536ddb8dc1052aa198406c7e48f2c81e7664d15f8f9d3715e",
        "756574c23bb01170b97d9fa1663a8ff2f5b97eaa5cd53f34140c1bcec8c262d9"
      ],
      [
        "0861d7e84cec6d6e33641ff6c85202fc0e9160797809ddc2193802499caf05d3",
        "34936e0a5dc7e2a6217d475fbb8c1c607fb8b3565908a04fd5948abdd399c59f"
      ],
      [
        "5b4a1dc887ef684d7b4b165b70acb70842a2fa105935af15ecb4a097e33b8f2b",
        "54d21511c05805e5298a72372b8289e9d59c46dc8b5c368bbfda620b68aa652c"
      ],
      [
        "755493ed60b13f03f9c019362a5af73fb49842dd6916e2572b1b6a312cd20cfc",
        "0750bcbf7e449cec422b93ace1489e1b177d4dbbaa781d315c74d54bb444e9a9"
      ],
      [
        "5f1c341065b6a81ed2edb6bc38ba81b4c2e3fe2058e5baa13e1406eb2c5b4b4b",
        "6179ebfa7f8086f26820fc99ca2f94c1be19bca672d79cea5b02a836119e06ba"
      ],
      [
        "1915024ee86acfba3f61ced9707521197195166fb1c4639bf3b3fcf0bf0ded46",
        "5f2e0547032221d2b00937cf524590e3d90901ef0286ea0b032c1a81461b6d92"
      ],
      [
        "4e942d95930f38c8786ff4a8e576e7a29fb7627afe1fff91cda5006ba0624f5d",
        "45902f695d512d70ce4c1e0520c0060896b94e14d2960b2fcf2ed5e138e0217b"
      ],
      [
        "63e45f3d91ab915d412bbaa17d1d249e1a1445077fbfaa6be7d35041c5116a91",
        "46dad5a4ec2ad0b86938f5e09f1c03b53b660fc5137648b08527cd20708003da"
      ],
      [
        "5e2ddd2175417f72c9962c503ac5adf94ed11f28b9d41fccb6a4512886f3cc87",
        "3523b218478911145af1dc431feb7db0a04066eb6e2ade3c7b67d11bc55323aa"
      ],
      [
        "62ff30a6b179a26e7247a8312cb3af3289e5d722f76a29f203aa623889aa05ec",
        "562beb7999019346beaa80dfd5b95d614e1ff96c1cb1037f65c44997b797d066"
      ],
      [
        "14988b5d62084fb8335c2f261cdeddc1b634b09cedfce713ff5f0a0bb588a556",
        "447068731fb98e821b8e413b3b48f2d1c8bea308f05aac877006b0f4c3b0cab3"
      ],
      [
        "1ac777f708a5942cc434236920e82ccc6af920c0a0676712255aa7082b37a5b6",
        "52a6f88d92af1887c781501c6e3a88169a2831b74aefd416f22b47e8335ce317"
      ],
      [
        "5959792833b71bd5042b78e42212af671f5f87a08eafd8cdde2dcec8140e4bb3",
        "41ce94633eabb8a1b08fac66f762997ed8c9e2af3558e1f6586ad6a5bf5b7b64"
      ],
      [
        "4464a7962e6722b457336fe98c91765b1ff178f9e892e90129e65fa7688a0607",
        "3d1510b92fd33c501f058a7a86bddedf1b83f9b6e4f04829d321117013f891fe"
      ],
      [
        "62906d81e7f800e662519f4324ab4c8aac197661c729eed3e744d09efe721c08",
        "4b68efb5b1b709ab86e3253d70bee87ba07875c04a64ecf7e35cd8cdc6c0f7d8"
      ],
      [
        "4300ff025ac78ef36e58ee7d0d732cf76cd0929fe265b3a093a57f23fc326757",
        "2f92880570846ff2e90d91f16bce3705c9c3ca8011cc543091463b623e4b3c01"
      ],
      [
        "5427ba28d94652527a9b0c76f57a451e46bdc06cbc8a2481df17f66ffb1524e3",
        "547a97c4afc8d1f74a5d51f7e524f68472f589cc0b396b21368628721537d722"
      ],
      [
        "424c4493810bfd5e3ffa21776326d8ff62bf8fe74504d7a2db5d3f74e5ce1015",
        "74d0daa832d40405d01551a58b330ffc5abd5356230d6d7cabeb5b1a55046f32"
      ],
      [
        "54e10980d81b4ae8778896684295fa5c5475e8d68ec2a26e1b0a65383507b3cd",
        "6b1eb48da6886c4d88cea720e9dc8b0d8c51a8f0e1943afa31a40eeb553c0676"
      ],
      [
        "732eb9e9ebb556e9f024c5574166738f4707b0fd005f568212ab575c1db71ddb",
        "1fc6b00c89e48114d6b13d9920a0c78093994f2b08df147bdbb56bead2cea165"
      ],
      [
        "74029c04b34b7f314855fee42a04d0ddfdeb92ef3bf7cff629928a97733d96fb",
        "501f63a252dfbc090733b5a208bfe08f81c91419ce3d2d6c0de8cdc5a5625014"
      ],
      [
        "04524402ebb71a60bf1055001000203a6d4917f112e50dd766cdd7b718a6edd7",
        "71c9e2d15cdc47c565a696ffbe55277570930ed7ade13b9a254059365d5bf338"
      ],
      [
        "2555c620a50f2bbeeacac66228a96941fa733aa6070855331613578ed7c12794",
        "2b3c1bc5cda7f93242561dbf7572237ac43bf013553230633a5e18b7e71597e5"
      ],
      [
        "555ea607b0ad18afaf70d7450543d7ffb5b883a3cad3e2778826ca97bf3211a6",
        "6df903158f51aa530d411720a760f8ad0ce9904d54955fda74a349be58eddf5f"
      ],
      [
        "4db3cfa284207a250a9c83e1fec07e804d70065da586ff2c2a7d2bcb92e6fca6",
        "2a4fbf1c51dc0b2a7783db2be3bd35c2d6462470c88c8b73ae3ce8503fa07154"
      ],
      [
        "5174e33ffdf28a87184a4d6427d821cbaa3b88ac293a90ca7e1eeae8c5050b16",
        "315ca6bc8e35e4a3d06f89e1db1575b16197963ee8e64746fa998ccd403561cc"
      ]
    ]
  },
  "doubles": {
    "step": 4,
    "points": [
      [
        "23a4860627e53aeeb8e22b1508249c9109578d33e7bf237459b2596d6c28f9f8",
        "709696f2827fc3729f980f2e3aad6e78b06a11ff8e079c27d87aab37c16727eb"
      ],
      [
        "5e7e07ed4e1decbfe6e9cbc126905449d4b578fbb561576d20b8bcdd0cc2a556",
        "0f55755c51f102796bf5ebaa81d3260e7d1b3d9ac127d9a80e142031566cf6c7"
      ],
      [
        "7d13c0248b891b47eb524f2692008e2f97b199bac426cb5902b9003a29ded6ea",
        "59a976ab2c01a81a91f1a56c75ccc77a9e1e9e878e9fe9c3952080a6805b20d5"
      ],
      [
        "5de7faa2ee4e70132f541f79ca07cd54a39fe1347a6844d19e9d678a8411a565",
        "2c9f23641e1c2e0aab8ea9926b432d92c0e8bc08901d6ff6df85e4cef854ec36"
      ],
      [
        "06b349eebfed4dad4a805b63a6ed2231a565cda752d9477ff427dd9a8c9ab5ed",
        "07a09289ff3e1f9aab68aa374c48df65f550c2323607b97744dee990608b64f8"
      ],
      [
        "0af367956af630266b1cc760154256ed79da960dddca9d72a1e8cf27d8d43a77",
        "21108d900134d3b3708dd28ace96b0b23dda9100e4b6a62a8131bd2f2ba408c5"
      ],
      [
        "1e45a60140a3b2dee9b8dc6ff307154a1b410bcd38e0e38fb10b2f6da1afbe2b",
        "0e730da473dffd60d2f3241a85e68acb47d26e5043ad047d893f072c8dda0a76"
      ],
      [
        "4d1e116d136158c5ddabd4276832800f2c081c1072de6f2d931797a46abc0cbb",
        "6d415be49d4e35b65cc51354b5008f8c43e84b7b5e8a4b84f44e1efb10c9b91a"
      ],
      [
        "2b6b892ae94b454b2c2d92bb947fc4d506d173d281779c2c153c001ded42d3d0",
        "7f1cf64e0e180fc4d6e12c1b5c5285f376e979616a52c94a0dea4d48c5880cd2"
      ],
      [
        "0f6c3a96e0032a9394337a02ffb2c83ba70efb8f566feab530fc90fa3b4710e5",
        "3d4e97e286378675038a4b58e84224ee515e1d6697ac79389f78479be167635a"
      ],
      [
        "52ee53b981dfbc41ddaa5ddc2754c4175f4811aa45f8e2b19a425657c238a83e",
        "7eb0a1be3400dec87b388cad51613957643cdf0595b891cc6f925fb36da7f1c3"
      ],
      [
        "52a837bc7a7bc9459bcc2ecf80f74d9ed99def0342e18cfbe8e799fbc504fd52",
        "50d6460185d8924e5485f23f36a98c86053514d163547adab6fe91478a411196"
      ],
      [
        "6b2bd5d00fab38ceca21a27d6aaec82626b14b555d859527718f8ca404eba4",
        "727340c27a15f6ab3d80547f0827c56ab1ba33bc30d1ef3909ea9a3af10c67e5"
      ],
      [
        "71dd75fe35761c01a48597ec730bc33237902fd4ad8612cbed1031eebdf40de4",
        "39674a4532078e34378667beae5cb55f814ead9bbaf7e01b3b69533e9f88a411"
      ],
      [
        "57426aefc21be9ccf162e23d25ac3002ba8534351e65613f870f690f2fd46cf5",
        "6b45b002fb4e8a6f59a6ffb006ed71f75434217333b266325204c7d1ac2e1f34"
      ],
      [
        "6222bd88bf2df9d5d44b60cfb4a08a960078db7ed51a35eb3e0b6b8ff4eda202",
        "0325bb42ea4ed025dd6bdaed261b7c4f5410b608ba902b068f1efa5782e45313"
      ],
      [
        "71ac99647b61b9eca6f0c23432a518f738aee708d5932d4ef0f172240250a226",
        "3a96c2c028ebe5f48913be30147e41bc5e1cab9595d5404138a9aa1b5574cf25"
      ],
      [
        "1f6a1fd8cc0e05b2742ba0fc0369b5247670543637dd033e64dbce90b2f23e9f",
        "779964401ee869a9b31c0ef874a86440ba85d25c2ce932bd31a0865869605e19"
      ],
      [
        "22e2c039067920c42980dcb3a905fc91601c2b34e819ce1532ada4a5fc39d5cc",
        "631cf9945a09bf26d7e595b3f8e3390696870512820df63c5418577089e1a8bb"
      ],
      [
        "608de273a9f6a534219d7aaede3cf65a81e4dc03d7a2765eced1d2b7be4610f4",
        "3b31d0113f98d81ab1312fb2837aa9c8dcc7960f84eb371358c6d841f67144fa"
      ],
      [
        "3f748617ca63ab3e44c6e34f63e7328ea56a2a146da34368a57dca181254fe02",
        "0fed89e6420fc47b3938a2891ba9acee4cbb2899ee4e9ca15a13dc527dc1641e"
      ],
      [
        "69d98b5ecc35d56c97c0bf312955d199befe116b417d70f5f57e2dfd0af81ce5",
        "3e26d487fbfe36ab44e0ca3b248fe94bce92a69b8154d50e2d5481f8259f4e8e"
      ],
      [
        "1e34443347f9e627b3531157faab6eaca1bc3114df4a1423cc12bf8417b5d622",
        "295955a5ed061eca7f87b9485666ba9489ec20a9c484224dc920350bb4a6fc79"
      ],
      [
        "51f4ff8c599b1c96da82941520a9f5abf4a31eb8b84fc95056145ceb3b5775d0",
        "35ac9588d46e41f3f6f99aee3852eeb4b12e807807d4bd1b7f8406b0d7863ac1"
      ],
      [
        "3faa2a093a19a02424f65a10955101f4dc015c43b2dfce8e001507abd741b845",
        "7a1de10dacfda389ca663b15574bdc8ae8c5b6e7cee647e77b11ddbfc6eb8edc"
      ],
      [
        "1924416956ea2c1269062588569b18178011ea7cba1a3266284f48aa01d5a90f",
        "0c8e28127b7dcdd206fb6fee96eb88cfc7db7319826ac8cdb8b1fb8adaf021de"
      ],
      [
        "49761c57ce3c8c4f1435d495903e2f536f3be3712e76af8d0b5a8b7d1ebc8fac",
        "3225035e1065094ef32d7f3e7a6f8ff2748025f96e0c0b44eb35576b61e150a8"
      ],
      [
        "4339fa86a23242851a16afc3ab05b352a7b4bf53599a49dd7e29d364fc3a757b",
        "6d07cc3462bae9160bbebb997510817040767faa9dbd13f158a5fe8a63a34b0e"
      ],
      [
        "6bda13918dcbaf8529d6326ae7a9c278b72417c2188c5ea4f062fc50639295fb",
        "2c3fa803b162ee887d0d97a6734866f992f846625f314117075da54bb6c20a36"
      ],
      [
        "4da4821314574d4fed4dcf692c8b15b99b73f13633210333ce7871359b6e6424",
        "314016034673d2d20529bc93a2dab6e462bcb5f66e1f4a6bf2170759a40a6e65"
      ],
      [
        "0b2cea0029ee963c0034b61bf19e384435f14554a7d297b5144838c38e375586",
        "47ea95da28d39aaade5edb8ed941c687603cfdd1508776e96d6683199e99daea"
      ],
      [
        "4c27afff3c45f32c952d3984e14e29a098e685c9c2e723e5fc8047ae60b7e824",
        "5f2c99e6526dc87d95f11eb626c29c3a90d0be1e51a4c49e5bbabd114bf5a66b"
      ],
      [
        "53e2a4ed1bbb48bd016c524a02f797654cfc969849f867681da94e341f377534",
        "5a2334fdda642732a3c9520ce06581aa7f0f082882554c37b8d390a25a9bd559"
      ],
      [
        "7b8d2c823baafe0d878a55e8af1db150dec85b1424a4901f9beffd3a6196e3d6",
        "1c45a557b3624f9b89ed15b3c3e1a065f1b453d948f7cf45d9494483f8af0c85"
      ],
      [
        "78877b5d8777410997dacaeea59400fc9db4421fac02c4282301c67d35fb7ffe",
        "0341b46c328333e4484ce8607619014d41775c408c88856d2f9e19812d90fbf5"
      ],
      [
        "2b556bbc070b5c4bae9e575836d1d68ee9fbe800448c0d2c233f78185eed3f91",
        "7ba01332807ebd892e00ddb368c0fa1b3f19b5b32efd90b178d984e1d7174d6f"
      ],
      [
        "0f72556998b0044799f0fd03210ded3d984e3843bbaf3c1d5d692bc94d43c4e7",
        "16c19c5037c103d447caef4efe6bd81a490e7c668f6870f1b080863b5315df5e"
      ],
      [
        "1cd96ef237b213cd446f13b3ec40d32ecc593bc6ea71e77efc284341a5f3da1a",
        "7a626aeb91efcb5f9777264f5e17ced8b411f68c713673ef0f184a5ccd60dbe3"
      ],
      [
        "31a75b21cb532622a7caf9e29e652ac4e47b1450edf6655acaf3797b55a7ca46",
        "77006e7cf104982f8865081a2ff8a6911546755e31c3586353b0bd0826c5d790"
      ],
      [
        "543d84cb04fb2bf787b7aa382eaab5cd8d050ad8ee52aa8a285b945652014031",
        "0358fdc5b63ed49e693d838f182b275846f42dd49a42ec2e6e932ba4de59ef20"
      ],
      [
        "0a2818f5f5d8937800c30ac6b847db2cdef655b864126302249144a5a15b205a",
        "187c76a49af10851bb049ba97c0fbbb14b2621522a4e8d9670ea46e56c9a1bd6"
      ],
      [
        "7efb45d3a2851109d7a8d50ddb08fe308bbf674c019b965cdad4570a141e648a",
        "0fe1198b11a1bf56867091c69d71f8b7792257dda321d43652e818acd0c28cda"
      ],
      [
        "472e960dd122a534f52377235350549df4a1dd7a08cfc580bff5fb4b0a70aa7b",
        "10585d04fc529fef4c0c0776154fc7ebbaedbae8a99937e47598d0578932b7cc"
      ],
      [
        "04892cfff7f94ff7f07c1241e3ac4945bc46ea9d6a3c1c3adbce109a9afceb6a",
        "3ae2aa25e2555135a7a3251c11a3f8eebe81758bc1c3e2cbc6e6ca461a543130"
      ],
      [
        "2401d311a3abfd2583f1c6aa519c1f18ff730a0abf730ddcc9c9739b04d8a85e",
        "653224f3488cae1ae19a414a9932035a2bf2c46803b5532bbb645e62387ee34d"
      ],
      [
        "0ea2c846a535a115972161612a192588d92d68a3c9050eae91b2817b94e68325",
        "3b82a8337b05f11bbac176a113be183a50a0331f3d3116f24b971b5a8b0d031b"
      ],
      [
        "0fb3f87c2c6c89c65b74299b77f3736546a8b9e41b19197476bff27354e1c128",
        "1034d42c15a2bfe3e682fad49dbc2812caadf0c584bc30b51625b85d74e9d5f7"
      ],
      [
        "1bc7af1e38185e7c2d8d04371c7e177d7a9ddee1b81d7d26db7ad644c7dad28d",
        "61d909d855661f2f7a5eef87795dc0491d027e12631b270fcaf2f65900314833"
      ],
      [
        "469d0960dbd0ef9c91c4597ccf7c209549b187ff63bd378b7dac577198d74a4d",
        "0b5f21c7f86832241f2157c288bdc9394f83f8d57457f6d9f6b345e4909478cb"
      ],
      [
        "5e9ac4ab2f4a3c3526e1317f913d69e3826fe862efd0c80d9310319170c5cbeb",
        "505f00fa8aee03ccbd2f33529ae1e4e4bcf2644fe673d0b0290ec32be5b51bab"
      ],
      [
        "11cd80e1fdcbc565efed81d17f3f54643ffeed1cff38f3825e115adbd82759f1",
        "43f11943f7ef3fa68b980fee45e98134f1df22263b2d14419d61ffe62822dbe0"
      ],
      [
        "3328bc121616a9477165ed282053d203c24f4826076c638a2c6723d42c9bfadb",
        "2bbf3f26c21b5cb273e5f4f0114c6718c5eb7291939b7697c74333cdfafac039"
      ],
      [
        "0ba774bb605dd804cae6887e81f6bd2c59e024fac8bf5f5c48a841a037c28398",
        "54ba013ad2d04dcdfb5a151b7347ee9a10067ddd0a3907e9bc337a77bf911321"
      ],
      [
        "1074ff0267662dc2b4ce65aaa0229c375a3d0d843ce9349233949581c869b64c",
        "299be0decb680ec28923da4d049770107d42c180b460da13a7b1efc7e6d5b022"
      ],
      [
        "25ed76d78c87c3bd64b4331902c5a853734283e25f19f320295667b80a340d35",
        "179b5f92f545c7b326b3a63fb0b32a0f52b4159988436d5af50c1d0d76373947"
      ],
      [
        "75d942c04210dcde5d1bd4fabfc732d3f95568e399382c0423c83c41cb05dc3f",
        "696cc14856cdc13c8fd7e2c5771731cbf38e3fad47a424679765c4874e35ab2d"
      ],
      [
        "5d9324f56975477d5945599eeeccec67708c996cd3f3f2818bf2591507e3502a",
        "10985a3cfd573205281aec24e2c8b41f5cd8cdfc9d7be34675cf306bbe1b4f6a"
      ],
      [
        "7511066c0e12105a7b937c7ecef367d5afe6e621e5cabf4e490b09b7ada7ee07",
        "604df365b8391cbca8848f88daa700b770da5bb136f70bfb0a3ea33ba386fcd5"
      ],
      [
        "2596e5b3cf5494e60d2a750d03c66abc2e0183af53620b893f9cf9fc3b76dc26",
        "68a0a7ac9a0cc093884a6b84f45a2cde595194e0f48dbd566fa78a3174b182fe"
      ],
      [
        "28bd38d44030dd9ca028b2a2f31a795f4c7a5e85a785df7847e3d525e99d4787",
        "552dd7405c4183733ad3c4e7ccb999b4fed81b7a4444aab499d41d6d78d5bbfc"
      ],
      [
        "59233a3346f61135f431f96cf0197e24ad38240b222c010a6ce538cf4c24347b",
        "3cce55908611d2b93f221613f09cfc4dbcd2e2b609233eea5439ad1908a10b20"
      ],
      [
        "5830f025f1078d408948f73096af97de1e9e70b3be85890acb21132c34ff961f",
        "67d451752c2433ffe66e47242e301e56db2b2f8203553cab9de717e25793d41e"
      ],
      [
        "6a0c8b194571e874b82d904da36d43096bbe36d512e24ff8dcb2b00b57ffd3ec",
        "5f85adb7749cc735ec838bcccfe7d4b52902c6132998d7ac8e032cad031c42b8"
      ],
      [
        "53b3f967bff8760948dec5e9282f35d1434a5503790b9012e17faefbe7c4d699",
        "404462283c8664a17daa5b4059dcd10e2699fd86d0140de9f3e8ad0566098ae5"
      ]
    ]
  }
};
}],
[/* 72 */ 'bcrypto', '/lib/ed448-browser.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * ed448.js - ed448 for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */



module.exports = __browser_require__(73 /* './js/ed448' */, module);
}],
[/* 73 */ 'bcrypto', '/lib/js/ed448.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * ed448.js - ed448 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://eprint.iacr.org/2015/625.pdf
 *   https://tools.ietf.org/html/rfc8032#section-5.2
 */



const EDDSA = __browser_require__(70 /* './eddsa' */, module);
const SHAKE256 = __browser_require__(74 /* '../shake256' */, module);

/*
 * Expose
 */

module.exports = new EDDSA('ED448', 'X448', 'MONT448', SHAKE256);
}],
[/* 74 */ 'bcrypto', '/lib/shake256.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * shake256.js - SHAKE256 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */



const SHAKE = __browser_require__(75 /* './shake' */, module);

/**
 * SHAKE256
 */

class SHAKE256 extends SHAKE {
  constructor() {
    super();
  }

  init() {
    return super.init(256);
  }

  static hash() {
    return new SHAKE256();
  }

  static hmac(len) {
    return super.hmac(256, len);
  }

  static digest(data, len) {
    return super.digest(data, 256, len);
  }

  static root(left, right, len) {
    return super.root(left, right, 256, len);
  }

  static multi(x, y, z, len) {
    return super.multi(x, y, z, 256, len);
  }

  static mac(data, key, len) {
    return super.mac(data, key, 256, len);
  }
}

/*
 * Static
 */

SHAKE256.native = SHAKE.native;
SHAKE256.id = 'SHAKE256';
SHAKE256.size = 32;
SHAKE256.bits = 256;
SHAKE256.blockSize = 136;
SHAKE256.zero = Buffer.alloc(32, 0x00);
SHAKE256.ctx = new SHAKE256();

/*
 * Expose
 */

module.exports = SHAKE256;
}],
[/* 75 */ 'bcrypto', '/lib/shake.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * shake.js - SHAKE implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-3
 *   https://keccak.team/specifications.html
 *   https://csrc.nist.gov/projects/hash-functions/sha-3-project/sha-3-standardization
 *   http://dx.doi.org/10.6028/NIST.FIPS.202
 */



const Keccak = __browser_require__(76 /* './keccak' */, module);

/**
 * SHAKE
 */

class SHAKE extends Keccak {
  /**
   * Create a SHAKE Context.
   * @constructor
   */

  constructor() {
    super();
  }

  final(len) {
    return super.final(0x1f, len);
  }

  static hash() {
    return new SHAKE();
  }

  static hmac(bits, len) {
    return super.hmac(bits, 0x1f, len);
  }

  static digest(data, bits, len) {
    return super.digest(data, bits, 0x1f, len);
  }

  static root(left, right, bits, len) {
    return super.root(left, right, bits, 0x1f, len);
  }

  static multi(x, y, z, bits, len) {
    return super.multi(x, y, z, bits, 0x1f, len);
  }

  static mac(data, key, bits, len) {
    return super.mac(data, key, bits, 0x1f, len);
  }
}

/*
 * Static
 */

SHAKE.native = Keccak.native;
SHAKE.id = 'SHAKE256';
SHAKE.size = 32;
SHAKE.bits = 256;
SHAKE.blockSize = 136;
SHAKE.zero = Buffer.alloc(32, 0x00);
SHAKE.ctx = new SHAKE();

/*
 * Expose
 */

module.exports = SHAKE;
}],
[/* 76 */ 'bcrypto', '/lib/keccak-browser.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * keccak.js - keccak for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */



module.exports = __browser_require__(77 /* './js/keccak' */, module);
}],
[/* 77 */ 'bcrypto', '/lib/js/keccak.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * keccak.js - Keccak/SHA3 implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on emn178/js-sha3:
 *   Copyright (c) 2015-2017, Chen, Yi-Cyuan (MIT License).
 *   https://github.com/emn178/js-sha3
 *
 * Parts of this software are based on rhash/RHash:
 *   Copyright (c) 2005-2014, Aleksey Kravchenko
 *   https://github.com/rhash/RHash
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-3
 *   https://keccak.team/specifications.html
 *   https://csrc.nist.gov/projects/hash-functions/sha-3-project/sha-3-standardization
 *   http://dx.doi.org/10.6028/NIST.FIPS.202
 *   https://github.com/rhash/RHash/blob/master/librhash/sha3.c
 *   https://github.com/emn178/js-sha3/blob/master/src/sha3.js
 */



const assert = __browser_require__(24 /* '../internal/assert' */, module);
const HMAC = __browser_require__(27 /* '../internal/hmac' */, module);

/*
 * Constants
 */

const FINALIZED = 0x80000000;

const ROUND_CONST = new Uint32Array([
  0x00000001, 0x00000000, 0x00008082, 0x00000000,
  0x0000808a, 0x80000000, 0x80008000, 0x80000000,
  0x0000808b, 0x00000000, 0x80000001, 0x00000000,
  0x80008081, 0x80000000, 0x00008009, 0x80000000,
  0x0000008a, 0x00000000, 0x00000088, 0x00000000,
  0x80008009, 0x00000000, 0x8000000a, 0x00000000,
  0x8000808b, 0x00000000, 0x0000008b, 0x80000000,
  0x00008089, 0x80000000, 0x00008003, 0x80000000,
  0x00008002, 0x80000000, 0x00000080, 0x80000000,
  0x0000800a, 0x00000000, 0x8000000a, 0x80000000,
  0x80008081, 0x80000000, 0x00008080, 0x80000000,
  0x80000001, 0x00000000, 0x80008008, 0x80000000
]);

/**
 * Keccak
 */

class Keccak {
  constructor() {
    this.state = new Uint32Array(50);
    this.block = Buffer.alloc(200);
    this.bs = 136;
    this.pos = FINALIZED;
  }

  init(bits) {
    if (bits == null)
      bits = 256;

    assert((bits >>> 0) === bits);
    assert(bits >= 128);
    assert(bits <= 512);

    const rate = 1600 - bits * 2;

    assert(rate >= 0 && (rate & 63) === 0);

    this.bs = rate >>> 3;
    this.pos = 0;

    return this;
  }

  update(data) {
    assert((data != null && data._isBuffer === true));
    assert(!(this.pos & FINALIZED), 'Context is not initialized.');

    let len = data.length;
    let pos = this.pos;
    let off = 0;

    this.pos = (this.pos + len) % this.bs;

    if (pos > 0) {
      let want = this.bs - pos;

      if (want > len)
        want = len;

      data.copy(this.block, pos, off, off + want);

      pos += want;
      len -= want;
      off += want;

      if (pos < this.bs)
        return this;

      this._transform(this.block, 0);
    }

    while (len >= this.bs) {
      this._transform(data, off);
      off += this.bs;
      len -= this.bs;
    }

    if (len > 0)
      data.copy(this.block, 0, off, off + len);

    return this;
  }

  final(pad, len) {
    if (pad == null)
      pad = 0x01;

    if (len == null || len === 0)
      len = 100 - (this.bs >>> 1);

    assert((pad & 0xff) === pad);
    assert((len >>> 0) === len);
    assert(!(this.pos & FINALIZED), 'Context is not initialized.');

    this.block.fill(0, this.pos, this.bs);
    this.block[this.pos] |= pad;
    this.block[this.bs - 1] |= 0x80;
    this._transform(this.block, 0);
    this.pos = FINALIZED;

    assert(len <= this.bs);

    const out = Buffer.alloc(len);

    for (let i = 0; i < len; i++)
      out[i] = this.state[i >>> 2] >>> (8 * (i & 3));

    for (let i = 0; i < 50; i++)
      this.state[i] = 0;

    for (let i = 0; i < this.bs; i++)
      this.block[i] = 0;

    return out;
  }

  _transform(block, off) {
    const count = this.bs >>> 2;
    const s = this.state;

    for (let i = 0; i < count; i++)
      s[i] ^= readU32(block, off + i * 4);

    for (let n = 0; n < 48; n += 2) {
      const c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
      const c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
      const c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
      const c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
      const c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
      const c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
      const c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
      const c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
      const c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
      const c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

      const h0 = c8 ^ ((c2 << 1) | (c3 >>> 31));
      const l0 = c9 ^ ((c3 << 1) | (c2 >>> 31));
      const h1 = c0 ^ ((c4 << 1) | (c5 >>> 31));
      const l1 = c1 ^ ((c5 << 1) | (c4 >>> 31));
      const h2 = c2 ^ ((c6 << 1) | (c7 >>> 31));
      const l2 = c3 ^ ((c7 << 1) | (c6 >>> 31));
      const h3 = c4 ^ ((c8 << 1) | (c9 >>> 31));
      const l3 = c5 ^ ((c9 << 1) | (c8 >>> 31));
      const h4 = c6 ^ ((c0 << 1) | (c1 >>> 31));
      const l4 = c7 ^ ((c1 << 1) | (c0 >>> 31));

      s[0] ^= h0;
      s[1] ^= l0;
      s[10] ^= h0;
      s[11] ^= l0;
      s[20] ^= h0;
      s[21] ^= l0;
      s[30] ^= h0;
      s[31] ^= l0;
      s[40] ^= h0;
      s[41] ^= l0;

      s[2] ^= h1;
      s[3] ^= l1;
      s[12] ^= h1;
      s[13] ^= l1;
      s[22] ^= h1;
      s[23] ^= l1;
      s[32] ^= h1;
      s[33] ^= l1;
      s[42] ^= h1;
      s[43] ^= l1;

      s[4] ^= h2;
      s[5] ^= l2;
      s[14] ^= h2;
      s[15] ^= l2;
      s[24] ^= h2;
      s[25] ^= l2;
      s[34] ^= h2;
      s[35] ^= l2;
      s[44] ^= h2;
      s[45] ^= l2;

      s[6] ^= h3;
      s[7] ^= l3;
      s[16] ^= h3;
      s[17] ^= l3;
      s[26] ^= h3;
      s[27] ^= l3;
      s[36] ^= h3;
      s[37] ^= l3;
      s[46] ^= h3;
      s[47] ^= l3;

      s[8] ^= h4;
      s[9] ^= l4;
      s[18] ^= h4;
      s[19] ^= l4;
      s[28] ^= h4;
      s[29] ^= l4;
      s[38] ^= h4;
      s[39] ^= l4;
      s[48] ^= h4;
      s[49] ^= l4;

      const b0 = s[0];
      const b1 = s[1];
      const b32 = (s[11] << 4) | (s[10] >>> 28);
      const b33 = (s[10] << 4) | (s[11] >>> 28);
      const b14 = (s[20] << 3) | (s[21] >>> 29);
      const b15 = (s[21] << 3) | (s[20] >>> 29);
      const b46 = (s[31] << 9) | (s[30] >>> 23);
      const b47 = (s[30] << 9) | (s[31] >>> 23);
      const b28 = (s[40] << 18) | (s[41] >>> 14);
      const b29 = (s[41] << 18) | (s[40] >>> 14);
      const b20 = (s[2] << 1) | (s[3] >>> 31);
      const b21 = (s[3] << 1) | (s[2] >>> 31);
      const b2 = (s[13] << 12) | (s[12] >>> 20);
      const b3 = (s[12] << 12) | (s[13] >>> 20);
      const b34 = (s[22] << 10) | (s[23] >>> 22);
      const b35 = (s[23] << 10) | (s[22] >>> 22);
      const b16 = (s[33] << 13) | (s[32] >>> 19);
      const b17 = (s[32] << 13) | (s[33] >>> 19);
      const b48 = (s[42] << 2) | (s[43] >>> 30);
      const b49 = (s[43] << 2) | (s[42] >>> 30);
      const b40 = (s[5] << 30) | (s[4] >>> 2);
      const b41 = (s[4] << 30) | (s[5] >>> 2);
      const b22 = (s[14] << 6) | (s[15] >>> 26);
      const b23 = (s[15] << 6) | (s[14] >>> 26);
      const b4 = (s[25] << 11) | (s[24] >>> 21);
      const b5 = (s[24] << 11) | (s[25] >>> 21);
      const b36 = (s[34] << 15) | (s[35] >>> 17);
      const b37 = (s[35] << 15) | (s[34] >>> 17);
      const b18 = (s[45] << 29) | (s[44] >>> 3);
      const b19 = (s[44] << 29) | (s[45] >>> 3);
      const b10 = (s[6] << 28) | (s[7] >>> 4);
      const b11 = (s[7] << 28) | (s[6] >>> 4);
      const b42 = (s[17] << 23) | (s[16] >>> 9);
      const b43 = (s[16] << 23) | (s[17] >>> 9);
      const b24 = (s[26] << 25) | (s[27] >>> 7);
      const b25 = (s[27] << 25) | (s[26] >>> 7);
      const b6 = (s[36] << 21) | (s[37] >>> 11);
      const b7 = (s[37] << 21) | (s[36] >>> 11);
      const b38 = (s[47] << 24) | (s[46] >>> 8);
      const b39 = (s[46] << 24) | (s[47] >>> 8);
      const b30 = (s[8] << 27) | (s[9] >>> 5);
      const b31 = (s[9] << 27) | (s[8] >>> 5);
      const b12 = (s[18] << 20) | (s[19] >>> 12);
      const b13 = (s[19] << 20) | (s[18] >>> 12);
      const b44 = (s[29] << 7) | (s[28] >>> 25);
      const b45 = (s[28] << 7) | (s[29] >>> 25);
      const b26 = (s[38] << 8) | (s[39] >>> 24);
      const b27 = (s[39] << 8) | (s[38] >>> 24);
      const b8 = (s[48] << 14) | (s[49] >>> 18);
      const b9 = (s[49] << 14) | (s[48] >>> 18);

      s[0] = b0 ^ (~b2 & b4);
      s[1] = b1 ^ (~b3 & b5);
      s[10] = b10 ^ (~b12 & b14);
      s[11] = b11 ^ (~b13 & b15);
      s[20] = b20 ^ (~b22 & b24);
      s[21] = b21 ^ (~b23 & b25);
      s[30] = b30 ^ (~b32 & b34);
      s[31] = b31 ^ (~b33 & b35);
      s[40] = b40 ^ (~b42 & b44);
      s[41] = b41 ^ (~b43 & b45);
      s[2] = b2 ^ (~b4 & b6);
      s[3] = b3 ^ (~b5 & b7);
      s[12] = b12 ^ (~b14 & b16);
      s[13] = b13 ^ (~b15 & b17);
      s[22] = b22 ^ (~b24 & b26);
      s[23] = b23 ^ (~b25 & b27);
      s[32] = b32 ^ (~b34 & b36);
      s[33] = b33 ^ (~b35 & b37);
      s[42] = b42 ^ (~b44 & b46);
      s[43] = b43 ^ (~b45 & b47);
      s[4] = b4 ^ (~b6 & b8);
      s[5] = b5 ^ (~b7 & b9);
      s[14] = b14 ^ (~b16 & b18);
      s[15] = b15 ^ (~b17 & b19);
      s[24] = b24 ^ (~b26 & b28);
      s[25] = b25 ^ (~b27 & b29);
      s[34] = b34 ^ (~b36 & b38);
      s[35] = b35 ^ (~b37 & b39);
      s[44] = b44 ^ (~b46 & b48);
      s[45] = b45 ^ (~b47 & b49);
      s[6] = b6 ^ (~b8 & b0);
      s[7] = b7 ^ (~b9 & b1);
      s[16] = b16 ^ (~b18 & b10);
      s[17] = b17 ^ (~b19 & b11);
      s[26] = b26 ^ (~b28 & b20);
      s[27] = b27 ^ (~b29 & b21);
      s[36] = b36 ^ (~b38 & b30);
      s[37] = b37 ^ (~b39 & b31);
      s[46] = b46 ^ (~b48 & b40);
      s[47] = b47 ^ (~b49 & b41);
      s[8] = b8 ^ (~b0 & b2);
      s[9] = b9 ^ (~b1 & b3);
      s[18] = b18 ^ (~b10 & b12);
      s[19] = b19 ^ (~b11 & b13);
      s[28] = b28 ^ (~b20 & b22);
      s[29] = b29 ^ (~b21 & b23);
      s[38] = b38 ^ (~b30 & b32);
      s[39] = b39 ^ (~b31 & b33);
      s[48] = b48 ^ (~b40 & b42);
      s[49] = b49 ^ (~b41 & b43);

      s[0] ^= ROUND_CONST[n + 0];
      s[1] ^= ROUND_CONST[n + 1];
    }
  }

  static hash() {
    return new Keccak();
  }

  static hmac(bits, pad, len) {
    if (bits == null)
      bits = 256;

    assert((bits >>> 0) === bits);

    const rate = 1600 - bits * 2;

    assert(rate >= 0 && (rate & 63) === 0);

    return new HMAC(Keccak, rate >>> 3, [bits], [pad, len]);
  }

  static digest(data, bits, pad, len) {
    return Keccak.ctx.init(bits).update(data).final(pad, len);
  }

  static root(left, right, bits, pad, len) {
    if (bits == null)
      bits = 256;

    if (len == null)
      len = 0;

    if (len === 0)
      len = bits >>> 3;

    assert((bits >>> 0) === bits);
    assert((bits & 7) === 0);
    assert((len >>> 0) === len);
    assert((left != null && left._isBuffer === true) && left.length === len);
    assert((right != null && right._isBuffer === true) && right.length === len);

    return Keccak.ctx.init(bits).update(left).update(right).final(pad, len);
  }

  static multi(x, y, z, bits, pad, len) {
    const {ctx} = Keccak;

    ctx.init(bits);
    ctx.update(x);
    ctx.update(y);

    if (z)
      ctx.update(z);

    return ctx.final(pad, len);
  }

  static mac(data, key, bits, pad, len) {
    return Keccak.hmac(bits, pad, len).init(key).update(data).final();
  }
}

/*
 * Static
 */

Keccak.native = 0;
Keccak.id = 'KECCAK256';
Keccak.size = 32;
Keccak.bits = 256;
Keccak.blockSize = 136;
Keccak.zero = Buffer.alloc(32, 0x00);
Keccak.ctx = new Keccak();

/*
 * Helpers
 */

function readU32(data, off) {
  return (data[off++]
        + data[off++] * 0x100
        + data[off++] * 0x10000
        + data[off] * 0x1000000);
}

/*
 * Expose
 */

module.exports = Keccak;
}],
[/* 78 */ 'bcrypto', '/lib/encoding/util.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * util.js - encoding utils for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */



const assert = __browser_require__(24 /* '../internal/assert' */, module);

/*
 * Util
 */

function countLeft(data) {
  assert((data != null && data._isBuffer === true));

  let i = 0;

  while (i < data.length && data[i] === 0x00)
    i += 1;

  let bits = (data.length - i) * 8;

  if (bits === 0)
    return 0;

  bits -= 8;

  let oct = data[i];

  while (oct) {
    bits += 1;
    oct >>>= 1;
  }

  return bits;
}

function countRight(data) {
  assert((data != null && data._isBuffer === true));

  let i = data.length;

  while (i > 0 && data[i - 1] === 0x00)
    i -= 1;

  let bits = i * 8;

  if (bits === 0)
    return 0;

  bits -= 8;

  let oct = data[i - 1];

  while (oct) {
    bits += 1;
    oct >>>= 1;
  }

  return bits;
}

function compareLeft(x, y) {
  assert((x != null && x._isBuffer === true));
  assert((y != null && y._isBuffer === true));

  let xpos = 0;
  let xlen = x.length;
  let ypos = 0;
  let ylen = y.length;

  while (xlen > 0 && x[xpos] === 0x00) {
    xpos += 1;
    xlen -= 1;
  }

  while (ylen > 0 && y[ypos] === 0x00) {
    ypos += 1;
    ylen -= 1;
  }

  if (xlen < ylen)
    return -1;

  if (xlen > ylen)
    return 1;

  for (let i = 0; i < xlen; i++) {
    if (x[xpos + i] < y[ypos + i])
      return -1;

    if (x[xpos + i] > y[ypos + i])
      return 1;
  }

  return 0;
}

function compareRight(x, y) {
  assert((x != null && x._isBuffer === true));
  assert((y != null && y._isBuffer === true));

  let xlen = x.length;
  let ylen = y.length;

  while (xlen > 0 && x[xlen - 1] === 0x00)
    xlen -= 1;

  while (ylen > 0 && y[ylen - 1] === 0x00)
    ylen -= 1;

  if (xlen < ylen)
    return -1;

  if (xlen > ylen)
    return 1;

  for (let i = xlen - 1; i >= 0; i--) {
    if (x[i] < y[i])
      return -1;

    if (x[i] > y[i])
      return 1;
  }

  return 0;
}

function trimLeft(data) {
  assert((data != null && data._isBuffer === true));

  let i = 0;

  while (i < data.length && data[i] === 0x00)
    i += 1;

  return data.slice(i);
}

function trimRight(data) {
  assert((data != null && data._isBuffer === true));

  let i = data.length;

  while (i > 0 && data[i - 1] === 0x00)
    i -= 1;

  return data.slice(0, i);
}

function padLeft(data, size) {
  assert((data != null && data._isBuffer === true));
  assert((size >>> 0) === size);

  if (data.length > size)
    data = trimLeft(data);

  if (data.length > size)
    throw new RangeError(`Buffer expected to be ${size} bytes in size.`);

  const out = Buffer.alloc(size, 0x00);

  data.copy(out, size - data.length);

  return out;
}

function padRight(data, size) {
  assert((data != null && data._isBuffer === true));
  assert((size >>> 0) === size);

  if (data.length > size)
    data = trimRight(data);

  if (data.length > size)
    throw new RangeError(`Buffer expected to be ${size} bytes in size.`);

  const out = Buffer.alloc(size, 0x00);

  data.copy(out, 0);

  return out;
}

/*
 * Expose
 */

exports.countLeft = countLeft;
exports.countRight = countRight;
exports.compareLeft = compareLeft;
exports.compareRight = compareRight;
exports.trimLeft = trimLeft;
exports.trimRight = trimRight;
exports.padLeft = padLeft;
exports.padRight = padRight;
}],
[/* 79 */ 'bns-plus', '/lib/util.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * util.js - utils for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 *
 * Parts of this software are based on miekg/dns and golang/go:
 *   https://github.com/miekg/dns/blob/master/labels.go
 *   https://github.com/miekg/dns/blob/master/dnsutil/util.go
 */

/* eslint spaced-comment: 0 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const IP = __browser_require__(4 /* 'binet' */, module);
const rng = __browser_require__(45 /* 'bcrypto/lib/random' */, module);
const {sizeName} = __browser_require__(80 /* './encoding' */, module);
const util = exports;

util.splitName = function splitName(s) {
  assert(typeof s === 'string');

  if (s.length === 0)
    return [];

  const idx = util.split(s);
  const labels = [];

  let fend = 0;
  let begin = 0;

  if (util.isFQDN(s))
    fend = s.length - 1;
  else
    fend = s.length;

  switch (idx.length) {
    case 0: {
      return [];
    }
    case 1: {
      break;
    }
    default: {
      for (let i = 1; i < idx.length; i++) {
        const end = idx[i];
        labels.push(s.substring(begin, end - 1));
        begin = end;
      }
      break;
    }
  }

  labels.push(s.substring(begin, fend));

  return labels;
};

util.compareName = function compareName(s1, s2) {
  assert(typeof s1 === 'string');
  assert(typeof s2 === 'string');

  let n = 0;

  if (s1 === '.' || s2 === '.')
    return 0;

  const l1 = util.split(s1);
  const l2 = util.split(s2);

  let j1 = l1.length - 1;
  let i1 = l1.length - 2;

  let j2 = l2.length - 1;
  let i2 = l2.length - 2;

  const a = s1.substring(l1[j1]);
  const b = s2.substring(l2[j2]);

  if (!util.equal(a, b))
    return n;

  n += 1;

  for (;;) {
    if (i1 < 0 || i2 < 0)
      break;

    const a = s1.substring(l1[i1], l1[j1]);
    const b = s2.substring(l2[i2], l2[j2]);

    if (!util.equal(a, b))
      break;

    n += 1;

    j1 -= 1;
    i1 -= 1;

    j2 -= 1;
    i2 -= 1;
  }

  return n;
};

util.countLabels = function countLabels(s) {
  assert(typeof s === 'string');

  let labels = 0;

  if (s === '.')
    return labels;

  let off = 0;
  let end = false;

  for (;;) {
    [off, end] = util.nextLabel(s, off);

    labels += 1;

    if (end)
      break;
  }

  return labels;
};

util.split = function split(s) {
  assert(typeof s === 'string');

  if (s === '.')
    return [];

  const idx = [0];

  let off = 0;
  let end = false;

  for (;;) {
    [off, end] = util.nextLabel(s, off);

    if (end)
      break;

    idx.push(off);
  }

  return idx;
};

util.nextLabel = function nextLabel(s, off) {
  assert(typeof s === 'string');
  assert(typeof off === 'number');

  if (s.length === 0)
    return [0, true];

  let i = 0;

  for (i = off; i < s.length - 1; i++) {
    if (s.charCodeAt(i) !== 0x2e) /*.*/
      continue;

    let j = i - 1;

    while (j >= 0 && s.charCodeAt(j) === 0x5c) /*\*/
      j -= 1;

    if ((j - i) % 2 === 0)
      continue;

    return [i + 1, false];
  }

  return [i + 1, true];
};

util.prevLabel = function prevLabel(s, n) {
  assert(typeof s === 'string');
  assert(typeof n === 'number');

  if (s.length === 0)
    return [0, true];

  if (n === 0)
    return [s.length, false];

  let i = s.length - 1;

  if (s.charCodeAt(i) === 0x2e) /*.*/
    i -= 1;

  for (; i >= 0 && n > 0; i--) {
    if (s.charCodeAt(i) !== 0x2e) /*.*/
      continue;

    let j = i - 1;

    while (j >= 0 && s.charCodeAt(j) === 0x5c) /*\*/
      j -= 1;

    if ((j - i) % 2 === 0)
      continue;

    n -= 1;

    if (n === 0)
      return [i + 1, false];
  }

  return [0, n > 1];
};

util.equal = function equal(a, b) {
  assert(typeof a === 'string');
  assert(typeof b === 'string');

  if (a.length !== b.length)
    return false;

  for (let i = a.length - 1; i >= 0; i--) {
    let x = a.charCodeAt(i);
    let y = b.charCodeAt(i);

    if (x >= 0x41 && x <= 0x5a)
      x |= 0x20;

    if (y >= 0x41 && y <= 0x5a)
      y |= 0x20;

    if (x !== y)
      return false;
  }

  return true;
};

util.compare = function compare(a, b) {
  assert(typeof a === 'string');
  assert(typeof b === 'string');

  const len = Math.min(a.length, b.length);

  for (let i = 0; i < len; i++) {
    let x = a.charCodeAt(i);
    let y = b.charCodeAt(i);

    if (x >= 0x41 && x <= 0x5a)
      x |= 0x20;

    if (y >= 0x41 && y <= 0x5a)
      y |= 0x20;

    if (x < y)
      return -1;

    if (x > y)
      return 1;
  }

  if (a.length < b.length)
    return -1;

  if (a.length > b.length)
    return 1;

  return 0;
};

util.isName = function isName(s) {
  assert(typeof s === 'string');

  try {
    sizeName(util.fqdn(s), null, false);
    return true;
  } catch (e) {
    return false;
  }
};

util.isFQDN = function isFQDN(s) {
  assert(typeof s === 'string');

  if (s.length === 0)
    return false;

  const i = s.length - 1;

  if (s.charCodeAt(i) !== 0x2e) /*.*/
    return false;

  let j = i - 1;

  while (j >= 0 && s.charCodeAt(j) === 0x5c) /*\*/
    j -= 1;

  return (j - i) % 2 !== 0;
};

util.fqdn = function fqdn(s) {
  if (util.isFQDN(s))
    return s;

  return s + '.';
};

util.trimFQDN = function trimFQDN(s) {
  if (!util.isFQDN(s))
    return s;

  return s.slice(0, -1);
};

util.isSubdomain = function isSubdomain(parent, child) {
  return util.compareName(parent, child) === util.countLabels(parent);
};

util.addOrigin = function addOrigin(s, origin) {
  assert(typeof s === 'string');
  assert(typeof origin === 'string');

  if (util.isFQDN(s))
    return s;

  if (origin.length === 0)
    return s;

  if (s === '@' || s.length === 0)
    return origin;

  if (origin === '.')
    return util.fqdn(s);

  return `${s}.${origin}`;
};

util.trimDomainName = function trimDomainName(s, origin) {
  assert(typeof s === 'string');
  assert(typeof origin === 'string');

  if (s.length === 0)
    return '@';

  if (origin === '.')
    return util.trimFQDN(s);

  const original = s;

  s = util.fqdn(s);
  origin = util.fqdn(origin);

  if (!util.isSubdomain(origin, s))
    return original;

  const slabels = util.split(s);
  const olabels = util.split(origin);
  const m = util.compareName(s, origin);

  if (olabels.length === m) {
    if (olabels.length === slabels.length)
      return '@';

    if (s[0] === '.' && slabels.length === olabels.length + 1)
      return '@';
  }

  return s.substring(0, slabels[slabels.length - m] - 1);
};

util.label = function label(s, labels, index) {
  if (typeof labels === 'number') {
    index = labels;
    labels = util.split(s);
  }

  assert(typeof s === 'string');
  assert(Array.isArray(labels));
  assert(typeof index === 'number');

  if (index < 0)
    index += labels.length;

  if (index >= labels.length)
    return '';

  const start = labels[index];

  if (index + 1 === labels.length) {
    if (util.isFQDN(s))
      return s.slice(start, -1);
    return s.substring(start);
  }

  const end = labels[index + 1];

  return s.substring(start, end - 1);
};

util.from = function from(s, labels, index) {
  if (typeof labels === 'number') {
    index = labels;
    labels = util.split(s);
  }

  assert(typeof s === 'string');
  assert(Array.isArray(labels));
  assert(typeof index === 'number');

  if (index < 0)
    index += labels.length;

  if (index >= labels.length)
    return '';

  return s.substring(labels[index]);
};

util.to = function to(s, labels, index) {
  if (typeof labels === 'number') {
    index = labels;
    labels = util.split(s);
  }

  assert(typeof s === 'string');
  assert(Array.isArray(labels));
  assert(typeof index === 'number');

  if (index < 0)
    index += labels.length;

  if (index >= labels.length)
    return '';

  return s.substring(0, labels[index]);
};

util.startsWith = function startsWith(s, pre) {
  assert(typeof s === 'string');
  assert(typeof pre === 'string');

  if (s.startsWith)
    return s.startsWith(pre);

  if (pre.length === 0)
    return true;

  if (s.length === 0)
    return false;

  if (pre.length > s.length)
    return false;

  if (pre.length === 1)
    return s[0] === pre;

  return s.substring(0, pre.length) === pre;
};

util.endsWith = function endsWith(s, suf) {
  assert(typeof s === 'string');
  assert(typeof suf === 'string');

  if (s.endsWith)
    return s.endsWith(suf);

  if (suf.length === 0)
    return true;

  if (s.length === 0)
    return false;

  if (suf.length > s.length)
    return false;

  if (suf.length === 1)
    return s[s.length - 1] === suf;

  return s.slice(-suf.length) === suf;
};

util.trimPrefix = function trimPrefix(s, pre) {
  if (util.startsWith(s, pre))
    return s.slice(pre.length);
  return s;
};

util.trimSuffix = function trimSuffix(s, suf) {
  if (util.endsWith(s, suf))
    return s.slice(0, -suf.length);
  return s;
};

util.isRRSet = function isRRSet(rrset) {
  assert(Array.isArray(rrset));

  if (rrset.length === 0)
    return false;

  if (rrset.length === 1)
    return true;

  const type = rrset[0].type;
  const class_ = rrset[0].class;
  const name = rrset[0].name;

  for (let i = 1; i < rrset.length; i++) {
    const rr = rrset[i];

    if (rr.type !== type
        || rr.class !== class_
        || !util.equal(rr.name, name)) {
      return false;
    }
  }

  return true;
};

util.filterSet = function filterSet(records, ...types) {
  assert(Array.isArray(records));

  const set = new Set(types);
  const out = [];

  for (const rr of records) {
    if (!set.has(rr.type))
      out.push(rr);
  }

  return out;
};

util.extractSet = function extractSet(records, name, ...types) {
  assert(Array.isArray(records));
  assert(typeof name === 'string');

  const set = new Set(types);
  const out = [];

  for (const rr of records) {
    if (set.has(rr.type)) {
      if (name !== '' && !util.equal(rr.name, name))
        continue;
      out.push(rr);
    }
  }

  return out;
};

util.hasType = function hasType(records, type) {
  assert(Array.isArray(records));
  assert(typeof type === 'number');

  for (const rr of records) {
    if (rr.type === type)
      return true;
  }

  return false;
};

util.hasAll = function hasAll(records, type) {
  assert(Array.isArray(records));
  assert(typeof type === 'number');

  for (const rr of records) {
    if (rr.type !== type)
      return false;
  }

  return true;
};

util.random = function random(n) {
  return rng.randomRange(0, n);
};

util.randomItem = function randomItem(items) {
  assert(Array.isArray(items));
  return items[util.random(items.length)];
};

util.timeOffset = 0;

util.now = function now() {
  return Math.floor(Date.now() / 1000) + util.timeOffset;
};

util.fakeTime = function fakeTime(time) {
  if (time == null)
    time = 0;

  if (typeof time === 'string')
    time = Math.floor(Date.parse(time) / 1000);

  assert(Number.isSafeInteger(time));
  assert(time >= 0);

  if (time === 0) {
    util.timeOffset = 0;
    return;
  }

  const now = Math.floor(Date.now() / 1000);

  util.timeOffset = time - now;
};

util.digDate = function digDate(time) {
  if (time == null)
    time = util.now();

  assert(Number.isSafeInteger(time));
  assert(time >= 0);

  const date = new Date(time * 1000);

  // We need to replicate something like:
  //   Tue Jun 12 21:27:00 PDT 2018
  // We use only ECMA-262 enforced methods
  // for this for compatibility purposes.

  // Format: Wed Jun 28 1993
  const ds = date.toDateString();

  // Format: 14:39:07 GMT-0700 (PDT)
  const ts = date.toTimeString();

  const dp = ds.split(' ');
  const tp = ts.split(' ');

  const [n, m, d, y] = dp;
  const [t] = tp;

  let z = '';

  // Timezone parsing.
  if (tp.length === 3) {
    // The timezone is in short form, e.g.
    //   14:39:07 GMT-0700 (PDT)
    z = tp[2];

    if (z[0] === '(')
      z = z.slice(1, -1);
  } else if (tp.length > 3) {
    // We have something like:
    //   22:03:24 GMT-0700 (Pacific Daylight Time)
    // Newer versions of v8 tend to do this.
    z = '';

    // Abbreviate.
    for (let i = 2; i < tp.length; i++) {
      const p = tp[i];

      if (i === 2 && p[0] === '(')
        z += p[1];
      else
        z += p[0];
    }
  } else {
    // Fallback to GMT+offset, e.g.
    //   GMT-0700
    z = tp[1];
  }

  return `${n} ${m} ${d} ${t} ${z} ${y}`;
};

util.parseInteger = function parseInteger(str, max, size) {
  assert(typeof str === 'string');

  let word = 0;

  if (str.length === 0 || str.length > size)
    throw new Error('Invalid integer.');

  for (let i = 0; i < str.length; i++) {
    const ch = str.charCodeAt(i) - 0x30;

    if (ch < 0 || ch > 9)
      throw new Error('Invalid integer.');

    word *= 10;
    word += ch;

    if (word > max)
      throw new Error('Invalid integer.');
  }

  return word;
};

util.parseU8 = function parseU8(str) {
  return util.parseInteger(str, 0xff, 3);
};

util.parseU16 = function parseU16(str) {
  return util.parseInteger(str, 0xffff, 5);
};

util.parseU32 = function parseU32(str) {
  return util.parseInteger(str, 0xffffffff, 10);
};

util.parseU48 = function parseU48(str) {
  return util.parseInteger(str, 0xffffffffffff, 15);
};

util.parseU64 = function parseU64(str) {
  assert(typeof str === 'string');

  if (str.length === 0 || str.length > 20)
    throw new Error('Invalid integer.');

  let hi = 0;
  let lo = 0;

  for (let i = 0; i < str.length; i++) {
    const ch = str.charCodeAt(i) - 0x30;

    if (ch < 0 || ch > 9)
      throw new Error('Invalid integer.');

    lo *= 10;
    lo += ch;

    hi *= 10;

    if (lo > 0xffffffff) {
      const m = lo % 0x100000000;
      hi += (lo - m) / 0x100000000;
      lo = m;
    }

    if (hi > 0xffffffff)
      throw new Error('Invalid integer.');
  }

  return [hi, lo];
};

util.serializeU64 = function serializeU64(hi, lo) {
  assert((hi >>> 0) === hi);
  assert((lo >>> 0) === lo);

  let str = '';

  do {
    const mhi = hi % 10;
    hi -= mhi;
    hi /= 10;
    lo += mhi * 0x100000000;

    const mlo = lo % 10;
    lo -= mlo;
    lo /= 10;

    const ch = mlo + 0x30;

    str = String.fromCharCode(ch) + str;
  } while (lo > 0 || hi > 0);

  return str;
};

util.dir = function dir(obj, inspect = true) {
  console.dir(obj, {
    depth: 20,
    colors: true,
    customInspect: inspect
  });
};

util.isIP = function isIP(host) {
  return IP.test(host) !== 0;
};

util.id = function id() {
  return rng.randomInt() & 0xffff;
};

util.cookie = function cookie() {
  return rng.randomBytes(8);
};

util.sortRandom = function sortRandom(items) {
  assert(Array.isArray(items));

  if (items.length <= 1)
    return items;

  return items.slice().sort(cmpRandom);
};

util.ensureLF = function ensureLF(str) {
  assert(typeof str === 'string');

  str = str.replace(/\r\n/g, '\n');
  str = str.replace(/\r/g, '\n');

  return str;
};

util.ensureSP = function ensureSP(str) {
  assert(typeof str === 'string');
  return str.replace(/[ \t\v]/g, ' ');
};

util.splitLF = function splitLF(str, limit) {
  assert(typeof str === 'string');
  if (limit === null)
    limit = undefined;
  return str.trim().split(/\n+/, limit);
};

util.splitSP = function splitSP(str, limit) {
  assert(typeof str === 'string');
  if (limit === null)
    limit = undefined;
  return str.trim().split(/[ \t\v]+/, limit);
};

util.stripBOM = function stripBOM(str) {
  assert(typeof str === 'string');

  if (str.length === 0)
    return str;

  if (str.charCodeAt(0) !== 0xfeff)
    return str;

  return str.substring(1);
};

util.stripSP = function stripSP(str) {
  assert(typeof str === 'string');
  return str.replace(/[ \t\v]+/g, '');
};

util.stripLF = function stripLF(str) {
  assert(typeof str === 'string');
  return str.replace(/\n+/g, '');
};

util.splitColon = function splitColon(str) {
  assert(typeof str === 'string');

  const index = str.indexOf(':');

  if (index === -1)
    return [str.toLowerCase(), ''];

  const left = str.substring(0, index).trim();
  const right = str.substring(index + 1).trim();

  return [left, right];
};

util.splitLines = function splitLines(str, escaped, limit) {
  assert(typeof str === 'string');

  str = util.stripBOM(str);
  str = util.ensureLF(str);
  str = util.ensureSP(str);

  if (escaped)
    str = str.replace(/\\\n/g, '');

  const lines = util.splitLF(str, limit);
  const out = [];

  for (const chunk of lines) {
    const line = chunk.trim();

    if (line.length === 0)
      continue;

    out.push(line);
  }

  return out;
};

util.isHex = function isHex(str) {
  assert(typeof str === 'string');

  if (str.length & 1)
    return false;

  return /^[A-Fa-f0-9]+$/.test(str);
};

util.parseHex = function parseHex(str) {
  assert(typeof str === 'string');

  if (str.length & 1)
    throw new Error('Invalid hex string.');

  const data = Buffer.from(str, 'hex');

  if (data.length !== (str.length >>> 1))
    throw new Error('Invalid hex string.');

  return data;
};

util.isB64 = function isB64(str) {
  assert(typeof str === 'string');
  return /^[A-Za-z0-9+\/=]+$/.test(str);
};

util.parseB64 = function parseB64(str) {
  assert(typeof str === 'string');

  const data = Buffer.from(str, 'base64');

  if (str.length > size64(data.length))
    throw new Error('Invalid base64 string.');

  return data;
};

util.padRight = function padRight(data, size) {
  assert((data != null && data._isBuffer === true));
  assert((size >>> 0) === size);

  if (data.length < size) {
    const buf = Buffer.allocUnsafe(size);
    data.copy(buf, 0);
    buf.fill(0x00, data.length, size);
    return buf;
  }

  if (data.length > size)
    return data.slice(0, size);

  return data;
};

util.pad = function pad(num, len) {
  assert((num >>> 0) === num);
  assert((len >>> 0) === len);

  let str = num.toString(10);

  while (str.length < len)
    str = '0' + str;

  return str;
};

util.parseTime = function parseTime(s) {
  assert(typeof s === 'string');
  assert(s.length === 14);

  const y = unpad(s, 0, 4);
  const m = unpad(s, 4, 6);
  const d = unpad(s, 6, 8);
  const hr = unpad(s, 8, 10);
  const mn = unpad(s, 10, 12);
  const sc = unpad(s, 12, 14);
  const da = new Date(0);

  da.setUTCFullYear(y);
  da.setUTCMonth(m - 1);
  da.setUTCDate(d);
  da.setUTCHours(hr);
  da.setUTCMinutes(mn);
  da.setUTCSeconds(sc);
  da.setUTCMilliseconds(0);

  const ms = da.getTime();

  if (!Number.isSafeInteger(ms))
    throw new RangeError('Invalid time value.');

  assert(ms % 1000 === 0);

  return ms / 1000;
};

util.serializeTime = function serializeTime(t) {
  assert(Number.isSafeInteger(t));
  assert(Number.isSafeInteger(t * 1000));

  const da = new Date(t * 1000);
  const ms = da.getTime();

  if (!Number.isSafeInteger(ms))
    throw new RangeError('Invalid time value.');

  const y = util.pad(da.getUTCFullYear(), 4);
  const m = util.pad(da.getUTCMonth() + 1, 2);
  const d = util.pad(da.getUTCDate(), 2);
  const hr = util.pad(da.getUTCHours(), 2);
  const mn = util.pad(da.getUTCMinutes(), 2);
  const sc = util.pad(da.getUTCSeconds(), 2);

  return `${y}${m}${d}${hr}${mn}${sc}`;
};

util.serial = function serial(t) {
  assert(Number.isSafeInteger(t));
  assert(Number.isSafeInteger(t * 1000));

  const date = new Date(t * 1000);
  const ms = date.getTime();

  if (!Number.isSafeInteger(ms))
    throw new RangeError('Invalid time value.');

  const y = date.getUTCFullYear() * 1e6;
  const m = (date.getUTCMonth() + 1) * 1e4;
  const d = date.getUTCDate() * 1e2;
  const h = date.getUTCHours();

  return y + m + d + h;
};

/*
 * Helpers
 */

function cmpRandom(a, b) {
  return -(rng.randomInt() & 1) | 1;
}

function unpad(str, start, end) {
  const num = str.substring(start, end);
  return util.parseU16(num);
}

function size64(size) {
  const expect = ((4 * size / 3) + 3) & ~3;
  return expect >>> 0;
}
}],
[/* 80 */ 'bns-plus', '/lib/encoding.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * encoding.js - encoding for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 *
 * Parts of this software are based on miekg/dns and golang/go:
 *   https://github.com/miekg/dns/blob/master/msg.go
 *   https://github.com/miekg/dns/blob/master/types.go
 *   https://github.com/golang/go/blob/master/src/net/dnsmsg.go
 */

/* eslint spaced-comment: 0 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const IP = __browser_require__(4 /* 'binet' */, module);
const bio = __browser_require__(14 /* 'bufio' */, module);
const constants = __browser_require__(11 /* './constants' */, module);
const {EncodingError} = bio;
const {MAX_NAME_SIZE, MAX_LABEL_SIZE} = constants;

/*
 * Constants
 */

const ASCII = [
  ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
  ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
  ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
  ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
  ' ', '!', '"', '#', '$', '%', '&', '\'',
  '(', ')', '*', '+', ',', '-', '.', '/',
  '0', '1', '2', '3', '4', '5', '6', '7',
  '8', '9', ':', ';', '<', '=', '>', '?',
  '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G',
  'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
  'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
  'X', 'Y', 'Z', '[', '\\', ']', '^', '_',
  '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
  'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
  'p', 'q', 'r', 's', 't', 'u', 'v', 'w',
  'x', 'y', 'z', '{', '|', '}', '~', ' '
];

const HEX = [
  '0', '1', '2', '3', '4', '5', '6', '7',
  '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
];

const POOL1 = Buffer.allocUnsafe(MAX_NAME_SIZE * 4);
const POOL2 = Buffer.allocUnsafe(MAX_NAME_SIZE * 4);
const DUMMY = Buffer.alloc(0);

/*
 * Encoding
 */

const encoding = exports;

encoding.sizeName = function sizeName(name, map, cmp) {
  const [off] = encoding.writeName(null, name, 0, map, cmp);
  return off;
};

encoding.writeName = function writeName(data, name, off, map, cmp) {
  if (data == null)
    data = null;

  if (map == null)
    map = null;

  if (cmp == null)
    cmp = map != null;

  assert(data === null || (data != null && data._isBuffer === true));
  assert(typeof name === 'string');
  assert((off >>> 0) === off);
  assert(map === null || (map instanceof Map));
  assert(typeof cmp === 'boolean');

  let nl = name.length;

  if (nl === 0 || name[nl - 1] !== '.')
    throw new EncodingError(0, 'No dot');

  if (nl > MAX_NAME_SIZE * 4)
    throw new EncodingError(0, 'Name too large');

  const n = POOL1;

  if (n.write(name, 'ascii') !== nl)
    throw new EncodingError(0, 'Invalid string');

  let pos = -1;
  let ptr = -1;
  let begin = 0;
  let escaped = false;
  let fresh = true;
  let labels = 0;

  for (let i = 0; i < nl; i++) {
    if (n[i] === 0x5c /*\\*/) {
      for (let j = i; j < nl - 1; j++)
        n[j] = n[j + 1];

      nl -= 1;

      if (isDigits(n, i, nl)) {
        n[i] = toByte(n, i);
        for (let j = i + 1; j < nl - 2; j++)
          n[j] = n[j + 2];
        nl -= 2;
      }

      escaped = n[i] === 0x2e;
      fresh = false;

      continue;
    }

    if (n[i] === 0x2e /*.*/) {
      if (i > 0 && n[i - 1] === 0x2e /*.*/ && !escaped)
        throw new EncodingError(off, 'Multiple dots');

      const size = i - begin;

      if (size > MAX_LABEL_SIZE)
        throw new EncodingError(off, 'Maximum label size exceeded');

      if (data) {
        if (off + 1 > data.length)
          throw new EncodingError(off, 'EOF');
        data[off] = size;
      }

      if (cmp && !fresh) {
        name = n.toString('ascii', 0, nl);
        fresh = true;
      }

      if (map) {
        const s = name.substring(begin);
        if (s !== '.') {
          const p = map.get(s);
          if (p == null) {
            if (off < (2 << 13))
              map.set(s, off);
          } else {
            if (cmp && ptr === -1) {
              ptr = p;
              pos = off;
              break;
            }
          }
        }
      }

      off += 1;

      if (data) {
        if (off + size > data.length)
          throw new EncodingError(off, 'EOF');
        assert(n.copy(data, off, begin, i) === size);
      }

      off += size;

      labels += 1;
      begin = i + 1;
    }

    escaped = false;
  }

  if (nl > MAX_NAME_SIZE)
    throw new EncodingError(off, 'Maximum name size exceeded');

  if (nl === 1 && n[0] === 0x2e /*.*/)
    return [off, labels];

  if (ptr !== -1) {
    off = pos;

    if (data) {
      if (off + 2 > data.length)
        throw new EncodingError(off, 'EOF');
      bio.writeU16BE(data, ptr ^ 0xc000, off);
    }

    off += 2;

    return [off, labels];
  }

  if (data) {
    if (off + 1 > data.length)
      throw new EncodingError(off, 'EOF');
    data[off] = 0;
  }

  off += 1;

  return [off, labels];
};

encoding.readName = function readName(data, off, cmp) {
  if (cmp == null)
    cmp = true;

  assert((data != null && data._isBuffer === true));
  assert((off >>> 0) === off);
  assert(typeof cmp === 'boolean');

  let name = '';
  let res = 0;
  let max = MAX_NAME_SIZE;
  let ptr = 0;

  for (;;) {
    if (off >= data.length)
      throw new EncodingError(off, 'EOF');

    const c = data[off];

    off += 1;

    if (c === 0x00)
      break;

    switch (c & 0xc0) {
      case 0x00: {
        if (c > MAX_LABEL_SIZE)
          throw new EncodingError(off, 'Maximum label size exceeded');

        if (off + c > data.length)
          throw new EncodingError(off, 'EOF');

        if (name.length + c + 1 > max)
          throw new EncodingError(off, 'Maximum name length exceeded');

        for (let j = off; j < off + c; j++) {
          const b = data[j];

          switch (b) {
            case 0x2e /*.*/:
            case 0x28 /*(*/:
            case 0x29 /*)*/:
            case 0x3b /*;*/:
            case 0x20 /* */:
            case 0x40 /*@*/:
            case 0x22 /*"*/:
            case 0x5c /*\\*/: {
              if (!cmp)
                throw new EncodingError(off, 'Unexpected character');
              name += '\\' + ASCII[b];
              max += 1;
              break;
            }
            default: {
              if (b < 0x20 || b > 0x7e) {
                if (!cmp)
                  throw new EncodingError(off, 'Unexpected character');
                name += '\\' + toDDD(b);
                max += 3;
              } else {
                name += ASCII[b];
              }
              break;
            }
          }
        }

        name += '.';
        off += c;

        break;
      }

      case 0xc0: {
        if (!cmp)
          throw new EncodingError(off, 'Unexpected compression byte');

        if (off >= data.length)
          throw new EncodingError(off, 'EOF');

        const c1 = data[off];

        off += 1;

        if (ptr === 0)
          res = off;

        ptr += 1;

        if (ptr > 10)
          throw new EncodingError(off, 'Too many pointers');

        off = ((c ^ 0xc0) << 8) | c1;

        break;
      }

      default: {
        throw new EncodingError(off, 'Invalid byte');
      }
    }
  }

  if (ptr === 0)
    res = off;

  if (name.length === 0)
    name = '.';

  assert(name.length <= max);

  return [res, name];
};

encoding.writeNameBW = function writeNameBW(bw, name, map, cmp) {
  assert(bw);
  const {data, offset} = bw;
  const [off, labels] =
    encoding.writeName(data, name, offset, map, cmp);
  bw.offset = off;
  return labels;
};

encoding.readNameBR = function readNameBR(br, cmp) {
  if (cmp == null)
    cmp = true;

  assert(br);

  const [off, name] = encoding.readName(br.data, br.offset, cmp);

  br.offset = off;

  return name;
};

encoding.packName = function packName(name) {
  const size = encoding.sizeName(name, null, false);
  const data = Buffer.allocUnsafe(size);
  encoding.writeName(data, name, 0, null, false);
  return data;
};

encoding.unpackName = function unpackName(data) {
  const [, name] = encoding.readName(data, 0, true);
  return name;
};

encoding.isName = function isName(name) {
  assert(typeof name === 'string');

  let nl = name.length;

  if (nl === 0 || name[nl - 1] !== '.')
    return false;

  if (nl > MAX_NAME_SIZE * 4)
    return false;

  const n = POOL1;

  if (n.write(name, 'ascii') !== nl)
    return false;

  let escaped = false;
  let begin = 0;

  for (let i = 0; i < nl; i++) {
    if (n[i] === 0x5c /*\\*/) {
      for (let j = i; j < nl - 1; j++)
        n[j] = n[j + 1];

      nl -= 1;

      if (isDigits(n, i, nl)) {
        n[i] = toByte(n, i);

        for (let j = i + 1; j < nl - 2; j++)
          n[j] = n[j + 2];

        nl -= 2;

        if (n[i] >= 0x20 && n[i] <= 0x7e)
          return false;
      } else {
        switch (n[i]) {
          case 0x2e /*.*/:
          case 0x28 /*(*/:
          case 0x29 /*)*/:
          case 0x3b /*;*/:
          case 0x20 /* */:
          case 0x40 /*@*/:
          case 0x22 /*"*/:
          case 0x5c /*\\*/: {
            break;
          }
          default:
            return false;
        }
      }

      escaped = n[i] === 0x2e;

      continue;
    }

    switch (n[i]) {
      case 0x28 /*(*/:
      case 0x29 /*)*/:
      case 0x3b /*;*/:
      case 0x20 /* */:
      case 0x40 /*@*/:
      case 0x22 /*"*/:
      case 0x5c /*\\*/: {
        return false;
      }
      default:
        if (n[i] < 0x20 || n[i] > 0x7e)
          return false;
        break;
    }

    if (n[i] === 0x2e /*.*/) {
      if (i > 0 && n[i - 1] === 0x2e /*.*/ && !escaped)
        return false;

      const size = i - begin;

      if (size > MAX_LABEL_SIZE)
        return false;

      begin = i + 1;
    }

    escaped = false;
  }

  if (nl > MAX_NAME_SIZE)
    return false;

  return true;
};

encoding.toName = function toName(name, enc) {
  if (enc == null)
    enc = 'utf8';

  assert(typeof enc === 'string');

  if ((name != null && name._isBuffer === true)) {
    if (name.length + 1 > MAX_NAME_SIZE)
      throw new EncodingError(0, 'Name too large');

    name = name.toString('hex');
    enc = 'hex';
  }

  assert(typeof name === 'string');

  let str = encoding._escapeString(name, false, enc);

  if (str.length === 0 || str[str.length - 1] !== '.')
    str += '.';

  const buf = POOL2;
  const [len] = encoding.writeName(buf, str, 0, null, false);

  if (len >= buf.length)
    throw new EncodingError(0, 'Name too large');

  const data = buf.slice(0, len);

  return encoding.readName(data, 0, true)[1];
};

encoding.fromName = function fromName(name, enc) {
  if (enc == null)
    enc = 'utf8';

  assert(encoding.isName(name));
  assert(typeof enc === 'string');

  return encoding._unescapeString(name, false, enc);
};

encoding.sizeRawString = function sizeRawString(str) {
  return encoding.writeRawString(null, str, 0);
};

encoding.writeRawString = function writeRawString(data, str, off) {
  if (data == null)
    data = null;

  assert(data === null || (data != null && data._isBuffer === true));
  assert(typeof str === 'string');
  assert((off >>> 0) === off);

  let sl = str.length;

  if (sl > MAX_NAME_SIZE * 4)
    throw new EncodingError(0, 'String too large');

  const s = POOL1;

  if (s.write(str, 'ascii') !== sl)
    throw new EncodingError(0, 'Invalid string');

  for (let i = 0; i < sl; i++) {
    if (s[i] === 0x5c /*\\*/) {
      for (let j = i; j < sl - 1; j++)
        s[j] = s[j + 1];

      sl -= 1;

      if (isDigits(s, i, sl)) {
        s[i] = toByte(s, i);
        for (let j = i + 1; j < sl - 2; j++)
          s[j] = s[j + 2];
        sl -= 2;
      }
    }

    if (data) {
      if (off + 1 > data.length)
        throw new EncodingError(off, 'EOF');
      data[off] = s[i];
    }

    off += 1;
  }

  if (sl > MAX_NAME_SIZE)
    throw new EncodingError(off, 'Maximum string size exceeded');

  return off;
};

encoding.readRawString = function readRawString(data, off, len, nsp) {
  if (nsp == null)
    nsp = false;

  assert((data != null && data._isBuffer === true));
  assert((off >>> 0) === off);
  assert((len >>> 0) === len);
  assert(typeof nsp === 'boolean');

  if (len > MAX_NAME_SIZE)
    throw new EncodingError(off, 'Maximum string size exceeded');

  if (off + len > data.length)
    throw new EncodingError(off, 'EOF');

  const SPACE = 0x20 + (nsp ? 1 : 0);
  const start = off;
  const end = off + len;

  let str = '';

  for (let i = start; i < end; i++) {
    const b = data[i];

    switch (b) {
      case 0x22 /*"*/:
      case 0x5c /*\\*/:
        str += '\\' + ASCII[b];
        break;
      default:
        if (b < SPACE || b > 0x7e)
          str += '\\' + toDDD(b);
        else
          str += ASCII[b];
        break;
    }
  }

  return [end, str];
};

encoding.packRawString = function packRawString(str) {
  const size = encoding.sizeRawString(str);
  const data = Buffer.allocUnsafe(size);
  encoding.writeRawString(data, str, 0);
  return data;
};

encoding.unpackRawString = function unpackRawString(data, nsp) {
  assert(data);
  const [, str] = encoding.readRawString(data, 0, data.length, nsp);
  return str;
};

encoding.writeRawStringBW = function writeRawStringBW(bw, str) {
  assert(bw);
  const {data, offset} = bw;
  bw.offset = encoding.writeRawString(data, str, offset);
  return bw;
};

encoding.readRawStringBR = function readRawStringBR(br, len, nsp) {
  assert(br);
  const [off, str] = encoding.readRawString(br.data, br.offset, len, nsp);
  br.offset = off;
  return str;
};

encoding.sizeString = function sizeString(str) {
  return encoding.writeString(null, str, 0);
};

encoding.writeString = function writeString(data, str, off) {
  if (data == null)
    data = null;

  assert(data === null || (data != null && data._isBuffer === true));
  assert(typeof str === 'string');
  assert((off >>> 0) === off);

  const start = off;

  if (data) {
    if (off + 1 > data.length)
      throw new EncodingError(off, 'EOF');
    data[off] = 0;
  }

  off += 1;

  const offset = encoding.writeRawString(data, str, off);
  const size = offset - off;

  if (data)
    data[start] = size;

  off += size;

  return off;
};

encoding.readString = function readString(data, off, nsp) {
  assert((data != null && data._isBuffer === true));
  assert((off >>> 0) === off);

  if (off + 1 > data.length)
    throw new EncodingError(off, 'EOF');

  const len = data[off];

  off += 1;

  return encoding.readRawString(data, off, len, nsp);
};

encoding.packString = function packString(str) {
  const size = encoding.sizeString(str);
  const data = Buffer.allocUnsafe(size);
  encoding.writeString(data, str, 0);
  return data;
};

encoding.unpackString = function unpackString(data, nsp) {
  const [, str] = encoding.readString(data, 0, nsp);
  return str;
};

encoding.isString = function isString(str, nsp) {
  if (nsp == null)
    nsp = false;

  assert(typeof str === 'string');
  assert(typeof nsp === 'boolean');

  let sl = str.length;

  if (sl > MAX_NAME_SIZE * 4)
    return false;

  const SPACE = 0x20 + (nsp ? 1 : 0);
  const s = POOL1;

  if (s.write(str, 'ascii') !== sl)
    return false;

  for (let i = 0; i < sl; i++) {
    if (s[i] === 0x5c /*\\*/) {
      for (let j = i; j < sl - 1; j++)
        s[j] = s[j + 1];

      sl -= 1;

      if (isDigits(s, i, sl)) {
        s[i] = toByte(s, i);

        for (let j = i + 1; j < sl - 2; j++)
          s[j] = s[j + 2];

        sl -= 2;

        if (s[i] >= SPACE && s[i] <= 0x7e)
          return false;
      } else {
        switch (s[i]) {
          case 0x22 /*"*/:
          case 0x5c /*\\*/:
            break;
          default:
            return false;
        }
      }

      continue;
    }

    switch (s[i]) {
      case 0x22 /*"*/:
      case 0x5c /*\\*/:
        return false;
      default:
        if (s[i] < SPACE || s[i] > 0x7e)
          return false;
        break;
    }
  }

  if (sl > MAX_NAME_SIZE)
    return false;

  return true;
};

encoding._escapeString = function _escapeString(str, nsp, enc) {
  if (nsp == null)
    nsp = false;

  if (enc == null)
    enc = 'utf8';

  assert(typeof nsp === 'boolean');

  let buf, len;

  if ((str != null && str._isBuffer === true)) {
    buf = str;
    len = buf.length;

    if (len > MAX_NAME_SIZE)
      throw new EncodingError(0, 'String too large');
  } else {
    assert(typeof str === 'string');
    assert(typeof enc === 'string');

    buf = POOL2;
    len = buf.write(str, enc);

    if (len >= buf.length)
      throw new EncodingError(0, 'String too large');
  }

  return encoding.readRawString(buf, 0, len, nsp)[1];
};

encoding.toString = function toString(str, nsp, enc) {
  return encoding._escapeString(str, nsp, enc);
};

encoding._unescapeString = function _unescapeString(str, nsp, enc) {
  if (nsp == null)
    nsp = false;

  if (enc == null)
    enc = 'utf8';

  assert(typeof str === 'string');
  assert(typeof enc === 'string');

  const buf = POOL2;
  const len = encoding.writeRawString(buf, str, 0);

  if (enc === 'buffer')
    return Buffer.from(buf.slice(0, len));

  return buf.toString(enc, 0, len);
};

encoding.fromString = function fromString(str, nsp, enc) {
  assert(encoding.isString(str, nsp));
  return encoding._unescapeString(str, nsp, enc);
};

encoding.writeStringBW = function writeStringBW(bw, str) {
  assert(bw && typeof bw === 'object');
  const {data, offset} = bw;
  bw.offset = encoding.writeString(data, str, offset);
  return bw;
};

encoding.readStringBR = function readStringBR(br, nsp) {
  assert(br && typeof br === 'object');
  const [off, str] = encoding.readString(br.data, br.offset, nsp);
  br.offset = off;
  return str;
};

encoding.writeIP = function writeIP(bw, str, size) {
  return IP.writeBW(bw, str, size);
};

encoding.readIP = function readIP(br, size) {
  return IP.readBR(br, size);
};

encoding.reverse = function reverse(addr) {
  const ip = IP.toBuffer(addr);

  let name = '';
  let i = 15;

  if (IP.isIPv4(ip)) {
    for (; i >= 12; i--) {
      const ch = ip[i];
      name += ch.toString(10);
      name += '.';
    }

    return `${name}in-addr.arpa.`;
  }

  for (; i >= 0; i--) {
    const ch = ip[i];
    name += HEX[ch & 0x0f];
    name += '.';
    name += HEX[ch >>> 4];
    name += '.';
  }

  return `${name}ip6.arpa.`;
};

encoding.toBitmap = function toBitmap(types) {
  assert(Array.isArray(types));

  if (types.length === 0)
    return Buffer.allocUnsafe(0);

  if (types.length > 32 * 256)
    throw new Error('Too many types for bitmap.');

  let max = 0;

  for (const type of types) {
    assert((type & 0xffff) === type);

    if (type > max)
      max = type;
  }

  const wins = (max >>> 8) + 1;
  const size = wins * 34;
  const map = Buffer.alloc(size, 0x00);

  for (const type of types) {
    const win = type >>> 8;
    const idx = type & 0xff;
    const oct = ((win * 34) + 2) + (idx >>> 3);
    const bit = idx & 7;

    map[oct] |= 1 << (7 - bit);
  }

  let off = 0;

  for (let win = 0; win < wins; win++) {
    const pos = (win * 34) + 2;

    let i = 31;

    for (; i >= 0; i--) {
      if (map[pos + i] !== 0)
        break;
    }

    const len = i + 1;

    if (len === 0)
      continue;

    map[off++] = win;
    map[off++] = len;

    for (let i = pos; i < pos + len; i++)
      map[off++] = map[i];
  }

  return map.slice(0, off);
};

encoding.fromBitmap = function fromBitmap(map) {
  assert((map != null && map._isBuffer === true));

  const types = [];

  let i = 0;

  while (i < map.length) {
    if (i + 2 > map.length)
      break;

    if (i >= 34 * 256)
      break;

    const win = map[i++];
    const len = map[i++];

    if (len === 0 || len > 32)
      break;

    if (i + len > map.length)
      break;

    const size = len << 3;

    for (let idx = 0; idx < size; idx++) {
      const oct = idx >>> 3;
      const bit = idx & 7;
      const ch = map[i + oct];
      const mask = 1 << (7 - bit);

      if (ch & mask) {
        const type = (win << 8) | idx;
        types.push(type);
      }
    }
  }

  return types;
};

encoding.hasType = function hasType(map, type) {
  assert((map != null && map._isBuffer === true));
  assert((type & 0xffff) === type);

  let i = 0;

  while (i < map.length) {
    if (i + 2 > map.length)
      break;

    if (i >= 34 * 256)
      break;

    const win = map[i++];
    const len = map[i++];

    if (len === 0 || len > 32)
      break;

    if (i + len > map.length)
      break;

    if (win * 256 > type)
      break;

    if ((win + 1) * 256 <= type) {
      i += len;
      continue;
    }

    if (type < (win * 256) + len * 8) {
      const oct = type >>> 3;
      const bit = type & 7;
      const ch = map[i + oct];
      const mask = 1 << (7 - bit);

      if (ch & mask)
        return true;
    }

    i += len;
  }

  return false;
};

encoding.toPortmap = function toPortmap(ports) {
  assert(Array.isArray(ports));

  if (ports.length === 0)
    return DUMMY;

  let max = 0;

  for (const port of ports) {
    assert((port & 0xffff) === port);

    if (port > max)
      max = port;
  }

  const bits = max + 1;
  const size = (bits + 7) / 8 | 0;
  const map = Buffer.alloc(size, 0x00);

  for (const port of ports) {
    const oct = port >>> 3;
    const bit = port & 7;
    map[oct] |= 1 << (7 - bit);
  }

  return map;
};

encoding.fromPortmap = function fromPortmap(map) {
  assert((map != null && map._isBuffer === true));

  const ports = [];

  for (let port = 0; port <= 1024; port++) {
    const oct = port >>> 3;
    const bit = port & 7;
    const mask = 1 << (7 - bit);

    if (oct >= map.length)
      break;

    const ch = map[oct];

    if (ch & mask)
      ports.push(port);
  }

  return ports;
};

encoding.hasPort = function hasPort(map, port) {
  assert((map != null && map._isBuffer === true));
  assert((port & 0xffff) === port);

  const oct = port >>> 3;
  const bit = port & 7;
  const mask = 1 << (7 - bit);

  if (oct >= map.length)
    return false;

  const ch = map[oct];

  if (ch & mask)
    return true;

  return false;
};

/*
 * Helpers
 */

function isDigit(num) {
  return num >= 0x30 && num <= 0x39;
}

function isDigits(buf, off, len) {
  assert((buf != null && buf._isBuffer === true));
  assert((off >>> 0) === off);
  assert((len >>> 0) === len);
  assert(len <= buf.length);

  if (off + 3 > len)
    return false;

  if (!isDigit(buf[off + 0]))
    return false;

  if (!isDigit(buf[off + 1]))
    return false;

  if (!isDigit(buf[off + 2]))
    return false;

  return true;
}

function toByte(buf, off) {
  assert((buf != null && buf._isBuffer === true));
  assert((off >>> 0) === off);
  assert(off + 3 <= buf.length);

  const hi = (buf[off + 0] - 0x30) * 100;
  const md = (buf[off + 1] - 0x30) * 10;
  const lo = (buf[off + 2] - 0x30) * 1;

  return hi + md + lo;
}

function toDDD(ch) {
  assert((ch & 0xff) === ch);

  const str = ch.toString(10);

  switch (str.length) {
    case 1:
      return `00${str}`;
    case 2:
      return `0${str}`;
    case 3:
      return str;
    default:
      throw new Error('Invalid byte.');
  }
}
}],
[/* 81 */ 'bns-plus', '/lib/internal/lazy-browser.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * lazy.js - lazy require for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const iana = __browser_require__(82 /* './iana' */, module);
const scan = __browser_require__(83 /* './scan' */, module);
const schema = __browser_require__(88 /* './schema' */, module);

/*
 * Lazy Require
 */

function lazy(name) {
  assert(typeof name === 'string');

  switch (name) {
    case './iana':
    case './internal/iana':
      return iana;
    case './scan':
    case './internal/scan':
      return scan;
    case './schema':
    case './internal/schema':
      return schema;
  }

  throw new Error(`Unknown module: ${name}.`);
}

/*
 * Expose
 */

module.exports = lazy;
}],
[/* 82 */ 'bns-plus', '/lib/internal/iana.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * iana.js - assigned names/numbers
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 *
 * Resources
 *   http://www.iana.org/assignments/port-numbers
 *   https://tools.ietf.org/html/rfc6335
 *   https://tools.ietf.org/html/rfc1010
 *   https://www.ietf.org/rfc/rfc1035.txt
 *   https://github.com/c-ares/c-ares/blob/master/ares_platform.c
 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const constants = __browser_require__(11 /* '../constants' */, module);
const toSymbol = constants._toSymbol;
const fromSymbol = constants._fromSymbol;
const isSymbol = constants._isSymbol;

/*
 * IANA
 */

const iana = exports;

/**
 * IANA Protocol Numbers
 * @enum {Number}
 * @default
 */

const protocols = {
  RESERVED: 0, // Reserved
  ICMP: 1, // Internet Control Message
  IGMP: 2, // Internet Group Management
  GGP: 3, // Gateway-to-Gateway
  // 4 unassigned
  ST: 5, // Stream
  TCP: 6, // Transmission Control
  UCL: 7, // UCL
  EGP: 8, // Exterior Gateway Protocol
  IGP: 9, // any private interior gateway
  'BBN-RCC-MON': 10, // BBN RCC Monitoring
  'NVP-II': 11, // Network Voice Protocol
  PUP: 12, // PUP
  ARGUS: 13, // ARGUS
  EMCON: 14, // EMCON
  XNET: 15, // Cross Net Debugger
  CHAOS: 16, // Chaos
  UDP: 17, // User Datagram
  MUX: 17, // Multiplexing
  'DCN-MEAS': 19, // DCN Measurement Subsystems
  HMP: 20, // Host Monitoring
  PRM: 21, // Packet Radio Measurement
  'XNS-IDP': 22, // XEROX NS IDP
  'TRUNK-1': 23, // Trunk-1
  'TRUNK-2': 24, // Trunk-2
  'LEAF-1': 25, // Leaf-1
  'LEAF-2': 26, // Leaf-2
  RDP: 27, // Reliable Data Protocol
  IRTP: 28, // Internet Reliable Transaction
  'ISO-TP4': 29, // ISO Transport Protocol Class 4
  NETBLT: 30, // Bulk Data Transfer Protocol
  'MFE-NSP': 31, // MFE Network Services Protocol
  'MERIT-INP': 32, // MERIT Internodal Protocol
  SEP: 33, // Sequential Exchange Protocol
  // 34-60 unassigned
  INTERNAL: 61, // any host internal protocol
  CFTP: 62, // CFTP
  LOCAL: 63 // any local network
};

/**
 * IANA Protocol Numbers by value
 * @const {Object}
 */

const protocolsByVal = {
  [protocols.RESERVED]: 'RESERVED',
  [protocols.ICMP]: 'ICMP',
  [protocols.IGMP]: 'IGMP',
  [protocols.GGP]: 'GGP',
  [protocols.ST]: 'ST',
  [protocols.TCP]: 'TCP',
  [protocols.UCL]: 'UCL',
  [protocols.EGP]: 'EGP',
  [protocols.IGP]: 'IGP',
  [protocols['BBN-RCC-MON']]: 'BBN-RCC-MON',
  [protocols['NVP-II']]: 'NVP-II',
  [protocols.PUP]: 'PUP',
  [protocols.ARGUS]: 'ARGUS',
  [protocols.EMCON]: 'EMCON',
  [protocols.XNET]: 'XNET',
  [protocols.CHAOS]: 'CHAOS',
  [protocols.UDP]: 'UDP',
  [protocols.MUX]: 'MUX',
  [protocols['DCN-MEAS']]: 'DCN-MEAS',
  [protocols.HMP]: 'HMP',
  [protocols.PRM]: 'PRM',
  [protocols['XNS-IDP']]: 'XNS-IDP',
  [protocols['TRUNK-1']]: 'TRUNK-1',
  [protocols['TRUNK-2']]: 'TRUNK-2',
  [protocols['LEAF-1']]: 'LEAF-1',
  [protocols['LEAF-2']]: 'LEAF-2',
  [protocols.RDP]: 'RDP',
  [protocols.IRTP]: 'IRTP',
  [protocols['ISO-TP4']]: 'ISO-TP4',
  [protocols.NETBLT]: 'NETBLT',
  [protocols['MFE-NSP']]: 'MFE-NSP',
  [protocols['MERIT-INP']]: 'MERIT-INP',
  [protocols.SEP]: 'SEP',
  [protocols.INTERNAL]: 'INTERNAL',
  [protocols.CFTP]: 'CFTP',
  [protocols.LOCAL]: 'LOCAL'
};

/**
 * IANA Port Numbers
 * @enum {Number}
 * @default
 */

const services = {
  'tcpmux': 1,
  'compressnet': 2,
  'rje': 5,
  'echo': 7,
  'discard': 9,
  'systat': 11,
  'daytime': 13,
  'qotd': 17,
  'msp': 18,
  'chargen': 19,
  'ftp-data': 20,
  'ftp': 21,
  'ssh': 22,
  'telnet': 23,
  'smtp': 25,
  'nsw-fe': 27,
  'msg-icp': 29,
  'msg-auth': 31,
  'dsp': 33,
  'time': 37,
  'rap': 38,
  'rlp': 39,
  'graphics': 41,
  'name': 42,
  'nameserver': 42,
  'nicname': 43,
  'mpm-flags': 44,
  'mpm': 45,
  'mpm-snd': 46,
  'ni-ftp': 47,
  'auditd': 48,
  'tacacs': 49,
  're-mail-ck': 50,
  'la-maint': 51,
  'xns-time': 52,
  'domain': 53,
  'xns-ch': 54,
  'isi-gl': 55,
  'xns-auth': 56,
  'xns-mail': 58,
  'ni-mail': 61,
  'acas': 62,
  'whois++': 63,
  'covia': 64,
  'tacacs-ds': 65,
  'sql*net': 66,
  'bootps': 67,
  'bootpc': 68,
  'tftp': 69,
  'gopher': 70,
  'netrjs-1': 71,
  'netrjs-2': 72,
  'netrjs-3': 73,
  'netrjs-4': 74,
  'deos': 76,
  'vettcp': 78,
  'finger': 79,
  'http': 80,
  'www': 80,
  'www-http': 80,
  'xfer': 82,
  'mit-ml-dev': 83,
  'ctf': 84,
  'mfcobol': 86,
  'kerberos': 88,
  'su-mit-tg': 89,
  'dnsix': 90,
  'mit-dov': 91,
  'npp': 92,
  'dcp': 93,
  'objcall': 94,
  'supdup': 95,
  'dixie': 96,
  'swift-rvf': 97,
  'tacnews': 98,
  'metagram': 99,
  'newacct': 100,
  'hostname': 101,
  'iso-tsap': 102,
  'gppitnp': 103,
  'acr-nema': 104,
  'cso': 105,
  'csnet-ns': 105,
  '3com-tsmux': 106,
  'rtelnet': 107,
  'snagas': 108,
  'pop2': 109,
  'pop3': 110,
  'sunrpc': 111,
  'mcidas': 112,
  'ident': 113,
  'auth': 113,
  'sftp': 115,
  'ansanotify': 116,
  'uucp-path': 117,
  'sqlserv': 118,
  'nntp': 119,
  'cfdptkt': 120,
  'erpc': 121,
  'smakynet': 122,
  'ntp': 123,
  'ansatrader': 124,
  'locus-map': 125,
  'nxedit': 126,
  'locus-con': 127,
  'gss-xlicen': 128,
  'pwdgen': 129,
  'cisco-fna': 130,
  'cisco-tna': 131,
  'cisco-sys': 132,
  'statsrv': 133,
  'ingres-net': 134,
  'epmap': 135,
  'profile': 136,
  'netbios-ns': 137,
  'netbios-dgm': 138,
  'netbios-ssn': 139,
  'emfis-data': 140,
  'emfis-cntl': 141,
  'bl-idm': 142,
  'imap': 143,
  'uma': 144,
  'uaac': 145,
  'iso-tp0': 146,
  'iso-ip': 147,
  'jargon': 148,
  'aed-512': 149,
  'sql-net': 150,
  'hems': 151,
  'bftp': 152,
  'sgmp': 153,
  'netsc-prod': 154,
  'netsc-dev': 155,
  'sqlsrv': 156,
  'knet-cmp': 157,
  'pcmail-srv': 158,
  'nss-routing': 159,
  'sgmp-traps': 160,
  'snmp': 161,
  'snmptrap': 162,
  'cmip-man': 163,
  'cmip-agent': 164,
  'xns-courier': 165,
  's-net': 166,
  'namp': 167,
  'rsvd': 168,
  'send': 169,
  'print-srv': 170,
  'multiplex': 171,
  'cl/1': 172,
  'xyplex-mux': 173,
  'mailq': 174,
  'vmnet': 175,
  'genrad-mux': 176,
  'xdmcp': 177,
  'nextstep': 178,
  'bgp': 179,
  'ris': 180,
  'unify': 181,
  'audit': 182,
  'ocbinder': 183,
  'ocserver': 184,
  'remote-kis': 185,
  'kis': 186,
  'aci': 187,
  'mumps': 188,
  'qft': 189,
  'gacp': 190,
  'prospero': 191,
  'osu-nms': 192,
  'srmp': 193,
  'irc': 194,
  'dn6-nlm-aud': 195,
  'dn6-smm-red': 196,
  'dls': 197,
  'dls-mon': 198,
  'smux': 199,
  'src': 200,
  'at-rtmp': 201,
  'at-nbp': 202,
  'at-3': 203,
  'at-echo': 204,
  'at-5': 205,
  'at-zis': 206,
  'at-7': 207,
  'at-8': 208,
  'qmtp': 209,
  'z39.50': 210,
  '914c/g': 211,
  'anet': 212,
  'ipx': 213,
  'vmpwscs': 214,
  'softpc': 215,
  'CAIlic': 216,
  'dbase': 217,
  'mpp': 218,
  'uarps': 219,
  'imap3': 220,
  'fln-spx': 221,
  'rsh-spx': 222,
  'cdc': 223,
  'masqdialer': 224,
  'direct': 242,
  'sur-meas': 243,
  'inbusiness': 244,
  'link': 245,
  'dsp3270': 246,
  'subntbcst_tftp': 247,
  'bhfhs': 248,
  'set': 257,
  'esro-gen': 259,
  'openport': 260,
  'nsiiops': 261,
  'arcisdms': 262,
  'hdap': 263,
  'bgmp': 264,
  'x-bone-ctl': 265,
  'sst': 266,
  'td-service': 267,
  'td-replica': 268,
  'manet': 269,
  'gist': 270,
  'http-mgmt': 280,
  'personal-link': 281,
  'cableport-ax': 282,
  'rescap': 283,
  'corerjd': 284,
  'fxp': 286,
  'k-block': 287,
  'novastorbakcup': 308,
  'entrusttime': 309,
  'bhmds': 310,
  'asip-webadmin': 311,
  'vslmp': 312,
  'magenta-logic': 313,
  'opalis-robot': 314,
  'dpsi': 315,
  'decauth': 316,
  'zannet': 317,
  'pkix-timestamp': 318,
  'ptp-event': 319,
  'ptp-general': 320,
  'pip': 321,
  'rtsps': 322,
  'texar': 333,
  'pdap': 344,
  'pawserv': 345,
  'zserv': 346,
  'fatserv': 347,
  'csi-sgwp': 348,
  'mftp': 349,
  'matip-type-a': 350,
  'matip-type-b': 351,
  'bhoetty': 351,
  'dtag-ste-sb': 352,
  'bhoedap4': 352,
  'ndsauth': 353,
  'bh611': 354,
  'datex-asn': 355,
  'cloanto-net-1': 356,
  'bhevent': 357,
  'shrinkwrap': 358,
  'nsrmp': 359,
  'scoi2odialog': 360,
  'semantix': 361,
  'srssend': 362,
  'rsvp_tunnel': 363,
  'aurora-cmgr': 364,
  'dtk': 365,
  'odmr': 366,
  'mortgageware': 367,
  'qbikgdp': 368,
  'rpc2portmap': 369,
  'codaauth2': 370,
  'clearcase': 371,
  'ulistproc': 372,
  'legent-1': 373,
  'legent-2': 374,
  'hassle': 375,
  'nip': 376,
  'tnETOS': 377,
  'dsETOS': 378,
  'is99c': 379,
  'is99s': 380,
  'hp-collector': 381,
  'hp-managed-node': 382,
  'hp-alarm-mgr': 383,
  'arns': 384,
  'ibm-app': 385,
  'asa': 386,
  'aurp': 387,
  'unidata-ldm': 388,
  'ldap': 389,
  'uis': 390,
  'synotics-relay': 391,
  'synotics-broker': 392,
  'meta5': 393,
  'embl-ndt': 394,
  'netcp': 395,
  'netware-ip': 396,
  'mptn': 397,
  'kryptolan': 398,
  'iso-tsap-c2': 399,
  'osb-sd': 400,
  'ups': 401,
  'genie': 402,
  'decap': 403,
  'nced': 404,
  'ncld': 405,
  'imsp': 406,
  'timbuktu': 407,
  'prm-sm': 408,
  'prm-nm': 409,
  'decladebug': 410,
  'rmt': 411,
  'synoptics-trap': 412,
  'smsp': 413,
  'infoseek': 414,
  'bnet': 415,
  'silverplatter': 416,
  'onmux': 417,
  'hyper-g': 418,
  'ariel1': 419,
  'smpte': 420,
  'ariel2': 421,
  'ariel3': 422,
  'opc-job-start': 423,
  'opc-job-track': 424,
  'icad-el': 425,
  'smartsdp': 426,
  'svrloc': 427,
  'ocs_cmu': 428,
  'ocs_amu': 429,
  'utmpsd': 430,
  'utmpcd': 431,
  'iasd': 432,
  'nnsp': 433,
  'mobileip-agent': 434,
  'mobilip-mn': 435,
  'dna-cml': 436,
  'comscm': 437,
  'dsfgw': 438,
  'dasp': 439,
  'sgcp': 440,
  'decvms-sysmgt': 441,
  'cvc_hostd': 442,
  'https': 443,
  'snpp': 444,
  'microsoft-ds': 445,
  'ddm-rdb': 446,
  'ddm-dfm': 447,
  'ddm-ssl': 448,
  'as-servermap': 449,
  'tserver': 450,
  'sfs-smp-net': 451,
  'sfs-config': 452,
  'creativeserver': 453,
  'contentserver': 454,
  'creativepartnr': 455,
  'macon-tcp': 456,
  'macon-udp': 456,
  'scohelp': 457,
  'appleqtc': 458,
  'ampr-rcmd': 459,
  'skronk': 460,
  'datasurfsrv': 461,
  'datasurfsrvsec': 462,
  'alpes': 463,
  'kpasswd': 464,
  'urd': 465,
  'igmpv3lite': 465,
  'digital-vrc': 466,
  'mylex-mapd': 467,
  'photuris': 468,
  'rcp': 469,
  'scx-proxy': 470,
  'mondex': 471,
  'ljk-login': 472,
  'hybrid-pop': 473,
  'tn-tl-w1': 474,
  'tn-tl-w2': 474,
  'tcpnethaspsrv': 475,
  'tn-tl-fd1': 476,
  'ss7ns': 477,
  'spsc': 478,
  'iafserver': 479,
  'iafdbase': 480,
  'ph': 481,
  'bgs-nsi': 482,
  'ulpnet': 483,
  'integra-sme': 484,
  'powerburst': 485,
  'avian': 486,
  'saft': 487,
  'gss-http': 488,
  'nest-protocol': 489,
  'micom-pfs': 490,
  'go-login': 491,
  'ticf-1': 492,
  'ticf-2': 493,
  'pov-ray': 494,
  'intecourier': 495,
  'pim-rp-disc': 496,
  'dantz': 497,
  'siam': 498,
  'iso-ill': 499,
  'isakmp': 500,
  'stmf': 501,
  'asa-appl-proto': 502,
  'intrinsa': 503,
  'citadel': 504,
  'mailbox-lm': 505,
  'ohimsrv': 506,
  'crs': 507,
  'xvttp': 508,
  'snare': 509,
  'fcp': 510,
  'passgo': 511,
  'exec': 512,
  'comsat': 512,
  'biff': 512,
  'login': 513,
  'who': 513,
  'shell': 514,
  'syslog': 514,
  'printer': 515,
  'videotex': 516,
  'talk': 517,
  'ntalk': 518,
  'utime': 519,
  'efs': 520,
  'router': 520,
  'ripng': 521,
  'ulp': 522,
  'ibm-db2': 523,
  'ncp': 524,
  'timed': 525,
  'tempo': 526,
  'stx': 527,
  'custix': 528,
  'irc-serv': 529,
  'courier': 530,
  'conference': 531,
  'netnews': 532,
  'netwall': 533,
  'windream': 534,
  'iiop': 535,
  'opalis-rdv': 536,
  'nmsp': 537,
  'gdomap': 538,
  'apertus-ldp': 539,
  'uucp': 540,
  'uucp-rlogin': 541,
  'commerce': 542,
  'klogin': 543,
  'kshell': 544,
  'appleqtcsrvr': 545,
  'dhcpv6-client': 546,
  'dhcpv6-server': 547,
  'afpovertcp': 548,
  'idfp': 549,
  'new-rwho': 550,
  'cybercash': 551,
  'devshr-nts': 552,
  'pirp': 553,
  'rtsp': 554,
  'dsf': 555,
  'remotefs': 556,
  'openvms-sysipc': 557,
  'sdnskmp': 558,
  'teedtap': 559,
  'rmonitor': 560,
  'monitor': 561,
  'chshell': 562,
  'nntps': 563,
  '9pfs': 564,
  'whoami': 565,
  'streettalk': 566,
  'banyan-rpc': 567,
  'ms-shuttle': 568,
  'ms-rome': 569,
  'meter': 570,
  'sonar': 572,
  'banyan-vip': 573,
  'ftp-agent': 574,
  'vemmi': 575,
  'ipcd': 576,
  'vnas': 577,
  'ipdd': 578,
  'decbsrv': 579,
  'sntp-heartbeat': 580,
  'bdp': 581,
  'scc-security': 582,
  'philips-vc': 583,
  'keyserver': 584,
  'password-chg': 586,
  'submission': 587,
  'cal': 588,
  'eyelink': 589,
  'tns-cml': 590,
  'http-alt': 591,
  'eudora-set': 592,
  'http-rpc-epmap': 593,
  'tpip': 594,
  'cab-protocol': 595,
  'smsd': 596,
  'ptcnameservice': 597,
  'sco-websrvrmg3': 598,
  'acp': 599,
  'ipcserver': 600,
  'syslog-conn': 601,
  'xmlrpc-beep': 602,
  'idxp': 603,
  'tunnel': 604,
  'soap-beep': 605,
  'urm': 606,
  'nqs': 607,
  'sift-uft': 608,
  'npmp-trap': 609,
  'npmp-local': 610,
  'npmp-gui': 611,
  'hmmp-ind': 612,
  'hmmp-op': 613,
  'sshell': 614,
  'sco-inetmgr': 615,
  'sco-sysmgr': 616,
  'sco-dtmgr': 617,
  'dei-icda': 618,
  'compaq-evm': 619,
  'sco-websrvrmgr': 620,
  'escp-ip': 621,
  'collaborator': 622,
  'oob-ws-http': 623,
  'asf-rmcp': 623,
  'cryptoadmin': 624,
  'dec_dlm': 625,
  'asia': 626,
  'passgo-tivoli': 627,
  'qmqp': 628,
  '3com-amp3': 629,
  'rda': 630,
  'ipp': 631,
  'bmpp': 632,
  'servstat': 633,
  'ginad': 634,
  'rlzdbase': 635,
  'ldaps': 636,
  'lanserver': 637,
  'mcns-sec': 638,
  'msdp': 639,
  'entrust-sps': 640,
  'repcmd': 641,
  'esro-emsdp': 642,
  'sanity': 643,
  'dwr': 644,
  'pssc': 645,
  'ldp': 646,
  'dhcp-failover': 647,
  'rrp': 648,
  'cadview-3d': 649,
  'obex': 650,
  'ieee-mms': 651,
  'hello-port': 652,
  'repscmd': 653,
  'aodv': 654,
  'tinc': 655,
  'spmp': 656,
  'rmc': 657,
  'tenfold': 658,
  'mac-srvr-admin': 660,
  'hap': 661,
  'pftp': 662,
  'purenoise': 663,
  'oob-ws-https': 664,
  'asf-secure-rmcp': 664,
  'sun-dr': 665,
  'mdqs': 666,
  'doom': 666,
  'disclose': 667,
  'mecomm': 668,
  'meregister': 669,
  'vacdsm-sws': 670,
  'vacdsm-app': 671,
  'vpps-qua': 672,
  'cimplex': 673,
  'acap': 674,
  'dctp': 675,
  'vpps-via': 676,
  'vpp': 677,
  'ggf-ncp': 678,
  'mrm': 679,
  'entrust-aaas': 680,
  'entrust-aams': 681,
  'xfr': 682,
  'corba-iiop': 683,
  'corba-iiop-ssl': 684,
  'mdc-portmapper': 685,
  'hcp-wismar': 686,
  'asipregistry': 687,
  'realm-rusd': 688,
  'nmap': 689,
  'vatp': 690,
  'msexch-routing': 691,
  'hyperwave-isp': 692,
  'connendp': 693,
  'ha-cluster': 694,
  'ieee-mms-ssl': 695,
  'rushd': 696,
  'uuidgen': 697,
  'olsr': 698,
  'accessnetwork': 699,
  'epp': 700,
  'lmp': 701,
  'iris-beep': 702,
  'elcsd': 704,
  'agentx': 705,
  'silc': 706,
  'borland-dsj': 707,
  'entrust-kmsh': 709,
  'entrust-ash': 710,
  'cisco-tdp': 711,
  'tbrpf': 712,
  'iris-xpc': 713,
  'iris-xpcs': 714,
  'iris-lwz': 715,
  'pana': 716,
  'netviewdm1': 729,
  'netviewdm2': 730,
  'netviewdm3': 731,
  'netgw': 741,
  'netrcs': 742,
  'flexlm': 744,
  'fujitsu-dev': 747,
  'ris-cm': 748,
  'kerberos-adm': 749,
  'rfile': 750,
  'loadav': 750,
  'kerberos-iv': 750,
  'pump': 751,
  'qrh': 752,
  'rrh': 753,
  'tell': 754,
  'nlogin': 758,
  'con': 759,
  'ns': 760,
  'rxe': 761,
  'quotad': 762,
  'cycleserv': 763,
  'omserv': 764,
  'webster': 765,
  'phonebook': 767,
  'vid': 769,
  'cadlock': 770,
  'rtip': 771,
  'cycleserv2': 772,
  'submit': 773,
  'notify': 773,
  'rpasswd': 774,
  'acmaint_dbd': 774,
  'entomb': 775,
  'acmaint_transd': 775,
  'wpages': 776,
  'multiling-http': 777,
  'wpgs': 780,
  'mdbs_daemon': 800,
  'device': 801,
  'fcp-udp': 810,
  'itm-mcell-s': 828,
  'pkix-3-ca-ra': 829,
  'netconf-ssh': 830,
  'netconf-beep': 831,
  'netconfsoaphttp': 832,
  'netconfsoapbeep': 833,
  'dhcp-failover2': 847,
  'gdoi': 848,
  'iscsi': 860,
  'owamp-control': 861,
  'twamp-control': 862,
  'rsync': 873,
  'iclcnet-locate': 886,
  'iclcnet_svinfo': 887,
  'accessbuilder': 888,
  'cddbp': 888,
  'omginitialrefs': 900,
  'smpnameres': 901,
  'ideafarm-door': 902,
  'ideafarm-panic': 903,
  'kink': 910,
  'xact-backup': 911,
  'apex-mesh': 912,
  'apex-edge': 913,
  'ftps-data': 989,
  'ftps': 990,
  'nas': 991,
  'telnets': 992,
  'imaps': 993,
  'ircs': 994,
  'pop3s': 995,
  'vsinet': 996,
  'maitrd': 997,
  'busboy': 998,
  'puparp': 998,
  'garcon': 999,
  'applix': 999,
  'puprouter': 999,
  'cadlock2': 1000,
  'surf': 1010,
  'exp1': 1021,
  'exp2': 1022
};

/**
 * IANA Port Numbers by value
 * @const {Object}
 */

const servicesByVal = {
  1: 'tcpmux',
  2: 'compressnet',
  3: 'compressnet',
  5: 'rje',
  7: 'echo',
  9: 'discard',
  11: 'systat',
  13: 'daytime',
  17: 'qotd',
  18: 'msp',
  19: 'chargen',
  20: 'ftp-data',
  21: 'ftp',
  22: 'ssh',
  23: 'telnet',
  25: 'smtp',
  27: 'nsw-fe',
  29: 'msg-icp',
  31: 'msg-auth',
  33: 'dsp',
  37: 'time',
  38: 'rap',
  39: 'rlp',
  41: 'graphics',
  42: 'name',
  43: 'nicname',
  44: 'mpm-flags',
  45: 'mpm',
  46: 'mpm-snd',
  47: 'ni-ftp',
  48: 'auditd',
  49: 'tacacs',
  50: 're-mail-ck',
  51: 'la-maint',
  52: 'xns-time',
  53: 'domain',
  54: 'xns-ch',
  55: 'isi-gl',
  56: 'xns-auth',
  58: 'xns-mail',
  61: 'ni-mail',
  62: 'acas',
  63: 'whois++',
  64: 'covia',
  65: 'tacacs-ds',
  66: 'sql*net',
  67: 'bootps',
  68: 'bootpc',
  69: 'tftp',
  70: 'gopher',
  71: 'netrjs-1',
  72: 'netrjs-2',
  73: 'netrjs-3',
  74: 'netrjs-4',
  76: 'deos',
  78: 'vettcp',
  79: 'finger',
  80: 'http',
  82: 'xfer',
  83: 'mit-ml-dev',
  84: 'ctf',
  85: 'mit-ml-dev',
  86: 'mfcobol',
  88: 'kerberos',
  89: 'su-mit-tg',
  90: 'dnsix',
  91: 'mit-dov',
  92: 'npp',
  93: 'dcp',
  94: 'objcall',
  95: 'supdup',
  96: 'dixie',
  97: 'swift-rvf',
  98: 'tacnews',
  99: 'metagram',
  100: 'newacct',
  101: 'hostname',
  102: 'iso-tsap',
  103: 'gppitnp',
  104: 'acr-nema',
  105: 'cso',
  106: '3com-tsmux',
  107: 'rtelnet',
  108: 'snagas',
  109: 'pop2',
  110: 'pop3',
  111: 'sunrpc',
  112: 'mcidas',
  113: 'ident',
  115: 'sftp',
  116: 'ansanotify',
  117: 'uucp-path',
  118: 'sqlserv',
  119: 'nntp',
  120: 'cfdptkt',
  121: 'erpc',
  122: 'smakynet',
  123: 'ntp',
  124: 'ansatrader',
  125: 'locus-map',
  126: 'nxedit',
  127: 'locus-con',
  128: 'gss-xlicen',
  129: 'pwdgen',
  130: 'cisco-fna',
  131: 'cisco-tna',
  132: 'cisco-sys',
  133: 'statsrv',
  134: 'ingres-net',
  135: 'epmap',
  136: 'profile',
  137: 'netbios-ns',
  138: 'netbios-dgm',
  139: 'netbios-ssn',
  140: 'emfis-data',
  141: 'emfis-cntl',
  142: 'bl-idm',
  143: 'imap',
  144: 'uma',
  145: 'uaac',
  146: 'iso-tp0',
  147: 'iso-ip',
  148: 'jargon',
  149: 'aed-512',
  150: 'sql-net',
  151: 'hems',
  152: 'bftp',
  153: 'sgmp',
  154: 'netsc-prod',
  155: 'netsc-dev',
  156: 'sqlsrv',
  157: 'knet-cmp',
  158: 'pcmail-srv',
  159: 'nss-routing',
  160: 'sgmp-traps',
  161: 'snmp',
  162: 'snmptrap',
  163: 'cmip-man',
  164: 'cmip-agent',
  165: 'xns-courier',
  166: 's-net',
  167: 'namp',
  168: 'rsvd',
  169: 'send',
  170: 'print-srv',
  171: 'multiplex',
  172: 'cl/1',
  173: 'xyplex-mux',
  174: 'mailq',
  175: 'vmnet',
  176: 'genrad-mux',
  177: 'xdmcp',
  178: 'nextstep',
  179: 'bgp',
  180: 'ris',
  181: 'unify',
  182: 'audit',
  183: 'ocbinder',
  184: 'ocserver',
  185: 'remote-kis',
  186: 'kis',
  187: 'aci',
  188: 'mumps',
  189: 'qft',
  190: 'gacp',
  191: 'prospero',
  192: 'osu-nms',
  193: 'srmp',
  194: 'irc',
  195: 'dn6-nlm-aud',
  196: 'dn6-smm-red',
  197: 'dls',
  198: 'dls-mon',
  199: 'smux',
  200: 'src',
  201: 'at-rtmp',
  202: 'at-nbp',
  203: 'at-3',
  204: 'at-echo',
  205: 'at-5',
  206: 'at-zis',
  207: 'at-7',
  208: 'at-8',
  209: 'qmtp',
  210: 'z39.50',
  211: '914c/g',
  212: 'anet',
  213: 'ipx',
  214: 'vmpwscs',
  215: 'softpc',
  216: 'CAIlic',
  217: 'dbase',
  218: 'mpp',
  219: 'uarps',
  220: 'imap3',
  221: 'fln-spx',
  222: 'rsh-spx',
  223: 'cdc',
  224: 'masqdialer',
  242: 'direct',
  243: 'sur-meas',
  244: 'inbusiness',
  245: 'link',
  246: 'dsp3270',
  247: 'subntbcst_tftp',
  248: 'bhfhs',
  256: 'rap',
  257: 'set',
  259: 'esro-gen',
  260: 'openport',
  261: 'nsiiops',
  262: 'arcisdms',
  263: 'hdap',
  264: 'bgmp',
  265: 'x-bone-ctl',
  266: 'sst',
  267: 'td-service',
  268: 'td-replica',
  269: 'manet',
  270: 'gist',
  280: 'http-mgmt',
  281: 'personal-link',
  282: 'cableport-ax',
  283: 'rescap',
  284: 'corerjd',
  286: 'fxp',
  287: 'k-block',
  308: 'novastorbakcup',
  309: 'entrusttime',
  310: 'bhmds',
  311: 'asip-webadmin',
  312: 'vslmp',
  313: 'magenta-logic',
  314: 'opalis-robot',
  315: 'dpsi',
  316: 'decauth',
  317: 'zannet',
  318: 'pkix-timestamp',
  319: 'ptp-event',
  320: 'ptp-general',
  321: 'pip',
  322: 'rtsps',
  333: 'texar',
  344: 'pdap',
  345: 'pawserv',
  346: 'zserv',
  347: 'fatserv',
  348: 'csi-sgwp',
  349: 'mftp',
  350: 'matip-type-a',
  351: 'matip-type-b',
  352: 'dtag-ste-sb',
  353: 'ndsauth',
  354: 'bh611',
  355: 'datex-asn',
  356: 'cloanto-net-1',
  357: 'bhevent',
  358: 'shrinkwrap',
  359: 'nsrmp',
  360: 'scoi2odialog',
  361: 'semantix',
  362: 'srssend',
  363: 'rsvp_tunnel',
  364: 'aurora-cmgr',
  365: 'dtk',
  366: 'odmr',
  367: 'mortgageware',
  368: 'qbikgdp',
  369: 'rpc2portmap',
  370: 'codaauth2',
  371: 'clearcase',
  372: 'ulistproc',
  373: 'legent-1',
  374: 'legent-2',
  375: 'hassle',
  376: 'nip',
  377: 'tnETOS',
  378: 'dsETOS',
  379: 'is99c',
  380: 'is99s',
  381: 'hp-collector',
  382: 'hp-managed-node',
  383: 'hp-alarm-mgr',
  384: 'arns',
  385: 'ibm-app',
  386: 'asa',
  387: 'aurp',
  388: 'unidata-ldm',
  389: 'ldap',
  390: 'uis',
  391: 'synotics-relay',
  392: 'synotics-broker',
  393: 'meta5',
  394: 'embl-ndt',
  395: 'netcp',
  396: 'netware-ip',
  397: 'mptn',
  398: 'kryptolan',
  399: 'iso-tsap-c2',
  400: 'osb-sd',
  401: 'ups',
  402: 'genie',
  403: 'decap',
  404: 'nced',
  405: 'ncld',
  406: 'imsp',
  407: 'timbuktu',
  408: 'prm-sm',
  409: 'prm-nm',
  410: 'decladebug',
  411: 'rmt',
  412: 'synoptics-trap',
  413: 'smsp',
  414: 'infoseek',
  415: 'bnet',
  416: 'silverplatter',
  417: 'onmux',
  418: 'hyper-g',
  419: 'ariel1',
  420: 'smpte',
  421: 'ariel2',
  422: 'ariel3',
  423: 'opc-job-start',
  424: 'opc-job-track',
  425: 'icad-el',
  426: 'smartsdp',
  427: 'svrloc',
  428: 'ocs_cmu',
  429: 'ocs_amu',
  430: 'utmpsd',
  431: 'utmpcd',
  432: 'iasd',
  433: 'nnsp',
  434: 'mobileip-agent',
  435: 'mobilip-mn',
  436: 'dna-cml',
  437: 'comscm',
  438: 'dsfgw',
  439: 'dasp',
  440: 'sgcp',
  441: 'decvms-sysmgt',
  442: 'cvc_hostd',
  443: 'https',
  444: 'snpp',
  445: 'microsoft-ds',
  446: 'ddm-rdb',
  447: 'ddm-dfm',
  448: 'ddm-ssl',
  449: 'as-servermap',
  450: 'tserver',
  451: 'sfs-smp-net',
  452: 'sfs-config',
  453: 'creativeserver',
  454: 'contentserver',
  455: 'creativepartnr',
  456: 'macon-tcp',
  457: 'scohelp',
  458: 'appleqtc',
  459: 'ampr-rcmd',
  460: 'skronk',
  461: 'datasurfsrv',
  462: 'datasurfsrvsec',
  463: 'alpes',
  464: 'kpasswd',
  465: 'urd',
  466: 'digital-vrc',
  467: 'mylex-mapd',
  468: 'photuris',
  469: 'rcp',
  470: 'scx-proxy',
  471: 'mondex',
  472: 'ljk-login',
  473: 'hybrid-pop',
  474: 'tn-tl-w1',
  475: 'tcpnethaspsrv',
  476: 'tn-tl-fd1',
  477: 'ss7ns',
  478: 'spsc',
  479: 'iafserver',
  480: 'iafdbase',
  481: 'ph',
  482: 'bgs-nsi',
  483: 'ulpnet',
  484: 'integra-sme',
  485: 'powerburst',
  486: 'avian',
  487: 'saft',
  488: 'gss-http',
  489: 'nest-protocol',
  490: 'micom-pfs',
  491: 'go-login',
  492: 'ticf-1',
  493: 'ticf-2',
  494: 'pov-ray',
  495: 'intecourier',
  496: 'pim-rp-disc',
  497: 'dantz',
  498: 'siam',
  499: 'iso-ill',
  500: 'isakmp',
  501: 'stmf',
  502: 'asa-appl-proto',
  503: 'intrinsa',
  504: 'citadel',
  505: 'mailbox-lm',
  506: 'ohimsrv',
  507: 'crs',
  508: 'xvttp',
  509: 'snare',
  510: 'fcp',
  511: 'passgo',
  512: 'exec',
  513: 'login',
  514: 'shell',
  515: 'printer',
  516: 'videotex',
  517: 'talk',
  518: 'ntalk',
  519: 'utime',
  520: 'efs',
  521: 'ripng',
  522: 'ulp',
  523: 'ibm-db2',
  524: 'ncp',
  525: 'timed',
  526: 'tempo',
  527: 'stx',
  528: 'custix',
  529: 'irc-serv',
  530: 'courier',
  531: 'conference',
  532: 'netnews',
  533: 'netwall',
  534: 'windream',
  535: 'iiop',
  536: 'opalis-rdv',
  537: 'nmsp',
  538: 'gdomap',
  539: 'apertus-ldp',
  540: 'uucp',
  541: 'uucp-rlogin',
  542: 'commerce',
  543: 'klogin',
  544: 'kshell',
  545: 'appleqtcsrvr',
  546: 'dhcpv6-client',
  547: 'dhcpv6-server',
  548: 'afpovertcp',
  549: 'idfp',
  550: 'new-rwho',
  551: 'cybercash',
  552: 'devshr-nts',
  553: 'pirp',
  554: 'rtsp',
  555: 'dsf',
  556: 'remotefs',
  557: 'openvms-sysipc',
  558: 'sdnskmp',
  559: 'teedtap',
  560: 'rmonitor',
  561: 'monitor',
  562: 'chshell',
  563: 'nntps',
  564: '9pfs',
  565: 'whoami',
  566: 'streettalk',
  567: 'banyan-rpc',
  568: 'ms-shuttle',
  569: 'ms-rome',
  570: 'meter',
  571: 'meter',
  572: 'sonar',
  573: 'banyan-vip',
  574: 'ftp-agent',
  575: 'vemmi',
  576: 'ipcd',
  577: 'vnas',
  578: 'ipdd',
  579: 'decbsrv',
  580: 'sntp-heartbeat',
  581: 'bdp',
  582: 'scc-security',
  583: 'philips-vc',
  584: 'keyserver',
  586: 'password-chg',
  587: 'submission',
  588: 'cal',
  589: 'eyelink',
  590: 'tns-cml',
  591: 'http-alt',
  592: 'eudora-set',
  593: 'http-rpc-epmap',
  594: 'tpip',
  595: 'cab-protocol',
  596: 'smsd',
  597: 'ptcnameservice',
  598: 'sco-websrvrmg3',
  599: 'acp',
  600: 'ipcserver',
  601: 'syslog-conn',
  602: 'xmlrpc-beep',
  603: 'idxp',
  604: 'tunnel',
  605: 'soap-beep',
  606: 'urm',
  607: 'nqs',
  608: 'sift-uft',
  609: 'npmp-trap',
  610: 'npmp-local',
  611: 'npmp-gui',
  612: 'hmmp-ind',
  613: 'hmmp-op',
  614: 'sshell',
  615: 'sco-inetmgr',
  616: 'sco-sysmgr',
  617: 'sco-dtmgr',
  618: 'dei-icda',
  619: 'compaq-evm',
  620: 'sco-websrvrmgr',
  621: 'escp-ip',
  622: 'collaborator',
  623: 'oob-ws-http',
  624: 'cryptoadmin',
  625: 'dec_dlm',
  626: 'asia',
  627: 'passgo-tivoli',
  628: 'qmqp',
  629: '3com-amp3',
  630: 'rda',
  631: 'ipp',
  632: 'bmpp',
  633: 'servstat',
  634: 'ginad',
  635: 'rlzdbase',
  636: 'ldaps',
  637: 'lanserver',
  638: 'mcns-sec',
  639: 'msdp',
  640: 'entrust-sps',
  641: 'repcmd',
  642: 'esro-emsdp',
  643: 'sanity',
  644: 'dwr',
  645: 'pssc',
  646: 'ldp',
  647: 'dhcp-failover',
  648: 'rrp',
  649: 'cadview-3d',
  650: 'obex',
  651: 'ieee-mms',
  652: 'hello-port',
  653: 'repscmd',
  654: 'aodv',
  655: 'tinc',
  656: 'spmp',
  657: 'rmc',
  658: 'tenfold',
  660: 'mac-srvr-admin',
  661: 'hap',
  662: 'pftp',
  663: 'purenoise',
  664: 'oob-ws-https',
  665: 'sun-dr',
  666: 'mdqs',
  667: 'disclose',
  668: 'mecomm',
  669: 'meregister',
  670: 'vacdsm-sws',
  671: 'vacdsm-app',
  672: 'vpps-qua',
  673: 'cimplex',
  674: 'acap',
  675: 'dctp',
  676: 'vpps-via',
  677: 'vpp',
  678: 'ggf-ncp',
  679: 'mrm',
  680: 'entrust-aaas',
  681: 'entrust-aams',
  682: 'xfr',
  683: 'corba-iiop',
  684: 'corba-iiop-ssl',
  685: 'mdc-portmapper',
  686: 'hcp-wismar',
  687: 'asipregistry',
  688: 'realm-rusd',
  689: 'nmap',
  690: 'vatp',
  691: 'msexch-routing',
  692: 'hyperwave-isp',
  693: 'connendp',
  694: 'ha-cluster',
  695: 'ieee-mms-ssl',
  696: 'rushd',
  697: 'uuidgen',
  698: 'olsr',
  699: 'accessnetwork',
  700: 'epp',
  701: 'lmp',
  702: 'iris-beep',
  704: 'elcsd',
  705: 'agentx',
  706: 'silc',
  707: 'borland-dsj',
  709: 'entrust-kmsh',
  710: 'entrust-ash',
  711: 'cisco-tdp',
  712: 'tbrpf',
  713: 'iris-xpc',
  714: 'iris-xpcs',
  715: 'iris-lwz',
  716: 'pana',
  729: 'netviewdm1',
  730: 'netviewdm2',
  731: 'netviewdm3',
  741: 'netgw',
  742: 'netrcs',
  744: 'flexlm',
  747: 'fujitsu-dev',
  748: 'ris-cm',
  749: 'kerberos-adm',
  750: 'rfile',
  751: 'pump',
  752: 'qrh',
  753: 'rrh',
  754: 'tell',
  758: 'nlogin',
  759: 'con',
  760: 'ns',
  761: 'rxe',
  762: 'quotad',
  763: 'cycleserv',
  764: 'omserv',
  765: 'webster',
  767: 'phonebook',
  769: 'vid',
  770: 'cadlock',
  771: 'rtip',
  772: 'cycleserv2',
  773: 'submit',
  774: 'rpasswd',
  775: 'entomb',
  776: 'wpages',
  777: 'multiling-http',
  780: 'wpgs',
  800: 'mdbs_daemon',
  801: 'device',
  810: 'fcp-udp',
  828: 'itm-mcell-s',
  829: 'pkix-3-ca-ra',
  830: 'netconf-ssh',
  831: 'netconf-beep',
  832: 'netconfsoaphttp',
  833: 'netconfsoapbeep',
  847: 'dhcp-failover2',
  848: 'gdoi',
  860: 'iscsi',
  861: 'owamp-control',
  862: 'twamp-control',
  873: 'rsync',
  886: 'iclcnet-locate',
  887: 'iclcnet_svinfo',
  888: 'accessbuilder',
  900: 'omginitialrefs',
  901: 'smpnameres',
  902: 'ideafarm-door',
  903: 'ideafarm-panic',
  910: 'kink',
  911: 'xact-backup',
  912: 'apex-mesh',
  913: 'apex-edge',
  989: 'ftps-data',
  990: 'ftps',
  991: 'nas',
  992: 'telnets',
  993: 'imaps',
  994: 'ircs',
  995: 'pop3s',
  996: 'vsinet',
  997: 'maitrd',
  998: 'busboy',
  999: 'garcon',
  1000: 'cadlock2',
  1010: 'surf',
  1021: 'exp1',
  1022: 'exp2'
};

/*
 * Helpers
 */

function getPort(service) {
  assert(typeof service === 'string');

  const port = services[service];

  if ((port & 0xffff) !== port)
    return 0;

  return port;
}

function getService(port) {
  assert((port & 0xffff) === port);
  return servicesByVal[port] || null;
}

function protocolToString(protocol) {
  return toSymbol(protocol, 'protocol', protocolsByVal, 'PROTOCOL', 0xff, 3);
}

function stringToProtocol(symbol) {
  return fromSymbol(symbol, 'protocol', protocols, 'PROTOCOL', 0xff, 3);
}

function isProtocolString(symbol) {
  return isSymbol(symbol, 'protocol', protocols, 'PROTOCOL', 0xff, 3);
}

/*
 * Expose
 */

iana.protocols = protocols;
iana.protocolsByVal = protocolsByVal;
iana.services = services;
iana.servicesByVal = servicesByVal;

iana.getPort = getPort;
iana.getService = getService;
iana.protocolToString = protocolToString;
iana.stringToProtocol = stringToProtocol;
iana.isProtocolString = isProtocolString;
}],
[/* 83 */ 'bns-plus', '/lib/internal/scan.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * scan.js - zone file parsing for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 *
 * Parts of this software are based on miekg/dns:
 *   https://github.com/miekg/dns/blob/master/scan.go
 *   https://github.com/miekg/dns/blob/master/scan_rr.go
 *   https://github.com/miekg/dns/blob/master/generate.go
 */

/* eslint spaced-comment: 0 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const fs = __browser_require__(84 /* 'bfile' */, module);
const IP = __browser_require__(4 /* 'binet' */, module);
const bio = __browser_require__(14 /* 'bufio' */, module);
const base32 = __browser_require__(7 /* 'bs32' */, module);
const Path = __browser_require__(87 /* 'path' */, module);
const encoding = __browser_require__(80 /* '../encoding' */, module);
const constants = __browser_require__(11 /* '../constants' */, module);
const lazy = __browser_require__(81 /* './lazy' */, module);
const schema = __browser_require__(88 /* './schema' */, module);
const util = __browser_require__(79 /* '../util' */, module);

const {
  dirname,
  resolve
} = Path;

const {
  types,
  classes,
  options,
  optionToString,
  stringToClass,
  stringToOption,
  stringToType,
  typeToString,
  DEFAULT_TTL,
  LOC_EQUATOR,
  LOC_PRIMEMERIDIAN
} = constants;

/*
 * Constants
 */

const MAX_TOKEN = 2048;
const MAX_INCLUDES = 7;
const DUMMY = Buffer.alloc(0);

const tokens = {
  EOF: 0,
  STRING: 1,
  BLANK: 2,
  QUOTE: 3,
  NEWLINE: 4,
  RRTYPE: 5,
  OWNER: 6,
  CLASS: 7,
  DIR_ORIGIN: 8,
  DIR_TTL: 9,
  DIR_INCLUDE: 10,
  DIR_GENERATE: 11,
  VALUE: 12,
  KEY: 13
};

const tokensByVal = {
  [tokens.EOF]: 'EOF',
  [tokens.STRING]: 'STRING',
  [tokens.BLANK]: 'BLANK',
  [tokens.QUOTE]: 'QUOTE',
  [tokens.NEWLINE]: 'NEWLINE',
  [tokens.RRTYPE]: 'RRTYPE',
  [tokens.OWNER]: 'OWNER',
  [tokens.CLASS]: 'CLASS',
  [tokens.DIR_ORIGIN]: 'DIR_ORIGIN',
  [tokens.DIR_TTL]: 'DIR_TTL',
  [tokens.DIR_INCLUDE]: 'DIR_INCLUDE',
  [tokens.DIR_GENERATE]: 'DIR_GENERATE',
  [tokens.KEY]: 'KEY',
  [tokens.VALUE]: 'VALUE'
};

const states = {
  EXPECT_OWNER_DIR: 0,
  EXPECT_OWNER_BL: 1,
  EXPECT_ANY: 2,
  EXPECT_ANY_NO_CLASS: 3,
  EXPECT_ANY_NO_CLASS_BL: 4,
  EXPECT_ANY_NO_TTL: 5,
  EXPECT_ANY_NO_TTL_BL: 6,
  EXPECT_RRTYPE: 7,
  EXPECT_RRTYPE_BL: 8,
  EXPECT_RDATA: 9,
  EXPECT_DIR_TTL_BL: 10,
  EXPECT_DIR_TTL: 11,
  EXPECT_DIR_ORIGIN_BL: 12,
  EXPECT_DIR_ORIGIN: 13,
  EXPECT_DIR_INCLUDE_BL: 14,
  EXPECT_DIR_INCLUDE: 15,
  EXPECT_DIR_GENERATE: 16,
  EXPECT_DIR_GENERATE_BL: 17
};

/**
 * Parse Error
 * @extends {Error}
 */

class ParseError extends Error {
  constructor(msg, tok, file, parent) {
    super();

    if (!msg)
      msg = 'parse error';

    if (!tok)
      tok = null;

    if (!file)
      file = '';

    if (!parent)
      parent = ParseError;

    if (tok) {
      if (!tok.error) {
        const name = tokensByVal[tok.type] || '';
        msg += `: ${JSON.stringify(tok.string)}`;
        msg += ` (${name.toLowerCase()})`;
      }
      msg += ' at line:';
      msg += ` ${tok.line}:${tok.col}`;
    }

    if (file)
      msg += ` (${file})`;

    msg += '.';

    this.type = 'ParseError';
    this.name = 'ParseError';
    this.code = 'EPARSEERROR';
    this.message = msg;
    this.tok = tok;
    this.file = file;

    if (Error.captureStackTrace)
      Error.captureStackTrace(this, parent);
  }
}

/**
 * Item
 */

class Item {
  constructor() {
    this.record = null;
    this.comment = '';
    this.error = null;
  }

  static fromRecord(record, comment) {
    const item = new this();
    item.record = record;
    item.comment = comment || '';
    return item;
  }

  static fromString(msg, tok, file) {
    const err = new ParseError(msg, tok, file, this.fromString);
    const item = new this();
    item.error = err;
    return item;
  }

  static fromError(err, tok, file) {
    if (err.type === 'ParseError') {
      if (tok && !err.tok)
        err.tok = tok;
      if (file && !err.file)
        err.file = file;
    }
    const item = new this();
    item.error = err;
    return item;
  }
}

/**
 * TTL State
 */

class TTLState {
  constructor(ttl, directive) {
    this.ttl = ttl || 0;
    this.directive = directive || false;
  }
}

/**
 * Token
 */

class Token {
  constructor(line, col) {
    this.string = '';
    this.error = false;
    this.type = tokens.EOF;
    this.line = line || 0;
    this.col = col || 0;
    this.value = 0;
    this.unknown = false;
    this.comment = '';
  }

  end() {
    return this.type === tokens.EOF
        || this.type === tokens.NEWLINE;
  }
}

/*
 * Lexer
 */

function* lexer(input, zone) {
  if (zone == null)
    zone = true;

  assert(typeof input === 'string');
  assert(typeof zone === 'boolean');

  let str = '';
  let com = '';
  let quote = false;
  let escape = false;
  let space = false;
  let commt = false;
  let rrtype = false;
  let owner = true;
  let brace = 0;
  let line = 0;
  let col = 0;

  for (let i = 0; i < input.length; i++) {
    const ch = input[i];

    if (str.length >= MAX_TOKEN) {
      const tok = new Token(line, col);
      tok.string = 'token length insufficient for parsing';
      tok.error = true;
      yield tok;
      return;
    }

    if (com.length >= MAX_TOKEN) {
      const tok = new Token(line, col);
      tok.string = 'comment length insufficient for parsing';
      tok.error = true;
      yield tok;
      return;
    }

    switch (ch) {
      case ' ':
      case '\t': {
        if (escape) {
          escape = false;
          str += ch;
          break;
        }

        if (quote) {
          str += ch;
          break;
        }

        if (commt) {
          com += ch;
          break;
        }

        if (str.length === 0) {
          ;
        } else if (owner && zone) {
          const tok = new Token(line, col);

          tok.type = tokens.OWNER;
          tok.string = str;

          switch (str.toUpperCase()) {
            case '$TTL':
              tok.type = tokens.DIR_TTL;
              break;
            case '$ORIGIN':
              tok.type = tokens.DIR_ORIGIN;
              break;
            case '$INCLUDE':
              tok.type = tokens.DIR_INCLUDE;
              break;
            case '$GENERATE':
              tok.type = tokens.DIR_GENERATE;
              break;
          }

          yield tok;
        } else {
          const tok = new Token(line, col);

          tok.type = tokens.STRING;
          tok.string = str;

          if (!rrtype) {
            const upper = str.toUpperCase();
            const t = types[upper];

            if ((t & 0xffff) === t && t !== types.ANY) {
              tok.type = tokens.RRTYPE;
              tok.value = t;
              rrtype = true;
            } else {
              if (util.startsWith(upper, 'TYPE')) {
                let t;
                try {
                  t = stringToType(upper);
                } catch (e) {
                  tok.string = 'unknown RR type';
                  tok.error = true;
                  yield tok;
                  return;
                }
                tok.type = tokens.RRTYPE;
                tok.unknown = true;
                tok.value = t;
                rrtype = true;
              }
            }

            if (!rrtype) {
              const c = classes[upper];

              if ((c & 0xffff) === c) {
                tok.type = tokens.CLASS;
                tok.value = c;
              } else {
                if (util.startsWith(upper, 'CLASS')) {
                  let c;
                  try {
                    c = stringToClass(upper);
                  } catch (e) {
                    tok.string = 'unknown class';
                    tok.error = true;
                    yield tok;
                    return;
                  }
                  tok.type = tokens.CLASS;
                  tok.unknown = true;
                  tok.value = c;
                }
              }
            }
          }

          yield tok;
        }

        str = '';

        if (!space && !commt) {
          const tok = new Token(line, col);
          tok.type = tokens.BLANK;
          tok.string = ' ';
          yield tok;
        }

        owner = false;
        space = true;

        break;
      }

      case ';': {
        if (escape) {
          escape = false;
          str += ch;
          break;
        }

        if (quote) {
          str += ch;
          break;
        }

        if (str.length > 0) {
          const tok = new Token(line, col);

          tok.type = tokens.STRING;
          tok.string = str;

          yield tok;

          str = '';
        }

        commt = true;
        com += ';';

        break;
      }

      case '\r': {
        escape = false;

        if (quote) {
          str += ch;
          break;
        }

        break;
      }

      case '\n': {
        escape = false;
        line += 1;
        col = 0;

        if (quote) {
          str += ch;
          break;
        }

        if (commt) {
          commt = false;
          rrtype = false;
          str = '';

          if (brace === 0) {
            owner = true;

            const tok = new Token(line, col);

            tok.type = tokens.NEWLINE;
            tok.string = '\n';
            tok.comment = com;

            yield tok;

            com = '';

            break;
          }

          com += ' ';

          break;
        }

        if (brace === 0) {
          if (str.length > 0) {
            const tok = new Token(line, col);

            tok.type = tokens.STRING;
            tok.string = str;

            if (!rrtype) {
              const upper = str.toUpperCase();
              const t = types[upper];

              if ((t & 0xffff) === t && t !== types.ANY) {
                tok.type = tokens.RRTYPE;
                tok.value = t;
                rrtype = true;
              }
            }

            yield tok;
          }

          const tok = new Token(line, col);

          tok.type = tokens.NEWLINE;
          tok.string = '\n';

          yield tok;

          str = '';
          commt = false;
          rrtype = false;
          owner = true;
          com = '';
        }

        break;
      }

      case '\\': {
        if (commt) {
          com += ch;
          break;
        }

        if (escape) {
          str += ch;
          escape = false;
          break;
        }

        str += ch;
        escape = true;
        break;
      }

      case '"': {
        if (commt) {
          com += ch;
          break;
        }

        if (escape) {
          str += ch;
          escape = false;
          break;
        }

        space = false;

        if (str.length > 0) {
          const tok = new Token(line, col);

          tok.type = tokens.STRING;
          tok.string = str;

          yield tok;

          str = '';
        }

        const tok = new Token(line, col);

        tok.type = tokens.QUOTE;
        tok.string = '"';

        yield tok;

        quote = !quote;

        break;
      }

      case '(':
      case ')': {
        if (commt) {
          com += ch;
          break;
        }

        if (escape) {
          str += ch;
          escape = false;
          break;
        }

        if (quote) {
          str += ch;
          break;
        }

        switch (ch) {
          case '(': {
            brace += 1;
            break;
          }
          case ')': {
            brace -= 1;
            if (brace < 0) {
              const tok = new Token(line, col);
              tok.string = 'extra closing brace';
              tok.error = true;
              yield tok;
              return;
            }
          }
        }

        break;
      }

      default: {
        escape = false;

        if (commt) {
          com += ch;
          break;
        }

        str += ch;
        space = false;

        break;
      }
    }

    col += 1;
  }

  if (str.length > 0) {
    const tok = new Token(line, col);
    tok.string = str;
    tok.type = tokens.STRING;
    tok.comment = com;
    yield tok;
  }

  if (brace !== 0) {
    const tok = new Token(line, col);
    tok.string = 'unbalanced brace';
    tok.error = true;
    yield tok;
    return;
  }

  const tok = new Token(line, col);

  tok.string = '';
  tok.type = tokens.EOF;
  tok.comment = com;

  yield tok;

  return;
}

/*
 * Parser
 */

function* parser(wire, input, origin, file, def, include) {
  if (origin == null)
    origin = '';

  if (file == null)
    file = '';

  if (def == null)
    def = null;

  if (include == null)
    include = 1;

  assert(wire && typeof wire.fromZone === 'function');
  assert(typeof input === 'string');
  assert(typeof origin === 'string');
  assert(typeof file === 'string');
  assert(def === null || (def instanceof TTLState));
  assert((include >>> 0) === include);

  if (origin !== '') {
    origin = util.fqdn(origin);

    if (!util.isName(origin)) {
      yield Item.fromString('bad initial origin name', new Token(), file);
      return;
    }
  }

  const hdr = new wire.Record();
  const dir = dirname(file);

  let state = states.EXPECT_OWNER_DIR;
  let unknown = false;
  let prev = '.';

  const iter = lexer(input, true);

  for (const tok of iter) {
    if (tok.error) {
      yield Item.fromString(tok.string, tok, file);
      return;
    }

    if (tok.type === tokens.EOF)
      break;

    switch (state) {
      case states.EXPECT_OWNER_DIR: {
        if (def)
          hdr.ttl = def.ttl;

        hdr.class = classes.IN;

        switch (tok.type) {
          case tokens.NEWLINE: {
            state = states.EXPECT_OWNER_DIR;
            break;
          }

          case tokens.OWNER: {
            try {
              prev = normalize(tok.string, origin);
            } catch (e) {
              yield Item.fromString('bad owner name', tok, file);
              return;
            }

            hdr.name = prev;
            state = states.EXPECT_OWNER_BL;

            break;
          }

          case tokens.DIR_TTL: {
            state = states.EXPECT_DIR_TTL_BL;
            break;
          }

          case tokens.DIR_ORIGIN: {
            state = states.EXPECT_DIR_ORIGIN_BL;
            break;
          }

          case tokens.DIR_INCLUDE: {
            state = states.EXPECT_DIR_INCLUDE_BL;
            break;
          }

          case tokens.DIR_GENERATE: {
            state = states.EXPECT_DIR_GENERATE_BL;
            break;
          }

          case tokens.RRTYPE: {
            hdr.name = prev;
            hdr.type = tok.value;
            unknown = tok.unknown;
            state = states.EXPECT_RDATA;
            break;
          }

          case tokens.CLASS: {
            hdr.name = prev;
            hdr.class = tok.value;
            state = states.EXPECT_ANY_NO_CLASS_BL;
            break;
          }

          case tokens.BLANK: {
            break;
          }

          case tokens.STRING: {
            try {
              hdr.ttl = stringToTTL(tok.string);
            } catch (e) {
              yield Item.fromString('not a TTL', tok, file);
              return;
            }

            if (!def || !def.directive)
              def = new TTLState(hdr.ttl, false);

            state = states.EXPECT_ANY_NO_TTL_BL;

            break;
          }

          default: {
            yield Item.fromString('syntax error at beginning', tok, file);
            return;
          }
        }

        break;
      }

      case states.EXPECT_DIR_INCLUDE_BL: {
        if (tok.type !== tokens.BLANK) {
          yield Item.fromString('no blank after $INCLUDE', tok, file);
          return;
        }
        state = states.EXPECT_DIR_INCLUDE;
        break;
      }

      case states.EXPECT_DIR_INCLUDE: {
        if (tok.type !== tokens.STRING) {
          yield Item.fromString('expected $INCLUDE value', tok, file);
          return;
        }

        if (!file) {
          yield Item.fromString('no path provided for $INCLUDE', tok, file);
          return;
        }

        let cinput = '';
        let corigin = origin;
        let cfile = tok.string;
        let next;

        try {
          next = read(iter, file);
        } catch (e) {
          yield Item.fromError(e, tok, file);
          return;
        }

        switch (next.type) {
          case tokens.BLANK: {
            try {
              next = read(iter, file);
            } catch (e) {
              yield Item.fromError(e, next, file);
              return;
            }

            if (next.type === tokens.STRING) {
              try {
                corigin = normalize(next.string, origin);
              } catch (e) {
                yield Item.fromString('bad origin name', next, file);
                return;
              }
            }

            break;
          }

          case tokens.EOF:
          case tokens.NEWLINE: {
            break;
          }

          default: {
            yield Item.fromString('garbage after $INCLUDE', next, file);
            return;
          }
        }

        cfile = resolve(dir, cfile);

        try {
          cinput = fs.readFileSync(cfile, 'utf8');
        } catch (e) {
          yield Item.fromString(`failed to open ${cfile}`, tok, file);
          return;
        }

        if (include + 1 > MAX_INCLUDES) {
          yield Item.fromString('too deeply nested $INCLUDE', tok, file);
          return;
        }

        yield* parser(wire, cinput, corigin, cfile, def, include + 1);

        state = states.EXPECT_OWNER_DIR;

        break;
      }

      case states.EXPECT_DIR_TTL_BL: {
        if (tok.type !== tokens.BLANK) {
          yield Item.fromString('no blank after $TTL', tok, file);
          return;
        }
        state = states.EXPECT_DIR_TTL;
        break;
      }

      case states.EXPECT_DIR_TTL: {
        if (tok.type !== tokens.STRING) {
          yield Item.fromString('expected $TTL value', tok, file);
          return;
        }

        try {
          slurp(iter, file);
        } catch (e) {
          yield Item.fromError(e, tok, file);
          return;
        }

        let ttl;
        try {
          ttl = stringToTTL(tok.string);
        } catch (e) {
          yield Item.fromString('expected $TTL value', tok, file);
          return;
        }

        def = new TTLState(ttl, true);
        state = states.EXPECT_OWNER_DIR;

        break;
      }

      case states.EXPECT_DIR_ORIGIN_BL: {
        if (tok.type !== tokens.BLANK) {
          yield Item.fromString('no blank after $ORIGIN', tok, file);
          return;
        }
        state = states.EXPECT_DIR_ORIGIN;
        break;
      }

      case states.EXPECT_DIR_ORIGIN: {
        if (tok.type !== tokens.STRING) {
          yield Item.fromString('expected $ORIGIN value', tok, file);
          return;
        }

        try {
          slurp(iter, file);
        } catch (e) {
          yield Item.fromError(e, tok, file);
          return;
        }

        try {
          origin = normalize(tok.string, origin);
        } catch (e) {
          yield Item.fromString('bad origin name', tok, file);
          return;
        }

        state = states.EXPECT_OWNER_DIR;

        break;
      }

      case states.EXPECT_DIR_GENERATE_BL: {
        if (tok.type !== tokens.BLANK) {
          yield Item.fromString('no blank after $GENERATE', tok, file);
          return;
        }
        state = states.EXPECT_DIR_GENERATE;
        break;
      }

      case states.EXPECT_DIR_GENERATE: {
        if (tok.type !== tokens.STRING) {
          yield Item.fromString('expected $GENERATE value', tok, file);
          return;
        }

        try {
          yield* generate(wire, iter, tok, origin, file);
        } catch (e) {
          yield Item.fromError(e, tok, file);
          return;
        }

        state = states.EXPECT_OWNER_DIR;

        break;
      }

      case states.EXPECT_OWNER_BL: {
        if (tok.type !== tokens.BLANK) {
          yield Item.fromString('no blank after owner', tok, file);
          return;
        }
        state = states.EXPECT_ANY;
        break;
      }

      case states.EXPECT_ANY: {
        switch (tok.type) {
          case tokens.RRTYPE: {
            if (!def) {
              yield Item.fromString('missing TTL', tok, file);
              return;
            }
            hdr.type = tok.value;
            unknown = tok.unknown;
            state = states.EXPECT_RDATA;
            break;
          }
          case tokens.CLASS: {
            hdr.class = tok.value;
            state = states.EXPECT_ANY_NO_CLASS_BL;
            break;
          }
          case tokens.STRING: {
            try {
              hdr.ttl = stringToTTL(tok.string);
            } catch (e) {
              yield Item.fromString('not a TTL', tok, file);
              return;
            }

            if (!def || !def.directive)
              def = new TTLState(hdr.ttl, false);

            state = states.EXPECT_ANY_NO_TTL_BL;

            break;
          }
          default: {
            yield Item.fromString('expected RR type, TTL or class', tok, file);
            return;
          }
        }
        break;
      }

      case states.EXPECT_ANY_NO_CLASS_BL: {
        if (tok.type !== tokens.BLANK) {
          yield Item.fromString('no blank before class', tok, file);
          return;
        }
        state = states.EXPECT_ANY_NO_CLASS;
        break;
      }

      case states.EXPECT_ANY_NO_TTL_BL: {
        if (tok.type !== tokens.BLANK) {
          yield Item.fromString('no blank before TTL', tok, file);
          return;
        }
        state = states.EXPECT_ANY_NO_TTL;
        break;
      }

      case states.EXPECT_ANY_NO_TTL: {
        switch (tok.type) {
          case tokens.CLASS: {
            hdr.class = tok.value;
            state = states.EXPECT_RRTYPE_BL;
            break;
          }
          case tokens.RRTYPE: {
            hdr.type = tok.value;
            unknown = tok.unknown;
            state = states.EXPECT_RDATA;
            break;
          }
          default: {
            yield Item.fromString('expected RR type or class', tok, file);
            return;
          }
        }
        break;
      }

      case states.EXPECT_ANY_NO_CLASS: {
        switch (tok.type) {
          case tokens.STRING: {
            try {
              hdr.ttl = stringToTTL(tok.string);
            } catch (e) {
              yield Item.fromString('not a TTL', tok, file);
              return;
            }

            if (!def || !def.directive)
              def = new TTLState(hdr.ttl, false);

            state = states.EXPECT_RRTYPE_BL;

            break;
          }
          case tokens.RRTYPE: {
            hdr.type = tok.value;
            unknown = tok.unknown;
            state = states.EXPECT_RDATA;
            break;
          }
          default: {
            yield Item.fromString('expected RR type or TTL', tok, file);
            return;
          }
        }
        break;
      }

      case states.EXPECT_RRTYPE_BL: {
        if (tok.type !== tokens.BLANK) {
          yield Item.fromString('no blank before RR type', tok, file);
          return;
        }
        state = states.EXPECT_RRTYPE;
        break;
      }

      case states.EXPECT_RRTYPE: {
        if (tok.type !== tokens.RRTYPE) {
          yield Item.fromString('unknown RR type', tok, file);
          return;
        }
        hdr.type = tok.value;
        unknown = tok.unknown;
        state = states.EXPECT_RDATA;
        break;
      }

      case states.EXPECT_RDATA: {
        const parse = unknown ? readUnknown : readRecord;

        let record, comment;
        try {
          [record, comment] = parse(wire, iter, hdr, origin, file);
        } catch (e) {
          yield Item.fromError(e, tok, file);
          return;
        }

        yield Item.fromRecord(record, comment);

        unknown = false;
        state = states.EXPECT_OWNER_DIR;

        break;
      }
    }
  }
}

function* generate(wire, iter, tok, origin, file) {
  let step = 1;

  const i = tok.string.indexOf('/');

  if (i !== -1) {
    if (i + 1 === tok.string.length)
      throw new ParseError('bad step in $GENERATE range.');

    try {
      const sub = tok.string.substring(i + 1);
      step = util.parseU32(sub);
    } catch (e) {
      throw new ParseError('bad step in $GENERATE range.');
    }

    tok.string = tok.string.substring(0, i);
  }

  const sx = tok.string.split('-', 3);

  if (sx.length !== 2)
    throw new ParseError('bad start-stop in $GENERATE range');

  let start;
  try {
    start = util.parseU32(sx[0]);
  } catch (e) {
    throw new ParseError('bad start in $GENERATE range');
  }

  let end;
  try {
    end = util.parseU32(sx[1]);
  } catch (e) {
    throw new ParseError('bad stop in $GENERATE range');
  }

  if (end < start)
    throw new ParseError('bad range in $GENERATE range');

  expect(iter, tokens.BLANK, file);

  let str = '';

  for (;;) {
    const tok = read(iter, file);

    if (tok.end())
      break;

    str += tok.string;
  }

  for (let i = 0; i <= end; i += step) {
    let escape = false;
    let dom = '';

    for (let j = 0; j < str.length; j++) {
      const ch = str[j];

      switch (ch) {
        case '\\': {
          if (escape) {
            dom += '\\';
            escape = false;
            continue;
          }
          escape = true;
          break;
        }

        case '$': {
          if (escape) {
            dom += '$';
            escape = false;
            continue;
          }

          escape = false;

          if (j + 1 >= str.length) {
            dom += i.toString(10);
            continue;
          }

          if (str[j + 1] === '$') {
            dom += '$';
            j += 1;
            continue;
          }

          if (str[j + 1] === '{') {
            const sub = str.substring(j + 2);
            const sep = sub.indexOf('}');

            if (sep === -1)
              throw new ParseError('bad modifier in $GENERATE');

            const fmt = str.substring(j + 2, j + 2 + sep);

            j += 2 + sep;
            dom += printf(fmt, i);

            continue;
          }

          dom += i.toString(10);

          break;
        }

        default: {
          if (escape) {
            escape = false;
            continue;
          }

          dom += ch;
          break;
        }
      }
    }

    const rr = parseRecord(wire, `$ORIGIN ${origin}\n${dom}`);

    yield Item.fromRecord(rr, '');
  }
}

function printf(fmt, index) {
  const xs = fmt.split(',', 4);

  if (xs.length !== 3)
    throw new ParseError('bad modifier in $GENERATE');

  const offset = parseInt(xs[0], 10);

  if (!isFinite(offset) || offset < -255 || offset > 255)
    throw new ParseError('bad offset in $GENERATE');

  let width;
  try {
    width = util.parseU8(xs[1]);
  } catch (e) {
    throw new ParseError('bad width in $GENERATE');
  }

  let base;
  switch (xs[2]) {
    case 'o':
      base = 8;
      break;
    case 'd':
      base = 10;
      break;
    case 'x':
    case 'X':
      base = 16;
      break;
    default:
      throw new ParseError('bad base in $GENERATE');
  }

  // Number to print.
  let num = index + offset;

  const neg = num < 0;

  if (neg)
    num = -num;

  // Stringified.
  let str = num.toString(base);

  while (str.length < width)
    str = '0' + str;

  if (neg)
    str = '-' + str;

  return str;
}

function readRecord(wire, iter, hdr, origin, file) {
  const RD = wire.recordsByVal[hdr.type];
  const format = schema.records[hdr.type];

  if (!RD)
    throw new ParseError('unknown rr type', null, file);

  const rr = new wire.Record();
  const rd = new RD();

  rr.name = hdr.name;
  rr.type = hdr.type;
  rr.class = hdr.class;
  rr.ttl = hdr.ttl;
  rr.data = rd;

  // Special case.
  if (hdr.type === types.LOC) {
    const comment = parseLOC(rd, iter, file);
    return [rr, comment];
  }

  let field, comment;

  for (const [name, type] of format) {
    [field, comment] = readString(wire, rd, type, iter, origin, file);
    rd[name] = field;
  }

  return [rr, comment];
}

function readUnknown(wire, iter, hdr, origin, file) {
  let RD = wire.recordsByVal[hdr.type];

  if (!RD)
    RD = wire.UNKNOWNRecord;

  const rr = new wire.Record();
  const rd = new RD();

  rr.name = hdr.name;
  rr.type = hdr.type;
  rr.class = hdr.class;
  rr.ttl = hdr.ttl;
  rr.data = rd;

  const tok1 = expect(iter, tokens.STRING, file);

  if (tok1.string !== '\\#')
    throw new ParseError('bad rfc3597 serialization', tok1, file);

  expect(iter, tokens.BLANK, file);

  const tok2 = expect(iter, tokens.STRING, file);

  let size;
  try {
    size = util.parseU32(tok2.string);
  } catch (e) {
    throw new ParseError('bad rfc3597 serialization', tok2, file);
  }

  const [hex, tok3] = concat(iter, file);

  if (size !== (hex.length >>> 1))
    throw new ParseError('invalid rfc3597 size', tok2, file);

  let data;
  try {
    data = util.parseHex(hex);
  } catch (e) {
    throw new ParseError('invalid rfc3597 hex', tok3, file);
  }

  rd.decode(data);

  return [rr, tok3.comment];
}

function readOption(wire, iter, code) {
  const OD = wire.optsByVal[code];
  const format = schema.options[code];

  if (!OD)
    throw new ParseError('unknown option code');

  const op = new wire.Option();
  const od = new OD();

  op.code = code;
  op.option = od;

  let field, comment;

  for (const [name, type] of format) {
    [field, comment] = readString(wire, od, type, iter, '', '');
    od[name] = field;
  }

  return [op, comment];
}

function readUnknownOption(wire, iter, code) {
  let OD = wire.optsByVal[code];

  if (!OD)
    OD = wire.UNKNOWNOption;

  const op = new wire.Option();
  const od = new OD();

  op.code = code;
  op.option = od;

  const tok1 = expect(iter, tokens.STRING, '');

  if (tok1.string !== '\\#')
    throw new ParseError('bad rfc3597 serialization', tok1, '');

  expect(iter, tokens.BLANK, '');

  const tok2 = expect(iter, tokens.STRING, '');

  let size;
  try {
    size = util.parseU32(tok2.string);
  } catch (e) {
    throw new ParseError('bad rfc3597 serialization', tok2, '');
  }

  const [hex, tok3] = concat(iter, '');

  if (size !== (hex.length >>> 1))
    throw new ParseError('invalid rfc3597 size', tok2, '');

  let data;
  try {
    data = util.parseHex(hex);
  } catch (e) {
    throw new ParseError('invalid rfc3597 hex', tok3, '');
  }

  od.decode(data);

  return [op, tok3.comment];
}

function readString(wire, rd, type, iter, origin, file) {
  assert(rd && typeof rd === 'object');
  assert((type >>> 0) === type);
  assert(iter && typeof iter.next === 'function');
  assert(typeof origin === 'string');
  assert(typeof file === 'string');

  switch (type) {
    case schema.NAME: {
      const tok = expect(iter, tokens.STRING, file);

      let name;
      try {
        name = normalize(tok.string, origin);
      } catch (e) {
        throw new ParseError('invalid name', tok, file);
      }

      return [name, skip(iter, file)];
    }

    case schema.SERVERS: {
      const names = [];
      const [items, tok] = collect(iter, file);

      for (const item of items) {
        let name;

        try {
          name = normalize(item, origin);
        } catch (e) {
          throw new ParseError('bad rendezvous server', tok, file);
        }

        names.push(name);
      }

      return [names, tok.comment];
    }

    case schema.INET4: {
      const tok = expect(iter, tokens.STRING, file);

      let ip;
      try {
        ip = IP.toBuffer(tok.string);
      } catch (e) {
        throw new ParseError('invalid ipv4', tok, file);
      }

      if (!IP.isIPv4(ip))
        throw new ParseError('invalid ipv4', tok, file);

      return [IP.toString(ip), skip(iter, file)];
    }

    case schema.INET6: {
      const tok = expect(iter, tokens.STRING, file);

      let ip;
      try {
        ip = IP.toBuffer(tok.string);
      } catch (e) {
        throw new ParseError('invalid ipv6', tok, file);
      }

      if (IP.isIPv4(ip))
        return `::ffff:${IP.toString(ip)}`;

      return [IP.toString(ip), skip(iter, file)];
    }

    case schema.INET: {
      const tok = expect(iter, tokens.STRING, file);

      let ip;
      try {
        ip = IP.normalize(tok.string);
      } catch (e) {
        throw new ParseError('invalid ip', tok, file);
      }

      return [ip, skip(iter, file)];
    }

    case schema.TARGET: {
      const tok = expect(iter, tokens.STRING, file);

      let ip;
      try {
        ip = IP.normalize(tok.string);
      } catch (e) {
        ;
      }

      if (ip)
        return [ip, skip(iter, file)];

      let name;
      try {
        name = normalize(tok.string, origin);
      } catch (e) {
        throw new ParseError('invalid name', tok, file);
      }

      return [name, skip(iter, file)];
    }

    case schema.HEX: {
      const tok = expect(iter, tokens.STRING, file);

      if (tok.string === '-')
        return [DUMMY, skip(iter, file)];

      let data;
      try {
        data = util.parseHex(tok.string);
      } catch (e) {
        throw new ParseError('invalid hex string', tok, file);
      }

      return [data, skip(iter, file)];
    }

    case schema.HEXEND: {
      const [str, tok] = concat(iter, file);

      if (str === '-')
        return [DUMMY, tok.comment];

      let data;
      try {
        data = util.parseHex(str);
      } catch (e) {
        throw new ParseError('invalid hex string', tok, file);
      }

      return [data, tok.comment];
    }

    case schema.BASE32: {
      const tok = expect(iter, tokens.STRING, file);

      if (tok.string === '-')
        return [DUMMY, skip(iter, file)];

      let data;
      try {
        data = base32.decodeHex(tok.string);
      } catch (e) {
        throw new ParseError('invalid base32 string', tok, file);
      }

      return [data, skip(iter, file)];
    }

    case schema.BASE64: {
      const tok = expect(iter, tokens.STRING, file);

      if (tok.string === '-')
        return [DUMMY, skip(iter, file)];

      let data;
      try {
        data = util.parseB64(tok.string);
      } catch (e) {
        throw new ParseError('invalid base64 string', tok, file);
      }

      return [data, skip(iter, file)];
    }

    case schema.BASE64END: {
      const [str, tok] = concat(iter, file);

      if (str === '-')
        return [DUMMY, tok.comment];

      let data;
      try {
        data = util.parseB64(str);
      } catch (e) {
        throw new ParseError('invalid base64 string', tok, file);
      }

      return [data, tok.comment];
    }

    case schema.CHAR: {
      expect(iter, tokens.QUOTE, file);

      const tok = read(iter, file);

      if (tok.type === tokens.QUOTE)
        return ['', skip(iter, file)];

      if (tok.type !== tokens.STRING)
        throw new ParseError('invalid character string', tok, file);

      expect(iter, tokens.QUOTE, file);

      if (!encoding.isString(tok.string, false))
        throw new ParseError('invalid character string', tok, file);

      return [tok.string, skip(iter, file)];
    }

    case schema.OCTET: {
      const tok = expect(iter, tokens.STRING, file);

      if (!encoding.isString(tok.string, true))
        throw new ParseError('invalid octet string', tok, file);

      return [tok.string, skip(iter, file)];
    }

    case schema.TXT: {
      const txt = [];

      let quote = false;
      let empty = false;
      let tok;

      for (;;) {
        tok = read(iter, file);

        if (tok.end())
          break;

        switch (tok.type) {
          case tokens.STRING: {
            empty = false;
            if (!encoding.isString(tok.string, false))
              throw new ParseError('invalid txt string', tok, file);
            txt.push(tok.string);
            break;
          }
          case tokens.BLANK: {
            if (quote)
              throw new ParseError('invalid txt', tok, file);
            break;
          }
          case tokens.QUOTE: {
            if (empty && quote)
              txt.push('');
            quote = !quote;
            empty = true;
            break;
          }
          default: {
            throw new ParseError('unexpected token', tok, file);
          }
        }
      }

      if (quote)
        throw new ParseError('unclosed txt quote', tok, file);

      return [txt, tok.comment];
    }

    case schema.NSEC: {
      const [items, tok] = collect(iter, file);
      const types = items.map(s => stringToType(s));
      const map = encoding.toBitmap(types);
      return [map, tok.comment];
    }

    case schema.TAGS: {
      const [items, tok] = collect(iter, file);
      const tags = items.map(s => util.parseU16(s));
      return [tags, tok.comment];
    }

    case schema.TIME: {
      const tok = expect(iter, tokens.STRING, file);
      const time = util.parseTime(tok.string);
      return [time, skip(iter, file)];
    }

    case schema.TYPE: {
      const tok = expect(iter, tokens.STRING, file);
      const type = stringToType(tok.string);
      return [type, skip(iter, file)];
    }

    case schema.U8: {
      const tok = expect(iter, tokens.STRING, file);
      const num = util.parseU8(tok.string);
      return [num, skip(iter, file)];
    }

    case schema.U16: {
      const tok = expect(iter, tokens.STRING, file);
      const num = util.parseU16(tok.string);
      return [num, skip(iter, file)];
    }

    case schema.U32: {
      const tok = expect(iter, tokens.STRING, file);
      const num = util.parseU32(tok.string);
      return [num, skip(iter, file)];
    }

    case schema.U48: {
      const tok = expect(iter, tokens.STRING, file);
      const num = util.parseU48(tok.string);
      return [num, skip(iter, file)];
    }

    case schema.U64: {
      const tok = expect(iter, tokens.STRING, file);
      const [hi, lo] = util.parseU64(tok.string);
      const num = Buffer.allocUnsafe(8);
      bio.writeU32BE(num, hi, 0);
      bio.writeU32BE(num, lo, 4);
      return [num, skip(iter, file)];
    }

    case schema.NID32: {
      const tok = expect(iter, tokens.STRING, file);
      const nid = parseNID32(tok.string);
      return [nid, skip(iter, file)];
    }

    case schema.NID64: {
      const tok = expect(iter, tokens.STRING, file);
      const nid = parseNID64(tok.string);
      return [nid, skip(iter, file)];
    }

    case schema.EUI48: {
      const tok = expect(iter, tokens.STRING, file);
      const eui = parseEUI(tok.string, 6);
      return [eui, skip(iter, file)];
    }

    case schema.EUI64: {
      const tok = expect(iter, tokens.STRING, file);
      const eui = parseEUI(tok.string, 8);
      return [eui, skip(iter, file)];
    }

    case schema.APL: {
      const {AP} = wire;
      const [items, tok] = collect(iter, file);
      const ap = items.map(s => AP.fromString(s));
      return [ap, tok.comment];
    }

    case schema.NSAP: {
      const tok = expect(iter, tokens.STRING, file);
      const nsap = parseNSAP(tok.string);
      return [nsap, skip(iter, file)];
    }

    case schema.ATMA: {
      const tok = expect(iter, tokens.STRING, file);
      const atma = parseATMA(tok.string, rd.format);
      return [atma, skip(iter, file)];
    }

    case schema.PROTOCOL: {
      const tok = expect(iter, tokens.STRING, file);
      const prot = parseProtocol(tok.string);
      return [prot, skip(iter, file)];
    }

    case schema.WKS: {
      const [services, tok] = collect(iter, file);
      const map = parseWKS(services);
      return [map, tok.comment];
    }

    case schema.TTL: {
      const tok = expect(iter, tokens.STRING, file);
      const num = stringToTTL(tok.string);
      return [num, skip(iter, file)];
    }

    default: {
      throw new ParseError('unknown schema type', null, file);
    }
  }
}

/*
 * API
 */

function parseZone(wire, input, origin, file) {
  assert(wire && typeof wire.fromZone === 'function');
  assert(typeof input === 'string');

  const def = new TTLState(DEFAULT_TTL, false);
  const iter = parser(wire, input, origin, file, def, 1);
  const out = [];

  for (const item of iter) {
    if (item.error)
      throw item.error;

    out.push(item.record);
  }

  return out;
}

function parseRecord(wire, input) {
  assert(wire && typeof wire.fromZone === 'function');
  assert(typeof input === 'string');

  const def = new TTLState(DEFAULT_TTL, false);
  const iter = parser(wire, input, '', '', def, 1);
  const it = iter.next();

  if (it.done)
    throw new ParseError('no record');

  const item = it.value;

  if (item.error)
    throw item.error;

  return item.record;
}

function parseData(wire, type, input) {
  assert(wire && typeof wire.fromZone === 'function');
  assert((type & 0xffff) === type);
  assert(typeof input === 'string');

  const typeName = typeToString(type);
  const str = `. 0 IN ${typeName} ${input}`;

  return parseRecord(wire, str).data;
}

function parseOption(wire, input) {
  assert(wire && typeof wire.fromZone === 'function');
  assert(typeof input === 'string');

  const iter = lexer(input, false);

  let tok = expect(iter, tokens.STRING);

  if (tok.string[tok.string.length - 1] === ':')
    tok.string = tok.string.slice(0, -1);

  let code = options[tok.string.toUpperCase()];
  let unknown = false;

  if ((code & 0xffff) !== code) {
    try {
      code = stringToOption(tok.string);
    } catch (e) {
      throw new ParseError('unknown option', tok);
    }
    unknown = true;
  }

  tok = read(iter);

  if (tok.type !== tokens.BLANK && !tok.end())
    throw new ParseError('unexpected token', tok);

  const parse = unknown ? readUnknownOption : readOption;
  const [option] = parse(wire, iter, code);

  return option;
}

function parseOptionData(wire, code, input) {
  assert(wire && typeof wire.fromZone === 'function');
  assert((code & 0xffff) === code);
  assert(typeof input === 'string');

  const codeName = optionToString(code);
  const str = `${codeName}: ${input}`;

  return parseOption(wire, str).option;
}

/*
 * Helpers
 */

function read(iter, file) {
  const it = iter.next();

  if (it.done) {
    const tok = new Token();
    tok.type = tokens.EOF;
    return tok;
  }

  const tok = it.value;

  if (tok.error)
    throw new ParseError(tok.string, tok, file, read);

  return tok;
}

function expect(iter, type, file) {
  const tok = read(iter, file);

  if (tok.type !== type)
    throw new ParseError('unexpected token', tok, expect);

  return tok;
}

function collect(iter, file) {
  const items = [];

  let tok;

  for (;;) {
    tok = read(iter, file);

    if (tok.end())
      break;

    switch (tok.type) {
      case tokens.BLANK:
        break;
      case tokens.STRING:
        items.push(tok.string);
        break;
      default:
        throw new ParseError('unexpected token', tok, file);
    }
  }

  return [items, tok];
}

function concat(iter, file) {
  let str = '';
  let tok;

  for (;;) {
    tok = read(iter, file);

    if (tok.end())
      break;

    switch (tok.type) {
      case tokens.BLANK:
        break;
      case tokens.STRING:
        str += tok.string;
        break;
      default:
        throw new ParseError('unexpected token', tok, file);
    }
  }

  return [str, tok];
}

function slurp(iter, file) {
  const tok = read(iter, file);

  switch (tok.type) {
    case tokens.BLANK: {
      const tok = read(iter, file);

      if (tok.type !== tokens.NEWLINE && tok.type !== tokens.EOF)
        throw new ParseError('garbage after rdata', tok, file);

      return tok.comment;
    }

    case tokens.EOF:
    case tokens.NEWLINE: {
      return tok.comment;
    }

    default: {
      throw new ParseError('garbage after rdata', tok, file);
    }
  }
}

function skip(iter, file) {
  const tok = read(iter, file);

  switch (tok.type) {
    case tokens.EOF:
    case tokens.NEWLINE:
    case tokens.BLANK: {
      return tok.comment;
    }
    default: {
      throw new ParseError('garbage after rdata', tok, file);
    }
  }
}

function stringToTTL(str) {
  assert(typeof str === 'string');

  let s = 0;
  let w = 0;

  if (str.length === 0 || str.length > 10)
    throw new Error('Invalid TTL.');

  for (let i = 0; i < str.length; i++) {
    const ch = str.charCodeAt(i);

    switch (ch) {
      case 0x73 /*s*/:
      case 0x53 /*S*/:
        s += w;
        w = 0;
        break;
      case 0x6d /*m*/:
      case 0x4d /*M*/:
        s += w * 60;
        w = 0;
        break;
      case 0x68 /*h*/:
      case 0x48 /*H*/:
        s += w * 60 * 60;
        w = 0;
        break;
      case 0x64 /*d*/:
      case 0x44 /*D*/:
        s += w * 60 * 60 * 24;
        w = 0;
        break;
      case 0x77 /*w*/:
      case 0x57 /*W*/:
        s += w * 60 * 60 * 24 * 7;
        w = 0;
        break;
      case 0x30 /*0*/:
      case 0x31 /*1*/:
      case 0x32 /*2*/:
      case 0x33 /*3*/:
      case 0x34 /*4*/:
      case 0x35 /*5*/:
      case 0x36 /*6*/:
      case 0x37 /*7*/:
      case 0x38 /*8*/:
      case 0x39 /*9*/:
        w *= 10;
        w += ch - 0x30;
        break;
      default:
        throw new Error('Invalid TTL.');
    }

    if (s > 0xffffffff)
      throw new Error('Invalid TTL.');
  }

  w += s;

  if (w > 0xffffffff)
    throw new Error('Invalid TTL.');

  return w;
}

function normalize(name, origin) {
  const fqdn = toAbsoluteName(name, origin);

  if (!encoding.isName(fqdn))
    throw new Error('Bad name.');

  return fqdn;
}

function toAbsoluteName(name, origin) {
  if (origin == null)
    origin = '';

  assert(typeof name === 'string');
  assert(typeof origin === 'string');

  if (name === '@') {
    if (origin === '')
      throw new Error('Bad origin.');

    return origin;
  }

  if (name === '')
    throw new Error('Bad name.');

  if (util.isFQDN(name))
    return name;

  if (origin === '')
    throw new Error('Bad origin.');

  return appendOrigin(name, origin);
}

function appendOrigin(name, origin) {
  if (origin == null)
    origin = '';

  assert(typeof name === 'string');
  assert(typeof origin === 'string');

  if (origin === '.')
    return name + origin;

  return `${name}.${origin}`;
}

function parseNID32(str) {
  assert(typeof str === 'string');

  const data = IP.toBuffer(str);

  if (!IP.isIPv4(data))
    throw new Error('Invalid NID32.');

  return data.slice(12, 16);
}

function parseNID64(str) {
  assert(typeof str === 'string');

  if (str.indexOf('::') === -1) {
    if (str.length === 0
        || str[str.length - 1] !== ':') {
      str += ':';
    }
    str += ':';
  }

  const data = IP.toBuffer(str);

  return data.slice(0, 8);
}

function parseEUI(str, size) {
  assert(typeof str === 'string');
  assert(size === 6 || size === 8);

  if (str.length !== (size * 2) + (size - 1))
    throw new Error('Invalid EUI.');

  if (str[0] === '-' || str[str.length - 1] === '-')
    throw new Error('Invalid EUI.');

  if (str.indexOf('--') !== -1)
    throw new Error('Invalid EUI.');

  str = str.replace(/-/g, '');

  if (str.length !== size * 2)
    throw new Error('Invalid EUI.');

  return util.parseHex(str);
}

function parseNSAP(str) {
  assert(typeof str === 'string');
  assert(str.length >= 2);
  assert(str[0] === '0');
  assert(str[1] === 'x' || str[1] === 'X');

  const s = str.substring(2);
  const hex = s.replace(/\./g, '');

  return util.parseHex(hex);
}

function parseATMA(str, format) {
  assert(typeof str === 'string');

  // Whoever designed the presentation
  // for this one has severe brain damage.
  // The `format` byte decides the format!
  // 0 = AESA / ISO8348/AD2 a.k.a NSAP
  // 1 = E.164 a.k.a Keypad Style (7bit IA5)
  switch (format) {
    case 0: {
      // Note: no leading 0x.
      const hex = str.replace(/\./g, '');
      return util.parseHex(hex);
    }
    case 1: {
      // Technically IA5.
      return Buffer.from(str, 'ascii');
    }
    default: {
      // The geniuses specifying ATMA
      // didn't specify how to present
      // unknown formats. Just use hex.
      return util.parseHex(str);
    }
  }
}

function parseProtocol(str) {
  const iana = lazy('./iana');
  return iana.stringToProtocol(str);
}

function parseWKS(names) {
  assert(Array.isArray(names));

  const iana = lazy('./iana');
  const ports = [];

  for (const name of names) {
    const port = iana.getPort(name);

    if (port === 0)
      continue;

    ports.push(port);
  }

  return encoding.toPortmap(ports);
}

function hasM(str) {
  assert(typeof str === 'string');

  const len = str.length;

  if (len === 0)
    return false;

  const ch = str.charCodeAt(len - 1);

  return ch === 0x4d /*M*/ || ch === 0x6d /*m*/;
}

function stringToCM(str) {
  assert(typeof str === 'string');

  if (hasM(str))
    str = str.slice(0, -1);

  const s = str.split('.', 3);
  assert(s.length >= 1);

  let meters = 0;
  let cmeters = 0;

  switch (s.length) {
    case 3:
      throw new Error('Invalid integer.');
    case 2:
      cmeters = parseInt(s[1]);
    case 1:
      meters = parseInt(s[0]);
      break;
  }

  if (!isFinite(meters) || !isFinite(cmeters))
    throw new Error('Invalid integer.');

  let e = 0;
  let val = cmeters;

  if (meters > 0) {
    e = 2;
    val = meters;
  }

  while (val > 10) {
    e += 1;
    val -= val % 10;
    val /= 10;
  }

  if (e > 9)
    throw new Error('Invalid exponent.');

  const m = val & 0xff;

  return [e, m];
}

function locCheckNorth(token, latitude) {
  switch (token) {
    case 'n':
    case 'N':
      return [LOC_EQUATOR + latitude, true];
    case 's':
    case 'S':
      return [LOC_EQUATOR - latitude, false];
  }
  return [latitude, false];
}

function locCheckEast(token, longitude) {
  switch (token) {
    case 'e':
    case 'E':
      return [LOC_PRIMEMERIDIAN + longitude, true];
    case 'w':
    case 'W':
      return [LOC_PRIMEMERIDIAN - longitude, true];
  }
  return [longitude, false];
}

function parseLOC(rd, iter, file) {
  assert(rd && typeof rd === 'object');
  assert(iter && typeof iter.next === 'function');

  let ok, tok;

  // Defaults.
  rd.horizPre = 165; // 10000
  rd.vertPre = 162; // 10
  rd.size = 18; // 1

  // North.
  tok = expect(iter, tokens.STRING, file);

  const lat = util.parseU32(tok.string);

  rd.latitude = 1000 * 60 * 60 * lat;
  rd.latitude >>>= 0;

  expect(iter, tokens.BLANK, file);

  tok = expect(iter, tokens.STRING, file);

  [rd.latitude, ok] = locCheckNorth(tok.string, rd.latitude);

  if (!ok) {
    const lat = util.parseU32(tok.string);

    rd.latitude += 1000 * 60 * lat;
    rd.latitude >>>= 0;

    expect(iter, tokens.BLANK, file);

    tok = expect(iter, tokens.STRING, file);

    const sec = parseFloat(tok.string);

    if (!isFinite(sec))
      throw new ParseError('bad LOC latitude seconds', tok, file);

    rd.latitude += (1000 * sec) >>> 0;
    rd.latitude >>>= 0;

    expect(iter, tokens.BLANK, file);

    tok = expect(iter, tokens.STRING, file);

    [rd.latitude, ok] = locCheckNorth(tok.string, rd.latitude);

    if (!ok)
      throw new ParseError('bad LOC latitude north/south', tok, file);
  }

  // East.
  expect(iter, tokens.BLANK, file);

  tok = expect(iter, tokens.STRING, file);

  const lon = util.parseU32(tok.string);

  rd.longitude = 1000 * 60 * 60 * lon;
  rd.longitude >>>= 0;

  expect(iter, tokens.BLANK, file);

  tok = expect(iter, tokens.STRING, file);

  [rd.longitude, ok] = locCheckEast(tok.string, rd.longitude);

  if (!ok) {
    const lon = util.parseU32(tok.string);

    rd.longitude += 1000 * 60 * lon;
    rd.longitude >>>= 0;

    expect(iter, tokens.BLANK, file);

    tok = expect(iter, tokens.STRING, file);

    const sec = parseFloat(tok.string);

    if (!isFinite(sec))
      throw new ParseError('bad LOC longitude seconds', tok, file);

    rd.longitude += (1000 * sec) >>> 0;
    rd.longitude >>>= 0;

    expect(iter, tokens.BLANK, file);

    tok = expect(iter, tokens.STRING, file);

    [rd.longitude, ok] = locCheckEast(tok.string, rd.longitude);

    if (!ok)
      throw new ParseError('bad LOC latitude east/west', tok, file);
  }

  // Altitude.
  expect(iter, tokens.BLANK, file);

  tok = expect(iter, tokens.STRING, file);

  if (hasM(tok.string))
    tok.string = tok.string.slice(0, -1);

  const alt = parseFloat(tok.string);

  if (!isFinite(alt))
    throw new ParseError('bad LOC altitude', tok, file);

  rd.altitude = alt * 100.0 + 10000000.0 + 0.5;
  rd.altitude >>>= 0;

  // Params
  let count = 0;

  for (;;) {
    tok = read(iter, file);

    if (tok.end())
      break;

    switch (tok.type) {
      case tokens.STRING: {
        switch (count) {
          case 0: {
            const [e, m] = stringToCM(tok.string);
            rd.size = (e & 0x0f) | ((m << 4) & 0xf0);
            break;
          }
          case 1: {
            const [e, m] = stringToCM(tok.string);
            rd.horizPre = (e & 0x0f) | ((m << 4) & 0xf0);
            break;
          }
          case 2: {
            const [e, m] = stringToCM(tok.string);
            rd.vertPre = (e & 0x0f) | ((m << 4) & 0xf0);
            break;
          }
        }
        count += 1;
        break;
      }
      case tokens.BLANK: {
        break;
      }
      default: {
        throw new ParseError('unexpected token', tok, file);
      }
    }
  }

  return tok.comment;
}

/*
 * Expose
 */

exports.parseZone = parseZone;
exports.parseRecord = parseRecord;
exports.parseData = parseData;
exports.parseOption = parseOption;
exports.parseOptionData = parseOptionData;
}],
[/* 84 */ 'bfile', '/lib/bfile.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * bfile.js - promisified fs module
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bfile
 */



/*
 * Expose
 */

module.exports = __browser_require__(85 /* './fs' */, module);
}],
[/* 85 */ 'bfile', '/lib/fs-browser.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * fs-browser.js - promisified fs module
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bfile
 */



const {FSError} = __browser_require__(86 /* './error' */, module);
const {ENOENT, EBADF} = FSError;

/*
 * Constants
 */

const constants = {
  UV_FS_SYMLINK_DIR: 1,
  UV_FS_SYMLINK_JUNCTION: 2,
  O_RDONLY: 0,
  O_WRONLY: 1,
  O_RDWR: 2,
  UV_DIRENT_UNKNOWN: 0,
  UV_DIRENT_FILE: 1,
  UV_DIRENT_DIR: 2,
  UV_DIRENT_LINK: 3,
  UV_DIRENT_FIFO: 4,
  UV_DIRENT_SOCKET: 5,
  UV_DIRENT_CHAR: 6,
  UV_DIRENT_BLOCK: 7,
  S_IFMT: 61440,
  S_IFREG: 32768,
  S_IFDIR: 16384,
  S_IFCHR: 8192,
  S_IFBLK: 24576,
  S_IFIFO: 4096,
  S_IFLNK: 40960,
  S_IFSOCK: 49152,
  O_CREAT: 64,
  O_EXCL: 128,
  O_NOCTTY: 256,
  O_TRUNC: 512,
  O_APPEND: 1024,
  O_DIRECTORY: 65536,
  O_NOATIME: 262144,
  O_NOFOLLOW: 131072,
  O_SYNC: 1052672,
  O_DSYNC: 4096,
  O_DIRECT: 16384,
  O_NONBLOCK: 2048,
  S_IRWXU: 448,
  S_IRUSR: 256,
  S_IWUSR: 128,
  S_IXUSR: 64,
  S_IRWXG: 56,
  S_IRGRP: 32,
  S_IWGRP: 16,
  S_IXGRP: 8,
  S_IRWXO: 7,
  S_IROTH: 4,
  S_IWOTH: 2,
  S_IXOTH: 1,
  F_OK: 0,
  R_OK: 4,
  W_OK: 2,
  X_OK: 1,
  UV_FS_COPYFILE_EXCL: 1,
  COPYFILE_EXCL: 1,
  UV_FS_COPYFILE_FICLONE: 2,
  COPYFILE_FICLONE: 2,
  UV_FS_COPYFILE_FICLONE_FORCE: 4,
  COPYFILE_FICLONE_FORCE: 4
};

/*
 * Errors
 */

function enoent(syscall) {
  return async (path) => {
    throw new FSError(ENOENT, syscall, path);
  };
}

function enoentSync(syscall) {
  return (path) => {
    throw new FSError(ENOENT, syscall, path);
  };
}

function ebadf(syscall) {
  return async () => {
    throw new FSError(EBADF, syscall);
  };
}

function ebadfSync(syscall) {
  return () => {
    throw new FSError(EBADF, syscall);
  };
}

function emit(handler, desc, syscall) {
  setTimeout(() => {
    handler(new FSError(desc, syscall));
  }, 1);
}

/*
 * Noop
 */

async function noop() {}

function noopSync() {}

/*
 * Streams
 */

const readStream = {
  emit: noopSync,
  on: (event, handler) => {
    if (event === 'error')
      emit(handler, ENOENT, 'stat');
  },
  once: (event, handler) => {
    if (event === 'error')
      emit(handler, ENOENT, 'stat');
  },
  addListener: (event, handler) => {
    if (event === 'error')
      emit(handler, ENOENT, 'stat');
  },
  off: noopSync,
  removeListener: noopSync,
  removeAllListeners: noopSync,
  listeners: () => [],
  listenerCount: () => 0,
  readable: true,
  writable: false,
  pipe: enoentSync('stat'),
  write: noopSync,
  end: noopSync,
  close: noopSync,
  destroy: noopSync
};

const writeStream = {
  emit: noopSync,
  on: noopSync,
  once: noopSync,
  addListener: noopSync,
  off: noopSync,
  removeListener: noopSync,
  removeAllListeners: noopSync,
  listeners: () => [],
  listenerCount: () => 0,
  readable: false,
  writable: true,
  write: () => true,
  end: () => true,
  close: noopSync,
  destroy: noopSync
};

/*
 * Expose
 */

exports.access = enoent('stat');
exports.accessSync = enoentSync('stat');
exports.appendFile = enoent('open');
exports.appendFileSync = enoentSync('open');
exports.chmod = noop;
exports.chmodSync = noopSync;
exports.chown = noop;
exports.chownSync = noopSync;
exports.close = ebadf('close');
exports.closeSync = ebadfSync('close');
exports.constants = constants;
exports.copyFile = noop;
exports.copyFileSync = noopSync;
exports.createReadStream = () => readStream;
exports.createWriteStream = () => writeStream;
exports.exists = null;
exports.existsSync = null;
exports.fchmod = ebadf('fchmod');
exports.fchmodSync = ebadfSync('fchmod');
exports.fchown = ebadf('fchown');
exports.fchownSync = ebadfSync('fchown');
exports.fdatasync = ebadf('fdatasync');
exports.fdatasyncSync = ebadfSync('fdatasync');
exports.fstat = ebadf('fstat');
exports.fstatSync = ebadfSync('fstat');
exports.fsync = ebadf('fsync');
exports.fsyncSync = ebadfSync('fsync');
exports.ftruncate = ebadf('ftruncate');
exports.ftruncateSync = ebadfSync('ftruncate');
exports.futimes = ebadf('futimes');
exports.futimesSync = ebadfSync('futimes');
exports.lchmod = noop;
exports.lchmodSync = noopSync;
exports.lchown = noop;
exports.lchownSync = noopSync;
exports.link = noop;
exports.linkSync = noopSync;
exports.lstat = enoent('lstat');
exports.lstatSync = enoentSync('lstat');
exports.mkdir = noop;
exports.mkdirSync = noopSync;
exports.mkdtemp = async () => `/tmp/${Math.random().toString(36)}`;
exports.mkdtempSync = () => `/tmp/${Math.random().toString(36)}`;
exports.open = enoent('open');
exports.openSync = enoentSync('open');
exports.opendir = enoent('opendir');
exports.opendirSync = enoentSync('opendir');
exports.read = ebadf('read');
exports.readSync = ebadfSync('read');
exports.readdir = enoent('readdir');
exports.readdirSync = enoentSync('readdir');
exports.readFile = enoent('open');
exports.readFileSync = enoentSync('open');
exports.readlink = enoent('readlink');
exports.readlinkSync = enoentSync('readlink');
exports.realpath = enoent('stat');
exports.realpath.native = enoent('stat');
exports.realpathSync = enoentSync('stat');
exports.realpathSync.native = enoentSync('stat');
exports.rename = noop;
exports.renameSync = noopSync;
exports.rmdir = noop;
exports.rmdirSync = noopSync;
exports.stat = enoent('stat');
exports.statSync = enoentSync('stat');
exports.symlink = noop;
exports.symlinkSync = noopSync;
exports.truncate = noop;
exports.truncateSync = noopSync;
exports.unlink = noop;
exports.unlinkSync = noopSync;
exports.unwatchFile = noopSync;
exports.utimes = noop;
exports.utimesSync = noopSync;
exports.watch = () => readStream;
exports.watchFile = noopSync;
exports.write = ebadf('write');
exports.writeSync = ebadfSync('write');
exports.writeFile = noop;
exports.writeFileSync = noopSync;
exports.writev = ebadf('writev');
exports.writevSync = ebadfSync('writev');

exports.F_OK = exports.constants.F_OK || 0;
exports.R_OK = exports.constants.R_OK || 0;
exports.W_OK = exports.constants.W_OK || 0;
exports.X_OK = exports.constants.X_OK || 0;

exports.Dir = class Dir {};
exports.Dirent = class Dirent {};
exports.Stats = class Stats {};
exports.ReadStream = class ReadStream {};
exports.WriteStream = class WriteStream {};
exports.FileReadStream = class FileReadStream {};
exports.FileWriteStream = class FileWriteStream {};

exports.promises = exports;

exports.copy = noop;
exports.copySync = noopSync;
exports.empty = noop;
exports.emptySync = noopSync;
exports.exists = async () => false;
exports.existsSync = () => false;
exports.lstatTry = () => null;
exports.lstatTrySync = async () => null;
exports.mkdirp = noop;
exports.mkdirpSync = noopSync;
exports.move = noop;
exports.moveSync = noopSync;
exports.outputFile = noop;
exports.outputFileSync = noopSync;
exports.readJSON = enoent('open');
exports.readJSONSync = enoentSync('open');
exports.remove = noop;
exports.removeSync = noopSync;
exports.rimraf = noop; // Compat.
exports.rimrafSync = noopSync;
exports.statTry = async () => null;
exports.statTrySync = () => null;
exports.stats = enoent('stat');
exports.statsSync = enoentSync('stat');
exports.statsTry = async () => null;
exports.statsTrySync = () => null;
exports.traverse = async () => undefined;
exports.traverseSync = () => undefined;
exports.walk = () => [];
exports.walkSync = () => [];
exports.writeJSON = noop;
exports.writeJSONSync = noopSync;

exports.handle = exports.open;

exports.features = {
  VERSION: 0,
  HAS_STAT_NUMBERS: false,
  HAS_COPY_FILE: false,
  HAS_COPY_FILE_IMPL: false,
  HAS_REALPATH_NATIVE: false,
  HAS_REALPATH_NATIVE_IMPL: false,
  HAS_RW_READY: false,
  HAS_WATCHER_CLOSE: false,
  HAS_PROMISES: false,
  HAS_PROMISES_IMPL: false,
  HAS_STAT_BIGINTS: false,
  HAS_DEPRECATED_LCHOWN: false,
  HAS_DIRENT: false,
  HAS_DIRENT_IMPL: false,
  HAS_RW_TYPED_ARRAY: false,
  HAS_RECURSIVE_MKDIR: false,
  HAS_OPTIONAL_FLAGS: false,
  HAS_WRITE_PENDING: false,
  HAS_STABLE_PROMISES: false,
  USE_STABLE_PROMISES: false,
  HAS_WRITEV: false,
  HAS_WRITEV_IMPL: false,
  HAS_STAT_NANO: false,
  HAS_RECURSIVE_RMDIR: false,
  HAS_OPENDIR: false,
  HAS_OPENDIR_IMPL: false,
  HAS_ALL: false
};

exports.unsupported = true;
}],
[/* 86 */ 'bfile', '/lib/error.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * error.js - errors for bfile
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bfile
 */



/**
 * ArgError
 */

class ArgError extends TypeError {
  constructor(name, value, expect) {
    let msg;

    if (Array.isArray(expect) && expect.length === 1)
      [expect] = expect;

    if (Array.isArray(expect)) {
      const last = expect.pop();

      msg = `The "${name}" argument must be one of type `
          + `${expect.join(', ')}, or ${last}. `
          + `Received type ${typeof value}`;
    } else {
      msg = `The "${name}" argument must be of type ${expect}. `
          + `Received type ${typeof value}`;
    }

    super(msg);

    this.code = 'ERR_INVALID_ARG_TYPE';
    this.name = `TypeError [${this.code}]`;

    if (Error.captureStackTrace)
      Error.captureStackTrace(this, this.constructor);
  }
}

/**
 * FSError
 */

class FSError extends Error {
  constructor(desc, ...args) {
    let message, syscall, path;

    if (desc == null || typeof desc !== 'object')
      throw new TypeError('invalid arguments for fs error');

    message = desc.message;

    if (args.length === 3)
      [message, syscall, path] = args;
    else if (args.length === 2)
      [syscall, path] = args;
    else if (args.length === 1)
      [syscall] = args;

    let msg = `${desc.code}:`;

    if (message)
      msg += ` ${message},`;

    if (syscall)
      msg += ` ${syscall}`;

    if (path)
      msg += ` ${path}`;

    super(msg);

    this.code = desc.code;
    this.errno = desc.errno;

    if (syscall)
      this.syscall = syscall;

    if (path)
      this.path = path;

    if (Error.captureStackTrace)
      Error.captureStackTrace(this, this.constructor);
  }
}

/*
 * Errors
 */

FSError.EPERM = {
  code: 'EPERM',
  errno: -1,
  message: 'operation not permitted'
};

FSError.ENOENT = {
  code: 'ENOENT',
  errno: -2,
  message: 'no such file or directory'
};

FSError.EIO = {
  code: 'EIO',
  errno: -5,
  message: 'I/O error'
};

FSError.EBADF = {
  code: 'EBADF',
  errno: -9,
  message: 'bad file descriptor'
};

FSError.EACCES = {
  code: 'EACCES',
  errno: -13,
  message: 'permission denied'
};

FSError.EEXIST = {
  code: 'EEXIST',
  errno: -17,
  message: 'file already exists'
};

FSError.ENOTDIR = {
  code: 'ENOTDIR',
  errno: -20,
  message: 'not a directory'
};

FSError.EISDIR = {
  code: 'EISDIR',
  errno: -21,
  message: 'file is a directory'
};

/*
 * Expose
 */

exports.ArgError = ArgError;
exports.FSError = FSError;
}],
[/* 87 */ 'bpkg', '/lib/builtins/path.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * path-browserify@1.0.0 - the path module from node core for browsers
 * Copyright (c) 2019, James Halliday (MIT)
 * https://github.com/browserify/path-browserify
 *
 * License for path-browserify@1.0.0:
 *
 * This software is released under the MIT license:
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

// 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
  }
}

// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
  var res = '';
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var code;
  for (var i = 0; i <= path.length; ++i) {
    if (i < path.length)
      code = path.charCodeAt(i);
    else if (code === 47 /*/*/)
      break;
    else
      code = 47 /*/*/;
    if (code === 47 /*/*/) {
      if (lastSlash === i - 1 || dots === 1) {
        // NOOP
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
          if (res.length > 2) {
            var lastSlashIndex = res.lastIndexOf('/');
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = '';
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = '';
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += '/..';
          else
            res = '..';
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += '/' + path.slice(lastSlash + 1, i);
        else
          res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 /*.*/ && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root;
  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
  if (!dir) {
    return base;
  }
  if (dir === pathObject.root) {
    return dir + base;
  }
  return dir + sep + base;
}

var posix = {
  // path.resolve([from ...], to)
  resolve: function resolve() {
    var resolvedPath = '';
    var resolvedAbsolute = false;
    var cwd;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path;
      if (i >= 0)
        path = arguments[i];
      else {
        if (cwd === undefined)
          cwd = process.cwd();
        path = cwd;
      }

      assertPath(path);

      // Skip empty entries
      if (path.length === 0) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

    if (resolvedAbsolute) {
      if (resolvedPath.length > 0)
        return '/' + resolvedPath;
      else
        return '/';
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return '.';
    }
  },

  normalize: function normalize(path) {
    assertPath(path);

    if (path.length === 0) return '.';

    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

    // Normalize the path
    path = normalizeStringPosix(path, !isAbsolute);

    if (path.length === 0 && !isAbsolute) path = '.';
    if (path.length > 0 && trailingSeparator) path += '/';

    if (isAbsolute) return '/' + path;
    return path;
  },

  isAbsolute: function isAbsolute(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
  },

  join: function join() {
    if (arguments.length === 0)
      return '.';
    var joined;
    for (var i = 0; i < arguments.length; ++i) {
      var arg = arguments[i];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === undefined)
          joined = arg;
        else
          joined += '/' + arg;
      }
    }
    if (joined === undefined)
      return '.';
    return posix.normalize(joined);
  },

  relative: function relative(from, to) {
    assertPath(from);
    assertPath(to);

    if (from === to) return '';

    from = posix.resolve(from);
    to = posix.resolve(to);

    if (from === to) return '';

    // Trim any leading backslashes
    var fromStart = 1;
    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47 /*/*/)
        break;
    }
    var fromEnd = from.length;
    var fromLen = fromEnd - fromStart;

    // Trim any leading backslashes
    var toStart = 1;
    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47 /*/*/)
        break;
    }
    var toEnd = to.length;
    var toLen = toEnd - toStart;

    // Compare paths to find the longest common path from root
    var length = fromLen < toLen ? fromLen : toLen;
    var lastCommonSep = -1;
    var i = 0;
    for (; i <= length; ++i) {
      if (i === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === 47 /*/*/) {
            // We get here if `from` is the exact base path for `to`.
            // For example: from='/foo/bar'; to='/foo/bar/baz'
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            // We get here if `from` is the root
            // For example: from='/'; to='/foo'
            return to.slice(toStart + i);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
            // We get here if `to` is the exact base path for `from`.
            // For example: from='/foo/bar/baz'; to='/foo/bar'
            lastCommonSep = i;
          } else if (i === 0) {
            // We get here if `to` is the root.
            // For example: from='/foo'; to='/'
            lastCommonSep = 0;
          }
        }
        break;
      }
      var fromCode = from.charCodeAt(fromStart + i);
      var toCode = to.charCodeAt(toStart + i);
      if (fromCode !== toCode)
        break;
      else if (fromCode === 47 /*/*/)
        lastCommonSep = i;
    }

    var out = '';
    // Generate the relative path based on the path difference between `to`
    // and `from`
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
        if (out.length === 0)
          out += '..';
        else
          out += '/..';
      }
    }

    // Lastly, append the rest of the destination (`to`) path that comes after
    // the common path parts
    if (out.length > 0)
      return out + to.slice(toStart + lastCommonSep);
    else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47 /*/*/)
        ++toStart;
      return to.slice(toStart);
    }
  },

  _makeLong: function _makeLong(path) {
    return path;
  },

  dirname: function dirname(path) {
    assertPath(path);
    if (path.length === 0) return '.';
    var code = path.charCodeAt(0);
    var hasRoot = code === 47 /*/*/;
    var end = -1;
    var matchedSlash = true;
    for (var i = path.length - 1; i >= 1; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }

    if (end === -1) return hasRoot ? '/' : '.';
    if (hasRoot && end === 1) return '//';
    return path.slice(0, end);
  },

  basename: function basename(path, ext) {
    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
    assertPath(path);

    var start = 0;
    var end = -1;
    var matchedSlash = true;
    var i;

    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path) return '';
      var extIdx = ext.length - 1;
      var firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
          if (firstNonSlashEnd === -1) {
            // We saw the first non-path separator, remember this index in case
            // we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            // Try to match the explicit extension
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                // We matched the extension, so mark this as the end of our path
                // component
                end = i;
              }
            } else {
              // Extension does not match, so our result is the entire path
              // component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
      return path.slice(start, end);
    } else {
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // path component
          matchedSlash = false;
          end = i + 1;
        }
      }

      if (end === -1) return '';
      return path.slice(start, end);
    }
  },

  extname: function extname(path) {
    assertPath(path);
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;
    for (var i = path.length - 1; i >= 0; --i) {
      var code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
        // We saw a non-dot character immediately before the dot
        preDotState === 0 ||
        // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return '';
    }
    return path.slice(startDot, end);
  },

  format: function format(pathObject) {
    if (pathObject === null || typeof pathObject !== 'object') {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format('/', pathObject);
  },

  parse: function parse(path) {
    assertPath(path);

    var ret = { root: '', dir: '', base: '', ext: '', name: '' };
    if (path.length === 0) return ret;
    var code = path.charCodeAt(0);
    var isAbsolute = code === 47 /*/*/;
    var start;
    if (isAbsolute) {
      ret.root = '/';
      start = 1;
    } else {
      start = 0;
    }
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var i = path.length - 1;

    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;

    // Get non-dir info
    for (; i >= start; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
    // We saw a non-dot character immediately before the dot
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
      }
      ret.ext = path.slice(startDot, end);
    }

    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';

    return ret;
  },

  sep: '/',
  delimiter: ':',
  win32: null,
  posix: null
};

posix.posix = posix;

module.exports = posix;
}],
[/* 88 */ 'bns-plus', '/lib/internal/schema.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * schema.js - schemas for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 *
 * Parts of this software are based on miekg/dns and golang/go:
 *   https://github.com/miekg/dns/blob/master/msg.go
 *   https://github.com/miekg/dns/blob/master/types.go
 *   https://github.com/golang/go/blob/master/src/net/dnsmsg.go
 */

/* eslint spaced-comment: 0 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const IP = __browser_require__(4 /* 'binet' */, module);
const base32 = __browser_require__(7 /* 'bs32' */, module);
const bio = __browser_require__(14 /* 'bufio' */, module);
const constants = __browser_require__(11 /* '../constants' */, module);
const encoding = __browser_require__(80 /* '../encoding' */, module);
const lazy = __browser_require__(81 /* './lazy' */, module);
const util = __browser_require__(79 /* '../util' */, module);

const {
  types,
  options,
  typeToString,
  stringToType,
  LOC_EQUATOR,
  LOC_PRIMEMERIDIAN,
  LOC_HOURS,
  LOC_DEGREES,
  LOC_ALTITUDEBASE
} = constants;

/*
 * Types
 */

const NAME = 0;
const SERVERS = 1;
const INET4 = 2;
const INET6 = 3;
const INET = 4;
const TARGET = 5;
const HEX = 6;
const HEXEND = 7;
const BASE32 = 8;
const BASE64 = 9;
const BASE64END = 10;
const CHAR = 11;
const OCTET = 12;
const TXT = 13;
const NSEC = 14;
const TAGS = 15;
const TIME = 16;
const TYPE = 17;
const U8 = 18;
const U16 = 19;
const U32 = 20;
const U48 = 21;
const U64 = 22;
const NID32 = 23;
const NID64 = 24;
const EUI48 = 25;
const EUI64 = 26;
const APL = 27;
const NSAP = 28;
const ATMA = 29;
const PROTOCOL = 30;
const WKS = 31;
const TTL = 32;

/*
 * Schemas
 */

const UNKNOWNSchema = [
  ['data', HEXEND]
];

const ASchema = [
  ['address', INET4]
];

const NSSchema = [
  ['ns', NAME]
];

const MDSchema = [
  ['md', NAME]
];

const MFSchema = [
  ['md', NAME]
];

const CNAMESchema = [
  ['target', NAME]
];

const SOASchema = [
  ['ns', NAME],
  ['mbox', NAME],
  ['serial', U32],
  ['refresh', TTL],
  ['retry', TTL],
  ['expire', TTL],
  ['minttl', TTL]
];

const MBSchema = [
  ['mb', NAME]
];

const MGSchema = [
  ['mg', NAME]
];

const MRSchema = [
  ['mr', NAME]
];

const NULLSchema = UNKNOWNSchema;

const WKSSchema = [
  ['address', INET4],
  ['protocol', PROTOCOL],
  ['bitmap', WKS]
];

const PTRSchema = [
  ['ptr', NAME]
];

const HINFOSchema = [
  ['cpu', CHAR],
  ['os', CHAR]
];

const MINFOSchema = [
  ['rmail', NAME],
  ['email', NAME]
];

const MXSchema = [
  ['preference', U16],
  ['mx', NAME]
];

const TXTSchema = [
  ['txt', TXT]
];

const RPSchema = [
  ['mbox', NAME],
  ['txt', NAME]
];

const AFSDBSchema = [
  ['subtype', U16],
  ['hostname', NAME]
];

const X25Schema = [
  ['psdnAddress', OCTET]
];

const ISDNSchema = [
  ['address', OCTET],
  ['sa', OCTET]
];

const RTSchema = [
  ['preference', U16],
  ['host', NAME]
];

const NSAPSchema = [
  ['nsap', NSAP]
];

const NSAPPTRSchema = PTRSchema;

const SIGSchema = [
  ['typeCovered', U16],
  ['algorithm', U8],
  ['labels', U8],
  ['origTTL', U32],
  ['expiration', TIME],
  ['inception', TIME],
  ['keyTag', U16],
  ['signerName', NAME],
  ['signature', BASE64END]
];

const KEYSchema = [
  ['flags', U16],
  ['protocol', U8],
  ['algorithm', U8],
  ['publicKey', BASE64END]
];

const PXSchema = [
  ['preference', U16],
  ['map822', NAME],
  ['mapx400', NAME]
];

const GPOSSchema = [
  ['longitude', OCTET],
  ['latitude', OCTET],
  ['altitude', OCTET]
];

const AAAASchema = [
  ['address', INET6]
];

const LOCSchema = [
  ['version', U8],
  ['size', U8],
  ['horizPre', U8],
  ['vertPre', U8],
  ['latitude', U32],
  ['longitude', U32],
  ['altitude', U32]
];

const NXTSchema = [
  ['nextDomain', NAME],
  ['typeBitmap', NSEC]
];

const EIDSchema = [
  ['endpoint', HEXEND]
];

const NIMLOCSchema = [
  ['locator', HEXEND]
];

const SRVSchema = [
  ['priority', U16],
  ['weight', U16],
  ['port', U16],
  ['target', NAME]
];

const ATMASchema = [
  ['format', U8],
  ['address', ATMA]
];

const NAPTRSchema = [
  ['order', U16],
  ['preference', U16],
  ['flags', CHAR],
  ['service', CHAR],
  ['regexp', CHAR],
  ['replacement', NAME]
];

const KXSchema = [
  ['preference', U16],
  ['exchanger', NAME]
];

const CERTSchema = [
  ['certType', U16],
  ['keyTag', U16],
  ['algorithm', U8],
  ['certificate', BASE64END]
];

const A6Schema = [
  ['prefixLen', U8],
  ['address', U16],
  ['prefix', NAME]
];

const DNAMESchema = CNAMESchema;

const OPTSchema = UNKNOWNSchema;

const APLSchema = [
  ['items', APL]
];

const DSSchema = [
  ['keyTag', U16],
  ['algorithm', U8],
  ['digestType', U8],
  ['digest', HEXEND]
];

const SSHFPSchema = [
  ['algorithm', U8],
  ['digestType', U8],
  ['fingerprint', HEXEND]
];

const IPSECKEYSchema = [
  ['precedence', U8],
  ['gatewayType', U8],
  ['algorithm', U8],
  ['target', TARGET],
  ['publicKey', BASE64END]
];

const RRSIGSchema = [
  ['typeCovered', TYPE],
  ['algorithm', U8],
  ['labels', U8],
  ['origTTL', U32],
  ['expiration', TIME],
  ['inception', TIME],
  ['keyTag', U16],
  ['signerName', NAME],
  ['signature', BASE64END]
];

const NSECSchema = [
  ['nextDomain', NAME],
  ['typeBitmap', NSEC]
];

const DNSKEYSchema = KEYSchema;

const DHCIDSchema = [
  ['digest', BASE64END]
];

const NSEC3Schema = [
  ['hash', U8],
  ['flags', U8],
  ['iterations', U16],
  ['salt', HEX],
  ['nextDomain', BASE32],
  ['typeBitmap', NSEC]
];

const NSEC3PARAMSchema = [
  ['hash', U8],
  ['flags', U8],
  ['iterations', U16],
  ['salt', HEXEND]
];

const TLSASchema = [
  ['usage', U8],
  ['selector', U8],
  ['matchingType', U8],
  ['certificate', HEXEND]
];

const SMIMEASchema = TLSASchema;

const HIPSchema = [
  ['algorithm', U8],
  ['hit', HEX],
  ['publicKey', BASE64],
  ['servers', SERVERS]
];

const NINFOSchema = [
  ['zsData', TXT]
];

const RKEYSchema = KEYSchema;

const TALINKSchema = [
  ['prevName', NAME],
  ['nextName', NAME]
];

const CDSSchema = DSSchema;

const CDNSKEYSchema = DNSKEYSchema;

const OPENPGPKEYSchema = [
  ['publicKey', BASE64END]
];

const CSYNCSchema = [
  ['serial', U32],
  ['flags', U16],
  ['typeBitmap', NSEC]
];

const SPFSchema = TXTSchema;

const UINFOSchema = [
  ['uinfo', CHAR]
];

const UIDSchema = [
  ['uid', U32]
];

const GIDSchema = [
  ['gid', U32]
];

const UNSPECSchema = UNKNOWNSchema;

const NIDSchema = [
  ['preference', U16],
  ['nodeID', NID64]
];

const L32Schema = [
  ['preference', U16],
  ['locator32', NID32]
];

const L64Schema = [
  ['preference', U16],
  ['locator64', NID64]
];

const LPSchema = [
  ['preference', U16],
  ['fqdn', NAME]
];

const EUI48Schema = [
  ['address', EUI48]
];

const EUI64Schema = [
  ['address', EUI64]
];

const TKEYSchema = [
  ['algorithm', NAME],
  ['inception', U32],
  ['expiration', U32],
  ['mode', U16],
  ['error', U16],
  ['key', HEX],
  ['other', HEXEND]
];

const TSIGSchema = [
  ['algorithm', NAME],
  ['timeSigned', TIME],
  ['fudge', U16],
  ['mac', HEX],
  ['origID', U16],
  ['error', U16],
  ['other', HEXEND]
];

const URISchema = [
  ['priority', U16],
  ['weight', U16],
  ['target', OCTET]
];

const CAASchema = [
  ['flag', U8],
  ['tag', OCTET],
  ['value', CHAR]
];

const AVCSchema = TXTSchema;

const DOASchema = [
  ['enterprise', U32],
  ['doa', U32],
  ['location', U8],
  ['mediaType', CHAR],
  ['data', BASE64END]
];

const TASchema = [
  ['keyTag', U16],
  ['algorithm', U8],
  ['digestType', U8],
  ['digest', HEXEND]
];

const DLVSchema = DSSchema;

const LLQSchema = [
  ['version', U16],
  ['opcode', U16],
  ['error', U16],
  ['id', HEX],
  ['leaseLife', U32]
];

const ULSchema = [
  ['lease', U32]
];

const NSIDSchema = [
  ['nsid', HEXEND]
];

const DAUSchema = [
  ['algCode', HEXEND]
];

const DHUSchema = DAUSchema;

const N3USchema = DAUSchema;

const SUBNETSchema = [
  ['family', U16],
  ['sourceNetmask', U8],
  ['sourceScope', U8],
  ['address', HEXEND]
];

const EXPIRESchema = [
  ['expire', U32]
];

const COOKIESchema = [
  ['cookie', HEXEND]
];

const TCPKEEPALIVESchema = [
  ['length', U16],
  ['timeout', U16]
];

const PADDINGSchema = [
  ['padding', HEXEND]
];

const CHAINSchema = [
  ['trustPoint', NAME]
];

const KEYTAGSchema = [
  ['tags', TAGS]
];

const LOCALSchema = [
  ['data', HEXEND]
];

/**
 * Record Schemas By Value
 * @const {Object}
 * @default
 */

const records = {
  [types.UNKNOWN]: UNKNOWNSchema,
  [types.A]: ASchema,
  [types.NS]: NSSchema,
  [types.MD]: MDSchema,
  [types.MF]: MFSchema,
  [types.CNAME]: CNAMESchema,
  [types.SOA]: SOASchema,
  [types.MB]: MBSchema,
  [types.MG]: MGSchema,
  [types.MR]: MRSchema,
  [types.NULL]: NULLSchema,
  [types.WKS]: WKSSchema,
  [types.PTR]: PTRSchema,
  [types.HINFO]: HINFOSchema,
  [types.MINFO]: MINFOSchema,
  [types.MX]: MXSchema,
  [types.TXT]: TXTSchema,
  [types.RP]: RPSchema,
  [types.AFSDB]: AFSDBSchema,
  [types.X25]: X25Schema,
  [types.ISDN]: ISDNSchema,
  [types.RT]: RTSchema,
  [types.NSAP]: NSAPSchema,
  [types.NSAPPTR]: NSAPPTRSchema,
  [types.SIG]: SIGSchema,
  [types.KEY]: KEYSchema,
  [types.PX]: PXSchema,
  [types.GPOS]: GPOSSchema,
  [types.AAAA]: AAAASchema,
  [types.LOC]: LOCSchema,
  [types.NXT]: NXTSchema,
  [types.EID]: EIDSchema,
  [types.NIMLOC]: NIMLOCSchema,
  [types.SRV]: SRVSchema,
  [types.ATMA]: ATMASchema,
  [types.NAPTR]: NAPTRSchema,
  [types.KX]: KXSchema,
  [types.CERT]: CERTSchema,
  [types.A6]: A6Schema,
  [types.DNAME]: DNAMESchema,
  [types.SINK]: null,
  [types.OPT]: OPTSchema,
  [types.APL]: APLSchema,
  [types.DS]: DSSchema,
  [types.SSHFP]: SSHFPSchema,
  [types.IPSECKEY]: IPSECKEYSchema,
  [types.RRSIG]: RRSIGSchema,
  [types.NSEC]: NSECSchema,
  [types.DNSKEY]: DNSKEYSchema,
  [types.DHCID]: DHCIDSchema,
  [types.NSEC3]: NSEC3Schema,
  [types.NSEC3PARAM]: NSEC3PARAMSchema,
  [types.TLSA]: TLSASchema,
  [types.SMIMEA]: SMIMEASchema,
  [types.HIP]: HIPSchema,
  [types.NINFO]: NINFOSchema,
  [types.RKEY]: RKEYSchema,
  [types.TALINK]: TALINKSchema,
  [types.CDS]: CDSSchema,
  [types.CDNSKEY]: CDNSKEYSchema,
  [types.OPENPGPKEY]: OPENPGPKEYSchema,
  [types.CSYNC]: CSYNCSchema,
  [types.SPF]: SPFSchema,
  [types.UINFO]: UINFOSchema,
  [types.UID]: UIDSchema,
  [types.GID]: GIDSchema,
  [types.UNSPEC]: UNSPECSchema,
  [types.NID]: NIDSchema,
  [types.L32]: L32Schema,
  [types.L64]: L64Schema,
  [types.LP]: LPSchema,
  [types.EUI48]: EUI48Schema,
  [types.EUI64]: EUI64Schema,
  [types.TKEY]: TKEYSchema,
  [types.TSIG]: TSIGSchema,
  [types.URI]: URISchema,
  [types.CAA]: CAASchema,
  [types.AVC]: AVCSchema,
  [types.DOA]: DOASchema,
  [types.IXFR]: null,
  [types.AXFR]: null,
  [types.MAILB]: null,
  [types.MAILA]: null,
  [types.ANY]: null,
  [types.TA]: TASchema,
  [types.DLV]: DLVSchema,
  [types.RESERVED]: null
};

/**
 * EDNS0 Option Classes By Value
 * @const {Object}
 */

const opts = {
  [options.RESERVED]: UNKNOWNSchema,
  [options.LLQ]: LLQSchema,
  [options.UL]: ULSchema,
  [options.NSID]: NSIDSchema,
  [options.DAU]: DAUSchema,
  [options.DHU]: DHUSchema,
  [options.N3U]: N3USchema,
  [options.SUBNET]: SUBNETSchema,
  [options.EXPIRE]: EXPIRESchema,
  [options.COOKIE]: COOKIESchema,
  [options.TCPKEEPALIVE]: TCPKEEPALIVESchema,
  [options.PADDING]: PADDINGSchema,
  [options.CHAIN]: CHAINSchema,
  [options.KEYTAG]: KEYTAGSchema,
  [options.LOCAL]: LOCALSchema,
  [options.LOCALSTART]: LOCALSchema,
  [options.LOCALEND]: LOCALSchema
};

/*
 * Encoding
 */

function toString(wire, rd, schema) {
  assert(wire && typeof wire.fromZone === 'function');
  assert(rd && typeof rd === 'object');
  assert(Array.isArray(schema));

  // Special case.
  if (schema === LOCSchema)
    return serializeLOC(rd);

  const str = [];

  for (let i = 0; i < schema.length; i++) {
    const [name, type] = schema[i];
    const value = rd[name];
    str.push(writeString(wire, rd, type, value));
  }

  return str.join(' ');
}

function writeString(wire, rd, type, value) {
  assert((type >>> 0) === type);

  switch (type) {
    case NAME: {
      assert(typeof value === 'string');
      return value;
    }

    case SERVERS: {
      assert(Array.isArray(value));
      return value.join(' ');
    }

    case INET4: {
      assert(typeof value === 'string');
      return value;
    }

    case INET6: {
      assert(typeof value === 'string');
      return value;
    }

    case INET: {
      assert(typeof value === 'string');
      return value;
    }

    case TARGET: {
      assert(typeof value === 'string');
      return value;
    }

    case HEX: {
      assert((value != null && value._isBuffer === true));

      if (value.length === 0)
        return '-';

      return value.toString('hex').toUpperCase();
    }

    case HEXEND: {
      assert((value != null && value._isBuffer === true));

      if (value.length === 0)
        return '-';

      const hex = value.toString('hex').toUpperCase();
      const chunks = [];

      for (let i = 0; i < hex.length; i += 56)
        chunks.push(hex.substring(i, i + 56));

      return chunks.join(' ');
    }

    case BASE32: {
      assert((value != null && value._isBuffer === true));

      if (value.length === 0)
        return '-';

      return base32.encodeHex(value).toUpperCase();
    }

    case BASE64: {
      assert((value != null && value._isBuffer === true));

      if (value.length === 0)
        return '-';

      return value.toString('base64');
    }

    case BASE64END: {
      assert((value != null && value._isBuffer === true));

      if (value.length === 0)
        return '-';

      const b64 = value.toString('base64');
      const chunks = [];

      for (let i = 0; i < b64.length; i += 56)
        chunks.push(b64.substring(i, i + 56));

      return chunks.join(' ');
    }

    case CHAR: {
      assert(typeof value === 'string');
      return quote(value);
    }

    case OCTET: {
      assert(typeof value === 'string');
      return value;
    }

    case TXT: {
      assert(Array.isArray(value));

      const chunks = [];

      for (const str of value)
        chunks.push(quote(str));

      return chunks.join(' ');
    }

    case NSEC: {
      assert((value != null && value._isBuffer === true));

      const types = encoding.fromBitmap(value);
      const parts = [];

      for (const type of types)
        parts.push(typeToString(type));

      return parts.join(' ');
    }

    case TAGS: {
      assert(Array.isArray(value));
      return value.join(' ');
    }

    case TIME: {
      return util.serializeTime(value);
    }

    case TYPE: {
      return typeToString(value);
    }

    case U8: {
      assert((value & 0xff) === value);
      return value.toString(10);
    }

    case U16: {
      assert((value & 0xffff) === value);
      return value.toString(10);
    }

    case U32: {
      assert((value >>> 0) === value);
      return value.toString(10);
    }

    case U48: {
      assert(Number.isSafeInteger(value));
      assert(value >= 0 && value <= 0xffffffffffff);
      return value.toString(10);
    }

    case U64: {
      assert((value != null && value._isBuffer === true) && value.length === 8);
      const hi = bio.readU32BE(value, 0);
      const lo = bio.readU32BE(value, 4);
      return util.serializeU64(hi, lo);
    }

    case NID32: {
      return serializeNID32(value);
    }

    case NID64: {
      return serializeNID64(value);
    }

    case EUI48: {
      return serializeEUI(value, 6);
    }

    case EUI64: {
      return serializeEUI(value, 8);
    }

    case APL: {
      assert(Array.isArray(value));

      const parts = [];

      for (const ap of value)
        parts.push(ap.toString());

      return parts.join(' ');
    }

    case NSAP: {
      return serializeNSAP(value);
    }

    case ATMA: {
      return serializeATMA(value, rd.format);
    }

    case PROTOCOL: {
      return serializeProtocol(value);
    }

    case WKS: {
      return serializeWKS(value);
    }

    case TTL: {
      assert((value >>> 0) === value);
      return value.toString(10);
    }

    default: {
      throw new Error('Unknown type.');
    }
  }
}

function fromJSON(wire, rd, schema, json) {
  assert(wire && typeof wire.fromZone === 'function');
  assert(rd && typeof rd === 'object');
  assert(Array.isArray(schema));
  assert(json && typeof json === 'object');

  for (let i = 0; i < schema.length; i++) {
    const [name, type] = schema[i];
    rd[name] = readJSON(wire, rd, type, json[name]);
  }

  return rd;
}

function toJSON(wire, rd, schema) {
  assert(wire && typeof wire.fromZone === 'function');
  assert(rd && typeof rd === 'object');
  assert(Array.isArray(schema));

  const json = {};

  for (let i = 0; i < schema.length; i++) {
    const [name, type] = schema[i];
    json[name] = writeJSON(wire, rd, type, rd[name]);
  }

  return json;
}

function readJSON(wire, rd, type, value) {
  assert((type >>> 0) === type);

  switch (type) {
    case NAME: {
      assert(encoding.isName(value));
      return value;
    }

    case SERVERS: {
      assert(Array.isArray(value));

      const names = [];

      for (const name of value) {
        assert(encoding.isName(name));
        names.push(name);
      }

      return names;
    }

    case INET4: {
      const ip = IP.toBuffer(value);

      assert(IP.isIPv4(ip));

      return IP.toString(ip);
    }

    case INET6: {
      const ip = IP.toBuffer(value);

      if (IP.isIPv4(ip))
        return `::ffff:${IP.toString(ip)}`;

      return IP.toString(ip);
    }

    case INET: {
      return IP.normalize(value);
    }

    case TARGET: {
      assert(typeof value === 'string');

      try {
        return IP.normalize(value);
      } catch (e) {
        ;
      }

      if (!encoding.isName(value))
        throw new Error('Invalid target.');

      return value;
    }

    case HEX:
    case HEXEND: {
      return util.parseHex(value);
    }

    case BASE32: {
      return base32.decodeHex(value);
    }

    case BASE64:
    case BASE64END: {
      return util.parseB64(value);
    }

    case CHAR: {
      assert(encoding.isString(value, false));
      return value;
    }

    case OCTET: {
      assert(encoding.isString(value, true));
      return value;
    }

    case TXT: {
      assert(Array.isArray(value));

      const txt = [];

      for (const str of value) {
        assert(encoding.isString(str, false));
        txt.push(str);
      }

      return txt;
    }

    case NSEC: {
      return encoding.toBitmap(value);
    }

    case TAGS: {
      assert(Array.isArray(value));

      const tags = [];

      for (const tag of value) {
        assert((tag & 0xffff) === tag);
        tags.push(tag);
      }

      return tags;
    }

    case TIME: {
      assert(Number.isSafeInteger(value));
      assert(value >= 0 && value <= 0xffffffffffff);
      return value;
    }

    case TYPE: {
      return stringToType(value);
    }

    case U8: {
      assert((value & 0xff) === value);
      return value;
    }

    case U16: {
      assert((value & 0xffff) === value);
      return value;
    }

    case U32: {
      assert((value >>> 0) === value);
      return value;
    }

    case U48: {
      assert(Number.isSafeInteger(value));
      assert(value >= 0 && value <= 0xffffffffffff);
      return value;
    }

    case U64: {
      assert(typeof value === 'string');
      assert(value.length === 16);
      return util.parseHex(value);
    }

    case NID32: {
      assert(typeof value === 'string');
      assert(value.length === 8);
      return util.parseHex(value);
    }

    case NID64: {
      assert(typeof value === 'string');
      assert(value.length === 16);
      return util.parseHex(value);
    }

    case EUI48: {
      assert(typeof value === 'string');
      assert(value.length === 12);
      return util.parseHex(value);
    }

    case EUI64: {
      assert(typeof value === 'string');
      assert(value.length === 16);
      return util.parseHex(value);
    }

    case APL: {
      assert(Array.isArray(value));

      const {AP} = wire;
      const items = [];

      for (const json of value)
        items.push(AP.fromJSON(json));

      return items;
    }

    case NSAP: {
      return util.parseHex(value);
    }

    case ATMA: {
      return util.parseHex(value);
    }

    case PROTOCOL: {
      assert((value & 0xff) === value);
      return value;
    }

    case WKS: {
      return util.parseHex(value);
    }

    case TTL: {
      assert((value >>> 0) === value);
      return value;
    }

    default: {
      throw new Error('Unknown type.');
    }
  }
}

function writeJSON(wire, rd, type, value) {
  assert((type >>> 0) === type);

  switch (type) {
    case NAME: {
      assert(typeof value === 'string');
      return value;
    }

    case SERVERS: {
      assert(Array.isArray(value));
      return value;
    }

    case INET4: {
      assert(typeof value === 'string');
      return value;
    }

    case INET6: {
      assert(typeof value === 'string');
      return value;
    }

    case INET: {
      assert(typeof value === 'string');
      return value;
    }

    case TARGET: {
      assert(typeof value === 'string');
      return value;
    }

    case HEX:
    case HEXEND: {
      assert((value != null && value._isBuffer === true));
      return value.toString('hex');
    }

    case BASE32: {
      assert((value != null && value._isBuffer === true));
      return base32.encodeHex(value);
    }

    case BASE64:
    case BASE64END: {
      assert((value != null && value._isBuffer === true));
      return value.toString('base64');
    }

    case CHAR: {
      assert(typeof value === 'string');
      return value;
    }

    case OCTET: {
      assert(typeof value === 'string');
      return value;
    }

    case TXT: {
      assert(Array.isArray(value));
      return value;
    }

    case NSEC: {
      return encoding.fromBitmap(value);
    }

    case TAGS: {
      assert(Array.isArray(value));
      return value;
    }

    case TIME: {
      assert(Number.isSafeInteger(value));
      assert(value >= 0 && value <= 0xffffffffffff);
      return value;
    }

    case TYPE: {
      assert(typeof value === 'number');
      return typeToString(value);
    }

    case U8: {
      assert((value & 0xff) === value);
      return value;
    }

    case U16: {
      assert((value & 0xffff) === value);
      return value;
    }

    case U32: {
      assert((value >>> 0) === value);
      return value;
    }

    case U48: {
      assert(Number.isSafeInteger(value));
      assert(value >= 0 && value <= 0xffffffffffff);
      return value;
    }

    case U64: {
      assert((value != null && value._isBuffer === true) && value.length === 8);
      return value.toString('hex');
    }

    case NID32: {
      assert((value != null && value._isBuffer === true) && value.length === 4);
      return value.toString('hex');
    }

    case NID64: {
      assert((value != null && value._isBuffer === true) && value.length === 8);
      return value.toString('hex');
    }

    case EUI48: {
      assert((value != null && value._isBuffer === true) && value.length === 6);
      return value.toString('hex');
    }

    case EUI64: {
      assert((value != null && value._isBuffer === true) && value.length === 8);
      return value.toString('hex');
    }

    case APL: {
      assert(Array.isArray(value));

      const items = [];

      for (const ap of value)
        items.push(ap.toJSON());

      return items;
    }

    case NSAP: {
      assert((value != null && value._isBuffer === true));
      return value.toString('hex');
    }

    case ATMA: {
      assert((value != null && value._isBuffer === true));
      return value.toString('hex');
    }

    case PROTOCOL: {
      assert((value & 0xff) === value);
      return value;
    }

    case WKS: {
      assert((value != null && value._isBuffer === true));
      return value.toString('hex');
    }

    case TTL: {
      assert((value >>> 0) === value);
      return value;
    }

    default: {
      throw new Error('Unknown type.');
    }
  }
}

/*
 * Helpers
 */

function quote(str) {
  assert(typeof str === 'string');
  return `"${str}"`;
}

function serializeNID32(data) {
  assert((data != null && data._isBuffer === true));

  if (data.length !== 4)
    throw new Error('Invalid NID32.');

  return IP.toString(data);
}

function serializeNID64(data) {
  assert((data != null && data._isBuffer === true));

  if (data.length !== 8)
    throw new Error('Invalid NID32.');

  const ip = util.padRight(data, 16);
  const str = IP.toString(ip);

  if (str[str.length - 1] !== ':')
    throw new Error('Invalid NID32.');

  if (str[str.length - 2] !== ':')
    throw new Error('Invalid NID32.');

  if (str.length === 2)
    return str;

  return str.slice(0, -2);
}

function serializeEUI(data, size) {
  assert((data != null && data._isBuffer === true));
  assert(size === 6 || size === 8);

  if (data.length !== size)
    throw new Error('Invalid EUI.');

  const hex = data.toString('hex');

  let str = '';

  for (let i = 0; i < hex.length; i += 2) {
    str += hex.substring(i, i + 2);
    if (i !== hex.length - 2)
      str += '-';
  }

  return str;
}

function serializeNSAP(data) {
  assert((data != null && data._isBuffer === true));
  return `0x${data.toString('hex')}`;
}

function serializeATMA(data, format) {
  assert((data != null && data._isBuffer === true));

  switch (format) {
    case 0:
      // Note: no leading 0x.
      return data.toString('hex');
    case 1:
      return data.toString('ascii');
    default:
      return data.toString('hex');
  }
}

function serializeProtocol(value) {
  const iana = lazy('./iana');
  return iana.protocolToString(value);
}

function serializeWKS(map) {
  assert((map != null && map._isBuffer === true));

  const iana = lazy('./iana');
  const ports = encoding.fromPortmap(map);
  const services = [];

  for (const port of ports) {
    const service = iana.getService(port);
    if (service)
      services.push(service);
  }

  return services.join(' ');
}

function cmToM(m, e) {
  assert((m & 0xff) === m);
  assert((e & 0xff) === e);

  if (e < 2) {
    if (e === 1)
      m *= 10;

    m = m.toString(10);

    if (m.length < 2)
      m = '0' + m;

    return `0.${m}`;
  }

  let s = m.toString(10);

  while (e > 2) {
    s += '0';
    e -= 1;
  }

  return s;
}

function serializeLOC(rd) {
  assert(rd && typeof rd === 'object');

  let str = '';

  // North.
  let lat = rd.latitude;
  let ns = 'N';

  if (lat > LOC_EQUATOR) {
    lat = lat - LOC_EQUATOR;
  } else {
    ns = 'S';
    lat = LOC_EQUATOR - lat;
  }

  const lh = (lat / LOC_DEGREES) >>> 0;
  lat %= LOC_DEGREES;

  const lm = (lat / LOC_HOURS) >>> 0;
  lat %= LOC_HOURS;

  const ls = lat / 1000;

  str += lh.toString(10);
  str += ' ';
  str += lm.toString(10);
  str += ' ';
  str += ls.toFixed(3);
  str += ' ';
  str += ns;
  str += ' ';

  // East.
  let lon = rd.longitude;
  let ew = 'E';

  if (lon > LOC_PRIMEMERIDIAN) {
    lon = lon - LOC_PRIMEMERIDIAN;
  } else {
    ew = 'W';
    lon = LOC_PRIMEMERIDIAN - lon;
  }

  const gh = (lon / LOC_DEGREES) >>> 0;
  lon %= LOC_DEGREES;

  const gm = (lon / LOC_HOURS) >>> 0;
  lon %= LOC_HOURS;

  const gs = lon / 1000;

  str += gh.toString(10);
  str += ' ';
  str += gm.toString(10);
  str += ' ';
  str += gs.toFixed(3);
  str += ' ';
  str += ew;
  str += ' ';

  // Altitude.
  let alt = rd.altitude / 100;
  alt -= LOC_ALTITUDEBASE;

  str += alt.toFixed(2);
  str += 'm ';

  // Params.
  str += cmToM((rd.size & 0xf0) >>> 4, rd.size & 0x0f) + 'm ';
  str += cmToM((rd.horizPre & 0xf0) >>> 4, rd.horizPre & 0x0f) + 'm ';
  str += cmToM((rd.vertPre & 0xf0) >>> 4, rd.vertPre & 0x0f) + 'm';

  return str;
}

/*
 * Expose
 */

exports.NAME = NAME;
exports.SERVERS = SERVERS;
exports.INET4 = INET4;
exports.INET6 = INET6;
exports.INET = INET;
exports.TARGET = TARGET;
exports.HEX = HEX;
exports.HEXEND = HEXEND;
exports.BASE32 = BASE32;
exports.BASE64 = BASE64;
exports.BASE64END = BASE64END;
exports.CHAR = CHAR;
exports.OCTET = OCTET;
exports.TXT = TXT;
exports.NSEC = NSEC;
exports.TAGS = TAGS;
exports.TIME = TIME;
exports.TYPE = TYPE;
exports.U8 = U8;
exports.U16 = U16;
exports.U32 = U32;
exports.U48 = U48;
exports.U64 = U64;
exports.NID32 = NID32;
exports.NID64 = NID64;
exports.EUI48 = EUI48;
exports.EUI64 = EUI64;
exports.APL = APL;
exports.NSAP = NSAP;
exports.ATMA = ATMA;
exports.PROTOCOL = PROTOCOL;
exports.WKS = WKS;
exports.TTL = TTL;

exports.records = records;
exports.options = opts;
exports.toString = toString;
exports.fromJSON = fromJSON;
exports.toJSON = toJSON;
}],
[/* 89 */ 'bns-plus', '/lib/openpgpkey.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * openpgpkey.js - OPENPGPKEY for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc7929
 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const dane = __browser_require__(12 /* './dane' */, module);
const wire = __browser_require__(90 /* './wire' */, module);

const {
  types,
  classes,
  Record,
  OPENPGPKEYRecord
} = wire;

/*
 * OPENPGPKEY
 */

const openpgpkey = exports;

openpgpkey.create = function create(key, email, options = {}) {
  assert((key != null && key._isBuffer === true));
  assert(options && typeof options === 'object');

  let {ttl} = options;

  if (ttl == null)
    ttl = 3600;

  assert((ttl >>> 0) === ttl);

  const rr = new Record();
  const rd = new OPENPGPKEYRecord();

  rr.name = openpgpkey.encodeEmail(email);
  rr.type = types.OPENPGPKEY;
  rr.class = classes.IN;
  rr.ttl = ttl;
  rr.data = rd;
  rd.publicKey = key;

  return rr;
};

openpgpkey.verify = function verify(rr, key) {
  assert(rr instanceof Record);
  assert(rr.type === types.OPENPGPKEY);
  assert((key != null && key._isBuffer === true));

  const rd = rr.data;

  return rd.publicKey.equals(key);
};

openpgpkey.encodeEmail = function encodeEmail(email, bits) {
  return dane.encodeEmail(email, 'openpgpkey', bits);
};

openpgpkey.encodeName = function encodeName(name, local, bits) {
  return dane.encodeName(name, 'openpgpkey', local, bits);
};

openpgpkey.decodeName = function decodeName(name) {
  return dane.decodeName(name, 'openpgpkey');
};

openpgpkey.isName = function isName(name) {
  return dane.isName(name, 'openpgpkey');
};
}],
[/* 90 */ 'bns-plus', '/lib/wire.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * wire.js - wire types for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 *
 * Parts of this software are based on miekg/dns and golang/go:
 *   https://github.com/miekg/dns/blob/master/msg.go
 *   https://github.com/miekg/dns/blob/master/types.go
 *   https://github.com/miekg/dns/blob/master/edns.go
 *   https://github.com/golang/go/blob/master/src/net/dnsmsg.go
 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const bio = __browser_require__(14 /* 'bufio' */, module);
const IP = __browser_require__(4 /* 'binet' */, module);
const constants = __browser_require__(11 /* './constants' */, module);
const encoding = __browser_require__(80 /* './encoding' */, module);
const lazy = __browser_require__(81 /* './internal/lazy' */, module);
const util = __browser_require__(79 /* './util' */, module);

const {
  Struct
} = bio;

const {
  sizeName,
  writeNameBW,
  readNameBR,
  sizeRawString,
  writeRawStringBW,
  readRawStringBR,
  sizeString,
  writeStringBW,
  readStringBR,
  readIP,
  writeIP,
  toBitmap,
  fromBitmap,
  hasType
} = encoding;

const {
  opcodes,
  opcodesByVal,
  flags,
  flagsByVal,
  codes,
  codesByVal,
  types,
  typesByVal,
  classes,
  classesByVal,
  eflags,
  eflagsByVal,
  options,
  optionsByVal,
  keyFlags,
  algs,
  algsByVal,
  hashes,
  hashesByVal,
  algHashes,
  nsecHashes,
  nsecHashesByVal,
  certTypes,
  certTypesByVal,
  usages,
  usagesByVal,
  selectors,
  selectorsByVal,
  matchingTypes,
  matchingTypesByVal,
  sshAlgs,
  sshAlgsByVal,
  sshHashes,
  sshHashesByVal,
  tsigAlgs,
  tsigAlgsByVal,
  tkeyModes,
  tkeyModesByVal,
  YEAR68,
  LOC_EQUATOR,
  LOC_PRIMEMERIDIAN,
  LOC_HOURS,
  LOC_DEGREES,
  LOC_ALTITUDEBASE,
  MAX_NAME_SIZE,
  MAX_LABEL_SIZE,
  MAX_UDP_SIZE,
  STD_EDNS_SIZE,
  MAX_EDNS_SIZE,
  MAX_MSG_SIZE,
  DNS_PORT,
  DEFAULT_TTL,
  KSK_2010,
  KSK_2017,
  KSK_ARPA,
  opcodeToString,
  stringToOpcode,
  isOpcodeString,
  codeToString,
  stringToCode,
  isCodeString,
  typeToString,
  stringToType,
  isTypeString,
  classToString,
  stringToClass,
  isClassString,
  optionToString,
  stringToOption,
  isOptionString,
  algToString,
  stringToAlg,
  isAlgString,
  hashToString,
  stringToHash,
  isHashString
} = constants;

/*
 * Constants
 */

const DUMMY = Buffer.alloc(0);
const DUMMY4 = Buffer.alloc(4);
const DUMMY6 = Buffer.alloc(6);
const DUMMY8 = Buffer.alloc(8);
const POOL16 = Buffer.allocUnsafe(16);

/**
 * Record Classes
 * @const {Object}
 */

let records = {};

/**
 * Record Classes By Value
 * @const {Object}
 */

let recordsByVal = {};

/**
 * EDNS0 Option Classes
 * @const {Object}
 */

let opts = {};

/**
 * EDNS0 Option Classes By Value
 * @const {Object}
 */

let optsByVal = {};

/**
 * Message
 */

class Message extends Struct {
  constructor() {
    super();

    this.id = 0;
    this.flags = 0;
    this.opcode = opcodes.QUERY;
    this.code = codes.NOERROR;
    this.question = [];
    this.answer = [];
    this.authority = [];
    this.additional = [];

    // Pseudo sections.
    this.edns = new EDNS();
    this.tsig = null;
    this.sig0 = null;

    // Extra properties.
    this.size = 0;
    this.malformed = false;
    this.trailing = DUMMY;
  }

  inject(msg) {
    assert(msg instanceof this.constructor);
    this.id = msg.id;
    this.flags = msg.flags;
    this.opcode = msg.opcode;
    this.code = msg.code;
    this.question = msg.question.slice();
    this.answer = msg.answer.slice();
    this.authority = msg.authority.slice();
    this.additional = msg.additional.slice();
    this.edns = msg.edns.clone();
    this.tsig = msg.tsig;
    this.sig0 = msg.sig0;
    this.size = msg.size;
    this.malformed = msg.malformed;
    this.trailing = msg.trailing;
    return this;
  }

  deepClone() {
    const msg = new this.constructor();
    return msg.decode(this.encode());
  }

  refresh() {
    this.size = 0;
    this.malformed = false;
    this.trailing = DUMMY;
    return this;
  }

  sections() {
    return [
      this.answer,
      this.authority,
      this.additional
    ];
  }

  *records() {
    for (const rr of this.answer)
      yield rr;

    for (const rr of this.authority)
      yield rr;

    for (const rr of this.additional)
      yield rr;
  }

  canonical() {
    for (const qs of this.question)
      qs.canonical();

    for (const rr of this.records())
      rr.canonical();

    this.edns.canonical();

    if (this.tsig)
      this.tsig.canonical();

    if (this.sig0)
      this.sig0.canonical();

    return this;
  }

  getFlag(bit) {
    return (this.flags & bit) !== 0;
  }

  setFlag(bit, value) {
    if (value)
      this.flags |= bit;
    else
      this.flags &= ~bit;

    return Boolean(value);
  }

  get qr() {
    return this.getFlag(flags.QR);
  }

  set qr(value) {
    return this.setFlag(flags.QR, value);
  }

  get aa() {
    return this.getFlag(flags.AA);
  }

  set aa(value) {
    return this.setFlag(flags.AA, value);
  }

  get tc() {
    return this.getFlag(flags.TC);
  }

  set tc(value) {
    return this.setFlag(flags.TC, value);
  }

  get rd() {
    return this.getFlag(flags.RD);
  }

  set rd(value) {
    return this.setFlag(flags.RD, value);
  }

  get ra() {
    return this.getFlag(flags.RA);
  }

  set ra(value) {
    return this.setFlag(flags.RA, value);
  }

  get z() {
    return this.getFlag(flags.Z);
  }

  set z(value) {
    return this.setFlag(flags.Z, value);
  }

  get ad() {
    return this.getFlag(flags.AD);
  }

  set ad(value) {
    return this.setFlag(flags.AD, value);
  }

  get cd() {
    return this.getFlag(flags.CD);
  }

  set cd(value) {
    return this.setFlag(flags.CD, value);
  }

  get qd() {
    return this.question;
  }

  set qd(value) {
    this.question = value;
  }

  get an() {
    return this.answer;
  }

  set an(value) {
    this.answer = value;
  }

  get ns() {
    return this.authority;
  }

  set ns(value) {
    this.authority = value;
  }

  get ar() {
    return this.additional;
  }

  set ar(value) {
    this.additional = value;
  }

  get qdcount() {
    return this.question.length;
  }

  get ancount() {
    return this.answer.length;
  }

  get nscount() {
    return this.authority.length;
  }

  get arcount() {
    let count = this.additional.length;

    if (this.edns.enabled)
      count += 1;

    if (this.tsig)
      count += 1;

    if (this.sig0)
      count += 1;

    return count;
  }

  setReply(req) {
    assert(req instanceof Message);

    this.id = req.id;
    this.opcode = req.opcode;
    this.qr = true;

    if (this.opcode === opcodes.QUERY) {
      this.rd = req.rd;
      this.cd = req.cd;
    }

    this.question = [];

    if (req.question.length > 0)
      this.question.push(req.question[0]);

    return this;
  }

  isEDNS() {
    return this.edns.enabled;
  }

  setEDNS(size, dnssec) {
    assert((size & 0xffff) === size);
    assert(typeof dnssec === 'boolean');

    this.edns.reset();
    this.edns.enabled = true;
    this.edns.size = size;
    this.edns.dnssec = dnssec;

    if (this.code > 0x0f)
      this.edns.code = this.code >>> 4;

    return this;
  }

  unsetEDNS() {
    this.edns.reset();

    if (this.code > 0x0f)
      this.code = codes.NOERROR;

    return this;
  }

  isDNSSEC() {
    if (!this.edns.enabled)
      return false;

    return this.edns.dnssec;
  }

  maxSize(max) {
    if (max == null)
      max = MAX_EDNS_SIZE;

    assert((max & 0xffff) === max);
    assert(max >= MAX_UDP_SIZE && max <= MAX_EDNS_SIZE);

    if (this.edns.enabled
        && this.edns.size >= MAX_UDP_SIZE) {
      return Math.min(max, this.edns.size);
    }

    return MAX_UDP_SIZE;
  }

  minTTL() {
    const now = util.now();

    let ttl = -1;

    for (const rr of this.records()) {
      if (rr.isOPT())
        continue;

      if (rr.ttl === 0)
        continue;

      if (ttl === -1 || rr.ttl < ttl)
        ttl = rr.ttl;

      if (rr.type === types.RRSIG) {
        const e = rr.data.expiration;
        const t = e - now;

        if (t > 0 && t < ttl)
          ttl = t;
      }
    }

    if (ttl === -1)
      ttl = 0;

    return ttl;
  }

  isAnswer() {
    if (this.answer.length > 0
        && (this.code === codes.NOERROR
        || this.code === codes.YXDOMAIN
        || this.code === codes.NXDOMAIN)) {
      return true;
    }

    return false;
  }

  isReferral() {
    if (this.isAnswer())
      return false;

    if (this.authority.length > 0
        && (this.code === codes.NOERROR
        || this.code === codes.YXDOMAIN)) {
      return true;
    }

    return false;
  }

  collect(name, type) {
    assert(typeof name === 'string');
    assert((type & 0xffff) === type);

    const result = [];

    let target = util.fqdn(name);

    for (const rr of this.answer) {
      if (!util.equal(rr.name, target))
        continue;

      if (rr.type === types.CNAME) {
        target = rr.data.target;

        if (type === types.ANY
            || type === types.CNAME) {
          result.push(rr);
        }

        continue;
      }

      if (type !== types.ANY) {
        if (rr.type !== type)
          continue;
      }

      result.push(rr);
    }

    return result;
  }

  getSize(map) {
    let size = 12;

    for (const qs of this.question)
      size += qs.getSize(map);

    for (const rr of this.answer)
      size += rr.getSize(map);

    for (const rr of this.authority)
      size += rr.getSize(map);

    for (const rr of this.additional)
      size += rr.getSize(map);

    if (this.edns.enabled)
      size += this.edns.getSize(map);

    if (this.tsig)
      size += this.tsig.getSize(map);

    if (this.sig0)
      size += this.sig0.getSize(map);

    return size;
  }

  write(bw, map) {
    bw.writeU16BE(this.id);

    let bits = this.flags;

    bits &= ~(0x0f << 11);
    bits |= (this.opcode & 0x0f) << 11;

    bits &= ~0x0f;
    bits |= this.code & 0x0f;

    bw.writeU16BE(bits);
    bw.writeU16BE(this.question.length);
    bw.writeU16BE(this.answer.length);
    bw.writeU16BE(this.authority.length);
    bw.writeU16BE(this.arcount);

    for (const qs of this.question)
      qs.write(bw, map);

    for (const rr of this.answer)
      rr.write(bw, map);

    for (const rr of this.authority)
      rr.write(bw, map);

    for (const rr of this.additional)
      rr.write(bw, map);

    if (this.code > 0x0f) {
      this.edns.enabled = true;
      this.edns.code = this.code >>> 4;
    }

    if (this.edns.enabled)
      this.edns.write(bw, map);

    if (this.tsig)
      this.tsig.write(bw, map);

    if (this.sig0)
      this.sig0.write(bw, map);

    return this;
  }

  encode(max) {
    const size = this.getSize();
    const bw = bio.write(size);

    this.write(bw, null);

    let msg = bw.render();

    if (max != null)
      msg = truncate(msg, max);

    if (msg.length > MAX_MSG_SIZE)
      throw new Error('Message exceeds size limits.');

    return msg;
  }

  compress(max) {
    const size = this.getSize();
    const bw = bio.write(size);
    const map = new Map();

    this.write(bw, map);

    let msg = bw.slice();

    if (max != null)
      msg = truncate(msg, max);

    if (msg.length > MAX_MSG_SIZE)
      throw new Error('Message exceeds size limits.');

    return msg;
  }

  read(br) {
    const size = br.data.length;
    const id = br.readU16BE();
    const bits = br.readU16BE();
    const qdcount = br.readU16BE();
    const ancount = br.readU16BE();
    const nscount = br.readU16BE();
    const arcount = br.readU16BE();

    this.size = size;
    this.id = id;
    this.flags = bits;
    this.flags &= ~(0x0f << 11);
    this.flags &= ~0x0f;
    this.opcode = (bits >>> 11) & 0x0f;
    this.code = bits & 0x0f;

    let tc = false;

    for (let i = 0; i < qdcount; i++) {
      if (br.left() === 0) {
        tc = true;
        break;
      }

      const qs = Question.read(br);

      this.question.push(qs);
    }

    for (let i = 0; i < ancount; i++) {
      if (br.left() === 0) {
        tc = true;
        break;
      }

      const rr = Record.read(br);

      this.answer.push(rr);
    }

    for (let i = 0; i < nscount; i++) {
      if (br.left() === 0) {
        tc = true;
        break;
      }

      const rr = Record.read(br);

      this.authority.push(rr);
    }

    for (let i = 0; i < arcount; i++) {
      if (br.left() === 0) {
        tc = true;
        break;
      }

      const rr = Record.read(br);

      if (rr.isOPT()) {
        this.edns.setRecord(rr);
        this.code &= 0x0f;
        this.code |= this.edns.code << 4;
        continue;
      }

      if (rr.isTSIG()) {
        this.tsig = rr;
        continue;
      }

      if (rr.isSIG0()) {
        this.sig0 = rr;
        continue;
      }

      this.additional.push(rr);
    }

    if (tc && !(bits & flags.TC))
      this.malformed = true;

    if (br.left() > 0)
      this.trailing = br.readBytes(br.left());

    return this;
  }

  toShort(name, type) {
    const qs = new Question(name, type);
    const rrs = this.collect(qs.name, qs.type);

    let out = '';

    for (const rr of rrs) {
      out += rr.data.toString();
      out += '\n';
    }

    return out;
  }

  toString(ms, host, port) {
    let diff = -1;
    let sec = -1;

    if (ms != null) {
      assert(Number.isSafeInteger(ms) && ms >= 0);
      diff = Math.max(0, Date.now() - ms);
      sec = Math.floor(ms / 1000);
    }

    if (host != null) {
      if (port == null)
        port = DNS_PORT;

      assert(typeof host === 'string');
      assert((port & 0xffff) === port);
    }

    const opcode = opcodeToString(this.opcode);
    const status = codeToString(this.code);
    const id = this.id.toString(10);
    const flags = [];

    if (this.qr)
      flags.push('qr');

    if (this.aa)
      flags.push('aa');

    if (this.tc)
      flags.push('tc');

    if (this.rd)
      flags.push('rd');

    if (this.ra)
      flags.push('ra');

    if (this.z)
      flags.push('z');

    if (this.ad)
      flags.push('ad');

    if (this.cd)
      flags.push('cd');

    let str = '';

    str += ';; ->>HEADER<<-';
    str += ` opcode: ${opcode}, status: ${status}, id: ${id}\n`;
    str += `;; flags: ${flags.join(' ')};`;
    str += ` QUERY: ${this.question.length},`;
    str += ` ANSWER: ${this.answer.length},`;
    str += ` AUTHORITY: ${this.authority.length},`;
    str += ` ADDITIONAL: ${this.arcount}\n`;

    if (this.edns.enabled) {
      const version = this.edns.version;
      const flags = this.edns.dnssec ? ' do' : '';
      const udp = this.edns.size;

      str += '\n';
      str += ';; OPT PSEUDOSECTION:\n';
      str += `; EDNS: version: ${version}, flags:${flags}; udp: ${udp}`;

      for (const opt of this.edns.options) {
        str += '\n';
        str += '; ';
        str += opt.toString();
      }
    }

    if (this.question.length > 0) {
      str += '\n';
      str += ';; QUESTION SECTION:\n';

      for (const qs of this.question) {
        str += ';';
        str += qs.toString();
        str += '\n';
      }
    }

    if (this.answer.length > 0) {
      str += '\n';
      str += ';; ANSWER SECTION:\n';

      for (const rr of this.answer) {
        str += rr.toString();
        str += '\n';
      }
    }

    if (this.authority.length > 0) {
      str += '\n';
      str += ';; AUTHORITY SECTION:\n';

      for (const rr of this.authority) {
        str += rr.toString();
        str += '\n';
      }
    }

    if (this.additional.length > 0) {
      str += '\n';
      str += ';; ADDITIONAL SECTION:\n';

      for (const rr of this.additional) {
        str += rr.toString();
        str += '\n';
      }
    }

    if (this.tsig) {
      str += '\n';
      str += ';; TSIG PSEUDOSECTION:\n';
      str += this.tsig.toString();
      str += '\n';
    }

    if (this.sig0) {
      str += '\n';
      str += ';; SIG0 PSEUDOSECTION:\n';
      str += this.sig0.toString();
      str += '\n';
    }

    str += '\n';

    if (diff !== -1)
      str += `;; Query time: ${diff} msec\n`;

    if (host)
      str += `;; SERVER: ${host}#${port}(${host})\n`;

    if (sec !== -1)
      str += `;; WHEN: ${util.digDate(sec)}\n`;

    if (!this.size)
      this.size = this.getSize();

    if (this.size > 0)
      str += `;; MSG SIZE  rcvd: ${this.size}\n`;

    // Unbound style:
    if (this.trailing.length > 0) {
      str += '\n';
      str += ';; trailing garbage: 0x';
      str += this.trailing.toString('hex');
      str += '\n';
    }

    return str;
  }

  fromString(str) {
    let opcode = 0;
    let code = 0;
    let id = 0;
    let qdcount = 0;
    let ancount = 0;
    let nscount = 0;
    let arcount = 0;
    let enabled = false;
    let version = 0;
    let dnssec = false;
    let udp = MAX_UDP_SIZE;
    let options = null;
    let question = null;
    let answer = null;
    let authority = null;
    let additional = null;
    let tsig = null;
    let sig0 = null;
    let size = 0;
    let trailing = DUMMY;
    let index = -1;

    const lines = util.splitLines(str);

    const read = () => {
      index += 1;
      if (index === lines.length)
        throw new Error('Unexpected EOF.');
      return lines[index];
    };

    const expect = (prefix) => {
      const line = read();
      if (!util.startsWith(line, prefix))
        throw new Error('Unexpected line.');
      return line;
    };

    const seek = (prefix) => {
      for (;;) {
        const line = read();
        if (util.startsWith(line, prefix))
          return line;
      }
    };

    const find = (prefix) => {
      const i = index;
      try {
        return seek(prefix);
      } catch (e) {
        index = i;
        return null;
      }
    };

    const peek = () => {
      if (index + 1 === lines.length)
        return '';
      const line = read();
      index -= 1;
      return line;
    };

    const hdrLine = seek(';; ->>HEADER<<-');
    const hdr = util.splitSP(hdrLine, 9);

    assert(hdr.length === 8);
    assert(hdr[0] === ';;');
    assert(hdr[1] === '->>HEADER<<-');
    assert(hdr[2] === 'opcode:');
    assert(util.endsWith(hdr[3], ','));
    assert(hdr[4] === 'status:');
    assert(util.endsWith(hdr[5], ','));
    assert(hdr[6] === 'id:');
    assert(!util.endsWith(hdr[7], ','));

    opcode = stringToOpcode(hdr[3].slice(0, -1));
    code = stringToCode(hdr[5].slice(0, -1));
    id = util.parseU16(hdr[7]);

    const subLine = expect(';; flags:');
    const sub = util.splitSP(subLine);

    assert(sub.length >= 9);
    assert(sub[0] === ';;');

    if (sub[1] === 'flags:;') {
      sub[1] = 'flags:';
      sub.splice(2, 0, ';');
    }

    assert(sub[1] === 'flags:');

    let bits = 0;
    let counts = null;

    for (let i = 2; i < sub.length; i++) {
      let flag = sub[i];

      const end = flag[flag.length - 1] === ';';

      if (end)
        flag = flag.slice(0, -1);

      switch (flag) {
        case '':
          break;
        case 'qr':
          bits |= flags.QR;
          break;
        case 'aa':
          bits |= flags.AA;
          break;
        case 'tc':
          bits |= flags.TC;
          break;
        case 'rd':
          bits |= flags.RD;
          break;
        case 'ra':
          bits |= flags.RA;
          break;
        case 'z':
          bits |= flags.Z;
          break;
        case 'ad':
          bits |= flags.AD;
          break;
        case 'cd':
          bits |= flags.CD;
          break;
        default:
          throw new Error(`Unknown flag: ${flag}.`);
      }

      if (end) {
        counts = sub.slice(i + 1);
        break;
      }
    }

    if (!counts)
      throw new Error('Malformed subheader.');

    assert(counts.length === 8);
    assert(counts[0] === 'QUERY:');
    assert(util.endsWith(counts[1], ','));
    assert(counts[2] === 'ANSWER:');
    assert(util.endsWith(counts[3], ','));
    assert(counts[4] === 'AUTHORITY:');
    assert(util.endsWith(counts[5], ','));
    assert(counts[6] === 'ADDITIONAL:');
    assert(!util.endsWith(counts[7], ','));

    qdcount = util.parseU16(counts[1].slice(0, -1));
    ancount = util.parseU16(counts[3].slice(0, -1));
    nscount = util.parseU16(counts[5].slice(0, -1));
    arcount = util.parseU16(counts[7]);
    options = [];

    if (find(';; OPT PSEUDOSECTION:')) {
      const line = expect('; EDNS: version: ');

      const hdr = util.splitSP(line);
      assert(hdr.length >= 7);
      assert(util.endsWith(hdr[3], ','));

      if (hdr[4] === 'flags:;') {
        hdr[4] = 'flags:';
        hdr.splice(5, 0, ';');
      }

      assert(hdr[4] === 'flags:');

      enabled = true;
      version = util.parseU8(hdr[3].slice(0, -1));

      assert(arcount > 0);
      arcount -= 1;

      let sub = null;

      for (let i = 5; i < hdr.length; i++) {
        let flag = hdr[i];

        const end = flag[flag.length - 1] === ';';

        if (end)
          flag = flag.slice(0, -1);

        switch (flag) {
          case '':
            break;
          case 'do':
            dnssec = true;
            break;
          default:
            throw new Error(`Unknown EDNS flag: ${flag}.`);
        }

        if (end) {
          sub = hdr.slice(i + 1);
          break;
        }
      }

      if (!sub)
        throw new Error('Malformed EDNS header.');

      assert(sub.length === 2);
      assert(sub[0] === 'udp:');

      udp = util.parseU16(sub[1]);

      while (util.startsWith(peek(), '; ')) {
        let line = read().substring(2);

        // Hack.
        if (util.startsWith(line, 'COOKIE: ')
            && util.endsWith(line, ' (echoed)')) {
          line = line.slice(0, -9);
        }

        options.push(Option.fromString(line));
      }
    }

    question = [];

    if (qdcount > 0) {
      seek(';; QUESTION SECTION:');

      for (let i = 0; i < qdcount; i++) {
        const line = read();

        assert(line[0] === ';');

        const text = line.substring(1);
        const qs = Question.fromString(text);

        question.push(qs);
      }
    }

    answer = [];

    if (ancount > 0) {
      seek(';; ANSWER SECTION:');

      for (let i = 0; i < ancount; i++) {
        const line = read();
        const rr = Record.fromString(line);

        answer.push(rr);
      }
    }

    authority = [];

    if (nscount > 0) {
      seek(';; AUTHORITY SECTION:');

      for (let i = 0; i < nscount; i++) {
        const line = read();
        const rr = Record.fromString(line);

        authority.push(rr);
      }
    }

    additional = [];

    if (arcount > 0) {
      const section = seek(';; ');

      switch (section) {
        case ';; ADDITIONAL SECTION:':
        case ';; TSIG PSEUDOSECTION:':
        case ';; SIG0 PSEUDOSECTION:':
          break;
        default:
          throw new Error('Unexpected section.');
      }

      for (let i = 0; i < arcount; i++) {
        const line = read();

        if (line[0] === ';') {
          arcount += 1;
          continue;
        }

        const rr = Record.fromString(line);

        if (rr.isTSIG()) {
          tsig = rr;
          continue;
        }

        if (rr.isSIG0()) {
          sig0 = rr;
          continue;
        }

        additional.push(rr);
      }
    }

    const sizeLine = find(';; MSG SIZE  rcvd: ');

    if (sizeLine) {
      const text = sizeLine.substring(19);
      size = util.parseU32(text);
    }

    const garbageLine = find(';; trailing garbage: 0x');

    if (garbageLine) {
      const text = garbageLine.substring(23);
      trailing = util.parseHex(text);
    }

    this.opcode = opcode;
    this.code = code;
    this.id = id;
    this.flags = bits;

    this.edns.enabled = enabled;
    this.edns.version = version;
    this.edns.dnssec = dnssec;
    this.edns.size = udp;
    this.edns.code = code >>> 4;
    this.edns.options = options;

    this.question = question;
    this.answer = answer;
    this.authority = authority;
    this.additional = additional;
    this.tsig = tsig;
    this.sig0 = sig0;

    this.size = size;
    this.malformed = false;
    this.trailing = trailing;

    return this;
  }

  getJSON() {
    if (!this.size)
      this.size = this.getSize();

    return {
      id: this.id,
      opcode: opcodeToString(this.opcode),
      code: codeToString(this.code),
      qr: this.qr,
      aa: this.aa,
      tc: this.tc,
      rd: this.rd,
      ra: this.ra,
      z: this.z,
      ad: this.ad,
      cd: this.cd,
      question: this.question.map(qs => qs.toJSON()),
      answer: this.answer.map(rr => rr.toJSON()),
      authority: this.authority.map(rr => rr.toJSON()),
      additional: this.additional.map(rr => rr.toJSON()),
      edns: this.edns.enabled ? this.edns.toJSON() : undefined,
      tsig: this.tsig ? this.tsig.data.toJSON() : undefined,
      sig0: this.sig0 ? this.sig0.data.toJSON() : undefined,
      size: this.size,
      trailing: this.trailing.length > 0
        ? this.trailing.toString('hex')
        : undefined
    };
  }

  fromJSON(json) {
    assert(json && typeof json === 'object');
    assert((json.id & 0xffff) === json.id);
    assert(typeof json.qr === 'boolean');
    assert(typeof json.aa === 'boolean');
    assert(typeof json.tc === 'boolean');
    assert(typeof json.rd === 'boolean');
    assert(typeof json.ra === 'boolean');
    assert(typeof json.z === 'boolean');
    assert(typeof json.ad === 'boolean');
    assert(typeof json.cd === 'boolean');
    assert(Array.isArray(json.question));
    assert(Array.isArray(json.answer));
    assert(Array.isArray(json.authority));
    assert(Array.isArray(json.additional));

    this.id = json.id;
    this.opcode = stringToOpcode(json.opcode);
    this.code = stringToCode(json.code);
    this.qr = json.qr;
    this.aa = json.aa;
    this.tc = json.tc;
    this.rd = json.rd;
    this.ra = json.ra;
    this.z = json.z;
    this.ad = json.ad;
    this.cd = json.cd;

    for (const qs of json.question)
      this.question.push(Question.fromJSON(qs));

    for (const rr of json.answer)
      this.answer.push(Record.fromJSON(rr));

    for (const rr of json.authority)
      this.authority.push(Record.fromJSON(rr));

    for (const rr of json.additional) {
      const record = Record.fromJSON(rr);

      assert(!record.isOPT());
      assert(!record.isTSIG());
      assert(!record.isSIG0());

      this.additional.push(record);
    }

    if (json.edns != null) {
      this.edns.fromJSON(json.edns);
      this.code &= 0x0f;
      this.code |= this.edns.code << 4;
    }

    if (json.tsig != null) {
      this.tsig = new Record();
      this.tsig.name = '.';
      this.tsig.type = types.TSIG;
      this.tsig.class = classes.ANY;
      this.tsig.ttl = 0;
      this.tsig.data = TSIGRecord.fromJSON(json.tsig);
    }

    if (json.sig0 != null) {
      this.sig0 = new Record();
      this.sig0.name = '.';
      this.sig0.type = types.SIG;
      this.sig0.class = classes.ANY;
      this.sig0.ttl = 0;
      this.sig0.data = SIGRecord.fromJSON(json.sig0);
    }

    if (json.size != null) {
      assert((json.size >>> 0) === json.size);
      this.size = json.size;
    }

    this.malformed = false;

    if (json.trailing != null)
      this.trailing = util.parseHex(json.trailing);

    return this;
  }
}

/**
 * EDNS
 */

class EDNS extends Struct {
  constructor() {
    super();

    this.enabled = false;
    this.size = MAX_UDP_SIZE;
    this.code = 0;
    this.version = 0;
    this.flags = 0;
    this.options = [];
  }

  inject(edns) {
    assert(edns instanceof this.constructor);
    this.enabled = edns.enabled;
    this.size = edns.size;
    this.code = edns.code;
    this.version = edns.version;
    this.flags = edns.flags;
    this.options = edns.options.slice();
    return this;
  }

  clone() {
    const copy = new this.constructor();
    return copy.inject(this);
  }

  reset() {
    this.enabled = false;
    this.size = MAX_UDP_SIZE;
    this.code = 0;
    this.version = 0;
    this.flags = 0;
    this.options = [];
    return this;
  }

  canonical() {
    // Note: not mentioned in RFC 4034.
    for (const opt of this.options)
      opt.canonical();
    return this;
  }

  getFlag(bit) {
    return (this.flags & bit) !== 0;
  }

  setFlag(bit, value) {
    if (value)
      this.flags |= bit;
    else
      this.flags &= ~bit;

    return Boolean(value);
  }

  get dnssec() {
    return this.getFlag(eflags.DO);
  }

  set dnssec(value) {
    return this.setFlag(eflags.DO, value);
  }

  set(code, option) {
    assert((code & 0xffff) === code);
    assert(option instanceof OptionData);

    const opt = new Option();
    opt.code = code;
    opt.option = option;

    for (let i = 0; i < this.options.length; i++) {
      const item = this.options[i];
      if (item.code === code) {
        this.options[i] = opt;
        return this;
      }
    }

    this.options.push(opt);

    return this;
  }

  get(code) {
    assert((code & 0xffff) === code);

    for (const opt of this.options) {
      if (opt.code === code)
        return opt.option;
    }

    return null;
  }

  has(code) {
    return this.get(code) != null;
  }

  remove(code) {
    assert((code & 0xffff) === code);

    for (let i = 0; i < this.options.length; i++) {
      const opt = this.options[i];
      if (opt.code === code) {
        this.options.splice(i, 1);
        return opt.option;
      }
    }

    return null;
  }

  add(option) {
    assert(option instanceof OptionData);
    assert(option.code !== options.RESERVED);
    return this.set(option.code, option);
  }

  setCookie(cookie) {
    assert((cookie != null && cookie._isBuffer === true));
    const option = new COOKIEOption();
    option.cookie = cookie;
    return this.add(option);
  }

  getCookie() {
    const opt = this.get(options.COOKIE);

    if (!opt)
      return null;

    return opt.cookie;
  }

  hasCookie() {
    return this.getCookie() != null;
  }

  removeCookie() {
    const opt = this.remove(options.COOKIE);

    if (!opt)
      return null;

    return opt.cookie;
  }

  getDataSize(map) {
    let size = 0;
    for (const opt of this.options)
      size += opt.getSize(map);
    return size;
  }

  getSize(map) {
    let size = 0;
    size += 1;
    size += 10;
    size += this.getDataSize(map);
    return size;
  }

  write(bw, map) {
    bw.writeU8(0);
    bw.writeU16BE(types.OPT);
    bw.writeU16BE(this.size);

    bw.writeU8(this.code);
    bw.writeU8(this.version);
    bw.writeU16BE(this.flags);

    bw.writeU16BE(0);

    const off = bw.offset;

    for (const opt of this.options)
      opt.write(bw, map);

    const size = bw.offset - off;

    bio.writeU16BE(bw.data, size, off - 2);

    return this;
  }

  read(br) {
    assert(br.readU8() === 0);
    assert(br.readU16BE() === types.OPT);

    this.size = br.readU16BE();

    this.code = br.readU8();
    this.version = br.readU8();
    this.flags = br.readU16BE();

    const size = br.readU16BE();
    const child = br.readChild(size);

    while (child.left())
      this.options.push(Option.read(child));

    return this;
  }

  setRecord(rr) {
    assert(rr instanceof Record);
    assert(rr.type === types.OPT);

    const rd = rr.data;

    this.enabled = true;
    this.size = rr.class;
    this.code = (rr.ttl >>> 24) & 0xff;
    this.version = (rr.ttl >>> 16) & 0xff;
    this.flags = rr.ttl & 0xffff;
    this.options = [];

    for (const opt of rd.options)
      this.options.push(opt);

    return this;
  }

  toRecord() {
    const rr = new Record();
    const rd = new OPTRecord();

    rr.name = '.';
    rr.type = types.OPT;

    rr.class = this.size;

    rr.ttl |= (this.code & 0xff) << 24;
    rr.ttl |= (this.version & 0xff) << 16;
    rr.ttl |= this.flags & 0xffff;
    rr.ttl >>>= 0;

    rr.data = rd;

    for (const opt of this.options)
      rd.options.push(opt);

    return rr;
  }

  fromRecord(rr) {
    return this.setRecord(rr);
  }

  static fromRecord(rr) {
    return new this().fromRecord(rr);
  }

  getJSON() {
    return {
      enabled: this.enabled,
      size: this.size,
      code: this.code,
      version: this.version,
      dnssec: this.dnssec,
      options: this.options.map(opt => opt.toJSON())
    };
  }

  fromJSON(json) {
    assert(json && typeof json === 'object');
    assert(typeof json.enabled === 'boolean');
    assert((json.size & 0xffff) === json.size);
    assert((json.code & 0xff) === json.code);
    assert((json.version & 0xff) === json.version);
    assert(typeof json.dnssec === 'boolean');
    assert(Array.isArray(json.options));

    this.enabled = json.enabled;
    this.size = json.size;
    this.code = json.code;
    this.version = json.version;
    this.dnssec = json.dnssec;

    for (const opt of json.options)
      this.options.push(Option.fromJSON(opt));

    return this;
  }
}

/**
 * Question
 */

class Question extends Struct {
  constructor(name, type) {
    super();

    if (name == null)
      name = '';

    if (type == null)
      type = types.ANY;

    if (typeof type === 'string')
      type = stringToType(type);

    assert(typeof name === 'string');
    assert((type & 0xffff) === type);

    this.name = util.fqdn(name);
    this.type = type;
    this.class = classes.IN;
  }

  equals(qs) {
    assert(qs instanceof Question);
    return util.equal(this.name, qs.name)
      && this.type === qs.type
      && this.class === qs.class;
  }

  inject(qs) {
    assert(qs instanceof this.constructor);
    this.name = qs.name;
    this.type = qs.type;
    this.class = qs.class;
    return this;
  }

  clone() {
    const qs = new this.constructor();
    return qs.inject(this);
  }

  canonical() {
    // Note: not mentioned in RFC 4034.
    this.name = this.name.toLowerCase();
    return this;
  }

  getSize(map) {
    return sizeName(this.name, map) + 4;
  }

  write(bw, map) {
    writeNameBW(bw, this.name, map);
    bw.writeU16BE(this.type);
    bw.writeU16BE(this.class);
    return this;
  }

  read(br) {
    this.name = readNameBR(br);

    if (br.left() === 0)
      return this;

    this.type = br.readU16BE();

    if (br.left() === 0)
      return this;

    this.class = br.readU16BE();

    return this;
  }

  toString() {
    const name = this.name;
    const class_ = classToString(this.class);
    const type = typeToString(this.type);
    return `${name} ${class_} ${type}`;
  }

  fromString(str) {
    const parts = util.splitSP(str, 4);

    assert(parts.length === 3);
    assert(encoding.isName(parts[0]));

    this.name = parts[0];
    this.class = stringToClass(parts[1]);
    this.type = stringToType(parts[2]);

    return this;
  }

  getJSON() {
    return {
      name: this.name,
      class: classToString(this.class),
      type: typeToString(this.type)
    };
  }

  fromJSON(json) {
    assert(json && typeof json === 'object');
    assert(typeof json.name === 'string');
    assert(encoding.isName(json.name));

    this.name = json.name;
    this.class = stringToClass(json.class);
    this.type = stringToType(json.type);

    return this;
  }
}

/**
 * Record
 */

class Record extends Struct {
  constructor() {
    super();
    this.name = '.';
    this.type = types.UNKNOWN;
    this.class = classes.IN;
    this.ttl = 0;
    this.data = new UNKNOWNRecord();
  }

  inject(rr) {
    assert(rr instanceof this.constructor);
    this.name = rr.name;
    this.type = rr.type;
    this.class = rr.class;
    this.ttl = rr.ttl;
    this.data = rr.data;
    return this;
  }

  deepClone() {
    const rr = new this.constructor();
    return rr.decode(this.encode());
  }

  canonical() {
    this.name = this.name.toLowerCase();
    this.data.canonical();
    return this;
  }

  isOPT() {
    return this.type === types.OPT;
  }

  isTSIG() {
    return this.name === '.'
        && this.type === types.TSIG
        && this.class === classes.ANY
        && this.ttl === 0;
  }

  isSIG0() {
    return this.name === '.'
        && this.type === types.SIG
        && this.class === classes.ANY
        && this.ttl === 0
        && this.data.typeCovered === 0;
  }

  getSize(map) {
    let size = 0;
    size += sizeName(this.name, map);
    size += 10;
    size += this.data.getSize(map);
    return size;
  }

  write(bw, map) {
    writeNameBW(bw, this.name, map);
    bw.writeU16BE(this.type);
    bw.writeU16BE(this.class);
    bw.writeU32BE(this.ttl);
    bw.writeU16BE(0);

    const off = bw.offset;

    this.data.write(bw, map);

    const size = bw.offset - off;

    bio.writeU16BE(bw.data, size, off - 2);

    return this;
  }

  read(br) {
    this.name = readNameBR(br);
    this.type = br.readU16BE();
    this.class = br.readU16BE();
    this.ttl = br.readU32BE();

    const size = br.readU16BE();
    const child = br.readChild(size);

    this.data = readData(this.type, child);

    return this;
  }

  toString() {
    const name = this.name;
    const ttl = this.ttl.toString(10);
    const class_ = classToString(this.class);
    const type = typeToString(this.type);
    const isUnknown = typesByVal[this.type] == null;

    let body = this.data.toString();

    if (isUnknown) {
      assert(this.data.type === types.UNKNOWN);
      const size = this.data.getSize().toString(10);
      body = `\\# ${size} ${body}`;
    }

    return `${name} ${ttl} ${class_} ${type} ${body}`;
  }

  fromString(str) {
    const scan = lazy('./internal/scan');
    const rr = scan.parseRecord(exports, str);
    return this.inject(rr);
  }

  getJSON() {
    return {
      name: this.name,
      ttl: this.ttl,
      class: classToString(this.class),
      type: typeToString(this.type),
      data: this.data.toJSON()
    };
  }

  fromJSON(json) {
    assert(json && typeof json === 'object');
    assert(typeof json.name === 'string');
    assert(encoding.isName(json.name));
    assert((json.ttl >>> 0) === json.ttl);
    assert(json.data && typeof json.data === 'object');

    this.name = json.name;
    this.ttl = json.ttl;
    this.class = stringToClass(json.class);
    this.type = stringToType(json.type);

    const RD = recordsByVal[this.type];

    let data;
    if (types[json.type] == null) {
      const rd = util.parseHex(json.data.data);

      if (RD)
        data = RD.decode(rd);
      else
        data = UNKNOWNRecord.decode(rd);
    } else {
      if (!RD)
        throw new Error(`Unknown record type: ${json.type}.`);

      data = RD.fromJSON(json.data);
    }

    this.data = data;

    return this;
  }
}

/**
 * RecordData
 */

class RecordData extends Struct {
  constructor() {
    super();
  }

  get type() {
    return types.UNKNOWN;
  }

  _schema() {
    const schema = lazy('./internal/schema');
    const s = schema.records[this.type];

    if (!s)
      return schema.records[types.UNKNOWN];

    return s;
  }

  canonical() {
    return this;
  }

  toString() {
    const schema = lazy('./internal/schema');
    return schema.toString(exports, this, this._schema());
  }

  fromString(str) {
    const scan = lazy('./internal/scan');
    const rd = scan.parseData(exports, this.type, str);
    return this.inject(rd);
  }

  getJSON() {
    const schema = lazy('./internal/schema');
    return schema.toJSON(exports, this, this._schema());
  }

  fromJSON(json) {
    const schema = lazy('./internal/schema');
    return schema.fromJSON(exports, this, this._schema(), json);
  }
}

/**
 * UNKNOWN Record
 */

class UNKNOWNRecord extends RecordData {
  constructor() {
    super();
    this.data = DUMMY;
  }

  get type() {
    return types.UNKNOWN;
  }

  getSize() {
    return this.data.length;
  }

  write(bw) {
    bw.writeBytes(this.data);
    return this;
  }

  read(br) {
    this.data = br.readBytes(br.left());
    return this;
  }
}

/**
 * A Record
 * Address Record
 * @see https://tools.ietf.org/html/rfc1035
 */

class ARecord extends RecordData {
  constructor() {
    super();
    this.address = '0.0.0.0';
  }

  get type() {
    return types.A;
  }

  getSize() {
    return 4;
  }

  write(bw) {
    writeIP(bw, this.address, 4);
    return this;
  }

  read(br) {
    this.address = readIP(br, 4);
    return this;
  }
}

/**
 * NS Record
 * Name Server Record
 * @see https://tools.ietf.org/html/rfc1035#page-12
 */

class NSRecord extends RecordData {
  constructor() {
    super();
    this.ns = '.';
  }

  get type() {
    return types.NS;
  }

  canonical() {
    this.ns = this.ns.toLowerCase();
    return this;
  }

  getSize(map) {
    return sizeName(this.ns, map);
  }

  write(bw, map) {
    writeNameBW(bw, this.ns, map);
    return this;
  }

  read(br) {
    this.ns = readNameBR(br);
    return this;
  }
}

/**
 * MD Record
 * Mail Destination Record (obsolete)
 * @see https://tools.ietf.org/html/rfc883
 * @see https://tools.ietf.org/html/rfc973
 */

class MDRecord extends RecordData {
  constructor() {
    super();
    this.md = '.';
  }

  get type() {
    return types.MD;
  }

  canonical() {
    this.md = this.md.toLowerCase();
    return this;
  }

  getSize(map) {
    return sizeName(this.md, map);
  }

  write(bw, map) {
    writeNameBW(bw, this.md, map);
    return this;
  }

  read(br) {
    this.md = readNameBR(br);
    return this;
  }
}

/**
 * MF Record
 * Mail Forwarder Record (obsolete)
 * @see https://tools.ietf.org/html/rfc883
 * @see https://tools.ietf.org/html/rfc973
 */

class MFRecord extends RecordData {
  constructor() {
    super();
    this.mf = '.';
  }

  get type() {
    return types.MF;
  }

  canonical() {
    this.mf = this.mf.toLowerCase();
    return this;
  }

  getSize(map) {
    return sizeName(this.mf, map);
  }

  write(bw, map) {
    writeNameBW(bw, this.mf, map);
    return this;
  }

  read(br) {
    this.mf = readNameBR(br);
    return this;
  }
}

/**
 * CNAME Record
 * Canonical Name Record
 * @see https://tools.ietf.org/html/rfc1035#page-12
 */

class CNAMERecord extends RecordData {
  constructor() {
    super();
    this.target = '.';
  }

  get type() {
    return types.CNAME;
  }

  canonical() {
    this.target = this.target.toLowerCase();
    return this;
  }

  getSize(map) {
    return sizeName(this.target, map);
  }

  write(bw, map) {
    writeNameBW(bw, this.target, map);
    return this;
  }

  read(br) {
    this.target = readNameBR(br);
    return this;
  }
}

/**
 * SOA Record
 * Start of Authority Record
 * @see https://tools.ietf.org/html/rfc1035#page-12
 * @see https://tools.ietf.org/html/rfc2308
 */

class SOARecord extends RecordData {
  constructor() {
    super();
    this.ns = '.';
    this.mbox = '.';
    this.serial = 0;
    this.refresh = 0;
    this.retry = 0;
    this.expire = 0;
    this.minttl = 0;
  }

  get type() {
    return types.SOA;
  }

  canonical() {
    this.ns = this.ns.toLowerCase();
    this.mbox = this.mbox.toLowerCase();
    return this;
  }

  getSize(map) {
    let size = 0;
    size += sizeName(this.ns, map);
    size += sizeName(this.mbox, map);
    size += 20;
    return size;
  }

  write(bw, map) {
    writeNameBW(bw, this.ns, map);
    writeNameBW(bw, this.mbox, map);
    bw.writeU32BE(this.serial);
    bw.writeU32BE(this.refresh);
    bw.writeU32BE(this.retry);
    bw.writeU32BE(this.expire);
    bw.writeU32BE(this.minttl);
    return this;
  }

  read(br) {
    this.ns = readNameBR(br);
    this.mbox = readNameBR(br);
    this.serial = br.readU32BE();
    this.refresh = br.readU32BE();
    this.retry = br.readU32BE();
    this.expire = br.readU32BE();
    this.minttl = br.readU32BE();
    return this;
  }
}

/**
 * MB Record
 * Mailbox Record (expiremental)
 * @see https://tools.ietf.org/html/rfc883
 * @see https://tools.ietf.org/html/rfc1035
 * @see https://tools.ietf.org/html/rfc2505
 */

class MBRecord extends RecordData {
  constructor() {
    super();
    this.mb = '.';
  }

  get type() {
    return types.MB;
  }

  canonical() {
    this.mb = this.mb.toLowerCase();
    return this;
  }

  getSize(map) {
    return sizeName(this.mb, map);
  }

  write(bw, map) {
    writeNameBW(bw, this.mb, map);
    return this;
  }

  read(br) {
    this.mb = readNameBR(br);
    return this;
  }
}

/**
 * MG Record
 * Mail Group Record (experimental)
 * @see https://tools.ietf.org/html/rfc883
 * @see https://tools.ietf.org/html/rfc1035
 * @see https://tools.ietf.org/html/rfc2505
 */

class MGRecord extends RecordData {
  constructor() {
    super();
    this.mg = '.';
  }

  get type() {
    return types.MG;
  }

  canonical() {
    this.mg = this.mg.toLowerCase();
    return this;
  }

  getSize(map) {
    return sizeName(this.mg, map);
  }

  write(bw, map) {
    writeNameBW(bw, this.mg, map);
    return this;
  }

  read(br) {
    this.mg = readNameBR(br);
    return this;
  }
}

/**
 * MR Record
 * Mail Rename Record (experimental)
 * @see https://tools.ietf.org/html/rfc883
 * @see https://tools.ietf.org/html/rfc1035
 * @see https://tools.ietf.org/html/rfc2505
 */

class MRRecord extends RecordData {
  constructor() {
    super();
    this.mr = '.';
  }

  get type() {
    return types.MR;
  }

  canonical() {
    this.mr = this.mr.toLowerCase();
    return this;
  }

  getSize(map) {
    return sizeName(this.mr, map);
  }

  write(bw, map) {
    writeNameBW(bw, this.mr, map);
    return this;
  }

  read(br) {
    this.mr = readNameBR(br);
    return this;
  }
}

/**
 * NULL Record
 * Null Record (obsolete)
 * @see https://tools.ietf.org/html/rfc883
 * @see https://tools.ietf.org/html/rfc1035
 */

class NULLRecord extends UNKNOWNRecord {
  constructor() {
    super();
  }

  get type() {
    return types.NULL;
  }
}

/**
 * WKS Record
 * Well-known Services Record (deprecated)
 * @see https://tools.ietf.org/html/rfc883
 * @see https://tools.ietf.org/html/rfc1035
 * @see https://tools.ietf.org/html/rfc1123
 * @see https://tools.ietf.org/html/rfc1127
 */

class WKSRecord extends RecordData {
  constructor() {
    super();
    this.address = '0.0.0.0';
    this.protocol = 0;
    this.bitmap = DUMMY;
  }

  get type() {
    return types.WKS;
  }

  setPorts(ports) {
    this.bitmap = encoding.toPortmap(ports);
    return this;
  }

  getPorts() {
    return encoding.fromPortmap(this.bitmap);
  }

  hasPort(port) {
    return encoding.hasPort(this.bitmap, port);
  }

  getSize() {
    return 5 + this.bitmap.length;
  }

  write(bw) {
    writeIP(bw, this.address, 4);
    bw.writeU8(this.protocol);
    bw.writeBytes(this.bitmap);
    return this;
  }

  read(br) {
    this.address = readIP(br, 4);
    this.protocol = br.readU8();
    this.bitmap = br.readBytes(br.left());
    return this;
  }
}

/**
 * PTR Record
 * Pointer Record
 * @see https://tools.ietf.org/html/rfc1035
 */

class PTRRecord extends RecordData {
  constructor() {
    super();
    this.ptr = '.';
  }

  get type() {
    return types.PTR;
  }

  canonical() {
    this.ptr = this.ptr.toLowerCase();
    return this;
  }

  getSize(map) {
    return sizeName(this.ptr, map);
  }

  write(bw, map) {
    writeNameBW(bw, this.ptr, map);
    return this;
  }

  read(br) {
    this.ptr = readNameBR(br);
    return this;
  }
}

/**
 * HINFO Record
 * Host Information Record (not-in-use)
 * @see https://tools.ietf.org/html/rfc883
 */

class HINFORecord extends RecordData {
  constructor() {
    super();
    this.cpu = '';
    this.os = '';
  }

  get type() {
    return types.HINFO;
  }

  getSize() {
    let size = 0;
    size += sizeString(this.cpu);
    size += sizeString(this.os);
    return size;
  }

  write(bw) {
    writeStringBW(bw, this.cpu);
    writeStringBW(bw, this.os);
    return this;
  }

  read(br) {
    this.cpu = readStringBR(br);
    this.os = readStringBR(br);
    return this;
  }
}

/**
 * MINFO Record
 * Mail Info Record (experimental)
 * @see https://tools.ietf.org/html/rfc883
 * @see https://tools.ietf.org/html/rfc1035
 * @see https://tools.ietf.org/html/rfc2505
 */

class MINFORecord extends RecordData {
  constructor() {
    super();
    this.rmail = '.';
    this.email = '.';
  }

  get type() {
    return types.MINFO;
  }

  canonical() {
    this.rmail = this.rmail.toLowerCase();
    this.email = this.email.toLowerCase();
    return this;
  }

  getSize(map) {
    let size = 0;
    size += sizeName(this.rmail, map);
    size += sizeName(this.email, map);
    return size;
  }

  write(bw, map) {
    writeNameBW(bw, this.rmail, map);
    writeNameBW(bw, this.email, map);
    return this;
  }

  read(br) {
    this.rmail = readNameBR(br);
    this.email = readNameBR(br);
    return this;
  }
}

/**
 * MX Record
 * Mail Exchange Record
 * @see https://tools.ietf.org/html/rfc1035#page-12
 * @see https://tools.ietf.org/html/rfc7505
 */

class MXRecord extends RecordData {
  constructor() {
    super();
    this.preference = 0;
    this.mx = '.';
  }

  get type() {
    return types.MX;
  }

  canonical() {
    this.mx = this.mx.toLowerCase();
    return this;
  }

  getSize(map) {
    return 2 + sizeName(this.mx, map);
  }

  write(bw, map) {
    bw.writeU16BE(this.preference);
    writeNameBW(bw, this.mx, map);
    return this;
  }

  read(br) {
    this.preference = br.readU16BE();
    this.mx = readNameBR(br);
    return this;
  }
}

/**
 * TXT Record
 * Text Record
 * @see https://tools.ietf.org/html/rfc1035#page-12
 */

class TXTRecord extends RecordData {
  constructor() {
    super();
    this.txt = [];
  }

  get type() {
    return types.TXT;
  }

  getSize() {
    let size = 0;
    for (const txt of this.txt)
      size += sizeString(txt);
    return size;
  }

  write(bw) {
    for (const txt of this.txt)
      writeStringBW(bw, txt);
    return this;
  }

  read(br) {
    while (br.left())
      this.txt.push(readStringBR(br));
    return this;
  }
}

/**
 * RP Record
 * Responsible Person Record
 * @see https://tools.ietf.org/html/rfc1183
 */

class RPRecord extends RecordData {
  constructor() {
    super();
    this.mbox = '.';
    this.txt = '.';
  }

  get type() {
    return types.RP;
  }

  canonical() {
    this.mbox = this.mbox.toLowerCase();
    this.txt = this.txt.toLowerCase();
    return this;
  }

  getSize(map) {
    let size = 0;
    size += sizeName(this.mbox, map);
    size += sizeName(this.txt, map);
    return size;
  }

  write(bw, map) {
    writeNameBW(bw, this.mbox, map);
    writeNameBW(bw, this.txt, map);
    return this;
  }

  read(br) {
    this.mbox = readNameBR(br);
    this.txt = readNameBR(br);
    return this;
  }
}

/**
 * AFSDB Record
 * AFS Database Record
 * @see https://tools.ietf.org/html/rfc1183
 */

class AFSDBRecord extends RecordData {
  constructor() {
    super();
    this.subtype = 0;
    this.hostname = '.';
  }

  get type() {
    return types.AFSDB;
  }

  canonical() {
    this.hostname = this.hostname.toLowerCase();
    return this;
  }

  getSize(map) {
    return 2 + sizeName(this.hostname, map);
  }

  write(bw, map) {
    bw.writeU16BE(this.subtype);
    writeNameBW(bw, this.hostname, map);
    return this;
  }

  read(br) {
    this.subtype = br.readU16BE();
    this.hostname = readNameBR(br);
    return this;
  }
}

/**
 * X25Record
 * X25 Record (not-in-use)
 * @see https://tools.ietf.org/html/rfc1183
 */

class X25Record extends RecordData {
  constructor() {
    super();
    this.psdnAddress = '';
  }

  get type() {
    return types.X25;
  }

  getSize() {
    return sizeString(this.psdnAddress);
  }

  write(bw) {
    writeStringBW(bw, this.psdnAddress);
    return this;
  }

  read(br) {
    this.psdnAddress = readStringBR(br, true);
    return this;
  }
}

/**
 * ISDN Record
 * ISDN Record (not-in-use)
 * @see https://tools.ietf.org/html/rfc1183
 */

class ISDNRecord extends RecordData {
  constructor() {
    super();
    this.address = '';
    this.sa = '';
  }

  get type() {
    return types.ISDN;
  }

  getSize() {
    let size = 0;
    size += sizeString(this.address);
    size += sizeString(this.sa);
    return size;
  }

  write(bw) {
    writeStringBW(bw, this.address);
    writeStringBW(bw, this.sa);
    return this;
  }

  read(br) {
    this.address = readStringBR(br, true);
    this.sa = readStringBR(br, true);
    return this;
  }
}

/**
 * RT Record
 * RT Record (not-in-use)
 * @see https://tools.ietf.org/html/rfc1183
 */

class RTRecord extends RecordData {
  constructor() {
    super();
    this.preference = 0;
    this.host = '.';
  }

  get type() {
    return types.RT;
  }

  canonical() {
    this.host = this.host.toLowerCase();
    return this;
  }

  getSize(map) {
    return 2 + sizeName(this.host, map);
  }

  write(bw, map) {
    bw.writeU16BE(this.preference);
    writeNameBW(bw, this.host, map);
    return this;
  }

  read(br) {
    this.preference = br.readU16BE();
    this.host = readNameBR(br);
    return this;
  }
}

/**
 * NSAP Record
 * Network Service Access Point Record (not-in-use)
 * @see https://tools.ietf.org/html/rfc1706
 */

class NSAPRecord extends RecordData {
  constructor() {
    super();
    this.nsap = DUMMY;
  }

  get type() {
    return types.NSAP;
  }

  getSize() {
    return this.nsap.length;
  }

  write(bw) {
    bw.writeBytes(this.nsap);
    return this;
  }

  read(br) {
    this.nsap = br.readBytes(br.left());
    return this;
  }
}

/**
 * NSAPPTR Record
 * Network Service Access Point PTR Record (not-in-use)
 * @see https://tools.ietf.org/html/rfc1348
 */

class NSAPPTRRecord extends PTRRecord {
  constructor() {
    super();
  }

  get type() {
    return types.NSAPPTR;
  }
}

/**
 * SIG Record
 * Signature Record (obsolete)
 * @see https://tools.ietf.org/html/rfc2065
 * @see https://tools.ietf.org/html/rfc3755
 */

class SIGRecord extends RecordData {
  constructor() {
    super();
    this.typeCovered = 0;
    this.algorithm = 0;
    this.labels = 0;
    this.origTTL = 0;
    this.expiration = 0;
    this.inception = 0;
    this.keyTag = 0;
    this.signerName = '.';
    this.signature = DUMMY;
  }

  get type() {
    return types.SIG;
  }

  canonical() {
    this.signerName = this.signerName.toLowerCase();
    return this;
  }

  getSize(map) {
    let size = 0;
    size += 18;
    size += sizeName(this.signerName, map);
    size += this.signature.length;
    return size;
  }

  write(bw, map) {
    bw.writeU16BE(this.typeCovered);
    bw.writeU8(this.algorithm);
    bw.writeU8(this.labels);
    bw.writeU32BE(this.origTTL);
    bw.writeU32BE(this.expiration);
    bw.writeU32BE(this.inception);
    bw.writeU16BE(this.keyTag);
    writeNameBW(bw, this.signerName, map);
    bw.writeBytes(this.signature);
    return this;
  }

  read(br) {
    this.typeCovered = br.readU16BE();
    this.algorithm = br.readU8();
    this.labels = br.readU8();
    this.origTTL = br.readU32BE();
    this.expiration = br.readU32BE();
    this.inception = br.readU32BE();
    this.keyTag = br.readU16BE();
    this.signerName = readNameBR(br);
    this.signature = br.readBytes(br.left());
    return this;
  }

  toTBS() {
    const signerName = this.signerName;
    const signature = this.signature;

    this.signerName = signerName.toLowerCase();
    this.signature = DUMMY;

    let raw = null;

    try {
      raw = this.encode();
    } finally {
      this.signerName = signerName;
      this.signature = signature;
    }

    return raw;
  }

  validityPeriod(t) {
    if (t == null)
      t = util.now();

    assert(Number.isSafeInteger(t) && t >= 0);

    return t >= this.inception && t <= this.expiration;
  }

  getJSON() {
    const json = super.getJSON();
    json.algName = algToString(this.algorithm);
    return json;
  }

  toString() {
    const algName = algToString(this.algorithm);

    let str = super.toString();

    // Mimic `delv`.
    str += ' ';
    str += ` ; alg = ${algName}`;

    return str;
  }
}

/**
 * KEY Record
 * Key Record (obsolete)
 * @see https://tools.ietf.org/html/rfc2065
 * @see https://tools.ietf.org/html/rfc3755
 */

class KEYRecord extends RecordData {
  constructor() {
    super();
    this.flags = 0;
    this.protocol = 0;
    this.algorithm = 0;
    this.publicKey = DUMMY;
  }

  get type() {
    return types.KEY;
  }

  getSize() {
    return 4 + this.publicKey.length;
  }

  write(bw) {
    bw.writeU16BE(this.flags);
    bw.writeU8(this.protocol);
    bw.writeU8(this.algorithm);
    bw.writeBytes(this.publicKey);
    return this;
  }

  read(br) {
    this.flags = br.readU16BE();
    this.protocol = br.readU8();
    this.algorithm = br.readU8();
    this.publicKey = br.readBytes(br.left());
    return this;
  }

  keyTag(raw) {
    if (this.algorithm === algs.RSAMD5) {
      const key = this.publicKey;

      if (key.length < 2)
        return 0;

      return bio.readU16BE(key, key.length - 2);
    }

    if (!raw)
      raw = this.encode();

    let tag = 0;

    for (let i = 0; i < raw.length; i++) {
      const ch = raw[i];

      if (i & 1)
        tag += ch;
      else
        tag += ch << 8;

      tag |= 0;
    }

    tag += (tag >>> 16) & 0xffff;
    tag &= 0xffff;

    return tag;
  }

  revTag(raw) {
    if (!(this.flags & keyFlags.REVOKE))
      return this.keyTag(raw);

    this.flags &= ~keyFlags.REVOKE;

    try {
      return this.keyTag(raw);
    } finally {
      this.flags |= keyFlags.REVOKE;
    }
  }

  getJSON() {
    let type = 'ZSK';

    if (this.flags & keyFlags.SEP)
      type = 'KSK';

    const json = super.getJSON();

    json.keyType = type;
    json.keyTag = this.keyTag();
    json.algName = algToString(this.algorithm);

    if (isRSA(this.algorithm))
      json.bits = rsaBits(this.publicKey);

    return json;
  }

  toString() {
    let type = 'ZSK';

    if (this.flags & keyFlags.SEP)
      type = 'KSK';

    const algName = algToString(this.algorithm);
    const keyTag = this.keyTag();

    let str = super.toString();

    // Mimic `delv`.
    str += ' ';
    str += ` ; ${type}`;
    str += ` ; alg = ${algName}`;

    if (isRSA(this.algorithm)) {
      const [n, e] = rsaBits(this.publicKey);
      str += ` ; bits = ${n},${e}`;
    }

    str += ` ; key id = ${keyTag}`;

    return str;
  }
}

/**
 * PX Record
 * Pointer to X400 Mapping Information Record (not-in-use)
 * @see https://tools.ietf.org/html/rfc2163
 */

class PXRecord extends RecordData {
  constructor() {
    super();
    this.preference = 0;
    this.map822 = '.';
    this.mapx400 = '.';
  }

  get type() {
    return types.PX;
  }

  canonical() {
    this.map822 = this.map822.toLowerCase();
    this.mapx400 = this.mapx400.toLowerCase();
    return this;
  }

  getSize(map) {
    let size = 0;
    size += 2;
    size += sizeName(this.map822, map);
    size += sizeName(this.mapx400, map);
    return size;
  }

  write(bw, map) {
    bw.writeU16BE(this.preference);
    writeNameBW(bw, this.map822, map);
    writeNameBW(bw, this.mapx400, map);
    return this;
  }

  read(br) {
    this.preference = br.readU16BE();
    this.map822 = readNameBR(br);
    this.mapx400 = readNameBR(br);
    return this;
  }
}

/**
 * GPOS Record
 * Geographical Position Record (deprecated)
 * @see https://tools.ietf.org/html/rfc1712
 */

class GPOSRecord extends RecordData {
  constructor() {
    super();
    this.longitude = '';
    this.latitude = '';
    this.altitude = '';
  }

  get type() {
    return types.GPOS;
  }

  getSize() {
    let size = 0;
    size += sizeString(this.longitude);
    size += sizeString(this.latitude);
    size += sizeString(this.altitude);
    return size;
  }

  write(bw) {
    writeStringBW(bw, this.longitude);
    writeStringBW(bw, this.latitude);
    writeStringBW(bw, this.altitude);
    return this;
  }

  read(br) {
    this.longitude = readStringBR(br, true);
    this.latitude = readStringBR(br, true);
    this.altitude = readStringBR(br, true);
    return this;
  }
}

/**
 * AAAA Record
 * IPv6 Address Record
 * @see https://tools.ietf.org/html/rfc3596
 */

class AAAARecord extends RecordData {
  constructor() {
    super();
    this.address = '::';
  }

  get type() {
    return types.AAAA;
  }

  getSize() {
    return 16;
  }

  write(bw) {
    writeIP(bw, this.address, 16);
    return this;
  }

  read(br) {
    this.address = readIP(br, 16);
    return this;
  }
}

/**
 * LOC Record
 * Location Record
 * @see https://tools.ietf.org/html/rfc1876
 */

class LOCRecord extends RecordData {
  constructor() {
    super();
    this.version = 0;
    this.size = 0;
    this.horizPre = 0;
    this.vertPre = 0;
    this.latitude = 0;
    this.longitude = 0;
    this.altitude = 0;
  }

  get type() {
    return types.LOC;
  }

  getSize() {
    return 16;
  }

  write(bw) {
    bw.writeU8(this.version);
    bw.writeU8(this.size);
    bw.writeU8(this.horizPre);
    bw.writeU8(this.vertPre);
    bw.writeU32BE(this.latitude);
    bw.writeU32BE(this.longitude);
    bw.writeU32BE(this.altitude);
    return this;
  }

  read(br) {
    this.version = br.readU8();
    this.size = br.readU8();
    this.horizPre = br.readU8();
    this.vertPre = br.readU8();
    this.latitude = br.readU32BE();
    this.longitude = br.readU32BE();
    this.altitude = br.readU32BE();
    return this;
  }
}

/**
 * NXT Record
 * Next Domain Record (obsolete)
 * @see https://tools.ietf.org/html/rfc2065#section-5.2
 * @see https://tools.ietf.org/html/rfc2535#section-5.1
 * @see https://tools.ietf.org/html/rfc3755
 */

class NXTRecord extends RecordData {
  constructor() {
    super();
    this.nextDomain = '.';
    this.typeBitmap = DUMMY;
  }

  get type() {
    return types.NXT;
  }

  canonical() {
    this.nextDomain = this.nextDomain.toLowerCase();
    return this;
  }

  setTypes(types) {
    this.typeBitmap = toBitmap(types);
    return this;
  }

  getTypes() {
    return fromBitmap(this.typeBitmap);
  }

  hasType(type) {
    return hasType(this.typeBitmap, type);
  }

  getSize(map) {
    let size = 0;
    size += sizeName(this.nextDomain, map);
    size += this.typeBitmap.length;
    return size;
  }

  write(bw, map) {
    writeNameBW(bw, this.nextDomain, map);
    bw.writeBytes(this.typeBitmap);
    return this;
  }

  read(br) {
    this.nextDomain = readNameBR(br);
    this.typeBitmap = br.readBytes(br.left());
    return this;
  }
}

/**
 * EID Record
 * Endpoint Identifier Record (not-in-use)
 * @see http://ana-3.lcs.mit.edu/~jnc/nimrod/dns.txt
 */

class EIDRecord extends RecordData {
  constructor() {
    super();
    this.endpoint = DUMMY;
  }

  get type() {
    return types.EID;
  }

  getSize() {
    return this.endpoint.length;
  }

  write(bw) {
    bw.writeBytes(this.endpoint);
    return this;
  }

  read(br) {
    this.endpoint = br.readBytes(br.left());
    return this;
  }
}

/**
 * NIMLOC Record
 * Nimrod Locator Record (not-in-use)
 * @see http://ana-3.lcs.mit.edu/~jnc/nimrod/dns.txt
 */

class NIMLOCRecord extends RecordData {
  constructor() {
    super();
    this.locator = DUMMY;
  }

  get type() {
    return types.NIMLOC;
  }

  getSize() {
    return this.locator.length;
  }

  write(bw) {
    bw.writeBytes(this.locator);
    return this;
  }

  read(br) {
    this.locator = br.readBytes(br.left());
    return this;
  }
}

/**
 * SRV Record
 * Service Locator Record
 * @see https://tools.ietf.org/html/rfc2782
 */

class SRVRecord extends RecordData {
  constructor() {
    super();
    this.priority = 0;
    this.weight = 0;
    this.port = 0;
    this.target = '.';
  }

  get type() {
    return types.SRV;
  }

  canonical() {
    this.target = this.target.toLowerCase();
    return this;
  }

  getSize(map) {
    return 6 + sizeName(this.target, map);
  }

  write(bw, map) {
    bw.writeU16BE(this.priority);
    bw.writeU16BE(this.weight);
    bw.writeU16BE(this.port);
    writeNameBW(bw, this.target, map);
    return this;
  }

  read(br) {
    this.priority = br.readU16BE();
    this.weight = br.readU16BE();
    this.port = br.readU16BE();
    this.target = readNameBR(br);
    return this;
  }
}

/**
 * ATMA Record
 * Asynchronous Transfer Mode Record (not-in-use)
 * @see http://www.broadband-forum.org/ftp/pub/approved-specs/af-dans-0152.000.pdf
 */

class ATMARecord extends RecordData {
  constructor() {
    super();
    this.format = 0;
    this.address = DUMMY;
  }

  get type() {
    return types.ATMA;
  }

  getSize() {
    return 1 + this.address.length;
  }

  write(bw) {
    bw.writeU8(this.format);
    bw.writeBytes(this.address);
    return this;
  }

  read(br) {
    this.format = br.readU8();
    this.address = br.readBytes(br.left());
    return this;
  }
}

/**
 * NAPTR Record
 * Naming Authority Pointer Record
 * @see https://tools.ietf.org/html/rfc3403
 */

class NAPTRRecord extends RecordData {
  constructor() {
    super();
    this.order = 0;
    this.preference = 0;
    this.flags = '';
    this.service = '';
    this.regexp = '';
    this.replacement = '.';
  }

  get type() {
    return types.NAPTR;
  }

  canonical() {
    this.replacement = this.replacement.toLowerCase();
    return this;
  }

  getSize(map) {
    let size = 0;
    size += 4;
    size += sizeString(this.flags);
    size += sizeString(this.service);
    size += sizeString(this.regexp);
    size += sizeName(this.replacement, map);
    return size;
  }

  write(bw, map) {
    bw.writeU16BE(this.order);
    bw.writeU16BE(this.preference);
    writeStringBW(bw, this.flags);
    writeStringBW(bw, this.service);
    writeStringBW(bw, this.regexp);
    writeNameBW(bw, this.replacement, map);
    return this;
  }

  read(br) {
    this.order = br.readU16BE();
    this.preference = br.readU16BE();
    this.flags = readStringBR(br);
    this.service = readStringBR(br);
    this.regexp = readStringBR(br);
    this.replacement = readNameBR(br);
    return this;
  }
}

/**
 * KX Record
 * Key Exchanger Record
 * @see https://tools.ietf.org/html/rfc2230
 */

class KXRecord extends RecordData {
  constructor() {
    super();
    this.preference = 0;
    this.exchanger = '.';
  }

  get type() {
    return types.KX;
  }

  canonical() {
    this.exchanger = this.exchanger.toLowerCase();
    return this;
  }

  getSize(map) {
    return 2 + sizeName(this.exchanger, map);
  }

  write(bw, map) {
    bw.writeU16BE(this.preference);
    writeNameBW(bw, this.exchanger, map);
    return this;
  }

  read(br) {
    this.preference = br.readU16BE();
    this.exchanger = readNameBR(br);
    return this;
  }
}

/**
 * CERT Record
 * Certificate Record
 * @see https://tools.ietf.org/html/rfc4398
 */

class CERTRecord extends RecordData {
  constructor() {
    super();
    this.certType = 0;
    this.keyTag = 0;
    this.algorithm = 0;
    this.certificate = DUMMY;
  }

  get type() {
    return types.CERT;
  }

  getSize() {
    return 5 + this.certificate.length;
  }

  write(bw) {
    bw.writeU16BE(this.certType);
    bw.writeU16BE(this.keyTag);
    bw.writeU8(this.algorithm);
    bw.writeBytes(this.certificate);
    return this;
  }

  read(br) {
    this.certType = br.readU16BE();
    this.keyTag = br.readU16BE();
    this.algorithm = br.readU8();
    this.certificate = br.readBytes(br.left());
    return this;
  }

  getJSON() {
    const typeName = certTypesByVal[this.certType];
    const json = super.getJSON();

    if (typeName)
      json.typeName = typeName;

    json.algName = algToString(this.algorithm);

    return json;
  }

  toString() {
    const typeName = certTypesByVal[this.certType];
    const algName = algToString(this.algorithm);

    let str = super.toString();

    str += ' ';

    if (typeName)
      str += ` ; cert type = ${typeName}`;

    str += ` ; alg = ${algName}`;

    return str;
  }
}

/**
 * A6Record
 * A IPv6 Record (historic)
 * @see https://tools.ietf.org/html/rfc2874#section-3.1.1
 * @see https://tools.ietf.org/html/rfc6563
 */

class A6Record extends RecordData {
  constructor() {
    super();
    this.prefixLen = 0;
    this.address = '::';
    this.prefix = '.';
  }

  get type() {
    return types.A6;
  }

  canonical() {
    this.prefix = this.prefix.toLowerCase();
    return this;
  }

  getSize(map) {
    const len = this.prefixLen;
    assert(len <= 128);

    let size = 0;

    size += 1;
    size += (128 - len + 7) / 8 | 0;

    if (len > 0)
      size += sizeName(this.prefix, map);

    return size;
  }

  write(bw, map) {
    const len = this.prefixLen;
    assert(len <= 128);

    bw.writeU8(len);

    const size = (128 - len + 7) / 8 | 0;
    const ip = IP.toBuffer(this.address);

    bw.copy(ip, 16 - size, 16);

    if (len > 0)
      writeNameBW(bw, this.prefix, map);

    return this;
  }

  read(br) {
    const len = Math.min(128, br.readU8());
    const size = (128 - len + 7) / 8 | 0;
    const buf = br.readBytes(size, true);
    const ip = POOL16;

    ip.fill(0x00, 0, 16 - size);
    ip.copy(buf, 16 - size);

    this.prefixLen = len;
    this.address = IP.toString(ip);

    if (len > 0)
      this.prefix = readNameBR(br);

    return this;
  }
}

/**
 * DNAME Record
 * Delegation Name Record
 * @see https://tools.ietf.org/html/rfc6672
 */

class DNAMERecord extends CNAMERecord {
  constructor() {
    super();
  }

  get type() {
    return types.DNAME;
  }
}

/**
 * OPT Record
 * Option Record (EDNS) (pseudo-record)
 * @see https://tools.ietf.org/html/rfc6891#section-6.1
 */

class OPTRecord extends RecordData {
  constructor() {
    super();
    this.options = [];
  }

  get type() {
    return types.OPT;
  }

  canonical() {
    // Note: not mentioned in RFC 4034.
    for (const opt of this.options)
      opt.canonical();
    return this;
  }

  getSize(map) {
    let size = 0;
    for (const opt of this.options)
      size += opt.getSize(map);
    return size;
  }

  write(bw, map) {
    for (const opt of this.options)
      opt.write(bw, map);
    return this;
  }

  read(br) {
    while (br.left())
      this.options.push(Option.read(br));
    return this;
  }

  toString() {
    return '';
  }

  fromString(str) {
    return this;
  }

  getJSON() {
    return {
      options: this.options.map(opt => opt.toJSON())
    };
  }

  fromJSON(json) {
    assert(json && typeof json === 'object');
    assert(Array.isArray(json.options));

    for (const opt of json.options)
      this.options.push(Option.fromJSON(opt));

    return this;
  }
}

/**
 * APL Record
 * Address Prefix List Record (not-in-use)
 * @see https://tools.ietf.org/html/rfc3123
 */

class APLRecord extends RecordData {
  constructor() {
    super();
    this.items = [];
  }

  get type() {
    return types.APL;
  }

  getSize() {
    let size = 0;

    for (const ap of this.items)
      size += ap.getSize();

    return size;
  }

  write(bw) {
    for (const ap of this.items)
      ap.write(bw);

    return this;
  }

  read(br) {
    while (br.left())
      this.items.push(AP.read(br));

    return this;
  }
}

/**
 * DS Record
 * Delegation Signer
 * @see https://tools.ietf.org/html/rfc4034
 */

class DSRecord extends RecordData {
  constructor() {
    super();
    this.keyTag = 0;
    this.algorithm = 0;
    this.digestType = 0;
    this.digest = DUMMY;
  }

  get type() {
    return types.DS;
  }

  getSize() {
    return 4 + this.digest.length;
  }

  write(bw) {
    bw.writeU16BE(this.keyTag);
    bw.writeU8(this.algorithm);
    bw.writeU8(this.digestType);
    bw.writeBytes(this.digest);
    return this;
  }

  read(br) {
    this.keyTag = br.readU16BE();
    this.algorithm = br.readU8();
    this.digestType = br.readU8();
    this.digest = br.readBytes(br.left());
    return this;
  }

  getJSON() {
    const json = super.getJSON();
    json.algName = algToString(this.algorithm);
    json.hashName = hashToString(this.digestType);
    return json;
  }

  toString() {
    const algName = algToString(this.algorithm);
    const hashName = hashToString(this.digestType);

    let str = super.toString();

    // Mimic `delv`.
    str += ' ';
    str += ` ; alg = ${algName}`;
    str += ` ; hash = ${hashName}`;

    return str;
  }
}

/**
 * SSHFP Record
 * SSH Finger Print Record
 * @see https://tools.ietf.org/html/rfc4255
 */

class SSHFPRecord extends RecordData {
  constructor() {
    super();
    this.algorithm = 0;
    this.digestType = 0;
    this.fingerprint = DUMMY;
  }

  get type() {
    return types.SSHFP;
  }

  getSize() {
    return 2 + this.fingerprint.length;
  }

  write(bw) {
    bw.writeU8(this.algorithm);
    bw.writeU8(this.digestType);
    bw.writeBytes(this.fingerprint);
    return this;
  }

  read(br) {
    this.algorithm = br.readU8();
    this.digestType = br.readU8();
    this.fingerprint = br.readBytes(br.left());
    return this;
  }

  getJSON() {
    const algName = sshAlgsByVal[this.algorithm];
    const hashName = sshHashesByVal[this.digestType];
    const json = super.getJSON();

    if (algName)
      json.algName = algName;

    if (hashName)
      json.hashName = hashName;

    return json;
  }

  toString() {
    const algName = sshAlgsByVal[this.algorithm];
    const hashName = sshHashesByVal[this.digestType];

    let str = super.toString();

    str += ' ';

    if (algName)
      str += ` ; alg = ${algName}`;

    if (hashName)
      str += ` ; hash = ${hashName}`;

    return str;
  }
}

/**
 * IPSECKEY Record
 * IPsec Key Record
 * @see https://tools.ietf.org/html/rfc4025
 */

class IPSECKEYRecord extends RecordData {
  constructor() {
    super();
    this.precedence = 0;
    this.gatewayType = 1;
    this.algorithm = 0;
    this.target = '0.0.0.0';
    this.publicKey = DUMMY;
  }

  get type() {
    return types.IPSECKEY;
  }

  canonical() {
    // Note: not mentioned in RFC 4034.
    if (this.gatewayType === 3)
      this.target = this.target.toLowerCase();
    return this;
  }

  getSize(map) {
    let size = 3;

    switch (this.gatewayType) {
      case 1:
        size += 4;
        break;
      case 2:
        size += 16;
        break;
      case 3:
        size += sizeName(this.target, map);
        break;
    }

    size += this.publicKey.length;

    return size;
  }

  write(bw, map) {
    bw.writeU8(this.precedence);
    bw.writeU8(this.gatewayType);
    bw.writeU8(this.algorithm);

    switch (this.gatewayType) {
      case 1: {
        writeIP(bw, this.target, 4);
        break;
      }
      case 2: {
        writeIP(bw, this.target, 16);
        break;
      }
      case 3:
        writeNameBW(bw, this.target, map);
        break;
    }

    bw.writeBytes(this.publicKey);

    return this;
  }

  read(br) {
    this.precedence = br.readU8();
    this.gatewayType = br.readU8();
    this.algorithm = br.readU8();

    switch (this.gatewayType) {
      case 1:
        this.target = readIP(br, 4);
        break;
      case 2:
        this.target = readIP(br, 16);
        break;
      case 3:
        this.target = readNameBR(br);
        break;
    }

    this.publicKey = br.readBytes(br.left());

    return this;
  }
}

/**
 * RRSIG Record
 * DNSSEC Signature Record
 * @see https://tools.ietf.org/html/rfc4034
 */

class RRSIGRecord extends SIGRecord {
  constructor() {
    super();
  }

  get type() {
    return types.RRSIG;
  }
}

/**
 * NSEC Record
 * Next Secure Record
 * @see https://tools.ietf.org/html/rfc4034
 */

class NSECRecord extends RecordData {
  constructor() {
    super();
    this.nextDomain = '.';
    this.typeBitmap = DUMMY;
  }

  get type() {
    return types.NSEC;
  }

  canonical() {
    this.nextDomain = this.nextDomain.toLowerCase();
    return this;
  }

  setTypes(types) {
    this.typeBitmap = toBitmap(types);
    return this;
  }

  getTypes() {
    return fromBitmap(this.typeBitmap);
  }

  hasType(type) {
    return hasType(this.typeBitmap, type);
  }

  getSize() {
    let size = 0;
    size += sizeName(this.nextDomain, null, false);
    size += this.typeBitmap.length;
    return size;
  }

  write(bw) {
    writeNameBW(bw, this.nextDomain, null, false);
    bw.writeBytes(this.typeBitmap);
    return this;
  }

  read(br) {
    this.nextDomain = readNameBR(br);
    this.typeBitmap = br.readBytes(br.left());
    return this;
  }
}

/**
 * DNSKEY Record
 * DNS Key Record
 * @see https://tools.ietf.org/html/rfc4034
 */

class DNSKEYRecord extends KEYRecord {
  constructor() {
    super();
  }

  get type() {
    return types.DNSKEY;
  }
}

/**
 * DHCID Record
 * DHCP Identifier Record
 * @see https://tools.ietf.org/html/rfc4701
 */

class DHCIDRecord extends RecordData {
  constructor() {
    super();
    this.digest = DUMMY;
  }

  get type() {
    return types.DHCID;
  }

  getSize() {
    return this.digest.length;
  }

  write(bw) {
    bw.writeBytes(this.digest);
    return this;
  }

  read(br) {
    this.digest = br.readBytes(br.left());
    return this;
  }
}

/**
 * NSEC3Record
 * Next Secure Record (v3)
 * @see https://tools.ietf.org/html/rfc5155
 */

class NSEC3Record extends RecordData {
  constructor() {
    super();
    this.hash = 0;
    this.flags = 0;
    this.iterations = 0;
    this.salt = DUMMY;
    this.nextDomain = DUMMY;
    this.typeBitmap = DUMMY;
  }

  get type() {
    return types.NSEC3;
  }

  setTypes(types) {
    this.typeBitmap = toBitmap(types);
    return this;
  }

  getTypes() {
    return fromBitmap(this.typeBitmap);
  }

  hasType(type) {
    return hasType(this.typeBitmap, type);
  }

  getSize() {
    let size = 0;
    size += 6;
    size += this.salt.length;
    size += this.nextDomain.length;
    size += this.typeBitmap.length;
    return size;
  }

  write(bw) {
    bw.writeU8(this.hash);
    bw.writeU8(this.flags);
    bw.writeU16BE(this.iterations);
    bw.writeU8(this.salt.length);
    bw.writeBytes(this.salt);
    bw.writeU8(this.nextDomain.length);
    bw.writeBytes(this.nextDomain);
    bw.writeBytes(this.typeBitmap);
    return this;
  }

  read(br) {
    this.hash = br.readU8();
    this.flags = br.readU8();
    this.iterations = br.readU16BE();
    this.salt = br.readBytes(br.readU8());
    this.nextDomain = br.readBytes(br.readU8());
    this.typeBitmap = br.readBytes(br.left());
    return this;
  }

  getJSON() {
    const hashName = nsecHashesByVal[this.hash];
    const json = super.getJSON();

    if (hashName)
      json.hashName = hashName;

    return json;
  }

  toString() {
    const hashName = nsecHashesByVal[this.hash];

    let str = super.toString();

    str += ' ';

    if (hashName)
      str += ` ; hash = ${hashName}`;

    return str;
  }
}

/**
 * NSEC3PARAM Record
 * NSEC3 Params Record
 * @see https://tools.ietf.org/html/rfc5155
 */

class NSEC3PARAMRecord extends RecordData {
  constructor() {
    super();
    this.hash = 0;
    this.flags = 0;
    this.iterations = 0;
    this.salt = DUMMY;
  }

  get type() {
    return types.NSEC3PARAM;
  }

  getSize() {
    return 5 + this.salt.length;
  }

  write(bw) {
    bw.writeU8(this.hash);
    bw.writeU8(this.flags);
    bw.writeU16BE(this.iterations);
    bw.writeU8(this.salt.length);
    bw.writeBytes(this.salt);
    return this;
  }

  read(br) {
    this.hash = br.readU8();
    this.flags = br.readU8();
    this.iterations = br.readU16BE();
    this.salt = br.readBytes(br.readU8());
    return this;
  }

  getJSON() {
    const hashName = nsecHashesByVal[this.hash];
    const json = super.getJSON();

    if (hashName)
      json.hashName = hashName;

    return json;
  }

  toString() {
    const hashName = nsecHashesByVal[this.hash];

    let str = super.toString();

    str += ' ';

    if (hashName)
      str += ` ; hash = ${hashName}`;

    return str;
  }
}

/**
 * TLSA Record
 * TLSA Certificate Association Record
 * @see https://tools.ietf.org/html/rfc6698
 */

class TLSARecord extends RecordData {
  constructor() {
    super();
    this.usage = 0;
    this.selector = 0;
    this.matchingType = 0;
    this.certificate = DUMMY;
  }

  get type() {
    return types.TLSA;
  }

  getSize() {
    return 3 + this.certificate.length;
  }

  write(bw) {
    bw.writeU8(this.usage);
    bw.writeU8(this.selector);
    bw.writeU8(this.matchingType);
    bw.writeBytes(this.certificate);
    return this;
  }

  read(br) {
    this.usage = br.readU8();
    this.selector = br.readU8();
    this.matchingType = br.readU8();
    this.certificate = br.readBytes(br.left());
    return this;
  }

  getJSON() {
    const usageName = usagesByVal[this.usage];
    const selectorName = selectorsByVal[this.selector];
    const matchingTypeName = matchingTypesByVal[this.matchingType];
    const json = super.getJSON();

    if (usageName)
      json.usageName = usageName;

    if (selectorName)
      json.selectorName = selectorName;

    if (matchingTypeName)
      json.matchingTypeName = matchingTypeName;

    return json;
  }

  toString() {
    const usageName = usagesByVal[this.usage];
    const selectorName = selectorsByVal[this.selector];
    const matchingTypeName = matchingTypesByVal[this.matchingType];

    let str = super.toString();

    str += ' ';

    if (usageName)
      str += ` ; usage = ${usageName}`;

    if (selectorName)
      str += ` ; selector = ${selectorName}`;

    if (matchingTypeName)
      str += ` ; matching type = ${matchingTypeName}`;

    return str;
  }
}

/**
 * SMIMEA Record
 * S/MIME Certificate Association Record
 * @see https://tools.ietf.org/html/rfc8162
 */

class SMIMEARecord extends TLSARecord {
  constructor() {
    super();
  }

  get type() {
    return types.SMIMEA;
  }
}

/**
 * HIP Record
 * Host Identity Protocol Record
 * @see https://tools.ietf.org/html/rfc8005
 */

class HIPRecord extends RecordData {
  constructor() {
    super();
    this.algorithm = 0;
    this.hit = DUMMY;
    this.publicKey = DUMMY;
    this.servers = [];
  }

  get type() {
    return types.HIP;
  }

  canonical() {
    // Note: not mentioned in RFC 4034.
    for (let i = 0; i < this.servers.length; i++)
      this.servers[i] = this.servers[i].toLowerCase();

    return this;
  }

  getSize(map) {
    let size = 4;
    size += this.hit.length;
    size += this.publicKey.length;
    for (const name of this.servers)
      size += sizeName(name, map);
    return size;
  }

  write(bw, map) {
    bw.writeU8(this.hit.length);
    bw.writeU8(this.algorithm);
    bw.writeU16BE(this.publicKey.length);
    bw.writeBytes(this.hit);
    bw.writeBytes(this.publicKey);
    for (const name of this.servers)
      writeNameBW(bw, name, map);
    return this;
  }

  read(br) {
    const hitLen = br.readU8();

    this.algorithm = br.readU8();

    const keyLen = br.readU16BE();

    this.hit = br.readBytes(hitLen);
    this.publicKey = br.readBytes(keyLen);

    while (br.left())
      this.servers.push(readNameBR(br));

    return this;
  }
}

/**
 * NINFO Record
 * Zone Status Information (proposed)
 * @see https://www.iana.org/assignments/dns-parameters/NINFO/ninfo-completed-template
 * @see https://tools.ietf.org/html/draft-reid-dnsext-zs-01
 */

class NINFORecord extends RecordData {
  constructor() {
    super();
    this.zsData = [];
  }

  get type() {
    return types.NINFO;
  }

  getSize() {
    let size = 0;
    for (const zs of this.zsData)
      size += sizeString(zs);
    return size;
  }

  write(bw) {
    for (const zs of this.zsData)
      writeStringBW(bw, zs);
    return this;
  }

  read(br) {
    while (br.left())
      this.zsData.push(readStringBR(br));
    return this;
  }
}

/**
 * RKEY Record
 * R Key Record (proposed)
 * @see https://www.iana.org/assignments/dns-parameters/RKEY/rkey-completed-template
 * @see https://tools.ietf.org/html/draft-reid-dnsext-rkey-00
 */

class RKEYRecord extends KEYRecord {
  constructor() {
    super();
  }

  get type() {
    return types.RKEY;
  }
}

/**
 * TALINK Record
 * Trust Authorities Link Record (proposed)
 * @see https://www.iana.org/assignments/dns-parameters/TALINK/talink-completed-template
 * @see https://tools.ietf.org/html/draft-wijngaards-dnsop-trust-history-02
 */

class TALINKRecord extends RecordData {
  constructor() {
    super();
    this.prevName = '.';
    this.nextName = '.';
  }

  get type() {
    return types.TALINK;
  }

  canonical() {
    // Note: not mentioned in RFC 4034.
    this.prevName = this.prevName.toLowerCase();
    this.nextName = this.nextName.toLowerCase();
    return this;
  }

  getSize(map) {
    let size = 0;
    size += sizeName(this.prevName, map);
    size += sizeName(this.nextName, map);
    return size;
  }

  write(bw, map) {
    writeNameBW(bw, this.prevName, map);
    writeNameBW(bw, this.nextName, map);
    return this;
  }

  read(br) {
    this.prevName = readNameBR(br);
    this.nextName = readNameBR(br);
    return this;
  }
}

/**
 * CDS Record
 * Child DS Record
 * @see https://tools.ietf.org/html/rfc7344
 */

class CDSRecord extends DSRecord {
  constructor() {
    super();
  }

  get type() {
    return types.CDS;
  }
}

/**
 * CDNSKEY Record
 * Child DNSKEY Record
 * @see https://tools.ietf.org/html/rfc7344
 */

class CDNSKEYRecord extends KEYRecord {
  constructor() {
    super();
  }

  get type() {
    return types.CDNSKEY;
  }
}

/**
 * OPENPGPKEY Record
 * OpenPGP Public Key Record
 * @see https://tools.ietf.org/html/rfc7929
 */

class OPENPGPKEYRecord extends RecordData {
  constructor() {
    super();
    this.publicKey = DUMMY;
  }

  get type() {
    return types.OPENPGPKEY;
  }

  getSize() {
    return this.publicKey.length;
  }

  write(bw) {
    bw.writeBytes(this.publicKey);
    return this;
  }

  read(br) {
    this.publicKey = br.readBytes(br.left());
    return this;
  }
}

/**
 * CSYNC Record
 * Child Synchronization Record
 * @see https://tools.ietf.org/html/rfc7477
 */

class CSYNCRecord extends RecordData {
  constructor() {
    super();
    this.serial = 0;
    this.flags = 0;
    this.typeBitmap = DUMMY;
  }

  get type() {
    return types.CSYNC;
  }

  setTypes(types) {
    this.typeBitmap = toBitmap(types);
    return this;
  }

  getTypes() {
    return fromBitmap(this.typeBitmap);
  }

  hasType(type) {
    return hasType(this.typeBitmap, type);
  }

  getSize() {
    return 6 + this.typeBitmap.length;
  }

  write(bw) {
    bw.writeU32BE(this.serial);
    bw.writeU16BE(this.flags);
    bw.writeBytes(this.typeBitmap);
    return this;
  }

  read(br) {
    this.serial = br.readU32BE();
    this.flags = br.readU16BE();
    this.typeBitmap = br.readBytes(br.left());
    return this;
  }
}

/**
 * SPF Record
 * Sender Policy Framework Record (obsolete)
 * @see https://tools.ietf.org/html/rfc4408
 * @see https://tools.ietf.org/html/rfc7208
 */

class SPFRecord extends TXTRecord {
  constructor() {
    super();
  }

  get type() {
    return types.SPF;
  }
}

/**
 * UINFO Record
 * UINFO Record (obsolete)
 * (No Documentation)
 */

class UINFORecord extends RecordData {
  constructor() {
    super();
    this.uinfo = '';
  }

  get type() {
    return types.UINFO;
  }

  getSize() {
    return sizeString(this.uinfo);
  }

  write(bw) {
    writeStringBW(bw, this.uinfo);
    return this;
  }

  read(br) {
    this.uinfo = readStringBR(br);
    return this;
  }
}

/**
 * UID Record
 * UID Record (obsolete)
 * (No Documentation)
 */

class UIDRecord extends RecordData {
  constructor() {
    super();
    this.uid = 0;
  }

  get type() {
    return types.UID;
  }

  getSize() {
    return 4;
  }

  write(bw) {
    bw.writeU32BE(this.uid);
    return this;
  }

  read(br) {
    this.uid = br.readU32BE();
    return this;
  }
}

/**
 * GID Record
 * GID Record (obsolete)
 * (No Documentation)
 */

class GIDRecord extends RecordData {
  constructor() {
    super();
    this.gid = 0;
  }

  get type() {
    return types.GID;
  }

  getSize() {
    return 4;
  }

  write(bw) {
    bw.writeU32BE(this.gid);
    return this;
  }

  read(br) {
    this.gid = br.readU32BE();
    return this;
  }
}

/**
 * UNSPEC Record
 * UNSPEC Record (obsolete)
 * (No Documentation)
 */

class UNSPECRecord extends UNKNOWNRecord {
  constructor() {
    super();
  }

  get type() {
    return types.UNSPEC;
  }
}

/**
 * NID Record
 * Node Identifier Record
 * @see https://tools.ietf.org/html/rfc6742
 */

class NIDRecord extends RecordData {
  constructor() {
    super();
    this.preference = 0;
    this.nodeID = DUMMY8;
  }

  get type() {
    return types.NID;
  }

  getSize() {
    return 10;
  }

  write(bw) {
    bw.writeU16BE(this.preference);
    bw.writeBytes(this.nodeID);
    return this;
  }

  read(br) {
    this.preference = br.readU16BE();
    this.nodeID = br.readBytes(8);
    return this;
  }
}

/**
 * L32Record
 * Locator 32 Record
 * @see https://tools.ietf.org/html/rfc6742
 */

class L32Record extends RecordData {
  constructor() {
    super();
    this.preference = 0;
    this.locator32 = DUMMY4;
  }

  get type() {
    return types.L32;
  }

  getSize() {
    return 6;
  }

  write(bw) {
    bw.writeU16BE(this.preference);
    bw.writeBytes(this.locator32);
    return this;
  }

  read(br) {
    this.preference = br.readU16BE();
    this.locator32 = br.readBytes(4);
    return this;
  }
}

/**
 * L64Record
 * Locator 64 Record
 * @see https://tools.ietf.org/html/rfc6742
 */

class L64Record extends RecordData {
  constructor() {
    super();
    this.preference = 0;
    this.locator64 = DUMMY8;
  }

  get type() {
    return types.L64;
  }

  getSize() {
    return 10;
  }

  write(bw) {
    bw.writeU16BE(this.preference);
    bw.writeBytes(this.locator64);
    return this;
  }

  read(br) {
    this.preference = br.readU16BE();
    this.locator64 = br.readBytes(8);
    return this;
  }
}

/**
 * LP Record
 * Locator Pointer Record
 * @see https://tools.ietf.org/html/rfc6742
 */

class LPRecord extends RecordData {
  constructor() {
    super();
    this.preference = 0;
    this.fqdn = '.';
  }

  get type() {
    return types.LP;
  }

  canonical() {
    // Note: not mentioned in RFC 4034.
    this.fqdn = this.fqdn.toLowerCase();
    return this;
  }

  getSize(map) {
    return 2 + sizeName(this.fqdn, map);
  }

  write(bw, map) {
    bw.writeU16BE(this.preference);
    writeNameBW(bw, this.fqdn, map);
    return this;
  }

  read(br) {
    this.preference = br.readU16BE();
    this.fqdn = readNameBR(br);
    return this;
  }
}

/**
 * EUI48Record
 * Extended Unique Identifier Record (48 bit)
 * @see https://tools.ietf.org/html/rfc7043
 */

class EUI48Record extends RecordData {
  constructor() {
    super();
    this.address = DUMMY6;
  }

  get type() {
    return types.EUI48;
  }

  getSize() {
    return 6;
  }

  write(bw) {
    bw.writeBytes(this.address);
    return this;
  }

  read(br) {
    this.address = br.readBytes(6);
    return this;
  }
}

/**
 * EUI64Record
 * Extended Unique Identifier Record (64 bit)
 * @see https://tools.ietf.org/html/rfc7043
 */

class EUI64Record extends RecordData {
  constructor() {
    super();
    this.address = DUMMY8;
  }

  get type() {
    return types.EUI64;
  }

  getSize() {
    return 8;
  }

  write(bw) {
    bw.writeBytes(this.address);
    return this;
  }

  read(br) {
    this.address = br.readBytes(8);
    return this;
  }
}

/**
 * TKEY Record
 * Transaction Key Record
 * @see https://tools.ietf.org/html/rfc2930
 */

class TKEYRecord extends RecordData {
  constructor() {
    super();
    this.algorithm = '.';
    this.inception = 0;
    this.expiration = 0;
    this.mode = 0;
    this.error = 0;
    this.key = DUMMY;
    this.other = DUMMY;
  }

  get type() {
    return types.TKEY;
  }

  canonical() {
    // Note: not mentioned in RFC 4034.
    this.algorithm = this.algorithm.toLowerCase();
    return this;
  }

  getSize(map) {
    let size = 0;
    size += sizeName(this.algorithm, map);
    size += 16;
    size += this.key.length;
    size += this.other.length;
    return size;
  }

  write(bw, map) {
    writeNameBW(bw, this.algorithm, map);
    bw.writeU32BE(this.inception);
    bw.writeU32BE(this.expiration);
    bw.writeU16BE(this.mode);
    bw.writeU16BE(this.error);
    bw.writeU16BE(this.key.length);
    bw.writeBytes(this.key);
    bw.writeU16BE(this.other.length);
    bw.writeBytes(this.other);
    return this;
  }

  read(br) {
    this.algorithm = readNameBR(br);
    this.inception = br.readU32BE();
    this.expiration = br.readU32BE();
    this.mode = br.readU16BE();
    this.error = br.readU16BE();
    this.key = br.readBytes(br.readU16BE());
    this.other = br.readBytes(br.readU16BE());
    return this;
  }
}

/**
 * TSIG Record
 * Transaction Signature Record
 * @see https://tools.ietf.org/html/rfc2845
 */

class TSIGRecord extends RecordData {
  constructor() {
    super();
    this.algorithm = '.';
    this.timeSigned = 0;
    this.fudge = 0;
    this.mac = DUMMY;
    this.origID = 0;
    this.error = 0;
    this.other = DUMMY;
  }

  get type() {
    return types.TSIG;
  }

  canonical() {
    // Note: not mentioned in RFC 4034.
    this.algorithm = this.algorithm.toLowerCase();
    return this;
  }

  getSize(map) {
    let size = 16;
    size += sizeName(this.algorithm, map);
    size += this.mac.length;
    size += this.other.length;
    return size;
  }

  write(bw, map) {
    writeNameBW(bw, this.algorithm, map);
    bw.writeU16BE((this.timeSigned / 0x100000000) >>> 0);
    bw.writeU32BE(this.timeSigned >>> 0);
    bw.writeU16BE(this.fudge);
    bw.writeU16BE(this.mac.length);
    bw.writeBytes(this.mac);
    bw.writeU16BE(this.origID);
    bw.writeU16BE(this.error);
    bw.writeU16BE(this.other.length);
    bw.writeBytes(this.other);
    return this;
  }

  read(br) {
    this.algorithm = readNameBR(br);
    this.timeSigned = br.readU16BE() * 0x100000000 + br.readU32BE();
    this.fudge = br.readU16BE();
    this.mac = br.readBytes(br.readU16BE());
    this.origID = br.readU16BE();
    this.error = br.readU16BE();
    this.other = br.readBytes(br.readU16BE());
    return this;
  }

  getJSON() {
    const algorithm = this.algorithm.toLowerCase();
    const algName = tsigAlgsByVal[algorithm];
    const json = super.getJSON();

    if (algName)
      json.algName = algName;

    return json;
  }

  toString() {
    const algorithm = this.algorithm.toLowerCase();
    const algName = tsigAlgsByVal[algorithm];

    let str = super.toString();

    str += ' ';

    if (algName)
      str += ` ; alg = ${algName}`;

    return str;
  }
}

/**
 * URI Record
 * Uniform Resource Identifier Record
 * @see https://tools.ietf.org/html/rfc7553
 */

class URIRecord extends RecordData {
  constructor() {
    super();
    this.priority = 0;
    this.weight = 0;
    this.target = '';
  }

  get type() {
    return types.URI;
  }

  getSize() {
    return 4 + sizeRawString(this.target);
  }

  write(bw) {
    bw.writeU16BE(this.priority);
    bw.writeU16BE(this.weight);
    writeRawStringBW(bw, this.target);
    return this;
  }

  read(br) {
    this.priority = br.readU16BE();
    this.weight = br.readU16BE();
    this.target = readRawStringBR(br, br.left(), true);
    return this;
  }
}

/**
 * CAA Record
 * Certification Authority Authorization Record
 * @see https://tools.ietf.org/html/rfc6844
 */

class CAARecord extends RecordData {
  constructor() {
    super();
    this.flag = 0;
    this.tag = '';
    this.value = '';
  }

  get type() {
    return types.CAA;
  }

  getSize() {
    let size = 0;
    size += 1;
    size += sizeString(this.tag);
    size += sizeRawString(this.value);
    return size;
  }

  write(bw) {
    bw.writeU8(this.flag);
    writeStringBW(bw, this.tag);
    writeRawStringBW(bw, this.value);
    return this;
  }

  read(br) {
    this.flag = br.readU8();
    this.tag = readStringBR(br, true);
    this.value = readRawStringBR(br, br.left());
    return this;
  }
}

/**
 * AVC Record
 * Application Visibility and Control (proposed)
 * @see https://www.iana.org/assignments/dns-parameters/AVC/avc-completed-template
 */

class AVCRecord extends TXTRecord {
  constructor() {
    super();
  }

  get type() {
    return types.AVC;
  }
}

/**
 * DOA Record
 * Digital Object Architecture Record
 * @see https://www.ietf.org/archive/id/draft-durand-doa-over-dns-03.txt
 */

class DOARecord extends RecordData {
  constructor() {
    super();
    this.enterprise = 0;
    this.doa = 0;
    this.location = 0;
    this.mediaType = '';
    this.data = DUMMY;
  }

  get type() {
    return types.DOA;
  }

  getSize() {
    let size = 0;
    size += 9;
    size += sizeString(this.mediaType);
    size += this.data.length;
    return size;
  }

  write(bw) {
    bw.writeU32BE(this.enterprise);
    bw.writeU32BE(this.doa);
    bw.writeU8(this.location);
    writeStringBW(bw, this.mediaType);
    bw.writeBytes(this.data);
    return this;
  }

  read(br) {
    this.enterprise = br.readU32BE();
    this.doa = br.readU32BE();
    this.location = br.readU8();
    this.mediaType = readStringBR(br);
    this.data = br.readBytes(br.left());
    return this;
  }
}

/**
 * TA Record
 * Trust Authorities Record
 * @see http://www.watson.org/~weiler/INI1999-19.pdf
 */

class TARecord extends RecordData {
  constructor() {
    super();
    this.keyTag = 0;
    this.algorithm = 0;
    this.digestType = 0;
    this.digest = DUMMY;
  }

  get type() {
    return types.TA;
  }

  getSize() {
    return 4 + this.digest.length;
  }

  write(bw) {
    bw.writeU16BE(this.keyTag);
    bw.writeU8(this.algorithm);
    bw.writeU8(this.digestType);
    bw.writeBytes(this.digest);
    return this;
  }

  read(br) {
    this.keyTag = br.readU16BE();
    this.algorithm = br.readU8();
    this.digestType = br.readU8();
    this.digest = br.readBytes(br.left());
    return this;
  }
}

/**
 * DLV Record
 * DNSSEC Lookaside Validation Record
 * @see https://tools.ietf.org/html/rfc4431
 */

class DLVRecord extends DSRecord {
  constructor() {
    super();
  }

  get type() {
    return types.DLV;
  }
}

/**
 * Option Field
 * @see https://tools.ietf.org/html/rfc6891#section-6.1
 */

class Option extends Struct {
  constructor() {
    super();
    this.code = 0;
    this.option = new UNKNOWNOption();
  }

  canonical() {
    // Note: not mentioned in RFC 4034.
    this.option.canonical();
    return this;
  }

  getSize(map) {
    return 4 + this.option.getSize(map);
  }

  write(bw, map) {
    bw.writeU16BE(this.code);
    bw.writeU16BE(0);

    const off = bw.offset;

    this.option.write(bw, map);

    const size = bw.offset - off;

    bio.writeU16BE(bw.data, size, off - 2);

    return this;
  }

  read(br) {
    this.code = br.readU16BE();

    const size = br.readU16BE();
    const child = br.readChild(size);

    this.option = readOption(this.code, child);

    return this;
  }

  toString() {
    const code = optionToString(this.code);
    const isUnknown = optionsByVal[this.code] == null;

    let body = this.option.toString();

    if (isUnknown) {
      assert(this.option.code === options.RESERVED);
      const size = this.options.getSize().toString(10);
      body = `\\# ${size} ${body}`;
    }

    return `${code}: ${body}`;
  }

  fromString(str) {
    const scan = lazy('./internal/scan');
    const op = scan.parseOption(exports, str);
    return this.inject(op);
  }

  getJSON() {
    return {
      code: optionToString(this.code),
      option: this.option.toJSON()
    };
  }

  fromJSON(json) {
    assert(json && typeof json === 'object');
    assert(json.option && typeof json.option === 'object');

    const code = stringToOption(json.code);
    const Option = optsByVal[code];

    let option;
    if (options[json.code] == null) {
      const data = util.parseHex(json.option.data);

      if (Option)
        option = Option.decode(data);
      else
        option = UNKNOWNOption.decode(data);
    } else {
      if (!Option)
        throw new Error(`Unknown option code: ${json.code}.`);

      option = Option.fromJSON(json.option);
    }

    this.code = code;
    this.option = option;

    return this;
  }
}

/**
 * OptionData
 */

class OptionData extends Struct {
  constructor() {
    super();
  }

  get code() {
    return options.RESERVED;
  }

  _schema() {
    const schema = lazy('./internal/schema');
    const s = schema.options[this.code];

    if (!s)
      return schema.options[options.RESERVED];

    return s;
  }

  canonical() {
    return this;
  }

  toString() {
    const schema = lazy('./internal/schema');
    return schema.toString(exports, this, this._schema());
  }

  fromString(str) {
    const scan = lazy('./internal/scan');
    const od = scan.parseOptionData(exports, this.code, str);
    return this.inject(od);
  }

  getJSON() {
    const schema = lazy('./internal/schema');
    return schema.toJSON(exports, this, this._schema());
  }

  fromJSON(json) {
    const schema = lazy('./internal/schema');
    return schema.fromJSON(exports, this, this._schema(), json);
  }
}

/**
 * UNKNOWN Option
 * EDNS Unknown Option
 */

class UNKNOWNOption extends OptionData {
  constructor() {
    super();
    this.data = DUMMY;
  }

  get code() {
    return options.RESERVED;
  }

  getSize() {
    return this.data.length;
  }

  write(bw) {
    bw.writeBytes(this.data);
    return this;
  }

  read(br) {
    this.data = br.readBytes(br.left());
    return this;
  }
}

/**
 * LLQ Option
 * EDNS Long Lived Queries Option
 * @see http://tools.ietf.org/html/draft-sekar-dns-llq-01
 */

class LLQOption extends OptionData {
  constructor() {
    super();
    this.version = 0;
    this.opcode = 0;
    this.error = 0;
    this.id = DUMMY8;
    this.leaseLife = 0;
  }

  get code() {
    return options.LLQ;
  }

  getSize() {
    return 18;
  }

  write(bw) {
    bw.writeU16BE(this.version);
    bw.writeU16BE(this.opcode);
    bw.writeU16BE(this.error);
    bw.writeBytes(this.id);
    bw.writeU32BE(this.leaseLife);
    return this;
  }

  read(br) {
    this.version = br.readU16BE();
    this.opcode = br.readU16BE();
    this.error = br.readU16BE();
    this.id = br.readBytes(8);
    this.leaseLife = br.readU32BE();
    return this;
  }
}

/**
 * UL Option
 * EDNS Update Lease Option
 * @see http://files.dns-sd.org/draft-sekar-dns-ul.txt
 */

class ULOption extends OptionData {
  constructor() {
    super();
    this.lease = 0;
  }

  get code() {
    return options.UL;
  }

  getSize() {
    return 4;
  }

  write(bw) {
    bw.writeU32BE(this.lease);
    return this;
  }

  read(br) {
    this.lease = br.readU32BE();
    return this;
  }
}

/**
 * NSID Option
 * Nameserver Identifier Option
 * @see https://tools.ietf.org/html/rfc5001
 */

class NSIDOption extends OptionData {
  constructor() {
    super();
    this.nsid = DUMMY;
  }

  get code() {
    return options.NSID;
  }

  getSize() {
    return this.nsid.length;
  }

  write(bw) {
    bw.writeBytes(this.nsid);
    return this;
  }

  read(br) {
    this.nsid = br.readBytes(br.left());
    return this;
  }
}

/**
 * DAU Option
 * EDNS DNSSEC Algorithm Understood Option
 * @see https://tools.ietf.org/html/rfc6975
 */

class DAUOption extends OptionData {
  constructor() {
    super();
    this.algCode = DUMMY;
  }

  get code() {
    return options.DAU;
  }

  getSize() {
    return this.algCode.length;
  }

  write(bw) {
    bw.writeBytes(this.algCode);
    return this;
  }

  read(br) {
    this.algCode = br.readBytes(br.left());
    return this;
  }
}

/**
 * DHU Option
 * EDNS DS Hash Understood Option
 * @see https://tools.ietf.org/html/rfc6975
 */

class DHUOption extends DAUOption {
  constructor() {
    super();
  }

  get code() {
    return options.DHU;
  }
}

/**
 * N3U Option
 * EDNS NSEC3 Hash Understood Option
 * @see https://tools.ietf.org/html/rfc6975
 */

class N3UOption extends DAUOption {
  constructor() {
    super();
  }

  get code() {
    return options.N3U;
  }
}

/**
 * SUBNET Option
 * EDNS Subnet Option
 * @see https://tools.ietf.org/html/rfc7871
 */

class SUBNETOption extends OptionData {
  constructor() {
    super();
    this.family = 1;
    this.sourceNetmask = 0;
    this.sourceScope = 0;
    this.address = DUMMY;
  }

  get code() {
    return options.SUBNET;
  }

  // SOURCE PREFIX-LENGTH represents a number of bits.
  // The actual data must be padded to the end of the next octet.
  getAddressSize() {
    return Math.ceil(this.sourceNetmask / 8);
  }

  getSize() {
    return 4 + this.getAddressSize();
  }

  write(bw) {
    assert(this.address.length === this.getAddressSize());
    bw.writeU16BE(this.family);
    bw.writeU8(this.sourceNetmask);
    bw.writeU8(this.sourceScope);
    bw.writeBytes(this.address);

    return this;
  }

  read(br) {
    this.family = br.readU16BE();
    this.sourceNetmask = br.readU8();
    this.sourceScope = br.readU8();
    this.address = br.readBytes(this.getAddressSize());

    return this;
  }
}

/**
 * EXPIRE Option
 * EDNS Expire Option
 * @see https://tools.ietf.org/html/rfc7314
 */

class EXPIREOption extends OptionData {
  constructor() {
    super();
    this.expire = 0;
  }

  get code() {
    return options.EXPIRE;
  }

  getSize() {
    return 4;
  }

  write(bw) {
    bw.writeU32BE(this.expire);
    return this;
  }

  read(br) {
    this.expire = br.readU32BE();
    return this;
  }
}

/**
 * COOKIE Option
 * EDNS Cookie Option
 * @see https://tools.ietf.org/html/rfc7873
 */

class COOKIEOption extends OptionData {
  constructor() {
    super();
    this.cookie = DUMMY;
  }

  get code() {
    return options.COOKIE;
  }

  getSize() {
    return this.cookie.length;
  }

  write(bw) {
    bw.writeBytes(this.cookie);
    return this;
  }

  read(br) {
    this.cookie = br.readBytes(br.left());
    return this;
  }
}

/**
 * TCPKEEPALIVE Option
 * EDNS TCP Keep-Alive Option
 * @see https://tools.ietf.org/html/rfc7828
 */

class TCPKEEPALIVEOption extends OptionData {
  constructor() {
    super();
    this.length = 0;
    this.timeout = 0;
  }

  get code() {
    return options.TCPKEEPALIVE;
  }

  getSize() {
    return 4;
  }

  write(bw) {
    bw.writeU16BE(this.length);
    bw.writeU16BE(this.timeout);
    return this;
  }

  read(br) {
    this.length = br.readU16BE();
    this.timeout = br.readU16BE();
    return this;
  }
}

/**
 * PADDING Option
 * EDNS Padding Option
 * @see https://tools.ietf.org/html/rfc7830
 */

class PADDINGOption extends OptionData {
  constructor() {
    super();
    this.padding = DUMMY;
  }

  get code() {
    return options.PADDING;
  }

  getSize() {
    return this.padding.length;
  }

  write(bw) {
    bw.writeBytes(this.padding);
    return this;
  }

  read(br) {
    this.padding = br.readBytes(br.left());
    return this;
  }
}

/**
 * CHAIN Option
 * EDNS Chain Option
 * @see https://tools.ietf.org/html/rfc7901
 */

class CHAINOption extends OptionData {
  constructor() {
    super();
    this.trustPoint = '.';
  }

  get code() {
    return options.CHAIN;
  }

  canonical() {
    // Note: not mentioned in RFC 4034.
    this.trustPoint = this.trustPoint.toLowerCase();
    return this;
  }

  getSize(map) {
    return sizeName(this.trustPoint, map);
  }

  write(bw, map) {
    writeNameBW(bw, this.trustPoint, map);
    return this;
  }

  read(br) {
    this.trustPoint = readNameBR(br);
    return this;
  }
}

/**
 * KEYTAG Option
 * EDNS Key Tag Option
 * @see https://tools.ietf.org/html/rfc8145
 */

class KEYTAGOption extends OptionData {
  constructor() {
    super();
    this.tags = [];
  }

  get code() {
    return options.KEYTAG;
  }

  getSize() {
    return this.tags.length * 2;
  }

  write(bw) {
    for (const tag of this.tags)
      bw.writeU16BE(tag);
    return this;
  }

  read(br) {
    while (br.left())
      this.tags.push(br.readU16BE());
    return this;
  }
}

/**
 * LOCAL Option
 * EDNS Local Option
 * @see https://tools.ietf.org/html/rfc6891
 */

class LOCALOption extends OptionData {
  constructor() {
    super();
    this.data = DUMMY;
  }

  get code() {
    return options.LOCAL;
  }

  getSize() {
    return this.data.length;
  }

  write(bw) {
    bw.writeBytes(this.data);
    return this;
  }

  read(br) {
    this.data = br.readBytes(br.left());
    return this;
  }
}

/**
 * Address Prefix
 * Used for APL Records
 * @see https://tools.ietf.org/html/rfc3123
 */

class AP extends Struct {
  constructor() {
    super();
    this.family = 1;
    this.prefix = 0;
    this.n = 0;
    this.afd = DUMMY4;
  }

  getSize() {
    return 4 + this.afd.length;
  }

  write(bw) {
    bw.writeU16BE(this.family);
    bw.writeU8(this.prefix);
    bw.writeU8((this.n << 7) | this.afd.length);
    bw.writeBytes(this.afd);
    return this;
  }

  read(br) {
    const family = br.readU16BE();
    const prefix = br.readU8();

    const field = br.readU8();
    const n = field >>> 7;
    const len = field & 0x7f;
    const afd = br.readBytes(len);

    this.family = family;
    this.prefix = prefix;
    this.n = n;
    this.afd = afd;

    return this;
  }

  getJSON() {
    return {
      family: this.family,
      prefix: this.prefix,
      n: this.n,
      afd: this.afd.toString('hex')
    };
  }

  fromJSON(json) {
    assert(json && typeof json === 'object');
    assert((json.family & 0xff) === json.family);
    assert((json.prefix & 0xff) === json.prefix);
    assert((json.n & 1) === json.n);

    this.family = json.family;
    this.prefix = json.prefix;
    this.n = json.n;
    this.afd = util.parseHex(json.afd);

    return this;
  }

  getAFD() {
    if (this.family === 1) {
      const afd = util.padRight(this.afd, 4);
      return IP.toString(afd);
    }

    if (this.family === 2) {
      const afd = util.padRight(this.afd, 16);

      if (IP.isIPv4(afd))
        return `::ffff:${IP.toString(afd)}`;

      return IP.toString(afd);
    }

    return this.afd.toString('hex');
  }

  setAFD(addr) {
    if (this.family === 1) {
      const ip = IP.toBuffer(addr);

      if (!IP.isIPv4(ip))
        throw new Error('Invalid AFD.');

      this.afd = ip;

      return this;
    }

    if (this.family === 2) {
      this.afd = IP.toBuffer(addr);
      return this;
    }

    this.afd = util.parseHex(addr);

    return this;
  }

  toString() {
    let str = '';

    if (this.n)
      str += '!';

    str += this.family.toString(10);
    str += ':';
    str += this.getAFD();
    str += '/';
    str += this.prefix;

    return str;
  }

  fromString(str) {
    assert(typeof str === 'string');
    assert(str.length <= 265);

    let n = 0;

    // {[!]afi:address/prefix}
    if (str.length > 0 && str[0] === '!') {
      str = str.substring(1);
      n = 1;
    }

    const colon = str.indexOf(':');
    assert(colon !== -1);

    const afi = str.substring(0, colon);
    const rest = str.substring(colon + 1);

    const slash = rest.indexOf('/');
    assert(slash !== -1);

    const addr = rest.substring(0, slash);
    const prefix = rest.substring(slash + 1);

    this.family = util.parseU8(afi);
    this.prefix = util.parseU8(prefix);
    this.n = n;
    this.setAFD(addr);

    return this;
  }
}

/**
 * Record Classes
 * @const {Object}
 */

records = {
  UNKNOWN: UNKNOWNRecord,
  A: ARecord,
  NS: NSRecord,
  MD: MDRecord,
  MF: MFRecord,
  CNAME: CNAMERecord,
  SOA: SOARecord,
  MB: MBRecord,
  MG: MGRecord,
  MR: MRRecord,
  NULL: NULLRecord,
  WKS: WKSRecord,
  PTR: PTRRecord,
  HINFO: HINFORecord,
  MINFO: MINFORecord,
  MX: MXRecord,
  TXT: TXTRecord,
  RP: RPRecord,
  AFSDB: AFSDBRecord,
  X25: X25Record,
  ISDN: ISDNRecord,
  RT: RTRecord,
  NSAP: NSAPRecord,
  NSAPPTR: NSAPPTRRecord,
  SIG: SIGRecord,
  KEY: KEYRecord,
  PX: PXRecord,
  GPOS: GPOSRecord,
  AAAA: AAAARecord,
  LOC: LOCRecord,
  NXT: NXTRecord,
  EID: EIDRecord,
  NIMLOC: NIMLOCRecord,
  SRV: SRVRecord,
  ATMA: ATMARecord,
  NAPTR: NAPTRRecord,
  KX: KXRecord,
  CERT: CERTRecord,
  A6: A6Record,
  DNAME: DNAMERecord,
  SINK: null,
  OPT: OPTRecord,
  APL: APLRecord,
  DS: DSRecord,
  SSHFP: SSHFPRecord,
  IPSECKEY: IPSECKEYRecord,
  RRSIG: RRSIGRecord,
  NSEC: NSECRecord,
  DNSKEY: DNSKEYRecord,
  DHCID: DHCIDRecord,
  NSEC3: NSEC3Record,
  NSEC3PARAM: NSEC3PARAMRecord,
  TLSA: TLSARecord,
  SMIMEA: SMIMEARecord,
  HIP: HIPRecord,
  NINFO: NINFORecord,
  RKEY: RKEYRecord,
  TALINK: TALINKRecord,
  CDS: CDSRecord,
  CDNSKEY: CDNSKEYRecord,
  OPENPGPKEY: OPENPGPKEYRecord,
  CSYNC: CSYNCRecord,
  SPF: SPFRecord,
  UINFO: UINFORecord,
  UID: UIDRecord,
  GID: GIDRecord,
  UNSPEC: UNSPECRecord,
  NID: NIDRecord,
  L32: L32Record,
  L64: L64Record,
  LP: LPRecord,
  EUI48: EUI48Record,
  EUI64: EUI64Record,
  TKEY: TKEYRecord,
  TSIG: TSIGRecord,
  URI: URIRecord,
  CAA: CAARecord,
  AVC: AVCRecord,
  DOA: DOARecord,
  IXFR: null,
  AXFR: null,
  MAILB: null,
  MAILA: null,
  ANY: null,
  TA: TARecord,
  DLV: DLVRecord,
  RESERVED: null
};

/**
 * Record Classes By Value
 * @const {Object}
 */

recordsByVal = {
  [types.UNKNOWN]: UNKNOWNRecord,
  [types.A]: ARecord,
  [types.NS]: NSRecord,
  [types.MD]: MDRecord,
  [types.MF]: MFRecord,
  [types.CNAME]: CNAMERecord,
  [types.SOA]: SOARecord,
  [types.MB]: MBRecord,
  [types.MG]: MGRecord,
  [types.MR]: MRRecord,
  [types.NULL]: NULLRecord,
  [types.WKS]: WKSRecord,
  [types.PTR]: PTRRecord,
  [types.HINFO]: HINFORecord,
  [types.MINFO]: MINFORecord,
  [types.MX]: MXRecord,
  [types.TXT]: TXTRecord,
  [types.RP]: RPRecord,
  [types.AFSDB]: AFSDBRecord,
  [types.X25]: X25Record,
  [types.ISDN]: ISDNRecord,
  [types.RT]: RTRecord,
  [types.NSAP]: NSAPRecord,
  [types.NSAPPTR]: NSAPPTRRecord,
  [types.SIG]: SIGRecord,
  [types.KEY]: KEYRecord,
  [types.PX]: PXRecord,
  [types.GPOS]: GPOSRecord,
  [types.AAAA]: AAAARecord,
  [types.LOC]: LOCRecord,
  [types.NXT]: NXTRecord,
  [types.EID]: EIDRecord,
  [types.NIMLOC]: NIMLOCRecord,
  [types.SRV]: SRVRecord,
  [types.ATMA]: ATMARecord,
  [types.NAPTR]: NAPTRRecord,
  [types.KX]: KXRecord,
  [types.CERT]: CERTRecord,
  [types.A6]: A6Record,
  [types.DNAME]: DNAMERecord,
  [types.SINK]: null,
  [types.OPT]: OPTRecord,
  [types.APL]: APLRecord,
  [types.DS]: DSRecord,
  [types.SSHFP]: SSHFPRecord,
  [types.IPSECKEY]: IPSECKEYRecord,
  [types.RRSIG]: RRSIGRecord,
  [types.NSEC]: NSECRecord,
  [types.DNSKEY]: DNSKEYRecord,
  [types.DHCID]: DHCIDRecord,
  [types.NSEC3]: NSEC3Record,
  [types.NSEC3PARAM]: NSEC3PARAMRecord,
  [types.TLSA]: TLSARecord,
  [types.SMIMEA]: SMIMEARecord,
  [types.HIP]: HIPRecord,
  [types.NINFO]: NINFORecord,
  [types.RKEY]: RKEYRecord,
  [types.TALINK]: TALINKRecord,
  [types.CDS]: CDSRecord,
  [types.CDNSKEY]: CDNSKEYRecord,
  [types.OPENPGPKEY]: OPENPGPKEYRecord,
  [types.CSYNC]: CSYNCRecord,
  [types.SPF]: SPFRecord,
  [types.UINFO]: UINFORecord,
  [types.UID]: UIDRecord,
  [types.GID]: GIDRecord,
  [types.UNSPEC]: UNSPECRecord,
  [types.NID]: NIDRecord,
  [types.L32]: L32Record,
  [types.L64]: L64Record,
  [types.LP]: LPRecord,
  [types.EUI48]: EUI48Record,
  [types.EUI64]: EUI64Record,
  [types.TKEY]: TKEYRecord,
  [types.TSIG]: TSIGRecord,
  [types.URI]: URIRecord,
  [types.CAA]: CAARecord,
  [types.AVC]: AVCRecord,
  [types.DOA]: DOARecord,
  [types.IXFR]: null,
  [types.AXFR]: null,
  [types.MAILB]: null,
  [types.MAILA]: null,
  [types.ANY]: null,
  [types.TA]: TARecord,
  [types.DLV]: DLVRecord,
  [types.RESERVED]: null
};

/**
 * EDNS0 Option Classes
 * @const {Object}
 */

opts = {
  UNKNOWN: UNKNOWNOption,
  LLQ: LLQOption,
  UL: ULOption,
  NSID: NSIDOption,
  DAU: DAUOption,
  DHU: DHUOption,
  N3U: N3UOption,
  SUBNET: SUBNETOption,
  EXPIRE: EXPIREOption,
  COOKIE: COOKIEOption,
  TCPKEEPALIVE: TCPKEEPALIVEOption,
  PADDING: PADDINGOption,
  CHAIN: CHAINOption,
  KEYTAG: KEYTAGOption,
  LOCAL: LOCALOption,
  LOCALSTART: LOCALOption,
  LOCALEND: LOCALOption
};

/**
 * EDNS0 Option Classes By Value
 * @const {Object}
 */

optsByVal = {
  [options.RESERVED]: UNKNOWNOption,
  [options.LLQ]: LLQOption,
  [options.UL]: ULOption,
  [options.NSID]: NSIDOption,
  [options.DAU]: DAUOption,
  [options.DHU]: DHUOption,
  [options.N3U]: N3UOption,
  [options.SUBNET]: SUBNETOption,
  [options.EXPIRE]: EXPIREOption,
  [options.COOKIE]: COOKIEOption,
  [options.TCPKEEPALIVE]: TCPKEEPALIVEOption,
  [options.PADDING]: PADDINGOption,
  [options.CHAIN]: CHAINOption,
  [options.KEYTAG]: KEYTAGOption,
  [options.LOCAL]: LOCALOption,
  [options.LOCALSTART]: LOCALOption,
  [options.LOCALEND]: LOCALOption
};

/*
 * Decode
 */

function decodeData(type, data) {
  return readData(type, bio.read(data));
}

function readData(type, br) {
  assert((type & 0xffff) === type);

  switch (type) {
    case types.A:
      return ARecord.read(br);
    case types.NS:
      return NSRecord.read(br);
    case types.MD:
      return MDRecord.read(br);
    case types.MF:
      return MFRecord.read(br);
    case types.CNAME:
      return CNAMERecord.read(br);
    case types.SOA:
      return SOARecord.read(br);
    case types.MB:
      return MBRecord.read(br);
    case types.MG:
      return MGRecord.read(br);
    case types.MR:
      return MRRecord.read(br);
    case types.NULL:
      return NULLRecord.read(br);
    case types.WKS:
      return WKSRecord.read(br);
    case types.PTR:
      return PTRRecord.read(br);
    case types.HINFO:
      return HINFORecord.read(br);
    case types.MINFO:
      return MINFORecord.read(br);
    case types.MX:
      return MXRecord.read(br);
    case types.TXT:
      return TXTRecord.read(br);
    case types.RP:
      return RPRecord.read(br);
    case types.AFSDB:
      return AFSDBRecord.read(br);
    case types.X25:
      return X25Record.read(br);
    case types.ISDN:
      return ISDNRecord.read(br);
    case types.RT:
      return RTRecord.read(br);
    case types.NSAP:
      return NSAPRecord.read(br);
    case types.NSAPPTR:
      return NSAPPTRRecord.read(br);
    case types.SIG:
      return SIGRecord.read(br);
    case types.KEY:
      return KEYRecord.read(br);
    case types.PX:
      return PXRecord.read(br);
    case types.GPOS:
      return GPOSRecord.read(br);
    case types.AAAA:
      return AAAARecord.read(br);
    case types.LOC:
      return LOCRecord.read(br);
    case types.NXT:
      return NXTRecord.read(br);
    case types.EID:
      return EIDRecord.read(br);
    case types.NIMLOC:
      return NIMLOCRecord.read(br);
    case types.SRV:
      return SRVRecord.read(br);
    case types.ATMA:
      return ATMARecord.read(br);
    case types.NAPTR:
      return NAPTRRecord.read(br);
    case types.KX:
      return KXRecord.read(br);
    case types.CERT:
      return CERTRecord.read(br);
    case types.A6:
      return A6Record.read(br);
    case types.DNAME:
      return DNAMERecord.read(br);
    case types.OPT:
      return OPTRecord.read(br);
    case types.APL:
      return APLRecord.read(br);
    case types.DS:
      return DSRecord.read(br);
    case types.SSHFP:
      return SSHFPRecord.read(br);
    case types.IPSECKEY:
      return IPSECKEYRecord.read(br);
    case types.RRSIG:
      return RRSIGRecord.read(br);
    case types.NSEC:
      return NSECRecord.read(br);
    case types.DNSKEY:
      return DNSKEYRecord.read(br);
    case types.DHCID:
      return DHCIDRecord.read(br);
    case types.NSEC3:
      return NSEC3Record.read(br);
    case types.NSEC3PARAM:
      return NSEC3PARAMRecord.read(br);
    case types.TLSA:
      return TLSARecord.read(br);
    case types.SMIMEA:
      return SMIMEARecord.read(br);
    case types.HIP:
      return HIPRecord.read(br);
    case types.NINFO:
      return NINFORecord.read(br);
    case types.RKEY:
      return RKEYRecord.read(br);
    case types.TALINK:
      return TALINKRecord.read(br);
    case types.CDS:
      return CDSRecord.read(br);
    case types.CDNSKEY:
      return CDNSKEYRecord.read(br);
    case types.OPENPGPKEY:
      return OPENPGPKEYRecord.read(br);
    case types.CSYNC:
      return CSYNCRecord.read(br);
    case types.SPF:
      return SPFRecord.read(br);
    case types.UINFO:
      return UINFORecord.read(br);
    case types.UID:
      return UIDRecord.read(br);
    case types.GID:
      return GIDRecord.read(br);
    case types.UNSPEC:
      return UNSPECRecord.read(br);
    case types.NID:
      return NIDRecord.read(br);
    case types.L32:
      return L32Record.read(br);
    case types.L64:
      return L64Record.read(br);
    case types.LP:
      return LPRecord.read(br);
    case types.EUI48:
      return EUI48Record.read(br);
    case types.EUI64:
      return EUI64Record.read(br);
    case types.TKEY:
      return TKEYRecord.read(br);
    case types.TSIG:
      return TSIGRecord.read(br);
    case types.URI:
      return URIRecord.read(br);
    case types.CAA:
      return CAARecord.read(br);
    case types.AVC:
      return AVCRecord.read(br);
    case types.DOA:
      return DOARecord.read(br);
    case types.TA:
      return TARecord.read(br);
    case types.DLV:
      return DLVRecord.read(br);
    default:
      return UNKNOWNRecord.read(br);
  }
}

function decodeOption(code, data) {
  return readOption(code, bio.read(data));
}

function readOption(code, br) {
  assert((code & 0xffff) === code);

  switch (code) {
    case options.LLQ:
      return LLQOption.read(br);
    case options.UL:
      return ULOption.read(br);
    case options.NSID:
      return NSIDOption.read(br);
    case options.DAU:
      return DAUOption.read(br);
    case options.DHU:
      return DHUOption.read(br);
    case options.N3U:
      return N3UOption.read(br);
    case options.SUBNET:
      return SUBNETOption.read(br);
    case options.EXPIRE:
      return EXPIREOption.read(br);
    case options.COOKIE:
      return COOKIEOption.read(br);
    case options.TCPKEEPALIVE:
      return TCPKEEPALIVEOption.read(br);
    case options.PADDING:
      return PADDINGOption.read(br);
    case options.CHAIN:
      return CHAINOption.read(br);
    case options.KEYTAG:
      return KEYTAGOption.read(br);
    default:
      if (code >= options.LOCALSTART && code <= options.LOCALEND)
        return LOCALOption.read(br);
      return UNKNOWNOption.read(br);
  }
}

function fromZone(text, origin, file) {
  assert(typeof text === 'string');
  const scan = lazy('./internal/scan');
  return scan.parseZone(exports, text, origin, file);
}

function toZone(records) {
  assert(Array.isArray(records));

  let text = '';

  for (const rr of records) {
    assert(rr instanceof Record);
    text += rr.toString();
    text += '\n';
  }

  return text;
}

function truncate(msg, max) {
  assert((msg != null && msg._isBuffer === true));
  assert(msg.length >= 12);
  assert((max >>> 0) === max);
  assert(max >= 12);

  if (msg.length <= max)
    return msg;

  const br = bio.read(msg);

  br.seek(2);

  const bits = br.readU16BE();

  const counts = [
    br.readU16BE(),
    br.readU16BE(),
    br.readU16BE(),
    br.readU16BE()
  ];

  let last = br.offset;

  for (let s = 0; s < 4; s++) {
    const count = counts[s];

    let i = 0;
    let j = 0;

    while (br.offset <= max) {
      last = br.offset;
      j = i;

      if (i === count)
        break;

      i += 1;

      readNameBR(br);

      // Question.
      if (s === 0) {
        br.seek(4);
        continue;
      }

      // Record.
      br.seek(8);
      br.seek(br.readU16BE());
    }

    counts[s] = j;
  }

  bio.writeU16BE(msg, bits | flags.TC, 2);
  bio.writeU16BE(msg, counts[0], 4);
  bio.writeU16BE(msg, counts[1], 6);
  bio.writeU16BE(msg, counts[2], 8);
  bio.writeU16BE(msg, counts[3], 10);

  return msg.slice(0, last);
}

function isRSA(algorithm) {
  assert((algorithm & 0xff) === algorithm);

  switch (algorithm) {
    case algs.RSAMD5:
    case algs.RSASHA1:
    case algs.RSASHA1NSEC3SHA1:
    case algs.RSASHA256:
    case algs.RSASHA512:
      return true;
    default:
      return false;
  }
}

function rsaBits(buf) {
  assert((buf != null && buf._isBuffer === true));

  if (buf.length === 0)
    return 0;

  let explen = buf[0];
  let keyoff = 1;

  if (explen === 0) {
    if (buf.length < 3)
      return 0;
    explen = (buf[1] << 8) | buf[2];
    keyoff = 3;
  }

  if (buf.length < keyoff + explen)
    return 0;

  const e = buf.slice(keyoff, keyoff + explen);
  const n = buf.slice(keyoff + explen);

  return [countBits(n), countBits(e)];
}

function countBits(buf) {
  assert((buf != null && buf._isBuffer === true));

  let i = 0;

  for (; i < buf.length; i++) {
    if (buf[i] !== 0x00)
      break;
  }

  let bits = (buf.length - i) * 8;

  if (bits === 0)
    return 0;

  bits -= 8;

  let oct = buf[i];

  while (oct) {
    bits += 1;
    oct >>>= 1;
  }

  return bits;
}

/*
 * Expose
 */

exports.opcodes = opcodes;
exports.opcodesByVal = opcodesByVal;
exports.flags = flags;
exports.flagsByVal = flagsByVal;
exports.codes = codes;
exports.codesByVal = codesByVal;
exports.types = types;
exports.typesByVal = typesByVal;
exports.classes = classes;
exports.classesByVal = classesByVal;
exports.eflags = eflags;
exports.eflagsByVal = eflagsByVal;
exports.options = options;
exports.optionsByVal = optionsByVal;
exports.keyFlags = keyFlags;
exports.algs = algs;
exports.algsByVal = algsByVal;
exports.hashes = hashes;
exports.hashesByVal = hashesByVal;
exports.algHashes = algHashes;
exports.nsecHashes = nsecHashes;
exports.nsecHashesByVal = nsecHashesByVal;
exports.certTypes = certTypes;
exports.certTypesByVal = certTypesByVal;
exports.usages = usages;
exports.usagesByVal = usagesByVal;
exports.selectors = selectors;
exports.selectorsByVal = selectorsByVal;
exports.matchingTypes = matchingTypes;
exports.matchingTypesByVal = matchingTypesByVal;
exports.sshAlgs = sshAlgs;
exports.sshAlgsByVal = sshAlgsByVal;
exports.sshHashes = sshHashes;
exports.sshHashesByVal = sshHashesByVal;
exports.tsigAlgs = tsigAlgs;
exports.tsigAlgsByVal = tsigAlgsByVal;
exports.tkeyModes = tkeyModes;
exports.tkeyModesByVal = tkeyModesByVal;

exports.YEAR68 = YEAR68;
exports.LOC_EQUATOR = LOC_EQUATOR;
exports.LOC_PRIMEMERIDIAN = LOC_PRIMEMERIDIAN;
exports.LOC_HOURS = LOC_HOURS;
exports.LOC_DEGREES = LOC_DEGREES;
exports.LOC_ALTITUDEBASE = LOC_ALTITUDEBASE;

exports.MAX_NAME_SIZE = MAX_NAME_SIZE;
exports.MAX_LABEL_SIZE = MAX_LABEL_SIZE;
exports.MAX_UDP_SIZE = MAX_UDP_SIZE;
exports.STD_EDNS_SIZE = STD_EDNS_SIZE;
exports.MAX_EDNS_SIZE = MAX_EDNS_SIZE;
exports.MAX_MSG_SIZE = MAX_MSG_SIZE;
exports.DNS_PORT = DNS_PORT;
exports.DEFAULT_TTL = DEFAULT_TTL;
exports.KSK_2010 = KSK_2010;
exports.KSK_2017 = KSK_2017;
exports.KSK_ARPA = KSK_ARPA;

exports.opcodeToString = opcodeToString;
exports.stringToOpcode = stringToOpcode;
exports.isOpcodeString = isOpcodeString;

exports.codeToString = codeToString;
exports.stringToCode = stringToCode;
exports.isCodeString = isCodeString;

exports.typeToString = typeToString;
exports.stringToType = stringToType;
exports.isTypeString = isTypeString;

exports.classToString = classToString;
exports.stringToClass = stringToClass;
exports.isClassString = isClassString;

exports.optionToString = optionToString;
exports.stringToOption = stringToOption;
exports.isOptionString = isOptionString;

exports.algToString = algToString;
exports.stringToAlg = stringToAlg;
exports.isAlgString = isAlgString;

exports.hashToString = hashToString;
exports.stringToHash = stringToHash;
exports.isHashString = isHashString;

exports.Message = Message;
exports.EDNS = EDNS;
exports.Question = Question;
exports.Record = Record;
exports.RecordData = RecordData;

exports.UNKNOWNRecord = UNKNOWNRecord;
exports.ARecord = ARecord;
exports.NSRecord = NSRecord;
exports.MDRecord = MDRecord;
exports.MFRecord = MFRecord;
exports.CNAMERecord = CNAMERecord;
exports.SOARecord = SOARecord;
exports.MBRecord = MBRecord;
exports.MGRecord = MGRecord;
exports.MRRecord = MRRecord;
exports.NULLRecord = NULLRecord;
exports.WKSRecord = WKSRecord;
exports.PTRRecord = PTRRecord;
exports.HINFORecord = HINFORecord;
exports.MINFORecord = MINFORecord;
exports.MXRecord = MXRecord;
exports.TXTRecord = TXTRecord;
exports.RPRecord = RPRecord;
exports.AFSDBRecord = AFSDBRecord;
exports.X25Record = X25Record;
exports.ISDNRecord = ISDNRecord;
exports.RTRecord = RTRecord;
exports.NSAPRecord = NSAPRecord;
exports.NSAPPTRRecord = NSAPPTRRecord;
exports.SIGRecord = SIGRecord;
exports.KEYRecord = KEYRecord;
exports.PXRecord = PXRecord;
exports.GPOSRecord = GPOSRecord;
exports.AAAARecord = AAAARecord;
exports.LOCRecord = LOCRecord;
exports.NXTRecord = NXTRecord;
exports.EIDRecord = EIDRecord;
exports.NIMLOCRecord = NIMLOCRecord;
exports.SRVRecord = SRVRecord;
exports.ATMARecord = ATMARecord;
exports.NAPTRRecord = NAPTRRecord;
exports.KXRecord = KXRecord;
exports.CERTRecord = CERTRecord;
exports.A6Record = A6Record;
exports.DNAMERecord = DNAMERecord;
exports.OPTRecord = OPTRecord;
exports.APLRecord = APLRecord;
exports.DSRecord = DSRecord;
exports.SSHFPRecord = SSHFPRecord;
exports.IPSECKEYRecord = IPSECKEYRecord;
exports.RRSIGRecord = RRSIGRecord;
exports.NSECRecord = NSECRecord;
exports.DNSKEYRecord = DNSKEYRecord;
exports.DHCIDRecord = DHCIDRecord;
exports.NSEC3Record = NSEC3Record;
exports.NSEC3PARAMRecord = NSEC3PARAMRecord;
exports.TLSARecord = TLSARecord;
exports.SMIMEARecord = SMIMEARecord;
exports.HIPRecord = HIPRecord;
exports.NINFORecord = NINFORecord;
exports.RKEYRecord = RKEYRecord;
exports.TALINKRecord = TALINKRecord;
exports.CDSRecord = CDSRecord;
exports.CDNSKEYRecord = CDNSKEYRecord;
exports.OPENPGPKEYRecord = OPENPGPKEYRecord;
exports.CSYNCRecord = CSYNCRecord;
exports.SPFRecord = SPFRecord;
exports.UINFORecord = UINFORecord;
exports.UIDRecord = UIDRecord;
exports.GIDRecord = GIDRecord;
exports.UNSPECRecord = UNSPECRecord;
exports.NIDRecord = NIDRecord;
exports.L32Record = L32Record;
exports.L64Record = L64Record;
exports.LPRecord = LPRecord;
exports.EUI48Record = EUI48Record;
exports.EUI64Record = EUI64Record;
exports.TKEYRecord = TKEYRecord;
exports.TSIGRecord = TSIGRecord;
exports.URIRecord = URIRecord;
exports.CAARecord = CAARecord;
exports.AVCRecord = AVCRecord;
exports.DOARecord = DOARecord;
exports.TARecord = TARecord;
exports.DLVRecord = DLVRecord;

exports.Option = Option;
exports.OptionData = OptionData;
exports.UNKNOWNOption = UNKNOWNOption;
exports.LLQOption = LLQOption;
exports.ULOption = ULOption;
exports.NSIDOption = NSIDOption;
exports.DAUOption = DAUOption;
exports.DHUOption = DHUOption;
exports.N3UOption = N3UOption;
exports.SUBNETOption = SUBNETOption;
exports.EXPIREOption = EXPIREOption;
exports.COOKIEOption = COOKIEOption;
exports.TCPKEEPALIVEOption = TCPKEEPALIVEOption;
exports.PADDINGOption = PADDINGOption;
exports.CHAINOption = CHAINOption;
exports.KEYTAGOption = KEYTAGOption;
exports.LOCALOption = LOCALOption;

exports.AP = AP;

exports.records = records;
exports.recordsByVal = recordsByVal;
exports.opts = opts;
exports.optsByVal = optsByVal;

exports.decodeData = decodeData;
exports.readData = readData;

exports.decodeOption = decodeOption;
exports.readOption = readOption;

exports.fromZone = fromZone;
exports.toZone = toZone;
exports.truncate = truncate;
}],
[/* 91 */ 'bns-plus', '/lib/resolvconf.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * resolvconf.js - resolv.conf for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const fs = __browser_require__(84 /* 'bfile' */, module);
const IP = __browser_require__(4 /* 'binet' */, module);
const {DNS_PORT} = __browser_require__(11 /* './constants' */, module);
const util = __browser_require__(79 /* './util' */, module);

/*
 * Constants
 */

const LOCAL_NS = [
  '127.0.0.1',
  '::1'
];

const GOOGLE_NS = [
  '8.8.8.8',
  '8.8.4.4',
  '2001:4860:4860::8888',
  '2001:4860:4860::8844'
];

const OPENDNS_NS = [
  '208.67.222.222',
  '208.67.220.220',
  '208.67.222.220',
  '208.67.220.222',
  '2620:0:ccc::2',
  '2620:0:ccd::2'
];

/**
 * ResolvConf
 */

class ResolvConf {
  constructor() {
    this.ns4 = [];
    this.ns6 = [];
    this.keys = new Map();
    this.domain = null;
    this.search = null;
    this.sortlist = [];
    this.debug = false;
    this.dots = 1;
    this.timeout = 5000;
    this.attempts = 2;
    this.rotate = false;
    this.checkNames = true;
    this.inet6 = false;
    this.byteString = false;
    this.dotInt = false;
    this.edns = false;
    this.singleRequest = false;
    this.singleRequestReopen = false;
    this.tldQuery = true;
    this.forceTCP = false;
  }

  inject(conf) {
    assert(conf instanceof this.constructor);

    this.ns4 = conf.ns4.slice();
    this.ns6 = conf.ns6.slice();

    this.keys.clear();

    for (const [key, pub] of conf.keys)
      this.keys.set(key, pub);

    this.domain = conf.domain;

    if (conf.search)
      this.search = conf.search.slice();
    else
      this.search = null;

    this.sortlist = conf.sortlist.slice();
    this.debug = conf.debug;
    this.dots = conf.dots;
    this.timeout = conf.timeout;
    this.attempts = conf.attempts;
    this.rotate = conf.rotate;
    this.checkNames = conf.checkNames;
    this.inet6 = conf.inet6;
    this.byteString = conf.byteString;
    this.dotInt = conf.dotInt;
    this.edns = conf.edns;
    this.singleRequest = conf.singleRequest;
    this.singleRequestReopen = conf.singleRequestReopen;
    this.tldQuery = conf.tldQuery;
    this.forceTCP = conf.forceTCP;

    return this;
  }

  clone() {
    const copy = new this.constructor();
    return copy.inject(this);
  }

  clear() {
    this.ns4.length = 0;
    this.ns6.length = 0;
    this.keys.clear();
    this.domain = null;
    this.search = null;
    this.sortlist = [];
    this.debug = false;
    this.dots = 1;
    this.timeout = 5000;
    this.attempts = 2;
    this.rotate = false;
    this.checkNames = true;
    this.inet6 = false;
    this.byteString = false;
    this.dotInt = false;
    this.edns = false;
    this.singleRequest = false;
    this.singleRequestReopen = false;
    this.tldQuery = true;
    this.forceTCP = false;
    return this;
  }

  getSystem() {
    if (process.platform === 'win32')
      return null;

    return '/etc/resolv.conf';
  }

  getRaw(inet6) {
    assert(typeof inet6 === 'boolean');

    const servers = [];

    for (const addr of this.ns4)
      servers.push(addr);

    if (inet6) {
      for (const addr of this.ns6)
        servers.push(addr);
    }

    return servers;
  }

  getServers() {
    const servers = [];

    for (const addr of this.ns4)
      servers.push(addr.hostname);

    for (const addr of this.ns6)
      servers.push(addr.hostname);

    return servers;
  }

  setServers(servers) {
    assert(Array.isArray(servers));

    this.clearServers();

    for (const server of servers)
      this.addServer(server);

    return this;
  }

  clearServers() {
    this.ns4.length = 0;
    this.ns6.length = 0;
    this.keys.clear();
    return this;
  }

  setDefault() {
    return this.setGoogle();
  }

  setLocal() {
    return this.setServers(LOCAL_NS);
  }

  setGoogle() {
    return this.setServers(GOOGLE_NS);
  }

  setOpenDNS() {
    return this.setServers(OPENDNS_NS);
  }

  addServer(server) {
    assert(typeof server === 'string');

    const addr = IP.fromHost(server, DNS_PORT);

    switch (addr.type) {
      case 4:
        this.ns4.push(addr);
        break;
      case 6:
        this.ns6.push(addr);
        break;
      default:
        throw new Error('Invalid address.');
    }

    if (addr.key)
      this.keys.set(addr.hostname, addr.key);
  }

  setDomain(domain) {
    assert(typeof domain === 'string');

    if (!util.isName(domain))
      throw new Error('Invalid domain.');

    this.search = null;
    this.domain = util.fqdn(domain);

    return this;
  }

  setSearch(list) {
    assert(typeof list === 'string');

    if (list.length > 256)
      throw new Error('Search list too large.');

    const names = util.splitSP(list);

    this.domain = null;
    this.search = [];

    for (const name of names) {
      if (!util.isName(name))
        continue;

      if (this.search.length === 6)
        throw new Error('Search list too large.');

      this.search.push(util.fqdn(name));
    }

    return this;
  }

  setSort(list) {
    assert(typeof list === 'string');

    const pairs = util.splitSP(list);

    for (const pair of pairs) {
      const items = pair.split('/', 3);

      let ip = items[0];
      let mask = null;

      if (items.length > 1)
        mask = items[1];

      try {
        ip = IP.normalize(ip);
        if (mask)
          mask = IP.normalize(mask);
      } catch (e) {
        continue;
      }

      if (this.sortlist.length === 10)
        throw new Error('Sort list too large.');

      this.sortlist.push({ ip, mask });
    }

    return this;
  }

  toString(full) {
    if (full == null)
      full = false;

    assert(typeof full === 'boolean');

    let out = '';

    out += '# Generated by bns\n';

    for (const addr of this.getRaw(true)) {
      out += 'nameserver ';

      if (full)
        out += IP.toHost(addr.host, addr.port, addr.key);
      else
        out += addr.host;

      out += '\n';
    }

    if (this.domain)
      out += `domain ${util.trimFQDN(this.domain)}\n`;

    if (this.search) {
      for (const host of this.search)
        out += `search ${util.trimFQDN(host)}\n`;
    }

    if (this.sortlist.length > 0) {
      out += 'sortlist';
      for (const {ip, mask} of this.sortlist) {
        if (mask)
          out += ` ${ip}/${mask}`;
        else
          out += ` ${ip}`;
      }
      out += '\n';
    }

    out += 'options';

    if (this.debug)
      out += ' debug';

    if (this.dots !== 1)
      out += ` ndots:${this.dots}`;

    if (Math.ceil(this.timeout / 1000) !== 5)
      out += ` timeout:${Math.ceil(this.timeout / 1000)}`;

    if (this.attempts !== 2)
      out += ` attempts:${this.attempts}`;

    if (this.rotate)
      out += ' rotate';

    if (!this.checkNames)
      out += ' no-check-names';

    if (this.inet6)
      out += ' inet6';

    if (this.byteString)
      out += ' ip6-bytestring';

    if (this.dotInt)
      out += ' ip6-dotint';

    if (this.edns)
      out += ' edns0';

    if (this.singleRequest)
      out += ' single-request';

    if (this.singleRequestReopen)
      out += ' single-request-reopen';

    if (!this.tldQuery)
      out += ' no-tld-query';

    if (this.forceTCP)
      out += ' use-vc';

    out += '\n';

    if (out.slice(-8) === 'options\n')
      out = out.slice(0, -8);

    return out;
  }

  parseServer(text) {
    assert(typeof text === 'string');

    const server = text.trim().toLowerCase();

    try {
      return this.addServer(server);
    } catch (e) {
      return this;
    }
  }

  parseDomain(text) {
    assert(typeof text === 'string');

    const domain = text.trim().toLowerCase();

    try {
      return this.setDomain(domain);
    } catch (e) {
      return this;
    }
  }

  parseSearch(text) {
    assert(typeof text === 'string');

    const list = text.trim().toLowerCase();

    try {
      return this.setSearch(list);
    } catch (e) {
      return this;
    }
  }

  parseSort(text) {
    assert(typeof text === 'string');

    const list = text.trim().toLowerCase();

    try {
      return this.setSort(list);
    } catch (e) {
      return this;
    }
  }

  parseOptions(line) {
    assert(typeof line === 'string');

    const options = util.splitSP(line);

    for (const option of options) {
      const i = option.indexOf(':');

      let name = null;
      let arg = '';

      if (i !== -1) {
        name = option.substring(0, i);
        arg = option.substring(i + 1);
      } else {
        arg = option;
        name = arg;
      }

      name = name.toLowerCase();

      switch (name) {
        case 'debug': {
          this.debug = true;
          break;
        }
        case 'ndots': {
          try {
            this.dots = Math.min(15, util.parseU8(arg));
            this.dots = Math.max(1, this.dots);
          } catch (e) {
            continue;
          }
          break;
        }
        case 'timeout': {
          try {
            this.timeout = Math.min(30, util.parseU8(arg));
            this.timeout = Math.max(1, this.timeout);
            this.timeout *= 1000;
          } catch (e) {
            continue;
          }
          break;
        }
        case 'attempts': {
          try {
            this.attempts = Math.min(5, util.parseU8(arg));
            this.attempts = Math.max(1, this.attempts);
          } catch (e) {
            continue;
          }
          break;
        }
        case 'rotate': {
          this.rotate = true;
          break;
        }
        case 'no-check-names': {
          this.checkNames = false;
          break;
        }
        case 'inet6': {
          this.inet6 = true;
          break;
        }
        case 'ip6-bytestring': {
          this.byteString = true;
          break;
        }
        case 'ip6-dotint': {
          this.dotInt = true;
          break;
        }
        case 'no-ip6-dotint': {
          this.dotInt = false;
          break;
        }
        case 'edns0': {
          this.edns = true;
          break;
        }
        case 'single-request': {
          this.singleRequest = true;
          break;
        }
        case 'single-request-reopen': {
          this.singleRequestReopen = true;
          break;
        }
        case 'no-tld-query': {
          this.tldQuery = false;
          break;
        }
        case 'use-vc': {
          this.forceTCP = true;
          break;
        }
      }
    }

    return this;
  }

  fromString(text) {
    assert(typeof text === 'string');

    this.clearServers();

    const lines = util.splitLines(text, true);

    for (const line of lines) {
      if (line[0] === '#' || line[0] === ';')
        continue;

      const i = line.indexOf(' ');

      if (i === -1)
        continue;

      const option = line.substring(0, i).toLowerCase();
      const rest = line.substring(i + 1);

      switch (option) {
        case 'nameserver': {
          this.parseServer(rest);
          break;
        }
        case 'domain': {
          this.parseDomain(rest);
          break;
        }
        case 'search': {
          this.parseSearch(rest);
          break;
        }
        case 'sortlist': {
          this.parseSort(rest);
          break;
        }
        case 'options':
          this.parseOptions(rest);
          break;
      }
    }

    return this;
  }

  static fromString(text) {
    return new this().fromString(text);
  }

  readEnv() {
    if (process.env.LOCALDOMAIN)
      this.parseDomain(process.env.LOCALDOMAIN);

    if (process.env.RES_OPTIONS)
      this.parseOptions(process.env.RES_OPTIONS);

    return this;
  }

  fromFile(file) {
    assert(typeof file === 'string');
    const text = fs.readFileSync(file, 'utf8');
    return this.fromString(text);
  }

  static fromFile(file) {
    return new this().fromFile(file);
  }

  fromSystem() {
    const file = this.getSystem();

    if (file) {
      try {
        this.fromFile(file);
      } catch (e) {
        this.setDefault();
      }
    } else {
      this.setDefault();
    }

    this.readEnv();

    return this;
  }

  static fromSystem() {
    return new this().fromSystem();
  }

  async fromFileAsync(file) {
    assert(typeof file === 'string');
    const text = await fs.readFile(file, 'utf8');
    return this.fromString(text);
  }

  static fromFileAsync(file) {
    return new this().fromFileAsync(file);
  }

  async fromSystemAsync() {
    const file = this.getSystem();

    if (file) {
      try {
        await this.fromFileAsync(file);
      } catch (e) {
        this.setDefault();
      }
    } else {
      this.setDefault();
    }

    this.readEnv();

    return this;
  }

  static fromSystemAsync() {
    return new this().fromSystemAsync();
  }
}

/*
 * Expose
 */

module.exports = ResolvConf;
}],
[/* 92 */ 'bns-plus', '/lib/smimea.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * smimea.js - SMIMEA for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 *
 * Parts of this software are based on miekg/dns:
 *   https://github.com/miekg/dns/blob/master/smimea.go
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc6698
 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const dane = __browser_require__(12 /* './dane' */, module);
const wire = __browser_require__(90 /* './wire' */, module);

const {
  usages,
  selectors,
  matchingTypes
} = dane;

const {
  types,
  classes,
  Record,
  SMIMEARecord
} = wire;

/*
 * SMIMEA
 */

const smimea = exports;

smimea.create = function create(cert, email, options = {}) {
  assert((cert != null && cert._isBuffer === true));
  assert(options && typeof options === 'object');

  let {ttl, usage, selector, matchingType} = options;

  if (ttl == null)
    ttl = 3600;

  if (usage == null)
    usage = usages.DIC;

  if (selector == null)
    selector = selectors.SPKI;

  if (matchingType == null)
    matchingType = matchingTypes.SHA256;

  assert((ttl >>> 0) === ttl);
  assert((usage & 0xff) === usage);
  assert((selector & 0xff) === selector);
  assert((matchingType & 0xff) === matchingType);

  const rr = new Record();
  const rd = new SMIMEARecord();

  rr.name = smimea.encodeEmail(email);
  rr.type = types.SMIMEA;
  rr.class = classes.IN;
  rr.ttl = ttl;
  rr.data = rd;
  rd.usage = usage;
  rd.selector = selector;
  rd.matchingType = matchingType;

  const hash = dane.sign(cert, selector, matchingType);

  if (!hash)
    throw new Error('Unknown selector or matching type.');

  rd.certificate = hash;

  return rr;
};

smimea.verify = function verify(rr, cert) {
  assert(rr instanceof Record);
  assert(rr.type === types.SMIMEA);

  const rd = rr.data;

  return dane.verify(cert, rd.selector, rd.matchingType, rd.certificate);
};

smimea.encodeEmail = function encodeEmail(email, bits) {
  return dane.encodeEmail(email, 'smimecert', bits);
};

smimea.encodeName = function encodeName(name, local, bits) {
  return dane.encodeName(name, 'smimecert', local, bits);
};

smimea.decodeName = function decodeName(name) {
  return dane.decodeName(name, 'smimecert');
};

smimea.isName = function isName(name) {
  return dane.isName(name, 'smimecert');
};

/*
 * Expose
 */

smimea.usages = usages;
smimea.selectors = selectors;
smimea.matchingTypes = matchingTypes;
}],
[/* 93 */ 'bns-plus', '/lib/sshfp.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * sshfp.js - SSHFP for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const constants = __browser_require__(11 /* './constants' */, module);
const crypto = __browser_require__(13 /* './internal/crypto' */, module);
const util = __browser_require__(79 /* './util' */, module);
const wire = __browser_require__(90 /* './wire' */, module);

const {
  types,
  classes,
  sshAlgs,
  sshAlgsByVal,
  sshHashes,
  sshHashesByVal
} = constants;

const {
  Record,
  SSHFPRecord
} = wire;

/*
 * SSHFP
 */

const sshfp = exports;

sshfp.hash = function hash(key, digestType) {
  assert((key != null && key._isBuffer === true));
  assert((digestType & 0xff) === digestType);

  switch (digestType) {
    case sshHashes.SHA1:
      return crypto.sha1.digest(key);
    case sshHashes.SHA256:
      return crypto.sha256.digest(key);
  }

  return null;
};

sshfp.validate = function validate(key, digestType, fingerprint) {
  assert((fingerprint != null && fingerprint._isBuffer === true));

  const hash = sshfp.hash(key, digestType);

  if (!hash)
    return false;

  return hash.equals(fingerprint);
};

sshfp.create = function create(key, name, alg, digest) {
  assert((key != null && key._isBuffer === true));
  assert(typeof name === 'string');
  assert((alg & 0xff) === alg);
  assert((digest & 0xff) === digest);

  const rr = new Record();
  const rd = new SSHFPRecord();

  rr.name = util.fqdn(name);
  rr.type = types.SSHFP;
  rr.class = classes.IN;
  rr.ttl = 172800;
  rr.data = rd;
  rd.algorithm = alg;
  rd.digestType = digest;

  return sshfp.sign(rr, key);
};

sshfp.sign = function sign(rr, key) {
  assert(rr instanceof Record);
  assert(rr.type === types.SSHFP);

  const rd = rr.data;
  const hash = sshfp.hash(key, rd.digestType);

  if (!hash)
    throw new Error('Unknown digest type.');

  rd.fingerprint = hash;

  return rr;
};

sshfp.verify = function verify(rr, key) {
  assert(rr instanceof Record);
  assert(rr.type === types.SSHFP);

  const rd = rr.data;

  return sshfp.validate(key, rd.digestType, rd.fingerprint);
};

/*
 * Expose
 */

sshfp.algs = sshAlgs;
sshfp.algsByVal = sshAlgsByVal;
sshfp.hashes = sshHashes;
sshfp.hashesByVal = sshHashesByVal;
}],
[/* 94 */ 'bns-plus', '/lib/tlsa.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * tlsa.js - TLSA for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 *
 * Parts of this software are based on miekg/dns:
 *   https://github.com/miekg/dns/blob/master/tlsa.go
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc6698
 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const dane = __browser_require__(12 /* './dane' */, module);
const util = __browser_require__(79 /* './util' */, module);
const wire = __browser_require__(90 /* './wire' */, module);

const {
  usages,
  selectors,
  matchingTypes
} = dane;

const {
  types,
  classes,
  Record,
  TLSARecord
} = wire;

/*
 * TLSA
 */

const tlsa = exports;

tlsa.create = function create(cert, name, protocol, port, options = {}) {
  assert((cert != null && cert._isBuffer === true));
  assert(options && typeof options === 'object');

  let {ttl, usage, selector, matchingType} = options;

  if (ttl == null)
    ttl = 3600;

  if (usage == null)
    usage = usages.DIC;

  if (selector == null)
    selector = selectors.SPKI;

  if (matchingType == null)
    matchingType = matchingTypes.SHA256;

  assert((ttl >>> 0) === ttl);
  assert((usage & 0xff) === usage);
  assert((selector & 0xff) === selector);
  assert((matchingType & 0xff) === matchingType);

  const rr = new Record();
  const rd = new TLSARecord();

  rr.name = tlsa.encodeName(name, protocol, port);
  rr.type = types.TLSA;
  rr.class = classes.IN;
  rr.ttl = ttl;
  rr.data = rd;
  rd.usage = usage;
  rd.selector = selector;
  rd.matchingType = matchingType;

  const hash = dane.sign(cert, selector, matchingType);

  if (!hash)
    throw new Error('Unknown selector or matching type.');

  rd.certificate = hash;

  return rr;
};

tlsa.verify = function verify(rr, cert) {
  assert(rr instanceof Record);
  assert(rr.type === types.TLSA);

  const rd = rr.data;

  return dane.verify(cert, rd.selector, rd.matchingType, rd.certificate);
};

tlsa.encodeName = function encodeName(name, protocol, port) {
  assert(util.isName(name));
  assert(name.length === 0 || name[0] !== '_');
  assert(typeof protocol === 'string');
  assert(protocol.length >= 1 && protocol.length <= 62);
  assert(protocol[0] !== '_');
  assert(protocol.indexOf('.') === -1);
  assert((port & 0xffff) === port);

  if (name === '.')
    name = '';

  const encoded = util.fqdn(`_${port.toString(10)}._${protocol}.${name}`);

  assert(util.isName(encoded));

  return encoded;
};

tlsa.decodeName = function decodeName(name) {
  assert(util.isName(name));

  const labels = util.split(name);

  assert(labels.length >= 3);

  const port = util.label(name, labels, 0);
  const protocol = util.label(name, labels, 1);

  assert(port.length >= 2);
  assert(protocol.length >= 2);
  assert(port[0] === '_');
  assert(protocol[0] === '_');

  return {
    name: util.fqdn(util.from(name, labels, 2)),
    protocol: protocol.substring(1).toLowerCase(),
    port: util.parseU16(port.substring(1))
  };
};

tlsa.isName = function isName(name) {
  assert(util.isName(name));

  try {
    tlsa.decodeName(name);
    return true;
  } catch (e) {
    return false;
  }
};

/*
 * Expose
 */

tlsa.usages = usages;
tlsa.selectors = selectors;
tlsa.matchingTypes = matchingTypes;
}],
[/* 95 */ 'bpkg', '/lib/builtins/empty.js', function(exports, require, module, __filename, __dirname, __meta) {

}],
[/* 96 */ 'bns-plus', '/lib/authority.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * authority.js - authority object for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 *
 * Parts of this software are based on solvere:
 *   https://github.com/rolandshoemaker/solvere
 */



const assert = __browser_require__(2 /* 'bsert' */, module);

/**
 * Authority
 */

class Authority {
  constructor(zone, name) {
    assert(zone == null || typeof zone === 'string');
    assert(name == null || typeof name === 'string');

    this.zone = zone || '.';
    this.name = name || '.';
    this.servers = [];
  }

  add(host, port) {
    assert(typeof host === 'string');
    assert((port & 0xffff) === port);
    this.servers.push({ host, port });
    return this;
  }

  inject(auth) {
    assert(auth instanceof this.constructor);
    this.zone = auth.zone;
    this.name = auth.name;
    this.servers = auth.servers.slice();
    return this;
  }

  clone() {
    const copy = new this.constructor();
    return copy.inject(this);
  }
}

/*
 * Expose
 */

module.exports = Authority;
}],
[/* 97 */ 'bns-plus', '/lib/server/auth.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * auth.js - authoritative dns server for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 */



const DNSServer = __browser_require__(98 /* './dns' */, module);
const Zone = __browser_require__(107 /* '../zone' */, module);

/**
 * AuthServer
 * @extends EventEmitter
 */

class AuthServer extends DNSServer {
  constructor(options) {
    super(options);
    this.zone = new Zone();
    this.file = null;
    this.ra = false;
    this.initOptions(options);
  }

  setZSKFromString(str) {
    this.zone.setZSKFromString(str);
    return this;
  }

  setOrigin(name) {
    this.zone.setOrigin(name);
    return this;
  }

  setFile(file) {
    this.zone.clearRecords();
    this.zone.fromFile(file);
    this.file = file;
    return this;
  }

  async resolve(req, rinfo) {
    const [qs] = req.question;
    const {name, type} = qs;
    return this.zone.resolve(name, type);
  }
}

/*
 * Expose
 */

module.exports = AuthServer;
}],
[/* 98 */ 'bns-plus', '/lib/server/dns.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * dns.js - dns server for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const EventEmitter = __browser_require__(3 /* 'events' */, module);
const bio = __browser_require__(14 /* 'bufio' */, module);
const constants = __browser_require__(11 /* '../constants' */, module);
const dnssec = __browser_require__(99 /* '../dnssec' */, module);
const DNSError = __browser_require__(101 /* '../error' */, module);
const {Server} = __browser_require__(102 /* '../internal/net' */, module);
const wire = __browser_require__(90 /* '../wire' */, module);

const {
  codes,
  options,
  types,
  MAX_EDNS_SIZE,
  MAX_UDP_SIZE,
  MAX_MSG_SIZE
} = constants;

const {
  Message
} = wire;

/**
 * DNSServer
 * @extends EventEmitter
 */

class DNSServer extends EventEmitter {
  constructor(options) {
    super();

    this.server = new Server(options);
    this.resolver = null;
    this.ra = false;

    this.inet6 = this.server.inet6;
    this.tcp = this.server.tcp;
    this.maxConnections = 20;
    this.edns = false;
    this.ednsSize = MAX_EDNS_SIZE;
    this.dnssec = false;
    this.noAny = false;

    this.init();
  }

  init() {
    this.on('error', () => {});

    this.server.on('close', () => {
      this.emit('close');
    });

    this.server.on('error', (err) => {
      this.emit('error', err);
    });

    this.server.on('listening', () => {
      this.emit('listening');
    });

    this.server.on('message', async (msg, rinfo) => {
      try {
        await this.handle(msg, rinfo);
      } catch (e) {
        this.emit('error', e);
      }
    });
  }

  parseOptions(options) {
    if (options == null)
      return this;

    assert(options && typeof options === 'object');

    if (options.maxConnections != null) {
      assert((options.maxConnections >>> 0) === options.maxConnections);
      this.maxConnections = options.maxConnections;
    }

    if (options.edns != null) {
      assert(typeof options.edns === 'boolean');
      this.edns = options.edns;
    }

    if (options.ednsSize != null) {
      assert((options.ednsSize >>> 0) === options.ednsSize);
      assert(options.ednsSize >= MAX_UDP_SIZE);
      assert(options.ednsSize <= MAX_EDNS_SIZE);
      this.ednsSize = options.ednsSize;
    }

    if (options.dnssec != null) {
      assert(typeof options.dnssec === 'boolean');
      this.dnssec = options.dnssec;
      if (this.dnssec)
        this.edns = true;
    }

    if (options.noAny != null) {
      assert(typeof options.noAny === 'boolean');
      this.noAny = options.noAny;
    }

    return this;
  }

  initOptions(options) {
    return this.parseOptions(options);
  }

  log(...args) {
    this.emit('log', ...args);
    return this;
  }

  address() {
    return this.server.address();
  }

  async open(...args) {
    if (this.resolver)
      await this.resolver.open();

    await this.server.bind(...args);

    this.server.maxConnections = this.maxConnections;

    if (this.edns) {
      this.server.setRecvBufferSize(this.ednsSize);
      this.server.setSendBufferSize(this.ednsSize);
    } else {
      this.server.setRecvBufferSize(MAX_UDP_SIZE);
      this.server.setSendBufferSize(MAX_UDP_SIZE);
    }

    return this;
  }

  async close() {
    await this.server.close();

    if (!this.resolver)
      return undefined;

    return this.resolver.close();
  }

  async bind(...args) {
    return this.open(...args);
  }

  signSize() {
    return 0;
  }

  sign(msg, host, port) {
    return msg;
  }

  finalize(req, res) {
    assert(req instanceof Message);
    assert(res instanceof Message);

    const ds = this.dnssec && req.isDNSSEC();

    res.setReply(req);
    res.ra = this.ra;

    if (this.edns && req.isEDNS()) {
      res.setEDNS(this.ednsSize, ds);

      if (this.ra) {
        // Echo cookies if we're recursive.
        for (const opt of req.edns.options) {
          if (opt.code === options.COOKIE) {
            res.edns.options.push(opt);
            break;
          }
        }
      }
    } else {
      res.unsetEDNS();
    }

    if (this.ra) {
      if (res.answer.length > 0) {
        res.authority = [];
        res.additional = [];
      }

      if (!ds && !req.ad)
        res.ad = false;
    }

    if (!ds && req.question.length > 0) {
      const [qs] = req.question;

      // If we're recursive, and the
      // query was ANY, do not remove.
      if (!this.ra || qs.type !== types.ANY)
        dnssec.filterMessage(res, qs.type);
    }

    res.refresh();

    return this;
  }

  async resolve(req, rinfo) {
    if (!this.resolver)
      return null;

    const [qs] = req.question;

    return this.resolver.resolve(qs);
  }

  async answer(req, rinfo) {
    if (req.qr)
      throw new DNSError('unexpected qr bit', codes.FORMERR);

    if (req.code !== codes.NOERROR)
      throw new DNSError('unexpected rcode', codes.FORMERR);

    if (req.question.length !== 1)
      throw new DNSError('invalid question', codes.FORMERR);

    if (req.answer.length > 0)
      throw new DNSError('unexpected answer', codes.FORMERR);

    if (req.authority.length > 0)
      throw new DNSError('unexpected authority', codes.FORMERR);

    const [qs] = req.question;

    if (this.noAny && qs.type === types.ANY)
      throw new DNSError('ANY not accepted', codes.NOTIMP);

    const res = await this.resolve(req, rinfo);

    if (!res)
      return null;

    this.finalize(req, res);

    return res;
  }

  send(req, res, rinfo) {
    const {port, address, tcp} = rinfo;

    let msg;

    if (this.tcp && tcp) {
      msg = res.compress();
      msg = this.sign(msg, address, port);

      if (msg.length > MAX_MSG_SIZE)
        throw new Error('Message exceeds size limits.');
    } else {
      const maxSize = this.edns && req
        ? req.maxSize(this.ednsSize)
        : MAX_UDP_SIZE;

      const max = maxSize - this.signSize();

      if ((max >>> 0) !== max || max < 12)
        throw new Error('Invalid sign size.');

      msg = res.compress(max);
      msg = this.sign(msg, address, port);

      if (msg.length > maxSize)
        throw new Error('Invalid sign size.');
    }

    this.server.send(msg, 0, msg.length, port, address, tcp);

    return this;
  }

  async handle(msg, rinfo) {
    let req = null;
    let res = null;

    try {
      req = Message.decode(msg);
    } catch (e) {
      this.emit('error', e);

      if (msg.length < 2)
        return;

      res = new Message();
      res.id = bio.readU16BE(msg, 0);
      res.ra = this.ra;
      res.qr = true;
      res.code = codes.FORMERR;

      this.send(null, res, rinfo);

      return;
    }

    try {
      res = await this.answer(req, rinfo);
    } catch (e) {
      this.emit('error', e);

      res = new Message();
      res.code = codes.SERVFAIL;

      if (e.type === 'DNSError')
        res.code = e.errno;

      this.finalize(req, res);
    }

    if (res) {
      this.emit('query', req, res, rinfo);
      this.send(req, res, rinfo);
      return;
    }

    res = new Response(this, req, rinfo);
    res.setReply(req);
    res.ra = this.ra;

    this.emit('query', req, res, rinfo);
  }
}

/**
 * Response
 * @extends Message
 */

class Response extends Message {
  constructor(server, req, rinfo) {
    super();
    this._server = server;
    this._req = req;
    this._rinfo = rinfo;
    this._sent = false;
  }

  send() {
    if (this._sent)
      throw new Error('Response already sent.');

    this._sent = true;

    this._server.finalize(this._req, this);
    this._server.send(this._req, this, this._rinfo);
  }
}

/*
 * Expose
 */

module.exports = DNSServer;
}],
[/* 99 */ 'bns-plus', '/lib/dnssec.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * dnssec.js - DNSSEC for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 *
 * Parts of this software are based on miekg/dns and golang/go:
 *   https://github.com/miekg/dns/blob/master/dnssec.go
 *
 * Parts of this software are based on solvere:
 *   https://github.com/rolandshoemaker/solvere
 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const bio = __browser_require__(14 /* 'bufio' */, module);
const constants = __browser_require__(11 /* './constants' */, module);
const crypto = __browser_require__(13 /* './internal/crypto' */, module);
const encoding = __browser_require__(80 /* './encoding' */, module);
const keys = __browser_require__(100 /* './internal/keys' */, module);
const util = __browser_require__(79 /* './util' */, module);
const wire = __browser_require__(90 /* './wire' */, module);

const {
  readName,
  packName
} = encoding;

const {
  isRRSet,
  countLabels,
  splitName,
  extractSet
} = util;

const {
  classes,
  types,
  keyFlags,
  algs,
  algsByVal,
  hashes,
  hashesByVal,
  algHashes
} = constants;

const {
  Message,
  Record,
  DSRecord,
  DNSKEYRecord,
  RRSIGRecord
} = wire;

/*
 * Constants
 */

const algToHash = {
  [algs.RSAMD5]: crypto.md5, // Deprecated in RFC 6725
  [algs.DSA]: crypto.sha1,
  [algs.RSASHA1]: crypto.sha1,
  [algs.DSANSEC3SHA1]: crypto.sha1,
  [algs.RSASHA1NSEC3SHA1]: crypto.sha1,
  [algs.RSASHA256]: crypto.sha256,
  [algs.ECDSAP256SHA256]: crypto.sha256,
  [algs.ECDSAP384SHA384]: crypto.sha384,
  [algs.RSASHA512]: crypto.sha512,
  [algs.ED25519]: {},
  [algs.ED448]: {}
};

const hashToHash = {
  [hashes.SHA1]: crypto.sha1,
  [hashes.SHA256]: crypto.sha256,
  [hashes.GOST94]: crypto.gost94,
  [hashes.SHA384]: crypto.sha384,
  [hashes.SHA512]: crypto.sha512
};

/*
 * DNSSEC
 */

const dnssec = exports;

dnssec.filename = keys.filename;
dnssec.privFile = keys.privFile;
dnssec.pubFile = keys.pubFile;

dnssec.createPrivate = keys.createPrivate;
dnssec.createPrivateAsync = keys.createPrivateAsync;
dnssec.createPublic = keys.createPublic;
dnssec.encodePrivate = keys.encodePrivate;
dnssec.decodePrivate = keys.decodePrivate;

dnssec.readPrivate = keys.readPrivate;
dnssec.readPrivateAsync = keys.readPrivateAsync;
dnssec.readPublic = keys.readPublic;
dnssec.readPublicAsync = keys.readPublicAsync;
dnssec.writeKeys = keys.writeKeys;
dnssec.writeKeysAsync = keys.writeKeysAsync;
dnssec.writePrivate = keys.writePrivate;
dnssec.writePrivateAsync = keys.writePrivateAsync;
dnssec.writePublic = keys.writePublic;
dnssec.writePublicAsync = keys.writePublicAsync;

dnssec.makeKey = function makeKey(name, algorithm, priv, flags) {
  const pub = dnssec.createPublic(algorithm, priv);
  return dnssec.createKey(name, algorithm, pub, flags);
};

dnssec.createKey = function createKey(name, algorithm, publicKey, flags) {
  if (flags == null)
    flags = keyFlags.ZONE;

  assert(typeof name === 'string');
  assert(util.isFQDN(name));
  assert((algorithm & 0xff) === algorithm);
  assert((publicKey != null && publicKey._isBuffer === true));
  assert((flags & 0xffff) === flags);

  const rr = new Record();
  const rd = new DNSKEYRecord();

  rr.name = name;
  rr.class = classes.IN;
  rr.type = types.DNSKEY;
  rr.ttl = 172800;
  rr.data = rd;

  rd.flags = flags;
  rd.protocol = 3;
  rd.algorithm = algorithm;
  rd.publicKey = publicKey;

  return rr;
};

dnssec.createDS = function createDS(key, digestType) {
  if (digestType == null)
    digestType = hashes.SHA256;

  assert(key instanceof Record);
  assert(key.type === types.DNSKEY);
  assert((digestType & 0xff) === digestType);

  const kd = key.data;
  const hash = hashToHash[digestType];

  if (!hash)
    return null;

  const raw = kd.encode();
  const keyTag = kd.keyTag(raw);
  const owner = packName(key.name);

  const rr = new Record();
  const rd = new DSRecord();

  rr.name = key.name;
  rr.class = key.class;
  rr.type = types.DS;
  rr.ttl = key.ttl;
  rr.data = rd;

  rd.algorithm = kd.algorithm;
  rd.digestType = digestType;
  rd.keyTag = keyTag;
  rd.digest = hash.multi(owner, raw);

  return rr;
};

dnssec.signType = function signType(rrs, type, key, priv, lifespan) {
  assert(Array.isArray(rrs));
  assert((type & 0xffff) === type);

  const rrset = extractSet(rrs, '', type);

  if (rrset.length === 0)
    return rrs;

  const sig = dnssec.sign(key, priv, rrset, lifespan);

  rrs.push(sig);

  return rrs;
};

dnssec.sign = function sign(key, priv, rrset, lifespan) {
  if (lifespan == null)
    lifespan = 365 * 24 * 60 * 60;

  assert(key instanceof Record);
  assert(key.type === types.DNSKEY);
  assert(Array.isArray(rrset));
  assert((lifespan >>> 0) === lifespan);

  const rr = new Record();
  const rd = new RRSIGRecord();

  rr.name = key.name;
  rr.ttl = key.ttl;
  rr.class = key.class;
  rr.type = types.RRSIG;
  rr.data = rd;

  rd.keyTag = key.data.keyTag();
  rd.signerName = key.name;
  rd.algorithm = key.data.algorithm;
  rd.inception = util.now() - (24 * 60 * 60);
  rd.expiration = util.now() + lifespan;

  return dnssec.signRRSIG(rr, priv, rrset);
};

dnssec.signRRSIG = function signRRSIG(sig, priv, rrset) {
  assert(sig instanceof Record);
  assert(sig.type === types.RRSIG);
  assert((priv != null && priv._isBuffer === true));
  assert(Array.isArray(rrset));

  const sd = sig.data;

  if (!isRRSet(rrset))
    throw new Error('Invalid RR set.');

  if (sd.keyTag === 0 || sd.signerName.length === 0 || sd.algorithm === 0)
    throw new Error('Invalid signature record.');

  sig.type = types.RRSIG;
  sig.name = rrset[0].name;
  sig.class = rrset[0].class;
  sig.data = sd;

  if (sd.origTTL === 0)
    sd.origTTL = rrset[0].ttl;

  sd.typeCovered = rrset[0].type;
  sd.labels = countLabels(rrset[0].name);

  if (rrset[0].name[0] === '*')
    sd.labels -= 1;

  const data = dnssec.signatureHash(sig, rrset);

  if (!data)
    throw new Error('Bad number of labels.');

  sd.signature = dnssec.signData(priv, data, sd.algorithm);

  return sig;
};

dnssec.signData = function signData(priv, data, algorithm) {
  assert((priv != null && priv._isBuffer === true));
  assert((data != null && data._isBuffer === true));
  assert((algorithm & 0xff) === algorithm);

  const keybuf = priv;
  const hash = algToHash[algorithm];

  if (!hash)
    throw new Error('Unknown hash algorithm.');

  switch (algorithm) {
    case algs.DSA:
    case algs.DSANSEC3SHA1:
      return crypto.signDSA(hash, data, keybuf);
    case algs.RSAMD5:
    case algs.RSASHA1:
    case algs.RSASHA1NSEC3SHA1:
    case algs.RSASHA256:
    case algs.RSASHA512:
      return crypto.signRSA(hash, data, keybuf);
    case algs.ECDSAP256SHA256:
      return crypto.signP256(hash, data, keybuf);
    case algs.ECDSAP384SHA384:
      return crypto.signP384(hash, data, keybuf);
    case algs.ED25519:
      return crypto.signED25519(data, keybuf);
    case algs.ED448:
      return crypto.signED448(data, keybuf);
  }

  throw new Error('Unknown public key algorithm.');
};

dnssec.verify = function verify(sig, key, rrset) {
  assert(sig instanceof Record);
  assert(sig.type === types.RRSIG);
  assert(key instanceof Record);
  assert(key.type === types.DNSKEY);
  assert(Array.isArray(rrset));

  const s = sig.data; // RRSIG
  const k = key.data; // DNSKEY

  if (!isRRSet(rrset))
    return false; // Invalid RR set

  if (s.keyTag !== k.keyTag())
    return false; // Key tag mismatch

  if (sig.class !== key.class)
    return false; // Class mismatch

  if (s.algorithm !== k.algorithm)
    return false; // Algorithm mismatch

  if (!util.equal(s.signerName, key.name))
    return false; // Name mismatch

  if (k.protocol !== 3)
    return false; // Invalid protocol

  if (rrset[0].class !== sig.class)
    return false; // Class mismatch

  if (rrset[0].type !== s.typeCovered)
    return false; // Type mismatch

  const data = dnssec.signatureHash(sig, rrset);

  if (!data)
    return false;

  return dnssec.verifyData(sig, key, data, s.algorithm);
};

dnssec.verifyData = function verifyData(sig, key, data, algorithm) {
  assert(sig instanceof Record);
  assert(sig.type === types.RRSIG || sig.type === types.SIG);
  assert(key instanceof Record);
  assert(key.type === types.DNSKEY || key.type === types.KEY);
  assert((data != null && data._isBuffer === true));
  assert((algorithm & 0xff) === algorithm);

  const keybuf = key.data.publicKey;
  const sigbuf = sig.data.signature;
  const hash = algToHash[algorithm];

  if (!hash)
    return false;

  switch (algorithm) {
    case algs.DSA:
    case algs.DSANSEC3SHA1:
      return crypto.verifyDSA(hash, data, sigbuf, keybuf);
    case algs.RSAMD5:
    case algs.RSASHA1:
    case algs.RSASHA1NSEC3SHA1:
    case algs.RSASHA256:
    case algs.RSASHA512:
      return crypto.verifyRSA(hash, data, sigbuf, keybuf);
    case algs.ECDSAP256SHA256:
      return crypto.verifyP256(hash, data, sigbuf, keybuf);
    case algs.ECDSAP384SHA384:
      return crypto.verifyP384(hash, data, sigbuf, keybuf);
    case algs.ED25519:
      return crypto.verifyED25519(data, sigbuf, keybuf);
    case algs.ED448:
      return crypto.verifyED448(data, sigbuf, keybuf);
  }

  return false; // Unknown algorithm
};

dnssec.signatureHash = function signatureHash(sig, rrset) {
  assert(sig instanceof Record);
  assert(sig.type === types.RRSIG);
  assert(Array.isArray(rrset));

  const sd = sig.data;
  const records = [];

  for (const item of rrset) {
    assert(item instanceof Record);

    const rr = item.deepClone();
    const labels = splitName(rr.name);

    // Server is using wildcards.
    if (labels.length > sd.labels) {
      const i = labels.length - sd.labels;
      const name = labels.slice(i).join('.');
      rr.name = `*.${name}.`;
    }

    // Invalid RR set.
    if (labels.length < sd.labels)
      return null;

    // Canonical TTL.
    rr.ttl = sd.origTTL;

    // Canonicalize all domain
    // names (see RFC 4034).
    rr.canonical();

    // Push for sorting.
    records.push(rr.encode());
  }

  records.sort(compare);

  const tbs = sd.toTBS();

  let size = 0;

  size += tbs.length;

  for (let i = 0; i < records.length; i++) {
    const raw = records[i];

    if (i > 0 && raw.equals(records[i - 1]))
      continue;

    size += raw.length;
  }

  const bw = bio.write(size);

  bw.writeBytes(tbs);

  for (let i = 0; i < records.length; i++) {
    const raw = records[i];

    if (i > 0 && raw.equals(records[i - 1]))
      continue;

    bw.writeBytes(raw);
  }

  return bw.render();
};

dnssec.verifyDS = function verifyDS(msg, ds, name) {
  assert(msg instanceof Message);
  assert(Array.isArray(ds));
  assert(typeof name === 'string');

  if (ds.length === 0)
    return false;

  const kskMap = new Map();

  for (const rr of msg.answer) {
    if (rr.type !== types.DNSKEY)
      continue;

    const rd = rr.data;

    if (!(rd.flags & keyFlags.ZONE))
      continue;

    if (!util.equal(rr.name, name))
      continue;

    if (rd.flags & keyFlags.REVOKE)
      continue;

    kskMap.set(rd.keyTag(), rr);
  }

  const valid = new Map();

  for (const rr of ds) {
    assert(rr instanceof Record);
    assert(rr.type === types.DS);

    const rd = rr.data;
    const key = kskMap.get(rd.keyTag);

    if (!key)
      continue;

    const ds = dnssec.createDS(key, rd.digestType);

    if (!ds)
      continue; // Failed to convert KSK (unknown alg).

    if (!ds.data.digest.equals(rd.digest))
      return null; // Mismatching DS.

    if (ds.data.algorithm !== rd.algorithm)
      return null; // Mismatching algorithm.

    valid.set(rd.keyTag, key);

    continue;
  }

  if (valid.size === 0)
    return null;

  return valid;
};

dnssec.verifyZSK = function verifyZSK(msg, kskMap, name) {
  assert(msg instanceof Message);
  assert(kskMap instanceof Map);
  assert(typeof name === 'string');

  if (msg.answer.length === 0)
    return false; // No keys

  if (kskMap.size === 0)
    return false; // No keys

  const keys = [];
  const sigs = [];

  for (const rr of msg.answer) {
    const rd = rr.data;

    if (rr.type === types.DNSKEY) {
      if (!util.equal(rr.name, name))
        continue;
      keys.push(rr);
      continue;
    }

    if (rr.type === types.RRSIG) {
      if (rd.typeCovered !== types.DNSKEY)
        continue;

      if (!util.equal(rr.name, name))
        continue;

      if (!kskMap.has(rd.keyTag))
        continue;

      if (!rd.validityPeriod())
        continue; // Invalid Signature Period

      sigs.push(rr);
      continue;
    }
  }

  if (keys.length === 0)
    return false; // No keys

  if (sigs.length === 0)
    return false; // No sigs

  for (const sig of sigs) {
    const sd = sig.data;
    const key = kskMap.get(sd.keyTag);
    assert(key);

    if (!dnssec.verify(sig, key, keys))
      return false; // Invalid Signature
  }

  return true;
};

dnssec.verifyMessage = function verifyMessage(msg, zskMap, revSet) {
  if (revSet == null)
    revSet = new Set();

  assert(msg instanceof Message);
  assert(zskMap instanceof Map);
  assert(revSet instanceof Set);

  const isAnswer = msg.isAnswer();
  const isReferral = msg.isReferral();

  if (!isAnswer && !isReferral)
    return true;

  const set = new Set();

  let section = msg.answer;

  if (isReferral) {
    section = msg.authority;

    // We need a signed DS, NSEC3,
    // or NS record for a referral.
    if (util.hasType(section, types.DS))
      set.add(types.DS);

    if (util.hasType(section, types.NSEC))
      set.add(types.NSEC);

    if (util.hasType(section, types.NSEC3))
      set.add(types.NSEC3);
  }

  // If we don't have any specific
  // types to look for, verify
  // everything in the section.
  if (set.size === 0) {
    for (const rr of section) {
      // No signed signatures.
      if (rr.type === types.RRSIG
          || rr.type === types.SIG) {
        continue;
      }

      // No special records.
      if (rr.type === types.OPT
          || rr.type === types.TSIG) {
        continue;
      }

      set.add(rr.type);
    }
  }

  // Some kind of error.
  // Verify elsewhere.
  if (set.size === 0)
    return true;

  for (const rr of section) {
    if (rr.type !== types.RRSIG)
      continue;

    const rd = rr.data;

    if (!rd.validityPeriod())
      continue; // Invalid Signature Period

    if (!set.has(rd.typeCovered))
      continue; // Useless

    if (revSet.has(rd.keyTag))
      continue; // Revoked signature.

    const key = zskMap.get(rd.keyTag);

    if (!key)
      continue; // Missing DNS Key

    const rrset = extractSet(section, rr.name, rd.typeCovered);

    if (rrset.length === 0)
      continue; // Missing Signed

    if (!dnssec.verify(rr, key, rrset))
      continue; // Invalid Signature

    set.delete(rd.typeCovered);
  }

  if (set.size !== 0)
    return false; // Unsigned Data

  return true;
};

dnssec.filterMessage = function filterMessage(msg, type) {
  assert(msg instanceof Message);
  assert((type & 0xffff) === type);

  msg.answer = dnssec.filterSection(msg.answer, type);
  msg.authority = dnssec.filterSection(msg.authority, type);
  msg.additional = dnssec.filterSection(msg.additional, type);

  return msg;
};

dnssec.filterSection = function filterSection(section, type) {
  assert(Array.isArray(section));
  assert((type & 0xffff) === type);

  const filtered = [];

  for (const rr of section) {
    assert(rr instanceof Record);

    switch (rr.type) {
      case types.DS:
      case types.DLV:
      case types.DNSKEY:
      case types.RRSIG:
      case types.NXT:
      case types.NSEC:
      case types.NSEC3:
      case types.NSEC3PARAM:
        if (type !== rr.type)
          break;
        // fall through
      default:
        filtered.push(rr);
        break;
    }
  }

  return filtered;
};

dnssec.stripSignatures = function stripSignatures(msg) {
  assert(msg instanceof Message);

  msg.answer = util.filterSet(msg.answer, types.RRSIG);
  msg.authority = util.filterSet(msg.authority, types.RRSIG);
  msg.additional = util.filterSet(msg.additional, types.RRSIG);

  return msg;
};

/*
 * Helpers
 */

function compare(a, b) {
  const [ao] = readName(a, 0, true);
  const [bo] = readName(b, 0, true);
  const ab = a.slice(ao + 10);
  const bb = b.slice(bo + 10);
  return ab.compare(bb);
}

/*
 * Expose
 */

dnssec.keyFlags = keyFlags;
dnssec.algs = algs;
dnssec.algsByVal = algsByVal;
dnssec.hashes = hashes;
dnssec.hashesByVal = hashesByVal;
dnssec.algHashes = algHashes;
dnssec.algToHash = algToHash;
dnssec.hashToHash = hashToHash;
}],
[/* 100 */ 'bns-plus', '/lib/internal/keys.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * keys.js - DNSSEC keys for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const Path = __browser_require__(87 /* 'path' */, module);
const fs = __browser_require__(84 /* 'bfile' */, module);
const dsa = __browser_require__(40 /* 'bcrypto/lib/dsa' */, module);
const rsa = __browser_require__(54 /* 'bcrypto/lib/rsa' */, module);
const p256 = __browser_require__(58 /* 'bcrypto/lib/p256' */, module);
const p384 = __browser_require__(66 /* 'bcrypto/lib/p384' */, module);
const ed25519 = __browser_require__(68 /* 'bcrypto/lib/ed25519' */, module);
const crypto = __browser_require__(13 /* './crypto' */, module);
const constants = __browser_require__(11 /* '../constants' */, module);
const util = __browser_require__(79 /* '../util' */, module);
const wire = __browser_require__(90 /* '../wire' */, module);
const {types, Record} = wire;

const {
  algs,
  algToString
} = constants;

const {
  pad
} = util;

/*
 * Constants
 */

const VERSION = 'v1.3';

/*
 * Keys
 */

const keys = exports;

keys.filename = function filename(name, alg, tag) {
  assert(typeof name === 'string');
  assert(util.isName(name));
  assert((alg & 0xff) === alg);
  assert((tag & 0xffff) === tag);

  const fqdn = util.fqdn(name.toLowerCase());

  return `K${fqdn}+${pad(alg, 3)}+${pad(tag, 5)}`;
};

keys.privFile = function privFile(name, alg, tag) {
  const file = keys.filename(name, alg, tag);
  return `${file}.private`;
};

keys.pubFile = function pubFile(name, alg, tag) {
  const file = keys.filename(name, alg, tag);
  return `${file}.key`;
};

keys.createPrivate = function createPrivate(algorithm, bits, exp) {
  assert((algorithm & 0xff) === algorithm);

  switch (algorithm) {
    case algs.DSA:
    case algs.DSANSEC3SHA1: {
      return crypto.generateDSA(bits);
    }
    case algs.RSAMD5:
    case algs.RSASHA1:
    case algs.RSASHA1NSEC3SHA1:
    case algs.RSASHA256:
    case algs.RSASHA512: {
      return crypto.generateRSA(bits, exp);
    }
    case algs.ECDSAP256SHA256: {
      return crypto.generateP256();
    }
    case algs.ECDSAP384SHA384: {
      return crypto.generateP384();
    }
    case algs.ED25519: {
      return crypto.generateED25519();
    }
    case algs.ED448: {
      return crypto.generateED448();
    }
    default: {
      throw new Error(`Unsupported algorithm: ${algToString(algorithm)}.`);
    }
  }
};

keys.createPrivateAsync = async function createPrivateAsync(algorithm, bits, exp) {
  assert((algorithm & 0xff) === algorithm);

  switch (algorithm) {
    case algs.DSA:
    case algs.DSANSEC3SHA1: {
      return crypto.generateDSAAsync(bits);
    }
    case algs.RSAMD5:
    case algs.RSASHA1:
    case algs.RSASHA1NSEC3SHA1:
    case algs.RSASHA256:
    case algs.RSASHA512: {
      return crypto.generateRSAAsync(bits, exp);
    }
    case algs.ECDSAP256SHA256: {
      return crypto.generateP256();
    }
    case algs.ECDSAP384SHA384: {
      return crypto.generateP384();
    }
    case algs.ED25519: {
      return crypto.generateED25519();
    }
    case algs.ED448: {
      return crypto.generateED448();
    }
    default: {
      throw new Error(`Unsupported algorithm: ${algToString(algorithm)}.`);
    }
  }
};

keys.createPublic = function createPublic(algorithm, raw) {
  assert((algorithm & 0xff) === algorithm);
  assert((raw != null && raw._isBuffer === true));

  switch (algorithm) {
    case algs.DSA:
    case algs.DSANSEC3SHA1: {
      return crypto.createDSA(raw);
    }
    case algs.RSAMD5:
    case algs.RSASHA1:
    case algs.RSASHA1NSEC3SHA1:
    case algs.RSASHA256:
    case algs.RSASHA512: {
      return crypto.createRSA(raw);
    }
    case algs.ECDSAP256SHA256: {
      return crypto.createP256(raw);
    }
    case algs.ECDSAP384SHA384: {
      return crypto.createP384(raw);
    }
    case algs.ED25519: {
      return crypto.createED25519(raw);
    }
    case algs.ED448: {
      return crypto.createED448(raw);
    }
    default: {
      throw new Error(`Unsupported algorithm: ${algToString(algorithm)}.`);
    }
  }
};

keys.encodePrivate = function encodePrivate(algorithm, raw, time) {
  if (time == null)
    time = util.now();

  assert((algorithm & 0xff) === algorithm);
  assert((raw != null && raw._isBuffer === true));
  assert(Number.isSafeInteger(time) && time >= 0);

  switch (algorithm) {
    case algs.DSA:
    case algs.DSANSEC3SHA1: {
      return keys.encodeDSA(algorithm, raw, time);
    }
    case algs.RSAMD5:
    case algs.RSASHA1:
    case algs.RSASHA1NSEC3SHA1:
    case algs.RSASHA256:
    case algs.RSASHA512:
      return keys.encodeRSA(algorithm, raw, time);
    case algs.ECDSAP256SHA256:
    case algs.ECDSAP384SHA384:
    case algs.ED25519:
    case algs.ED448:
      return keys.encodeEC(algorithm, raw, time);
    default:
      throw new Error(`Unsupported algorithm: ${algToString(algorithm)}.`);
  }
};

keys.encodeDSA = function encodeDSA(algorithm, raw, time) {
  assert((algorithm & 0xff) === algorithm);

  const {p, q, g, y, x} = dsa.privateKeyExport(raw);
  const now = util.serializeTime(time);

  return [
    `Private-key-format: ${VERSION}`,
    `Algorithm: ${algorithm} (${algToString(algorithm)})`,
    `Prime(p): ${p.toString('base64')}`,
    `Subprime(q): ${q.toString('base64')}`,
    `Base(g): ${g.toString('base64')}`,
    `Private_value(x): ${x.toString('base64')}`,
    `Public_value(y): ${y.toString('base64')}`,
    `Created: ${now}`,
    `Publish: ${now}`,
    `Activate: ${now}`
  ].join('\n');
};

keys.encodeRSA = function encodeRSA(algorithm, raw, time) {
  assert((algorithm & 0xff) === algorithm);

  const {n, e, d, p, q, dp, dq, qi} = rsa.privateKeyExport(raw);
  const now = util.serializeTime(time);

  return [
    `Private-key-format: ${VERSION}`,
    `Algorithm: ${algorithm} (${algToString(algorithm)})`,
    `Modulus: ${n.toString('base64')}`,
    `PublicExponent: ${e.toString('base64')}`,
    `PrivateExponent: ${d.toString('base64')}`,
    `Prime1: ${p.toString('base64')}`,
    `Prime2: ${q.toString('base64')}`,
    `Exponent1: ${dp.toString('base64')}`,
    `Exponent2: ${dq.toString('base64')}`,
    `Coefficient: ${qi.toString('base64')}`,
    `Created: ${now}`,
    `Publish: ${now}`,
    `Activate: ${now}`
  ].join('\n');
};

keys.encodeEC = function encodeEC(algorithm, raw, time) {
  assert((algorithm & 0xff) === algorithm);
  assert((raw != null && raw._isBuffer === true));

  const now = util.serializeTime(time);

  return [
    `Private-key-format: ${VERSION}`,
    `Algorithm: ${algorithm} (${algToString(algorithm)})`,
    `PrivateKey: ${raw.toString('base64')}`,
    `Created: ${now}`,
    `Publish: ${now}`,
    `Activate: ${now}`
  ].join('\n');
};

keys.decodePrivate = function decodePrivate(str) {
  const {algorithm} = keys.decodeMeta(str);

  switch (algorithm) {
    case algs.DSA:
    case algs.DSANSEC3SHA1:
      return keys.decodeDSA(str);
    case algs.RSAMD5:
    case algs.RSASHA1:
    case algs.RSASHA1NSEC3SHA1:
    case algs.RSASHA256:
    case algs.RSASHA512:
      return keys.decodeRSA(str);
    case algs.ECDSAP256SHA256:
    case algs.ECDSAP384SHA384:
    case algs.ED25519:
    case algs.ED448:
      return keys.decodeEC(str);
    default:
      throw new Error(`Unsupported algorithm: ${algToString(algorithm)}.`);
  }
};

keys.decodeMeta = function decodeMeta(str) {
  assert(typeof str === 'string');

  const lines = util.splitLines(str);

  let format = VERSION;
  let algorithm = -1;
  let created = 0;
  let publish = 0;
  let activate = 0;

  for (const line of lines) {
    const [key, value] = util.splitColon(line);

    switch (key.toLowerCase()) {
      case 'private-key-format': {
        format = value.toLowerCase();
        break;
      }
      case 'algorithm': {
        const [left] = value.split(/[ \t]/);
        algorithm = util.parseU8(left);
        break;
      }
      case 'created': {
        created = util.parseTime(value);
        break;
      }
      case 'publish': {
        publish = util.parseTime(value);
        break;
      }
      case 'activate': {
        activate = util.parseTime(value);
        break;
      }
    }
  }

  if (algorithm === -1)
    throw new Error('Could not determine key algorithm.');

  return {
    format,
    algorithm,
    created,
    publish,
    activate
  };
};

keys.decodeDSA = function decodeDSA(str) {
  assert(typeof str === 'string');

  const lines = util.splitLines(str);

  let p, q, g, y, x;
  let algorithm = -1;

  for (const line of lines) {
    const [name, value] = util.splitColon(line);

    switch (name.toLowerCase()) {
      case 'algorithm': {
        const [left] = value.split(/[ \t]/);
        const alg = util.parseU8(left);

        switch (alg) {
          case algs.DSA:
          case algs.DSANSEC3SHA1:
            break;
          default:
            throw new Error(`Not a DSA algorithm: ${algToString(alg)}.`);
        }

        algorithm = alg;

        break;
      }
      case 'prime(p)': {
        p = util.parseB64(value);
        break;
      }
      case 'subprime(q)': {
        q = util.parseB64(value);
        break;
      }
      case 'base(g)': {
        g = util.parseB64(value);
        break;
      }
      case 'private_value(x)': {
        x = util.parseB64(value);
        break;
      }
      case 'public_value(y)': {
        y = util.parseB64(value);
        break;
      }
    }
  }

  if (algorithm === -1)
    throw new Error('Could not determine key algorithm.');

  const key = dsa.privateKeyImport({ p, q, g, y, x });

  return [algorithm, key];
};

keys.decodeRSA = function decodeRSA(str) {
  assert(typeof str === 'string');

  const lines = util.splitLines(str);

  let n, e, d, p, q, dp, dq, qi;
  let algorithm = -1;

  for (const line of lines) {
    const [name, value] = util.splitColon(line);

    switch (name.toLowerCase()) {
      case 'algorithm': {
        const [left] = value.split(/[ \t]/);
        const alg = util.parseU8(left);

        switch (alg) {
          case algs.RSAMD5:
          case algs.RSASHA1:
          case algs.RSASHA1NSEC3SHA1:
          case algs.RSASHA256:
          case algs.RSASHA512:
            break;
          default:
            throw new Error(`Not an RSA algorithm: ${algToString(alg)}.`);
        }

        algorithm = alg;

        break;
      }
      case 'modulus': {
        n = util.parseB64(value);
        break;
      }
      case 'publicexponent': {
        e = util.parseB64(value);
        break;
      }
      case 'privateexponent': {
        d = util.parseB64(value);
        break;
      }
      case 'prime1': {
        p = util.parseB64(value);
        break;
      }
      case 'prime2': {
        q = util.parseB64(value);
        break;
      }
      case 'exponent1': {
        dp = util.parseB64(value);
        break;
      }
      case 'exponent2': {
        dq = util.parseB64(value);
        break;
      }
      case 'coefficient': {
        qi = util.parseB64(value);
        break;
      }
    }
  }

  if (algorithm === -1)
    throw new Error('Could not determine key algorithm.');

  const key = rsa.privateKeyImport({ n, e, d, p, q, dp, dq, qi });

  return [algorithm, key];
};

keys.decodeEC = function decodeEC(str) {
  assert(typeof str === 'string');

  const lines = util.splitLines(str);

  let key = null;
  let algorithm = -1;

  for (const line of lines) {
    const [name, value] = util.splitColon(line);

    switch (name.toLowerCase()) {
      case 'algorithm': {
        const [left] = value.split(/[ \t]/);
        const alg = util.parseU8(left);

        switch (alg) {
          case algs.ECC:
          case algs.ECCGOST:
          case algs.ECDSAP256SHA256:
          case algs.ECDSAP384SHA384:
          case algs.ED25519:
          case algs.ED448:
            break;
          default:
            throw new Error(`Not an EC algorithm: ${algToString(alg)}.`);
        }

        algorithm = alg;

        break;
      }
      case 'privatekey': {
        key = util.parseB64(value);
        break;
      }
    }
  }

  if (algorithm === -1)
    throw new Error('Could not determine key algorithm.');

  if (!key)
    throw new Error('No private key found.');

  let valid = false;

  switch (algorithm) {
    case algs.ECDSAP256SHA256:
      valid = p256.privateKeyVerify(key);
      break;
    case algs.ECDSAP384SHA384:
      valid = p384.privateKeyVerify(key);
      break;
    case algs.ED25519:
      valid = ed25519.privateKeyVerify(key);
      break;
    case algs.ED448:
      valid = false;
      break;
    default:
      throw new Error(`Unsupported key algorithm: ${algToString(algorithm)}.`);
  }

  if (!valid)
    throw new Error(`Invalid key for algorithm: ${algToString(algorithm)}.`);

  return [algorithm, key];
};

keys.readPrivate = function readPrivate(dir, name, algorithm, keyTag) {
  assert(typeof dir === 'string');

  if (typeof name !== 'string') {
    const rr = name;

    assert(rr instanceof Record);

    const rd = rr.data;

    if (rr.type === types.DNSKEY) {
      name = rr.name;
      algorithm = rd.algorithm;
      keyTag = rd.keyTag();
    } else if (rr.type === types.DS) {
      name = rr.name;
      algorithm = rd.algorithm;
      keyTag = rd.keyTag;
    } else {
      throw new TypeError('Not a DNSKEY or DS record.');
    }
  }

  const file = keys.privFile(name, algorithm, keyTag);
  const str = readFile(dir, file, 'utf8');

  if (!str)
    return null;

  const [alg, priv] = keys.decodePrivate(str);

  if (alg !== algorithm)
    throw new Error('Algorithm mismatch for private key.');

  return priv;
};

keys.readPrivateAsync = async function readPrivateAsync(dir, name, algorithm, keyTag) {
  assert(typeof dir === 'string');

  if (typeof name !== 'string') {
    const rr = name;

    assert(rr instanceof Record);

    const rd = rr.data;

    if (rr.type === types.DNSKEY) {
      name = rr.name;
      algorithm = rd.algorithm;
      keyTag = rd.keyTag();
    } else if (rr.type === types.DS) {
      name = rr.name;
      algorithm = rd.algorithm;
      keyTag = rd.keyTag;
    } else {
      throw new TypeError('Not a DNSKEY or DS record.');
    }
  }

  const file = keys.privFile(name, algorithm, keyTag);
  const str = await readFileAsync(dir, file, 'utf8');

  if (!str)
    return null;

  const [alg, priv] = keys.decodePrivate(str);

  if (alg !== algorithm)
    throw new Error('Algorithm mismatch for private key.');

  return priv;
};

keys.readPublic = function readPublic(dir, name, algorithm, keyTag) {
  assert(typeof dir === 'string');

  if (typeof name !== 'string') {
    const rr = name;

    assert(rr instanceof Record);

    const rd = rr.data;

    if (rr.type === types.DNSKEY) {
      name = rr.name;
      algorithm = rd.algorithm;
      keyTag = rd.keyTag();
    } else if (rr.type === types.DS) {
      name = rr.name;
      algorithm = rd.algorithm;
      keyTag = rd.keyTag;
    } else {
      throw new TypeError('Not a DNSKEY or DS record.');
    }
  }

  const file = keys.pubFile(name, algorithm, keyTag);
  const str = readFile(dir, file, 'utf8');

  if (!str)
    return null;

  const key = Record.fromString(str);

  if (key.type !== types.DNSKEY)
    throw new Error('Type mismatch for public key.');

  if (key.data.keyTag() !== keyTag)
    throw new Error('DS mismatch for public key.');

  return key;
};

keys.readPublicAsync = async function readPublicAsync(dir, name, algorithm, keyTag) {
  assert(typeof dir === 'string');

  if (typeof name !== 'string') {
    const rr = name;

    assert(rr instanceof Record);

    const rd = rr.data;

    if (rr.type === types.DNSKEY) {
      name = rr.name;
      algorithm = rd.algorithm;
      keyTag = rd.keyTag();
    } else if (rr.type === types.DS) {
      name = rr.name;
      algorithm = rd.algorithm;
      keyTag = rd.keyTag;
    } else {
      throw new TypeError('Not a DNSKEY or DS record.');
    }
  }

  const file = keys.pubFile(name, algorithm, keyTag);
  const str = await readFileAsync(dir, file, 'utf8');

  if (!str)
    return null;

  const key = Record.fromString(str);

  if (key.type !== types.DNSKEY)
    throw new Error('Type mismatch for public key.');

  if (key.data.keyTag() !== keyTag)
    throw new Error('DS mismatch for public key.');

  return key;
};

keys.writeKeys = function writeKeys(dir, rr, priv, time) {
  keys.writePrivate(dir, rr, priv, time);
  keys.writePublic(dir, rr);
};

keys.writeKeysAsync = async function writeKeysAsync(dir, rr, priv, time) {
  await keys.writePrivateAsync(dir, rr, priv, time);
  await keys.writePublicAsync(dir, rr);
};

keys.writePrivate = function writePrivate(dir, rr, priv, time) {
  assert(typeof dir === 'string');
  assert(rr instanceof Record);
  assert(rr.type === types.DNSKEY);
  assert((priv != null && priv._isBuffer === true));

  const rd = rr.data;
  const file = keys.privFile(rr.name, rd.algorithm, rd.keyTag());
  const txt = keys.encodePrivate(rd.algorithm, priv, time);

  writeFile(dir, file, txt + '\n', 'utf8');
};

keys.writePrivateAsync = async function writePrivateAsync(dir, rr, priv, time) {
  assert(typeof dir === 'string');
  assert(rr instanceof Record);
  assert(rr.type === types.DNSKEY);
  assert((priv != null && priv._isBuffer === true));

  const rd = rr.data;
  const file = keys.privFile(rr.name, rd.algorithm, rd.keyTag());
  const txt = keys.encodePrivate(rd.algorithm, priv, time);

  return writeFileAsync(dir, file, txt + '\n', 'utf8');
};

keys.writePublic = function writePublic(dir, rr) {
  assert(typeof dir === 'string');
  assert(rr instanceof Record);
  assert(rr.type === types.DNSKEY);

  const rd = rr.data;
  const file = keys.pubFile(rr.name, rd.algorithm, rd.keyTag());
  const txt = rr.toString();

  writeFile(dir, file, txt + '\n', 'utf8');
};

keys.writePublicAsync = async function writePublicAsync(dir, rr) {
  assert(typeof dir === 'string');
  assert(rr instanceof Record);
  assert(rr.type === types.DNSKEY);

  const rd = rr.data;
  const file = keys.pubFile(rr.name, rd.algorithm, rd.keyTag());
  const txt = rr.toString();

  return writeFileAsync(dir, file, txt + '\n', 'utf8');
};

/*
 * Helpers
 */

function readFile(dir, file, enc) {
  assert(typeof dir === 'string');
  assert(typeof file === 'string');
  assert(enc == null || typeof enc === 'string');

  const path = Path.resolve(dir, file);

  try {
    return fs.readFileSync(path, enc);
  } catch (e) {
    if (e.code === 'ENOENT')
      return null;
    throw e;
  }
}

async function readFileAsync(dir, file, enc) {
  assert(typeof dir === 'string');
  assert(typeof file === 'string');
  assert(enc == null || typeof enc === 'string');

  const path = Path.resolve(dir, file);

  try {
    return await fs.readFile(path, enc);
  } catch (e) {
    if (e.code === 'ENOENT')
      return null;
    throw e;
  }
}

function writeFile(dir, file, txt, enc) {
  assert(typeof dir === 'string');
  assert(typeof file === 'string');
  assert(typeof txt === 'string');
  assert(enc == null || typeof enc === 'string');

  const path = Path.resolve(dir, file);

  fs.writeFileSync(path, txt, enc);
}

async function writeFileAsync(dir, file, txt, enc) {
  assert(typeof dir === 'string');
  assert(typeof file === 'string');
  assert(typeof txt === 'string');
  assert(enc == null || typeof enc === 'string');

  const path = Path.resolve(dir, file);

  return fs.writeFile(path, txt, enc);
}
}],
[/* 101 */ 'bns-plus', '/lib/error.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * error.js - dns error for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 */



const constants = __browser_require__(11 /* './constants' */, module);

const {
  codes,
  codeToString
} = constants;

/**
 * DNS Error
 * @extends {Error}
 */

class DNSError extends Error {
  constructor(msg, code) {
    super();

    if (typeof msg === 'number') {
      code = msg;
      msg = '';
    }

    if (code == null)
      code = codes.SERVFAIL;

    if (msg)
      msg = `: ${msg}.`;
    else
      msg = '';

    this.type = 'DNSError';
    this.name = 'DNSError';
    this.code = `E${codeToString(code)}`;
    this.errno = code;
    this.message = `${this.code}${msg}`;

    if (Error.captureStackTrace)
      Error.captureStackTrace(this, DNSError);
  }
}

/*
 * Expose
 */

module.exports = DNSError;
}],
[/* 102 */ 'bns-plus', '/lib/internal/net.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * net.js - dns server for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const EventEmitter = __browser_require__(3 /* 'events' */, module);
const IP = __browser_require__(4 /* 'binet' */, module);
const tcp = __browser_require__(103 /* 'btcp' */, module);
const udp = __browser_require__(105 /* 'budp' */, module);
const bio = __browser_require__(14 /* 'bufio' */, module);
const util = __browser_require__(79 /* '../util' */, module);
const hasIPv6 = IP.getPublic('ipv6').length > 0;

/**
 * Base
 * @extends EventEmitter
 */

class Base extends EventEmitter {
  /**
   * Create a base socket.
   * @constructor
   * @param {Function?} handler
   */

  constructor(options) {
    super();

    const opt = normalize(options);

    this.inet6 = opt.type === 'udp6';
    this.tcp = true;
    this.socket = udp.createSocket(opt);
    this.sockets = new Map();

    if (options && typeof options === 'object') {
      if (options.tcp != null) {
        assert(typeof options.tcp === 'boolean');
        this.tcp = options.tcp;
      }

      if (options.forceTCP != null) {
        assert(typeof options.forceTCP === 'boolean');
        if (options.forceTCP)
          this.tcp = true;
      }
    }

    this.init();
  }

  init() {
    this.socket.on('close', () => {
      this.emit('close');
    });

    this.socket.on('error', (err) => {
      this.emit('error', err);
    });

    this.socket.on('listening', () => {
      this.emit('listening');
    });

    this.socket.on('message', (msg, rinfo) => {
      const {address, port} = rinfo;
      const ip = IP.toBuffer(address);
      const v4 = IP.isIPv4(ip);
      this.emit('message', msg, {
        tcp: false,
        family: v4 ? 'IPv4' : 'IPv6',
        address: IP.toString(ip),
        port
      });
    });
  }

  addMembership(addr, iface) {
    this.socket.addMembership(addr, iface);
    return this;
  }

  address() {
    const {address, port} = this.socket.address();
    const host = this.inet6 ? ensure6(address) : ensure4(address);
    const ip = IP.toBuffer(host);
    const v4 = IP.isIPv4(ip);
    return {
      family: v4 ? 'IPv4' : 'IPv6',
      address: IP.toString(ip),
      port
    };
  }

  async bind(...args) {
    if (args.length > 1) {
      const [, host] = args;
      if (typeof host === 'string') {
        assert(util.isIP(host), 'Must bind to an IP address.');
        args[1] = this.inet6 ? ensure6(host) : ensure4(host);
      }
    }
    return this.socket.bind(...args);
  }

  async close() {
    for (const socket of this.sockets.values())
      socket.destroy();
    return this.socket.close();
  }

  dropMembership(addr, iface) {
    this.socket.dropMembership(addr, iface);
    return this;
  }

  getRecvBufferSize() {
    return this.socket.getRecvBufferSize();
  }

  getSendBufferSize() {
    return this.socket.getSendBufferSize();
  }

  ref() {
    this.socket.ref();
    return this;
  }

  async write(msg, port, host) {
    throw new Error('Abstract.');
  }

  async send(msg, pos, len, port, host, tcp) {
    if (this.tcp && tcp) {
      if (pos !== 0 && len !== msg.length)
        msg = msg.slice(pos, pos + len);
      return this.write(msg, port, host);
    }

    host = this.inet6 ? ensure6(host) : ensure4(host);

    return this.socket.send(msg, pos, len, port, host);
  }

  setBroadcast(flag) {
    this.socket.setBroadcast(flag);
    return this;
  }

  setMulticastInterface(iface) {
    this.socket.setMulticastInterface(iface);
    return this;
  }

  setMulticastLoopback(flag) {
    this.socket.setMulticastLoopback(flag);
    return this;
  }

  setMulticastTTL(ttl) {
    this.socket.setMulticastTTL(ttl);
    return this;
  }

  setRecvBufferSize(size) {
    this.socket.setRecvBufferSize(size);
    return this;
  }

  setSendBufferSize(size) {
    this.socket.setSendBufferSize(size);
    return this;
  }

  setTTL(ttl) {
    this.socket.setTTL(ttl);
    return this;
  }

  unref() {
    this.socket.unref();
    return this;
  }
}

/**
 * Client
 * @extends EventEmitter
 */

class Client extends Base {
  /**
   * Create a UDP socket.
   * @constructor
   * @param {Function?} handler
   */

  constructor(options) {
    super(options);
    this.socket.unref();
  }

  async write(msg, port, host) {
    const key = IP.toHost(host, port);
    const cache = this.sockets.get(key);

    if (cache) {
      cache.write(msg);
      return;
    }

    let socket = null;

    try {
      socket = await TCPSocket.connect(this, port, host);
    } catch (e) {
      return;
    }

    if (this.sockets.has(key)) {
      socket.destroy();
      socket = this.sockets.get(key);
    } else {
      socket.parent = this;
      this.sockets.set(key, socket);
    }

    socket.write(msg);
  }

  drop(port, host) {
    const key = IP.toHost(host, port);
    const socket = this.sockets.get(key);
    if (socket && socket.pending === 0)
      socket.destroy();
  }

  kill(port, host) {
    const key = IP.toHost(host, port);
    const socket = this.sockets.get(key);
    if (socket)
      socket.destroy();
  }
}

/**
 * Server
 * @extends EventEmitter
 */

class Server extends Base {
  /**
   * Create a UDP socket.
   * @constructor
   * @param {Function?} handler
   */

  constructor(options) {
    super(options);

    this.server = tcp.createServer();

    this.server.on('error', (err) => {
      this.emit('error', err);
    });

    this.server.on('connection', (conn) => {
      try {
        this._handleSocket(conn);
      } catch (e) {
        this.emit('error', e);
      }
    });
  }

  _handleSocket(conn) {
    if (!conn.remoteAddress) {
      conn.destroy();
      return;
    }

    const socket = TCPSocket.accept(this, conn);
    const key = IP.toHost(socket.host, socket.port);

    this.sockets.set(key, socket);
  }

  async bind(...args) {
    if (this.tcp)
      await this.server.listen(...args);
    return super.bind(...args);
  }

  async close() {
    if (this.tcp)
      await this.server.close();
    return super.close();
  }

  async write(msg, port, host) {
    const key = IP.toHost(host, port);
    const socket = this.sockets.get(key);

    if (socket)
      socket.write(msg);
  }

  get maxConnections() {
    return this.server.maxConnections;
  }

  set maxConnections(max) {
    this.server.maxConnections = max;
  }
}

/**
 * TCPSocket
 * @extends EventEmitter
 */

class TCPSocket extends EventEmitter {
  constructor(parent) {
    super();

    assert(parent);

    this.parent = parent;
    this.socket = new tcp.Socket();
    this.ctimer = null;
    this.btimer = null;
    this.connected = false;
    this.destroyed = false;
    this.parser = new Parser();
    this.buffered = 0;
    this.family = 'IPv4';
    this.host = '0.0.0.0';
    this.port = 0;
    this.pending = 0;

    this.init();
  }

  fire(...args) {
    this.parent.emit(...args);
  }

  init() {
    this.parser.on('message', (data) => {
      const rinfo = {
        tcp: true,
        family: this.family,
        address: this.host,
        port: this.port
      };

      if (this.pending > 0)
        this.pending -= 1;

      this.fire('message', data, rinfo);
    });
  }

  bind() {
    this.socket.once('error', (err) => {
      if (!this.connected)
        return;

      this.fire('error', err);
      this.destroy();
    });

    this.socket.once('close', () => {
      if (!this.connected)
        return;

      this.destroy();
    });

    this.socket.on('drain', () => {
      if (!this.connected)
        return;

      this.buffered = 0;
    });

    this.socket.on('data', (data) => {
      if (!this.connected)
        return;

      this.parser.feed(data);
    });

    this.socket.setNoDelay(true);

    this.btimer = setInterval(() => this.timeout(), 5000);
  }

  timeout() {
    if (this.buffered > (2 << 20))
      this.destroy();
  }

  accept(socket) {
    this.socket = socket;
    this.connected = true;
    this.family = socket.remoteFamily;
    this.host = IP.normalize(socket.remoteAddress);
    this.port = socket.remotePort;
    this.bind();
    return this;
  }

  async connect(...args) {
    if (this.connected)
      return this;

    this.socket.connect(...args);
    this.socket.unref();

    return new Promise((resolve, reject) => {
      const cleanup = () => {
        if (this.ctimer != null) {
          clearTimeout(this.ctimer);
          this.ctimer = null;
        }
        // eslint-disable-next-line no-use-before-define
        this.socket.removeListener('error', onError);
      };

      const onError = (err) => {
        cleanup();
        reject(err);
      };

      this.socket.once('connect', () => {
        this.connected = true;
        this.family = this.socket.remoteFamily;
        this.host = IP.normalize(this.socket.remoteAddress);
        this.port = this.socket.remotePort;
        this.bind();

        cleanup();
        resolve(this);
      });

      this.socket.once('error', onError);

      this.ctimer = setTimeout(() => {
        this.ctimer = null;
        cleanup();
        reject(new Error('Connection timed out.'));
      }, 10000);
    });
  }

  cleanup() {
    if (!this.connected)
      return;

    if (this.ctimer != null) {
      clearInterval(this.ctimer);
      this.ctimer = null;
    }

    if (this.btimer != null) {
      clearInterval(this.btimer);
      this.btimer = null;
    }

    const key = IP.toHost(this.host, this.port);

    if (this.parent.sockets.get(key) === this)
      this.parent.sockets.delete(key);

    this.connected = false;
  }

  close() {
    if (!this.connected)
      return this;

    this.cleanup();
    this.socket.end();

    return this;
  }

  destroy() {
    if (this.destroyed)
      return this;

    this.destroyed = true;
    this.cleanup();
    this.socket.destroy();

    return this;
  }

  write(msg) {
    if (this.buffered > (5 << 20)) {
      this.destroy();
      return false;
    }

    const buf = Buffer.allocUnsafe(2);
    bio.writeU16BE(buf, msg.length, 0);

    this.socket.write(buf);
    this.pending += 1;

    return this.socket.write(msg);
  }

  static accept(parent, socket) {
    return new this(parent).accept(socket);
  }

  static connect(parent, ...args) {
    return new this(parent).connect(...args);
  }
}

/**
 * Parser
 * @extends EventEmitter
 */

class Parser extends EventEmitter {
  constructor() {
    super();
    this.pending = [];
    this.total = 0;
    this.waiting = 2;
    this.hasSize = false;
  }

  feed(data) {
    this.total += data.length;
    this.pending.push(data);

    while (this.total >= this.waiting) {
      const chunk = Buffer.allocUnsafe(this.waiting);

      let off = 0;

      while (off < chunk.length) {
        const len = this.pending[0].copy(chunk, off);
        if (len === this.pending[0].length)
          this.pending.shift();
        else
          this.pending[0] = this.pending[0].slice(len);
        off += len;
      }

      assert.strictEqual(off, chunk.length);

      this.total -= chunk.length;

      if (!this.hasSize) {
        this.waiting = bio.readU16BE(chunk, 0);
        this.hasSize = true;
        continue;
      }

      this.waiting = 2;
      this.hasSize = false;

      this.emit('message', chunk);
    }
  }
}

/*
 * Helpers
 */

function ensure4(host) {
  const ip = IP.toBuffer(host);

  if (IP.isIPv4(ip))
    return host;

  if (IP.isNull(ip))
    return '0.0.0.0';

  if (IP.isLocal(ip))
    return '127.0.0.1';

  return host;
}

function ensure6(host) {
  const ip = IP.toBuffer(host);

  if (!IP.isIPv4(ip))
    return host;

  return `::ffff:${IP.toString(ip)}`;
}

function normalize(options) {
  let type = hasIPv6 ? 'udp6' : 'udp4';

  if (options == null)
    return { type };

  if (typeof options === 'string') {
    assert(options === 'udp4' || options === 'udp6');
    return { type: options };
  }

  if (typeof options !== 'object')
    throw new Error('Invalid options object.');

  if (options.type != null) {
    assert(options.type === 'udp4' || options.type === 'udp6');
    type = options.type;
  } else if (options.inet6 != null) {
    assert(typeof options.inet6 === 'boolean');
    type = options.inet6 ? 'udp6' : 'udp4';
  }

  const opt = { type };

  if (options.reuseAddr != null)
    opt.reuseAddr = options.reuseAddr;

  if (options.recvBufferSize != null)
    opt.recvBufferSize = options.recvBufferSize;

  if (options.sendBufferSize != null)
    opt.sendBufferSize = options.sendBufferSize;

  return opt;
}

/*
 * Expose
 */

exports.Client = Client;
exports.Server = Server;
}],
[/* 103 */ 'btcp', '/lib/btcp.js', function(exports, require, module, __filename, __dirname, __meta) {
module.exports = __browser_require__(104 /* './tcp' */, module);
}],
[/* 104 */ 'btcp', '/lib/tcp-browser.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * tcp.js - tcp backend for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

/* eslint prefer-arrow-callback: "off" */



const EventEmitter = __browser_require__(3 /* 'events' */, module);

/**
 * Socket
 * @extends EventEmitter
 */

class Socket extends EventEmitter {
  /**
   * Create a TCP server.
   * @constructor
   * @param {Function?} handler
   */

  constructor() {
    super();
    this.readable = true;
    this.writable = true;
    this.encrypted = false;
    this.bufferSize = 0;
    this.bytesRead = 0;
    this.bytesWritten = 0;
    this.connecting = false;
    this.destroyed = false;
    this.localAddress = '127.0.0.1';
    this.localPort = 0;
    this.remoteAddress = '127.0.0.1';
    this.remoteFamily = 'IPv4';
    this.remotePort = 0;
  }

  address() {
    return {
      address: '127.0.0.1',
      family: 'IPv4',
      port: 0
    };
  }

  connect(port, host) {
    throw new Error('Unsupported.');
  }

  destroy(err) {
    return this;
  }

  end(data, enc) {
    throw new Error('Unsupported.');
  }

  pause() {
    return this;
  }

  ref() {
    return this;
  }

  resume() {
    return this;
  }

  setEncoding(enc) {
    return this;
  }

  setKeepAlive(enable, delay) {
    return this;
  }

  setNoDelay(value) {
    return this;
  }

  setTimeout(timeout, callback) {
    return this;
  }

  unref() {
    return this;
  }

  write(data, enc) {
    throw new Error('Unsupported.');
  }
}

/**
 * Server
 * @extends EventEmitter
 */

class Server extends EventEmitter {
  /**
   * Create a TCP server.
   * @constructor
   * @param {Function?} handler
   */

  constructor(handler) {
    super();
  }

  address() {
    return {
      address: '127.0.0.1',
      family: 'IPv4',
      port: 0
    };
  }

  async close() {
    return;
  }

  async getConnections() {
    return 0;
  }

  async listen(...args) {
    const address = this.address();
    this.emit('listening', address);
    return address;
  }

  get listening() {
    return false;
  }

  set listening(value) {}

  get maxConnections() {
    return undefined;
  }

  set maxConnections(value) {}

  ref() {
    return this;
  }

  unref() {
    return this;
  }
}

/*
 * Constants
 */

exports.unsupported = true;

/**
 * Socket
 * @constructor
 */

exports.Socket = Socket;

/**
 * Server
 * @constructor
 */

exports.Server = Server;

/**
 * Create a TCP socket and connect.
 * @param {Number} port
 * @param {String} host
 * @returns {Object}
 */

exports.connect = function(port, host) {
  throw new Error('Unsupported.');
};

/**
 * Create a TCP socket and connect.
 * @param {Number} port
 * @param {String} host
 * @returns {Object}
 */

exports.createSocket = exports.connect;

/**
 * Create a TCP socket and connect.
 * @param {Number} port
 * @param {String} host
 * @returns {Object}
 */

exports.createConnection = exports.connect;

/**
 * Create a TCP server.
 * @param {Function?} handler
 * @returns {Object}
 */

exports.createServer = function createServer(handler) {
  return new Server(handler);
};
}],
[/* 105 */ 'budp', '/lib/budp.js', function(exports, require, module, __filename, __dirname, __meta) {
module.exports = __browser_require__(106 /* './udp' */, module);
}],
[/* 106 */ 'budp', '/lib/udp-browser.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * udp.js - udp backend for bcoin
 * Copyright (c) 2014-2017, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */

/* eslint prefer-arrow-callback: "off" */



const EventEmitter = __browser_require__(3 /* 'events' */, module);

/**
 * Socket
 * @extends EventEmitter
 */

class Socket extends EventEmitter {
  /**
   * Create a UDP socket.
   * @constructor
   */

  constructor(type) {
    super();
    this.type = type;
  }

  addMembership(addr, iface) {
    return this;
  }

  address() {
    return {
      family: this.type === 'udp6' ? 'IPv6' : 'IPv4',
      address: this.type === 'udp6' ? '::' : '0.0.0.0',
      port: 0
    };
  }

  async bind() {
    const address = this.address();
    this.emit('listening', address);
    return address;
  }

  async close() {
    this.emit('close');
  }

  dropMembership(addr, iface) {
    return this;
  }

  getRecvBufferSize() {
    return 512;
  }

  getSendBufferSize() {
    return 512;
  }

  hasBufferSize() {
    return true;
  }

  ref() {
    return this;
  }

  async send() {}

  setBroadcast(flag) {
    return this;
  }

  setMulticastInterface(iface) {
    return this;
  }

  setMulticastLoopback(flag) {
    return this;
  }

  setMulticastTTL(ttl) {
    return this;
  }

  setRecvBufferSize(size) {
    return this;
  }

  setSendBufferSize(size) {
    return this;
  }

  setTTL(ttl) {
    return this;
  }

  unref() {
    return this;
  }
}

/*
 * Constants
 */

exports.unsupported = true;

/**
 * Create a UDP socket.
 * @param {Object|String} options
 * @param {Function} cb
 * @returns {Object}
 */

exports.createSocket = function createSocket(options, cb) {
  let type = 'udp4';

  if (typeof options === 'object' && options && options.type)
    type = options.type;
  else if (typeof options === 'string')
    type = options;

  return new Socket(type);
};
}],
[/* 107 */ 'bns-plus', '/lib/zone.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * hints.js - root hints object for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 *
 * Parts of this software are based on solvere:
 *   https://github.com/rolandshoemaker/solvere
 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const fs = __browser_require__(84 /* 'bfile' */, module);
const constants = __browser_require__(11 /* './constants' */, module);
const util = __browser_require__(79 /* './util' */, module);
const wire = __browser_require__(90 /* './wire' */, module);
const dnssec = __browser_require__(99 /* './dnssec' */, module);
const {keyFlags} = dnssec;
const {ZONE} = keyFlags;


const {
  types,
  codes
} = constants;

const {
  Message,
  Record
} = wire;

/*
 * Constants
 */

const ROOT_HINTS = __browser_require__(108 /* './roothints' */, module);

/*
 * Cache
 */

let hints = null;

/**
 * Zone
 */

class Zone {
  constructor(origin) {
    this.origin = '.';
    this.count = 0;
    this.names = new Map();
    this.wild = new RecordMap(this);
    this.nsec = new NameList();
    this.zskpriv = null;
    this.zskkey = null;
    this.setOrigin(origin);
  }

  clear() {
    this.origin = '.';
    this.count = 0;
    this.clearRecords();
    return this;
  }

  clearRecords() {
    this.names.clear();
    this.wild.clear();
    this.nsec.clear();
    return this;
  }

  setZSKFromString(str) {
    const [alg, zskpriv] = dnssec.decodePrivate(str);
    this.zskpriv = zskpriv;
    this.zskkey = dnssec.makeKey(this.origin, alg, zskpriv, ZONE);
  }

  setOrigin(origin) {
    if (origin == null)
      origin = '.';

    assert(util.isFQDN(origin));

    this.origin = origin.toLowerCase();
    this.count = util.countLabels(this.origin);

    return this;
  }

  insert(record) {
    assert(record instanceof Record);

    const rr = record.deepClone();

    // Lowercase.
    rr.canonical();

    if (rr.type !== types.A && rr.type !== types.AAAA) {
      // Skip check for A and AAAA due to glue.
      if (!util.isSubdomain(this.origin, rr.name))
        throw new Error('Not a child of this zone.');
    }

    if (isWild(rr.name)) {
      this.wild.insert(rr);
    } else {
      if (!this.names.has(rr.name))
        this.names.set(rr.name, new RecordMap(this));

      const map = this.names.get(rr.name);

      map.insert(rr);
    }

    switch (rr.type) {
      case types.NSEC: {
        this.nsec.insert(rr.name);
        break;
      }
    }

    return this;
  }

  push(name, type, an) {
    assert(util.isFQDN(name));
    assert((type & 0xffff) === type);
    assert(Array.isArray(an));

    const map = this.names.get(name);

    if (map)
      map.push(name, type, an);
    else
      this.wild.push(name, type, an);

    return this;
  }

  get(name, type) {
    const an = [];
    this.push(name, type, an);
    return an;
  }

  has(name, type) {
    assert(util.isFQDN(name));
    assert((type & 0xffff) === type);

    const map = this.names.get(name);

    if (!map)
      return false;

    return map.rrs.has(type);
  }

  glue(name, an, type, ns) {
    assert(util.isFQDN(name));
    assert(Array.isArray(an));

    const initial = an.length;

    if (!type) {
      this.push(name, types.A, an);
      this.push(name, types.AAAA, an);
    } else {
      this.push(name, type, an);
    }

    const final = an.length;

    // If the only answer we have is a CNAME with no "glue",
    // include an SOA in the authority section, just like
    // if we had no answer for a name we're authoritative over.
    if (initial === final)
      this.push(name, types.SOA, ns);

    return this;
  }

  find(name, type) {
    const an = this.get(name, type);
    const ar = [];
    const ns = [];

    for (const rr of an) {
      switch (rr.type) {
        case types.CNAME:
          this.glue(rr.data.target, an, type, ns);
          break;
        case types.DNAME:
          this.glue(rr.data.target, an, type, ns);
          break;
        case types.NS:
          this.glue(rr.data.ns, ar);
          break;
        case types.SOA:
          this.glue(rr.data.ns, ar);
          break;
        case types.MX:
          this.glue(rr.data.mx, ar);
          break;
        case types.SRV:
          this.glue(rr.data.target, ar);
          break;
      }
    }

    return [an, ar, ns];
  }

  getHints() {
    if (!hints) {
      hints = wire.fromZone(ROOT_HINTS, '.');
      for (const rr of hints)
        rr.canonical();
    }

    const ns = [];
    const ar = [];

    for (const rr of hints) {
      switch (rr.type) {
        case types.NS:
          ns.push(rr);
          break;
        case types.A:
        case types.AAAA:
          ar.push(rr);
          break;
      }
    }

    return [ns, ar];
  }

  proveNoData(ns) {
    this.push(this.origin, types.NSEC, ns);
    return this;
  }

  proveNameError(name, ns) {
    const lower = this.nsec.lower(name);

    if (lower)
      this.push(lower, types.NSEC, ns);

    this.proveNoData(ns);

    return this;
  }

  query(name, type) {
    assert(util.isFQDN(name));
    assert((type & 0xffff) === type);

    const labels = util.split(name);
    const zone = util.from(name, labels, -this.count);
    const authority = util.equal(zone, this.origin);

    let [an, ar, ns] = this.find(name, type);
    let glue;

    // Do we have an answer?
    if (an.length > 0) {
      // Are we authoritative for this name?
      if (!authority) {
        // If we're not authoritative for this
        // name, this is probably a request
        // for a DS or NSEC record.
        if (type === types.NS) {
          // Exception: always send a
          // referral for an NS request.
          this.push(name, types.DS, an);
          return [[], an, ar, false, true];
        }

        return [an, [], ar, false, true];
      }

      // We're authoritative. Send the
      // answer and set the `aa` bit.
      return [an, ns, ar, true, true];
    }

    // Couldn't find anything.
    // Serve an SoA (no data).
    if (authority) {
      const ns = this.get(this.origin, types.SOA);
      this.proveNoData(ns);
      return [[], ns, [], true, false];
    }

    // Otherwise, they're requesting a
    // deeper subdomain of a name we
    // might have a referral for.
    const index = this.count + 1;
    const child = util.from(name, labels, -index);
    [ns, glue] = this.find(child, types.NS);

    // Couldn't find any nameservers.
    // Serve an SoA (nxdomain).
    if (ns.length === 0) {
      let ns = [];
      // The root zone can prove the TLD doesn't exist with authority
      // but regular authoritative name servers should be as quiet as possible.
      if (this.origin === '.') {
        ns = this.get(this.origin, types.SOA);
        this.proveNameError(child, ns);
      }
      return [[], ns, [], false, false];
    }

    // Send a referral, with DS records.
    this.push(child, types.DS, ns);

    return [[], ns, glue, false, true];
  }

  resolve(name, type) {
    assert(util.isFQDN(name));
    assert((type & 0xffff) === type);

    const qname = name.toLowerCase();
    const qtype = type === types.ANY ? types.NS : type;
    const [an, ns, ar, aa, ok] = this.query(qname, qtype);
    const msg = new Message();

    if (!aa && !ok)
      msg.code = codes.NXDOMAIN;

    msg.aa = aa;
    msg.answer = an;
    msg.authority = ns;
    msg.additional = ar;

    return msg;
  }

  fromString(text, file) {
    const rrs = wire.fromZone(text, this.origin, file);

    for (const rr of rrs)
      this.insert(rr);

    return this;
  }

  static fromString(origin, text, file) {
    return new this(origin).fromString(text, file);
  }

  fromFile(file) {
    const text = fs.readFileSync(file, 'utf8');
    return this.fromString(text, file);
  }

  static fromFile(origin, file) {
    return new this(origin).fromFile(file);
  }
}

/**
 * RecordMap
 */

class RecordMap {
  constructor(zone) {
    // type -> rrs
    this.rrs = new Map();
    // type covered -> sigs
    this.sigs = new Map();
    this.zone = zone;
  }

  clear() {
    this.rrs.clear();
    this.sigs.clear();
    return this;
  }

  insert(rr) {
    assert(rr instanceof Record);

    if (!this.rrs.has(rr.type))
      this.rrs.set(rr.type, []);

    const rrs = this.rrs.get(rr.type);

    rrs.push(rr);

    switch (rr.type) {
      case types.RRSIG: {
        const {typeCovered} = rr.data;

        if (!this.sigs.has(typeCovered))
          this.sigs.set(typeCovered, []);

        const sigs = this.sigs.get(typeCovered);
        sigs.push(rr);

        break;
      }
    }

    return this;
  }

  filterMatches(name, rrs) {
    const ret = [];

    for (const rr of rrs) {
      if (!isWild(rr.name)) {
        ret.push(rr);
        continue;
      }

      const x = util.splitName(name);
      const y = util.splitName(rr.name);

      if (x.length < y.length)
        continue;

      // Remove '*' label and test remainder
      y.shift();

      let push = true;
      for (let i = 1; i <= y.length; i++) {
        if (y[y.length - i] !== x[x.length - i]) {
          push = false;
          break;
        }
      }
      if (!push)
        continue;

      ret.push(rr);
    }

    return ret;
  }

  push(name, type, an) {
    assert(util.isFQDN(name));
    assert((type & 0xffff) === type);
    assert(Array.isArray(an));

    // If a name has a CNAME record, there should be no
    // other records for that name in the zone.
    // (RFC 1034 section 3.6.2, RFC 1912 section 2.4)
    if (type !== types.CNAME) {
      let rrs = this.rrs.get(types.CNAME);

      if (rrs && rrs.length > 0) {
        rrs = this.filterMatches(name, rrs);
        for (const rr of rrs)
          an.push(convert(name, rr));

        let sigs = this.sigs.get(types.CNAME);

        if (sigs) {
          sigs = this.filterMatches(name, sigs);
          for (const rr of sigs)
            an.push(convert(name, rr));
        }

        if (!sigs && this.zone.zskkey && this.zone.zskpriv) {
          // Create dnssec sig on the fly (especially useful for wildcard)
          const sig = dnssec.sign(this.zone.zskkey, this.zone.zskpriv, an);
          an.push(sig);
        }

        return this;
      }
    }

    let rrs = this.rrs.get(type);

    if (rrs && rrs.length > 0) {
      rrs = this.filterMatches(name, rrs);
      for (const rr of rrs)
        an.push(convert(name, rr));

      let sigs = this.sigs.get(type);

      if (sigs) {
        sigs = this.filterMatches(name, sigs);
        for (const rr of sigs)
          an.push(convert(name, rr));
      }

      if (!sigs && this.zone.zskkey && this.zone.zskpriv) {
        // Create dnssec sig on the fly (especially useful for wildcard)
        const sig = dnssec.sign(this.zone.zskkey, this.zone.zskpriv, an);
        an.push(sig);
      }
    }

    return this;
  }

  get(name, type) {
    const an = [];
    this.push(name, type, an);
    return an;
  }
}

/**
 * NameList
 */

class NameList {
  constructor() {
    this.names = [];
  }

  clear() {
    this.names.length = 0;
    return this;
  }

  insert(name) {
    return insertString(this.names, name);
  }

  lower(name) {
    return findLower(this.names, name);
  }
}

/*
 * Helpers
 */

function search(items, key, compare, insert) {
  let start = 0;
  let end = items.length - 1;

  while (start <= end) {
    const pos = (start + end) >>> 1;
    const cmp = compare(items[pos], key);

    if (cmp === 0)
      return pos;

    if (cmp < 0)
      start = pos + 1;
    else
      end = pos - 1;
  }

  if (!insert)
    return -1;

  return start;
}

function insert(items, item, compare, uniq) {
  const i = search(items, item, compare, true);

  if (uniq && i < items.length) {
    if (compare(items[i], item) === 0)
      return -1;
  }

  if (i === 0)
    items.unshift(item);
  else if (i === items.length)
    items.push(item);
  else
    items.splice(i, 0, item);

  return i;
}

function insertString(items, name) {
  assert(Array.isArray(items));
  assert(typeof name === 'string');

  return insert(items, name, util.compare, true) !== -1;
}

function findLower(items, name) {
  assert(Array.isArray(items));
  assert(typeof name === 'string');

  if (items.length === 0)
    return null;

  const i = search(items, name, util.compare, true);
  const match = items[i];
  const cmp = util.compare(match, name);

  if (cmp === 0)
    throw new Error('Not an NXDOMAIN.');

  if (cmp < 0)
    return match;

  if (i === 0)
    return null;

  return items[i - 1];
}

function isWild(name) {
  assert(typeof name === 'string');
  if (name.length < 2)
    return false;
  return name[0] === '*' && name[1] === '.';
}

function convert(name, rr) {
  if (!isWild(rr.name))
    return rr;

  rr = rr.clone();

  rr.name = name;

  return rr;
}

/*
 * Expose
 */

module.exports = Zone;
}],
[/* 108 */ 'bns-plus', '/lib/roothints.js', function(exports, require, module, __filename, __dirname, __meta) {
/* eslint max-len: 0 */

module.exports = `
;
; Root Zone
;

. 3600000 IN NS A.ROOT-SERVERS.NET.
A.ROOT-SERVERS.NET. 3600000 IN A 198.41.0.4
A.ROOT-SERVERS.NET. 3600000 IN AAAA 2001:503:ba3e::2:30

. 3600000 IN NS B.ROOT-SERVERS.NET.
B.ROOT-SERVERS.NET. 3600000 IN A 199.9.14.201
B.ROOT-SERVERS.NET. 3600000 IN AAAA 2001:500:200::b

. 3600000 IN NS C.ROOT-SERVERS.NET.
C.ROOT-SERVERS.NET. 3600000 IN A 192.33.4.12
C.ROOT-SERVERS.NET. 3600000 IN AAAA 2001:500:2::c

. 3600000 IN NS D.ROOT-SERVERS.NET.
D.ROOT-SERVERS.NET. 3600000 IN A 199.7.91.13
D.ROOT-SERVERS.NET. 3600000 IN AAAA 2001:500:2d::d

. 3600000 IN NS E.ROOT-SERVERS.NET.
E.ROOT-SERVERS.NET. 3600000 IN A 192.203.230.10
E.ROOT-SERVERS.NET. 3600000 IN AAAA 2001:500:a8::e

. 3600000 IN NS F.ROOT-SERVERS.NET.
F.ROOT-SERVERS.NET. 3600000 IN A 192.5.5.241
F.ROOT-SERVERS.NET. 3600000 IN AAAA 2001:500:2f::f

. 3600000 IN NS G.ROOT-SERVERS.NET.
G.ROOT-SERVERS.NET. 3600000 IN A 192.112.36.4
G.ROOT-SERVERS.NET. 3600000 IN AAAA 2001:500:12::d0d

. 3600000 IN NS H.ROOT-SERVERS.NET.
H.ROOT-SERVERS.NET. 3600000 IN A 198.97.190.53
H.ROOT-SERVERS.NET. 3600000 IN AAAA 2001:500:1::53

. 3600000 IN NS I.ROOT-SERVERS.NET.
I.ROOT-SERVERS.NET. 3600000 IN A 192.36.148.17
I.ROOT-SERVERS.NET. 3600000 IN AAAA 2001:7fe::53

. 3600000 IN NS J.ROOT-SERVERS.NET.
J.ROOT-SERVERS.NET. 3600000 IN A 192.58.128.30
J.ROOT-SERVERS.NET. 3600000 IN AAAA 2001:503:c27::2:30

. 3600000 IN NS K.ROOT-SERVERS.NET.
K.ROOT-SERVERS.NET. 3600000 IN A 193.0.14.129
K.ROOT-SERVERS.NET. 3600000 IN AAAA 2001:7fd::1

. 3600000 IN NS L.ROOT-SERVERS.NET.
L.ROOT-SERVERS.NET. 3600000 IN A 199.7.83.42
L.ROOT-SERVERS.NET. 3600000 IN AAAA 2001:500:9f::42

. 3600000 IN NS M.ROOT-SERVERS.NET.
M.ROOT-SERVERS.NET. 3600000 IN A 202.12.27.33
M.ROOT-SERVERS.NET. 3600000 IN AAAA 2001:dc3::35

;
; Trust Anchors
;

. 172800 IN DS 19036 8 2 49AAC11D7B6F6446702E54A1607371607A1A41855200FD2CE1CDDE32F24E8FB5
. 172800 IN DS 20326 8 2 E06D44B80B8F1D39A95C0B0D7C65D08458E880409BBC683457104237C7F8EC8D
`;
}],
[/* 109 */ 'bns-plus', '/lib/cache.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * cache.js - resolver cache for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 *
 * Parts of this software are based on solvere:
 *   https://github.com/rolandshoemaker/solvere
 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const Heap = __browser_require__(110 /* 'bheep' */, module);
const bio = __browser_require__(14 /* 'bufio' */, module);
const wire = __browser_require__(90 /* './wire' */, module);
const util = __browser_require__(79 /* './util' */, module);
const {Message, Question} = wire;

/**
 * Cache
 */

class Cache {
  constructor() {
    this.map = new Map();
    this.queue = new Heap((a, b) => a[1] - b[1]);
    this.size = 0;
    this.maxSize = 5 << 20;
  }

  get(id) {
    return this.map.get(id) || null;
  }

  has(id) {
    return this.map.has(id);
  }

  set(id, entry) {
    this.map.set(id, entry);
    return this;
  }

  remove(id) {
    this.map.delete(id);
    return this;
  }

  hash(qs, zone) {
    const n = qs.name.toLowerCase();
    const t = qs.type.toString(10);
    const z = zone.toLowerCase();
    return `${n};${t};${z}`;
  }

  prune() {
    while (this.size > this.maxSize) {
      const [id, deadline] = this.queue.shift();
      const entry = this.get(id);

      if (entry && entry.deadline() === deadline) {
        this.size -= entry.usage(id);
        this.remove(id);
      }

      this.size -= queueUsage(id);
    }

    return this;
  }

  insert(qs, zone, msg, ad, eternal = false) {
    assert(qs instanceof Question);
    assert(typeof zone === 'string');
    assert(msg instanceof Message);
    assert(typeof ad === 'boolean');
    assert(typeof eternal === 'boolean');

    const id = this.hash(qs, zone);
    const ttl = msg.minTTL();

    if (ttl === 0)
      return this;

    const item = this.get(id);

    if (item) {
      if (item.eternal)
        return this;

      const raw = msg.encode();

      this.size -= item.usage(id);

      item.msg = raw;
      item.setAD(ad);
      item.time = util.now();
      item.ttl = ttl;

      this.size += item.usage(id);

      this.size += queueUsage(id);
      this.queue.insert([id, item.deadline()]);
      this.prune();

      return this;
    }

    const raw = msg.encode();
    const entry = new CacheEntry(raw);

    entry.setAD(ad);
    entry.time = util.now();
    entry.ttl = ttl;
    entry.eternal = eternal;

    this.set(id, entry);
    this.size += entry.usage(id);

    if (!eternal) {
      this.size += queueUsage(id);
      this.queue.insert([id, entry.deadline()]);
      this.prune();
    }

    return this;
  }

  hit(qs, zone) {
    assert(qs instanceof Question);
    assert(typeof zone === 'string');

    const id = this.hash(qs, zone);
    const entry = this.get(id);

    if (!entry)
      return null;

    const now = util.now();

    if (entry.expired(now)) {
      this.size -= entry.usage(id);
      this.remove(id);
      return null;
    }

    const msg = Message.decode(entry.msg);
    const diff = now - entry.time;

    assert(diff >= 0);

    for (const rr of msg.records()) {
      if (rr.isOPT())
        continue;

      if (rr.ttl === 0)
        continue;

      if (rr.ttl <= diff) {
        rr.ttl = 1;
        continue;
      }

      rr.ttl -= diff;
    }

    return msg;
  }
}

/**
 * CacheEntry
 */

class CacheEntry {
  constructor(msg) {
    assert((msg != null && msg._isBuffer === true));
    this.msg = msg;
    this.time = 0;
    this.ttl = 0;
    this.eternal = false;
  }

  deadline() {
    if (this.eternal)
      return 0xffffffff;

    return this.time + this.ttl;
  }

  usage(id) {
    let size = 0;
    size += id.length * 2;
    size += 80 + this.msg.length;
    size += 8 * 3;
    return size;
  }

  setAD(ad) {
    let bits = bio.readU16BE(this.msg, 2);

    if (ad)
      bits |= wire.flags.AD;
    else
      bits &= ~wire.flags.AD;

    bio.writeU16BE(this.msg, bits, 2);
  }

  expired(now) {
    // Someone changed
    // their system time.
    // Clear cache.
    if (now < this.time)
      return true;

    if (this.eternal)
      return false;

    return now >= this.deadline();
  }
}

/*
 * Helpers
 */

function queueUsage(id) {
  return id.length * 2 + 20;
}

/*
 * Expose
 */

module.exports = Cache;
}],
[/* 110 */ 'bheep', '/lib/bheep.js', function(exports, require, module, __filename, __dirname, __meta) {
module.exports = __browser_require__(111 /* './heap' */, module);
}],
[/* 111 */ 'bheep', '/lib/heap.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * heap.js - heap object for bcoin
 * Copyright (c) 2017-2018, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcoin
 */



const assert = __browser_require__(2 /* 'bsert' */, module);

/**
 * Binary Heap
 * @alias module:utils.Heap
 */

class Heap {
  /**
   * Create a binary heap.
   * @constructor
   * @param {Function?} compare
   */

  constructor(compare) {
    this.compare = comparator;
    this.items = [];

    if (compare)
      this.set(compare);
  }

  /**
   * Initialize and sort heap.
   */

  init() {
    const n = this.items.length;

    if (n <= 1)
      return;

    for (let i = (n / 2 | 0) - 1; i >= 0; i--)
      this.down(i, n);
  }

  /**
   * Get heap size.
   * @returns {Number}
   */

  size() {
    return this.items.length;
  }

  /**
   * Set comparator.
   * @param {Function} compare
   */

  set(compare) {
    assert(typeof compare === 'function',
      'Comparator must be a function.');
    this.compare = compare;
  }

  /**
   * Push item onto heap.
   * @param {Object} item
   * @returns {Number}
   */

  insert(item) {
    this.items.push(item);
    this.up(this.items.length - 1);
    return this.items.length;
  }

  /**
   * Pop next item off of heap.
   * @param {Object} item
   * @returns {Object}
   */

  shift() {
    if (this.items.length === 0)
      return null;

    const n = this.items.length - 1;

    this.swap(0, n);
    this.down(0, n);

    return this.items.pop();
  }

  /**
   * Remove item from heap.
   * @param {Number} i
   * @returns {Object}
   */

  remove(i) {
    if (this.items.length === 0)
      return null;

    const n = this.items.length - 1;

    if (i < 0 || i > n)
      return null;

    if (n !== i) {
      this.swap(i, n);
      this.down(i, n);
      this.up(i);
    }

    return this.items.pop();
  }

  /**
   * Swap indicies.
   * @private
   * @param {Number} a
   * @param {Number} b
   */

  swap(a, b) {
    const x = this.items[a];
    const y = this.items[b];
    this.items[a] = y;
    this.items[b] = x;
  }

  /**
   * Compare indicies.
   * @private
   * @param {Number} i
   * @param {Number} j
   * @returns {Boolean}
   */

  less(i, j) {
    return this.compare(this.items[i], this.items[j]) < 0;
  }

  /**
   * Bubble item down.
   * @private
   * @param {Number} i
   * @param {Number} n
   */

  down(i, n) {
    for (;;) {
      const l = 2 * i + 1;

      assert(l >= 0);

      if (l < 0 || l >= n)
        break;

      let j = l;
      const r = l + 1;

      if (r < n && !this.less(l, r))
        j = r;

      if (!this.less(j, i))
        break;

      this.swap(i, j);
      i = j;
    }
  }

  /**
   * Bubble item up.
   * @private
   * @param {Number} i
   */

  up(i) {
    for (;;) {
      const j = (i - 1) / 2 | 0;

      assert(j >= 0);

      if (j < 0 || j === i)
        break;

      if (!this.less(i, j))
        break;

      this.swap(j, i);
      i = j;
    }
  }

  /**
   * Convert heap to sorted array.
   * @returns {Object[]}
   */

  toArray() {
    const heap = new Heap();
    const result = [];

    heap.compare = this.compare;
    heap.items = this.items.slice();

    while (heap.size() > 0)
      result.push(heap.shift());

    return result;
  }

  /**
   * Instantiate heap from array and comparator.
   * @param {Function} compare
   * @param {Object[]} items
   * @returns {Heap}
   */

  static fromArray(compare, items) {
    const heap = new Heap();
    heap.set(compare);
    heap.items = items;
    heap.init();
    return heap;
  }
}

/*
 * Helpers
 */

function comparator(a, b) {
  throw new Error('No heap comparator set.');
}

/*
 * Expose
 */

module.exports = Heap;
}],
[/* 112 */ 'bns-plus', '/lib/dns.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * dns.js - replacement dns node.js module
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 */



const API = __browser_require__(1 /* './api' */, module);
const Hosts = __browser_require__(113 /* './hosts' */, module);
const ResolvConf = __browser_require__(91 /* './resolvconf' */, module);
const StubResolver = __browser_require__(114 /* './resolver/stub' */, module);

let conf = null;
let hosts = null;

function createResolver(options, servers) {
  if (!conf)
    conf = ResolvConf.fromSystem();

  if (!hosts)
    hosts = Hosts.fromSystem();

  const resolver = new StubResolver(options);

  if (!options.conf)
    resolver.conf = conf.clone();

  if (!options.hosts)
    resolver.hosts = hosts.clone();

  if (servers)
    resolver.setServers(servers);

  return resolver;
}

module.exports = API.make(createResolver, {
  tcp: true,
  edns: false,
  dnssec: false
});
}],
[/* 113 */ 'bns-plus', '/lib/hosts.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * hosts.js - hosts file for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const Path = __browser_require__(87 /* 'path' */, module);
const fs = __browser_require__(84 /* 'bfile' */, module);
const IP = __browser_require__(4 /* 'binet' */, module);
const encoding = __browser_require__(80 /* './encoding' */, module);
const wire = __browser_require__(90 /* './wire' */, module);
const util = __browser_require__(79 /* './util' */, module);

const {
  Record,
  ARecord,
  AAAARecord,
  PTRRecord,
  types,
  classes
} = wire;

/**
 * Hosts
 */

class Hosts {
  constructor() {
    this.map = new Map();
    this.rev = new Map();
  }

  inject(hosts) {
    assert(hosts instanceof this.constructor);

    this.map.clear();

    for (const [key, value] of hosts.map)
      this.map.set(key, value.clone());

    this.rev.clear();

    for (const [key, value] of hosts.rev)
      this.rev.set(key, value);

    return this;
  }

  clone() {
    const copy = new this.constructor();
    return copy.inject(this);
  }

  clear() {
    this.clearHosts();
    return this;
  }

  getSystem() {
    if (process.platform === 'win32') {
      const root = process.env.SystemRoot || 'C:\\Windows';
      return Path.join(root, '\\System32\\Drivers\\etc\\hosts');
    }

    return '/etc/hosts';
  }

  getHosts() {
    const out = [];

    for (const [name, addr] of this.map) {
      if (addr.inet4)
        out.push([name, addr.inet4]);

      if (addr.inet6)
        out.push([name, addr.inet6]);
    }

    return out;
  }

  setHosts(hosts) {
    assert(Array.isArray(hosts));

    this.clearHosts();

    for (const item of hosts) {
      assert(Array.isArray(item) && item.length === 2);
      const [name, addr] = item;
      this.addHost(name, addr);
    }

    return this;
  }

  clearHosts() {
    this.map.clear();
    this.rev.clear();
    return this;
  }

  setDefault() {
    return this.setLocal();
  }

  setLocal() {
    this.clearHosts();
    this.addHost('localhost', '127.0.0.1');
    this.addHost('localhost', '::1');
    return this;
  }

  addHost(name, host, hostname = null) {
    assert(typeof name === 'string');
    assert(typeof host === 'string');
    assert(hostname === null || typeof hostname === 'string');

    name = name.toLowerCase();
    name = util.fqdn(name);

    if (!util.isName(name))
      throw new Error('Invalid name.');

    let local = false;

    if (util.endsWith(name, '.localdomain.')) {
      name = name.slice(0, -12);
      local = true;
    }

    if (hostname) {
      hostname = hostname.toLowerCase();
      hostname = util.fqdn(hostname);

      if (!util.isName(hostname))
        throw new Error('Invalid hostname.');
    }

    let entry = this.map.get(name);

    if (!entry)
      entry = new HostEntry();

    const ip = IP.toBuffer(host);
    const addr = IP.toString(ip);
    const rev = encoding.reverse(addr);

    entry.name = name;

    if (IP.isIPv4(ip))
      entry.inet4 = addr;
    else
      entry.inet6 = addr;

    entry.hostname = hostname;
    entry.local = local;

    this.map.set(name, entry);
    this.rev.set(rev, name);

    return this;
  }

  lookup(name) {
    const key = name.toLowerCase();
    const ptr = this.rev.get(key);

    if (ptr)
      return [this.map.get(ptr), true];

    return [this.map.get(key), false];
  }

  query(name, type) {
    assert(typeof name === 'string');
    assert((type & 0xffff) === type);

    const [entry, ptr] = this.lookup(name);

    if (!entry)
      return null;

    const answer = [];

    if (ptr) {
      if (type === types.PTR || type === types.ANY) {
        const rr = new Record();
        const rd = new PTRRecord();
        rr.name = name;
        rr.class = classes.IN;
        rr.ttl = 10800;
        rr.type = types.PTR;
        rr.data = rd;
        rd.ptr = entry.name;
        answer.push(rr);
      }

      return answer;
    }

    if (type === types.A || type === types.ANY) {
      if (entry.inet4) {
        const rr = new Record();
        const rd = new ARecord();
        rr.name = name;
        rr.class = classes.IN;
        rr.ttl = 10800;
        rr.type = types.A;
        rr.data = rd;
        rd.address = entry.inet4;
        answer.push(rr);
      }
    }

    if (type === types.AAAA || type === types.ANY) {
      if (entry.inet6) {
        const rr = new Record();
        const rd = new AAAARecord();
        rr.name = name;
        rr.class = classes.IN;
        rr.ttl = 10800;
        rr.type = types.AAAA;
        rr.data = rd;
        rd.address = entry.inet6;
        answer.push(rr);
      }
    }

    return answer;
  }

  toString() {
    let out = '';

    out += '#\n';
    out += '# /etc/hosts: static lookup table for host names\n';
    out += '# (generated by bns)\n';
    out += '#\n';
    out += '\n';
    out += '# <ip-address> <hostname.domain.org> <hostname>\n';

    for (const entry of this.map.values())
      out += entry.toString();

    out += '\n';
    out += '# End of file\n';

    return out;
  }

  fromString(text) {
    assert(typeof text === 'string');

    text = text.toLowerCase();

    const lines = util.splitLines(text, true);

    for (const chunk of lines) {
      const line = stripComments(chunk);

      if (line.length === 0)
        continue;

      const parts = util.splitSP(line);
      const ip = parts[0];

      let hostname = null;

      if (parts.length > 2)
        hostname = parts.pop();

      for (let i = 1; i < parts.length; i++) {
        const name = parts[i];
        try {
          this.addHost(name, ip, hostname);
        } catch (e) {
          continue;
        }
      }
    }

    return this;
  }

  static fromString(text) {
    return new this().fromString(text);
  }

  fromFile(file) {
    assert(typeof file === 'string');
    const text = fs.readFileSync(file, 'utf8');
    return this.fromString(text);
  }

  static fromFile(file) {
    return new this().fromFile(file);
  }

  fromSystem() {
    const file = this.getSystem();
    try {
      return this.fromFile(file);
    } catch (e) {
      return this.setLocal();
    }
  }

  static fromSystem() {
    return new this().fromSystem();
  }

  async fromFileAsync(file) {
    assert(typeof file === 'string');
    const text = await fs.readFile(file, 'utf8');
    return this.fromString(text);
  }

  static fromFileAsync(file) {
    return new this().fromFileAsync(file);
  }

  async fromSystemAsync() {
    const file = this.getSystem();
    try {
      return await this.fromFileAsync(file);
    } catch (e) {
      return this.setLocal();
    }
  }

  static fromSystemAsync() {
    return new this().fromSystemAsync();
  }
}

/**
 * HostEntry
 */

class HostEntry {
  constructor() {
    this.name = 'localhost';
    this.inet4 = null;
    this.inet6 = null;
    this.hostname = null;
    this.local = true;
  }

  inject(entry) {
    assert(entry instanceof this.constructor);
    this.name = entry.name;
    this.inet4 = entry.inet4;
    this.inet6 = entry.inet6;
    this.hostname = entry.hostname;
    this.local = entry.local;
    return this;
  }

  clone() {
    const copy = new this.constructor();
    return copy.inject(this);
  }

  toString() {
    let out = '';

    let name = util.trimFQDN(this.name);
    let hostname = '';

    if (this.local)
      name += '.localdomain';

    if (this.hostname)
      hostname = ` ${util.trimFQDN(this.hostname)}`;

    if (this.inet4)
      out += `${this.inet4} ${name}${hostname}\n`;

    if (this.inet6)
      out += `${this.inet6} ${name}${hostname}\n`;

    return out;
  }
}

/*
 * Helpers
 */

function stripComments(str) {
  assert(typeof str === 'string');
  return str.replace(/[ \t\v]*#.*$/g, '');
}

/*
 * Expose
 */

module.exports = Hosts;
}],
[/* 114 */ 'bns-plus', '/lib/resolver/stub.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * stub.js - stub dns resolver for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const constants = __browser_require__(11 /* '../constants' */, module);
const DNSResolver = __browser_require__(115 /* './dns' */, module);
const encoding = __browser_require__(80 /* '../encoding' */, module);
const Hosts = __browser_require__(113 /* '../hosts' */, module);
const ResolvConf = __browser_require__(91 /* '../resolvconf' */, module);
const util = __browser_require__(79 /* '../util' */, module);
const wire = __browser_require__(90 /* '../wire' */, module);
const {MAX_EDNS_SIZE} = constants;

const {
  Message,
  Question,
  opcodes,
  types,
  codes
} = wire;

/**
 * StubResolver
 * @extends DNSResolver
 */

class StubResolver extends DNSResolver {
  constructor(options) {
    super(options);

    this.rd = true;
    this.cd = false;
    this.conf = new ResolvConf();
    this.hosts = new Hosts();

    this.initOptions(options);
  }

  initOptions(options) {
    if (options == null)
      return this;

    this.parseOptions(options);

    if (options.conf != null) {
      assert(options.conf instanceof ResolvConf);
      this.conf = options.conf;
    }

    if (options.hosts != null) {
      if (Array.isArray(options.hosts)) {
        this.hosts.setHosts(options.hosts);
      } else {
        assert(options.hosts instanceof Hosts);
        this.hosts = options.hosts;
      }
    }

    if (options.rd != null) {
      assert(typeof options.rd === 'boolean');
      this.rd = options.rd;
    }

    if (options.cd != null) {
      assert(typeof options.cd === 'boolean');
      this.cd = options.cd;
    }

    if (options.servers != null) {
      assert(Array.isArray(options.servers));
      this.conf.setServers(options.servers);
    }

    return this;
  }

  getRaw() {
    return this.conf.getRaw(this.inet6);
  }

  getServers() {
    return this.conf.getServers();
  }

  setServers(servers) {
    this.conf.setServers(servers);
    return this;
  }

  getHosts() {
    return this.hosts.getHosts();
  }

  setHosts(hosts) {
    this.hosts.setHosts(hosts);
    return this;
  }

  async resolve(qs) {
    assert(qs instanceof Question);

    const {name, type} = qs;
    const answer = this.hosts.query(name, type);

    if (answer) {
      const res = new Message();

      res.id = util.id();
      res.opcode = opcodes.QUERY;
      res.code = codes.NOERROR;
      res.qr = true;
      res.rd = true;
      res.ra = true;
      res.ad = true;
      res.question = [qs];
      res.answer = answer;

      if (this.edns)
        res.setEDNS(MAX_EDNS_SIZE, this.dnssec);

      return res;
    }

    return this.query(qs, this.getRaw());
  }

  async lookup(name, type) {
    const qs = new Question(name, type);
    return this.resolve(qs);
  }

  async reverse(addr) {
    const name = encoding.reverse(addr);
    return this.lookup(name, types.PTR);
  }
}

/*
 * Expose
 */

module.exports = StubResolver;
}],
[/* 115 */ 'bns-plus', '/lib/resolver/dns.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * resolver.js - dns resolver for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const EventEmitter = __browser_require__(3 /* 'events' */, module);
const IP = __browser_require__(4 /* 'binet' */, module);
const bio = __browser_require__(14 /* 'bufio' */, module);
const constants = __browser_require__(11 /* '../constants' */, module);
const encoding = __browser_require__(80 /* '../encoding' */, module);
const {Client} = __browser_require__(102 /* '../internal/net' */, module);
const util = __browser_require__(79 /* '../util' */, module);
const wire = __browser_require__(90 /* '../wire' */, module);

const {
  DNS_PORT,
  MAX_UDP_SIZE,
  MAX_EDNS_SIZE,
  STD_EDNS_SIZE
} = constants;

const {
  Message,
  Question,
  opcodes,
  types,
  codes
} = wire;

/**
 * DNSResolver
 * @extends EventEmitter
 */

class DNSResolver extends EventEmitter {
  constructor(options) {
    super();

    this.socket = new Client(options);
    this.pending = new Map();
    this.timer = null;

    this.inet6 = this.socket.inet6;
    this.tcp = this.socket.tcp;
    this.forceTCP = false;
    this.maxAttempts = 3;
    this.maxTimeout = 2000;
    this.rd = false;
    this.cd = false;
    this.edns = false;
    this.ednsSize = MAX_EDNS_SIZE;
    this.dnssec = false;

    this.init();
  }

  init() {
    this.on('error', () => {});

    this.socket.on('close', () => {
      this.emit('close');
    });

    this.socket.on('error', (err) => {
      this.emit('error', err);
    });

    this.socket.on('listening', () => {
      this.emit('listening');
    });

    this.socket.on('message', (msg, rinfo) => {
      try {
        this.handle(msg, rinfo);
      } catch (e) {
        this.emit('error', e);
      }
    });
  }

  parseOptions(options) {
    if (options == null)
      return this;

    assert(options && typeof options === 'object');

    if (options.forceTCP != null) {
      assert(typeof options.forceTCP === 'boolean');
      this.forceTCP = options.forceTCP;
    }

    if (options.maxAttempts != null) {
      assert((options.maxAttempts >>> 0) === options.maxAttempts);
      this.maxAttempts = options.maxAttempts;
    }

    if (options.maxTimeout != null) {
      assert((options.maxTimeout >>> 0) === options.maxTimeout);
      this.maxTimeout = options.maxTimeout;
    }

    if (options.edns != null) {
      assert(typeof options.edns === 'boolean');
      this.edns = options.edns;
    }

    if (options.ednsSize != null) {
      assert((options.ednsSize >>> 0) === options.ednsSize);
      assert(options.ednsSize >= MAX_UDP_SIZE);
      assert(options.ednsSize <= MAX_EDNS_SIZE);
      this.ednsSize = options.ednsSize;
    }

    if (options.dnssec != null) {
      assert(typeof options.dnssec === 'boolean');
      this.dnssec = options.dnssec;
      if (this.dnssec)
        this.edns = true;
    }

    return this;
  }

  initOptions(options) {
    return this.parseOptions(options);
  }

  log(...args) {
    this.emit('log', ...args);
  }

  async open(...args) {
    await this.socket.bind(...args);

    if (this.edns) {
      this.socket.setRecvBufferSize(this.ednsSize);
      this.socket.setSendBufferSize(this.ednsSize);
    } else {
      this.socket.setRecvBufferSize(MAX_UDP_SIZE);
      this.socket.setSendBufferSize(MAX_UDP_SIZE);
    }

    this.timer = setInterval(() => this.maybeRetry(), 1000);

    if (this.timer.unref)
      this.timer.unref();

    return this;
  }

  async close() {
    await this.socket.close();

    if (this.timer != null) {
      clearInterval(this.timer);
      this.timer = null;
    }

    this.cancel();

    return this;
  }

  cancel() {
    const pending = this.pending;

    this.pending = new Map();

    for (const query of pending.values()) {
      query.unref();
      try {
        query.reject(new Error('Request cancelled.'));
      } catch (e) {
        this.emit('error', e);
      }
    }

    return this;
  }

  async bind(...args) {
    return this.open(...args);
  }

  maybeRetry() {
    const now = Date.now();

    for (const query of this.pending.values()) {
      if (now > query.time + this.maxTimeout)
        this.retry(query, true, false, true);
    }
  }

  verify(msg, host, port) {
    return true;
  }

  useTCP(type, size) {
    if (this.forceTCP) {
      assert(this.tcp);
      return true;
    }

    if (!this.tcp)
      return false;

    // Dig-style.
    if (this.rd) {
      if (type === types.ANY)
        return true;
    }

    if (this.edns)
      return size > this.ednsSize;

    return size > MAX_UDP_SIZE;
  }

  retry(query, rotate, forceTCP, isTimeout) {
    let server = query.server;

    query.unref();

    // Make sure our socket is dead.
    if (server.tcp) {
      const {port, host} = server;
      this.socket.kill(port, host);
    }

    if (query.attempts >= this.maxAttempts) {
      this.pending.delete(query.id);

      if (query.res)
        query.resolve(query.res);
      else
        query.reject(new Error('Request timed out.'));

      return;
    }

    if (rotate) {
      server = query.nextServer(server.tcp);
      this.log('Switched servers to: %s (%d).', server.host, query.id);
    }

    if (this.tcp && forceTCP)
      server.tcp = true;

    let req = query.req;

    if (isTimeout && query.attempts === this.maxAttempts - 1) {
      // Could be IP fragmentation somewhere.
      if (this.tcp) {
        // Try with TCP one last time.
        server.tcp = true;
        this.log('Last attempt over TCP (%s): %d.', server.host, query.id);
      } else if (req.edns.enabled && req.edns.size > STD_EDNS_SIZE) {
        // This should at least get us a truncated
        // response assuming MTU is 1280 or above.
        req = req.clone();
        req.edns.size = STD_EDNS_SIZE;
        this.log('Last attempt w/ small EDNS (%s): %d.', server.host, query.id);
      }
    }

    const {port, host, tcp} = server;
    const msg = req.encode();

    // Retry over TCP or UDP.
    this.socket.send(msg, 0, msg.length, port, host, tcp);

    this.log('Retrying (%s): %d (tcp=%s)...', host, query.id, tcp);

    // Update time.
    query.ref();
    query.time = Date.now();
    query.attempts += 1;
  }

  handle(msg, rinfo) {
    // Close socket once we get an answer.
    if (rinfo.tcp) {
      const {port, address} = rinfo;
      this.socket.drop(port, address);
    }

    if (msg.length < 2) {
      this.log('Malformed message (%s).', rinfo.address);
      return;
    }

    const id = bio.readU16BE(msg, 0);
    const query = this.pending.get(id);

    if (!query) {
      this.log('Unsolicited message (%s): %d.', rinfo.address, id);
      return;
    }

    const {host, port} = query.server;

    if (rinfo.address !== host || port !== rinfo.port) {
      this.log(
        'Possible reflection attack (%s != %s): %d.',
        rinfo.address, host, id);
      return;
    }

    query.unref();

    let {req} = query;
    let res = null;

    try {
      res = Message.decode(msg);
    } catch (e) {
      this.log('Message %d failed deserialization (%s):', id, rinfo.address);
      this.log(e.stack);
      this.pending.delete(id);
      query.reject(new Error('Encoding error.'));
      return;
    }

    if (!res.qr) {
      this.pending.delete(id);
      query.reject(new Error('Not a response.'));
      return;
    }

    if (!sameQuestion(req, res)) {
      this.pending.delete(id);
      query.reject(new Error('Invalid question.'));
      return;
    }

    if (this.tcp && res.tc) {
      if (rinfo.tcp) {
        this.pending.delete(id);
        query.reject(new Error('Truncated TCP msg.'));
        return;
      }

      // Retry over TCP if truncated.
      this.log('Retrying over TCP (%s): %d.', host, id);
      this.retry(query, false, true, false);

      return;
    }

    if (res.opcode !== opcodes.QUERY) {
      this.pending.delete(id);
      query.reject(new Error('Unexpected opcode.'));
      return;
    }

    if ((res.code === codes.FORMERR
        || res.code === codes.NOTIMP
        || res.code === codes.SERVFAIL)
        && (!res.isEDNS() && req.isEDNS())) {
      // They don't like edns.
      req = req.clone();
      req.unsetEDNS();

      query.req = req;
      query.res = res;

      this.log('Retrying without EDNS (%s): %d.', host, id);
      this.retry(query, false, false, false);

      return;
    }

    if (res.code === codes.FORMERR) {
      this.pending.delete(id);
      query.reject(new Error('Format error.'));
      return;
    }

    if (res.code === codes.SERVFAIL) {
      query.res = res;
      this.log('Retrying due to failure (%s): %d.', host, id);
      this.retry(query, true, false, false);
      return;
    }

    if (!this.verify(msg, host, port)) {
      this.pending.delete(id);
      query.reject(new Error('Could not verify response.'));
      return;
    }

    this.pending.delete(id);

    query.resolve(res);
  }

  async exchange(req, servers) {
    assert(req instanceof Message);
    assert(Array.isArray(servers));
    assert(req.question.length > 0);

    const [qs] = req.question;

    if (!util.isName(qs.name))
      throw new Error('Invalid qname.');

    if (servers.length === 0)
      throw new Error('No servers available.');

    req.id = util.id();
    req.qr = false;

    const msg = req.encode();
    const tcp = this.useTCP(qs.type, msg.length);
    const query = new Query(req, servers, tcp);
    const {port, host} = query.server;

    this.log('Querying server: %s (%d) (tcp=%s)', host, req.id, tcp);

    this.socket.send(msg, 0, msg.length, port, host, tcp);
    this.pending.set(query.id, query);

    query.ref();

    return new Promise((resolve, reject) => {
      query.resolve = resolve;
      query.reject = reject;
    });
  }

  async query(qs, servers) {
    assert(qs instanceof Question);
    assert(Array.isArray(servers));

    const req = new Message();
    req.opcode = opcodes.QUERY;
    req.rd = this.rd;
    req.cd = this.cd;
    req.question.push(qs);

    if (this.edns) {
      req.setEDNS(this.ednsSize, this.dnssec);

      // Cookie for recursive queries.
      // Note that some authoritative
      // servers get mad at this, most
      // notably alidns' servers.
      if (this.rd)
        req.edns.setCookie(util.cookie());
    }

    if (this.rd)
      req.ad = true;

    return this.exchange(req, servers);
  }

  async lookup(name, type, servers) {
    const qs = new Question(name, type);
    return this.query(qs, servers);
  }

  async reverse(addr, servers) {
    const name = encoding.reverse(addr);
    return this.lookup(name, types.PTR, servers);
  }
}

/**
 * Query
 */

class Query {
  constructor(req, servers, tcp) {
    assert(req instanceof Message);
    assert(Array.isArray(servers));
    assert(servers.length > 0);
    assert(typeof tcp === 'boolean');

    this.id = req.id;
    this.req = req;
    this.index = 0;
    this.servers = util.sortRandom(servers);
    this.resolve = null;
    this.reject = null;
    this.attempts = 1;
    this.res = null;
    this.server = null;
    this.time = Date.now();
    this.timer = null;

    this.nextServer(tcp);
  }

  ref() {
    if (this.timer == null)
      this.timer = setInterval(noop, 0x7fffffff);
  }

  unref() {
    if (this.timer != null)
      clearInterval(this.timer);
    this.timer = null;
  }

  getServer(index, tcp) {
    assert((index >>> 0) < this.servers.length);
    assert(typeof tcp === 'boolean');

    const server = this.servers[index];

    let addr;

    if (typeof server === 'string') {
      addr = IP.fromHost(server, DNS_PORT);
    } else {
      if (!server || typeof server !== 'object')
        throw new Error('Bad address passed to query.');
      addr = server;
    }

    const host = addr.address || addr.host;
    const port = addr.port || DNS_PORT;

    if (!util.isIP(host))
      throw new Error('Bad address passed to query.');

    if ((port & 0xffff) !== port)
      throw new Error('Bad address passed to query.');

    return {
      host: IP.normalize(host),
      port,
      tcp
    };
  }

  nextServer(tcp) {
    assert(this.index < this.servers.length);

    this.index += 1;

    if (this.index === this.servers.length)
      this.index = 0;

    this.server = this.getServer(this.index, tcp);

    return this.server;
  }
}

/*
 * Helpers
 */

function sameQuestion(req, res) {
  switch (res.code) {
    case codes.NOTIMP:
    case codes.FORMERR:
    case codes.NXRRSET:
      if (res.question.length === 0)
        break;
    case codes.BADCOOKIE:
    case codes.NOERROR:
    case codes.NXDOMAIN:
    case codes.YXDOMAIN:
    case codes.REFUSED:
    case codes.SERVFAIL:
    default:
      if (res.question.length === 0) {
        if (res.tc)
          return true;
        return false;
      }

      if (res.question.length > 1)
        return false;

      if (!res.question[0].equals(req.question[0]))
        return false;

      break;
  }

  return true;
}

function noop() {}

/*
 * Expose
 */

module.exports = DNSResolver;
}],
[/* 116 */ 'bns-plus', '/lib/hints.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * hints.js - root hints object for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 *
 * Parts of this software are based on solvere:
 *   https://github.com/rolandshoemaker/solvere
 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const fs = __browser_require__(84 /* 'bfile' */, module);
const IP = __browser_require__(4 /* 'binet' */, module);
const Authority = __browser_require__(96 /* './authority' */, module);
const constants = __browser_require__(11 /* './constants' */, module);
const dnssec = __browser_require__(99 /* './dnssec' */, module);
const util = __browser_require__(79 /* './util' */, module);
const wire = __browser_require__(90 /* './wire' */, module);
const {DNS_PORT} = constants;

const {
  types,
  classes,
  Record,
  NSRecord,
  ARecord,
  AAAARecord
} = wire;

/*
 * Constants
 */

const ROOT_HINTS = __browser_require__(108 /* './roothints' */, module);

/**
 * Hints
 */

class Hints {
  constructor() {
    this.ns = [];
    this.inet4 = new Map();
    this.inet6 = new Map();
    this.anchors = [];
    this.port = DNS_PORT;
  }

  inject(hints) {
    assert(hints instanceof this.constructor);

    this.ns = hints.ns.slice();

    this.inet4.clear();

    for (const [key, ip] of hints.inet4)
      this.inet4.set(key, ip);

    this.inet6.clear();

    for (const [key, ip] of hints.inet6)
      this.inet6.set(key, ip);

    this.anchors = hints.anchors.slice();
    this.port = hints.port;

    return this;
  }

  clone() {
    const copy = new this.constructor();
    return copy.inject(this);
  }

  clear() {
    this.ns.length = 0;
    this.inet4.clear();
    this.inet6.clear();
    this.anchors.length = 0;
    this.port = DNS_PORT;
    return this;
  }

  getSystem() {
    if (process.platform === 'win32')
      return null;

    return '/var/named/root.hint';
  }

  setDefault() {
    return this.setRoot();
  }

  setLocal() {
    this.clear();
    this.ns.push('hints.local.');
    this.inet4.set('hints.local.', '127.0.0.1');
    this.inet6.set('hints.local.', '::1');
    return this;
  }

  setRoot() {
    this.clear();
    return this.fromRoot();
  }

  addServer(name, addr) {
    if (!util.isName(name))
      throw new Error('Invalid name.');

    if (!util.isIP(addr))
      throw new Error('Invalid IP.');

    name = name.toLowerCase();
    name = util.fqdn(name);

    if (this.ns.indexOf(name) === -1)
      this.ns.push(name);

    const ip = IP.toBuffer(addr);

    if (IP.isIPv4(ip))
      this.inet4.set(name, IP.toString(ip));
    else
      this.inet6.set(name, IP.toString(ip));

    return this;
  }

  removeServer(name) {
    if (!util.isName(name))
      throw new Error('Invalid name.');

    name = name.toLowerCase();
    name = util.fqdn(name);

    const i = this.ns.indexOf(name);

    if (i === -1)
      return this;

    this.ns.splice(i, 1);
    this.inet4.delete(name);
    this.inet6.delete(name);

    return this;
  }

  addAnchor(ds) {
    if (typeof ds === 'string')
      ds = Record.fromString(ds);

    assert(ds instanceof Record);

    if (ds.type === types.DNSKEY)
      ds = dnssec.createDS(ds, dnssec.hashes.SHA256);

    assert(ds.type === types.DS);

    if (ds.name !== '.')
      throw new Error('Invalid anchor name.');

    if (ds.class !== classes.IN)
      throw new Error('Invalid anchor class.');

    ds = ds.clone();

    if (ds.ttl === 0)
      ds.ttl = 3600000;

    this.anchors.push(ds);

    return this;
  }

  removeAnchor(ds) {
    if (typeof ds === 'string')
      ds = Record.fromString(ds);

    assert(ds instanceof Record);

    if (ds.type === types.DNSKEY)
      ds = dnssec.createDS(ds, dnssec.hashes.SHA256);

    assert(ds.type === types.DS);

    const raw = ds.data.encode();

    let i;
    for (i = 0; i < this.anchors.length; i++) {
      const ds = this.anchors[i];
      if (ds.data.encode().equals(raw))
        break;
    }

    if (i === this.anchors.length)
      return this;

    this.anchors.splice(i, 1);

    return this;
  }

  getAuthority(inet6) {
    if (this.ns.length === 0)
      throw new Error('No nameservers available.');

    const auth = new Authority('.', 'hints.local.');

    for (const name of this.ns) {
      if (inet6) {
        const host = this.inet6.get(name);
        if (host)
          auth.add(host, this.port);
      }

      const host = this.inet4.get(name);

      if (host)
        auth.add(host, this.port);
    }

    assert(auth.servers.length > 0);

    return auth;
  }

  _toRecord(name) {
    const records = [];

    const inet4 = this.inet4.get(name);
    const inet6 = this.inet6.get(name);

    const rr = new Record();
    const rd = new NSRecord();
    rr.name = '.';
    rr.ttl = 3600000;
    rr.type = types.NS;
    rr.data = rd;
    rd.ns = name.toUpperCase();

    records.push(rr);

    if (inet4) {
      const rr = new Record();
      const rd = new ARecord();
      rr.name = name.toUpperCase();
      rr.ttl = 3600000;
      rr.type = types.A;
      rr.data = rd;
      rd.address = inet4;
      records.push(rr);
    }

    if (inet6) {
      const rr = new Record();
      const rd = new AAAARecord();
      rr.name = name.toUpperCase();
      rr.ttl = 3600000;
      rr.type = types.AAAA;
      rr.data = rd;
      rd.address = inet6;
      records.push(rr);
    }

    return records;
  }

  toRecords() {
    const records = [];

    for (const ns of this.ns) {
      for (const rr of this._toRecord(ns))
        records.push(rr);
    }

    for (const ds of this.anchors)
      records.push(ds);

    return records;
  }

  toString() {
    let out = '';

    out += this.toHintString();

    if (this.anchors.length > 0)
      out += this.toAnchorString();

    return out;
  }

  toHintString() {
    let out = '';

    out += ';\n';
    out += '; Root Zone\n';
    out += '; (generated by bns)\n';
    out += ';\n';
    out += '\n';

    for (const ns of this.ns) {
      for (const rr of this._toRecord(ns))
        out += `${rr.toString()}\n`;
      out += '\n';
    }

    return out;
  }

  toAnchorString() {
    let out = '';

    out += ';\n';
    out += '; Trust Anchors\n';
    out += ';\n';
    out += '\n';

    for (const rr of this.anchors)
      out += `${rr.toString()}\n`;

    return out;
  }

  fromRecords(records) {
    for (const rr of records) {
      const name = rr.name.toLowerCase();

      switch (rr.type) {
        case types.A: {
          this.inet4.set(name, rr.data.address);
          break;
        }
        case types.AAAA: {
          this.inet6.set(name, rr.data.address);
          break;
        }
      }
    }

    for (const rr of records) {
      const name = rr.name.toLowerCase();

      if (name !== '.')
        continue;

      switch (rr.type) {
        case types.NS: {
          const ns = rr.data.ns.toLowerCase();

          if (this.inet4.has(ns)
              || this.inet6.has(ns)) {
            this.ns.push(ns);
          }

          break;
        }

        case types.DS: {
          this.anchors.push(rr.clone());
          break;
        }

        case types.DNSKEY: {
          const ds = dnssec.createDS(rr, dnssec.hashes.SHA256);
          this.anchors.push(ds);
          break;
        }
      }
    }

    return this;
  }

  static fromRecords(records) {
    return new this().fromRecords(records);
  }

  fromString(text) {
    const records = wire.fromZone(text);
    return this.fromRecords(records);
  }

  static fromString(text) {
    return new this().fromString(text);
  }

  fromJSON(json) {
    assert(Array.isArray(json));

    const records = [];
    for (const item of json)
      records.push(Record.fromJSON(item));

    return this.fromRecords(records);
  }

  static fromJSON(json) {
    return new this().fromJSON(json);
  }

  fromRoot() {
    return this.fromString(ROOT_HINTS);
  }

  static fromRoot() {
    return new this().fromRoot();
  }

  fromFile(file) {
    assert(typeof file === 'string');
    const text = fs.readFileSync(file, 'utf8');
    return this.fromString(text);
  }

  static fromFile(file) {
    return new this().fromFile(file);
  }

  fromSystem() {
    const file = this.getSystem();

    if (file) {
      try {
        this.fromFile(file);
      } catch (e) {
        this.setDefault();
      }
    } else {
      this.setDefault();
    }

    return this;
  }

  static fromSystem() {
    return new this().fromSystem();
  }

  async fromFileAsync(file) {
    assert(typeof file === 'string');
    const text = await fs.readFile(file, 'utf8');
    return this.fromString(text);
  }

  static fromFileAsync(file) {
    return new this().fromFileAsync(file);
  }

  async fromSystemAsync() {
    const file = this.getSystem();

    if (file) {
      try {
        await this.fromFileAsync(file);
      } catch (e) {
        this.setDefault();
      }
    } else {
      this.setDefault();
    }

    return this;
  }

  static fromSystemAsync() {
    return new this().fromSystemAsync();
  }
}

/*
 * Expose
 */

module.exports = Hints;
}],
[/* 117 */ 'bns-plus', '/lib/hsig.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * hsig.js - HSIG for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const secp256k1 = __browser_require__(118 /* 'bcrypto/lib/secp256k1' */, module);
const blake2b = __browser_require__(121 /* 'bcrypto/lib/blake2b' */, module);
const sig0 = __browser_require__(123 /* './sig0' */, module);

/*
 * Constants
 */

const SIG0_ALGO_NAME = 'blake2bsecp256k1.';

const FUDGE_WINDOW = 21600; // 6 hours

/*
 * HSIG
 */

const hsig = exports;

hsig.createPrivate = function createPrivate() {
  return secp256k1.privateKeyGenerate();
};

hsig.createPrivateAsync = hsig.createPrivate;

hsig.createPublic = function createPublic(priv) {
  return secp256k1.publicKeyCreate(priv);
};

hsig.makeKey = function makeKey(priv) {
  const pub = secp256k1.publicKeyCreate(priv);
  return hsig.createKey(pub);
};

hsig.createKey = function createKey(pub) {
  return sig0.createKey(sig0.algs.PRIVATEDNS, pub, SIG0_ALGO_NAME);
};

hsig.sign = function sign(msg, priv) {
  assert((msg != null && msg._isBuffer === true));
  assert((priv != null && priv._isBuffer === true) && priv.length === 32);

  const pub = secp256k1.publicKeyCreate(priv, true);
  const key = hsig.createKey(pub);
  const fudge = FUDGE_WINDOW;

  return sig0.sign(msg, key, priv, fudge, (priv, data) => {
    const msg = blake2b.digest(data);
    return secp256k1.sign(msg, priv);
  });
};

hsig.verify = function verify(msg, pub) {
  assert((msg != null && msg._isBuffer === true));
  assert((pub != null && pub._isBuffer === true) && pub.length === 33);

  const key = hsig.createKey(pub);

  return sig0.verify(msg, key, (sig, key, data) => {
    const msg = blake2b.digest(data);
    const sigbuf = sig.data.signature;
    const keybuf = key.data.publicKey;

    const publicKey = keybuf.slice(SIG0_ALGO_NAME.length + 1);

    return secp256k1.verify(msg, sigbuf, publicKey);
  });
};

hsig.SIG0_ALGO_NAME = SIG0_ALGO_NAME;
}],
[/* 118 */ 'bcrypto', '/lib/secp256k1-browser.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * secp256k1.js - secp256k1 for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */



module.exports = __browser_require__(119 /* './js/secp256k1' */, module);
}],
[/* 119 */ 'bcrypto', '/lib/js/secp256k1.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * secp256k1.js - secp256k1 for bcrypto
 * Copyright (c) 2014-2015, Fedor Indutny (MIT License)
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */



const ECDSA = __browser_require__(60 /* './ecdsa' */, module);
const SHA256 = __browser_require__(33 /* '../sha256' */, module);
const pre = __browser_require__(120 /* './precomputed/secp256k1.json' */, module);

/*
 * Expose
 */

module.exports = new ECDSA('SECP256K1', SHA256, SHA256, pre);
}],
[/* 120 */ 'bcrypto', '/lib/js/precomputed/secp256k1.json', function(exports, require, module, __filename, __dirname, __meta) {
module.exports = {
  "naf": {
    "width": 9,
    "points": [
      [
        "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
        "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
      ],
      [
        "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
        "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
      ],
      [
        "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
        "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
      ],
      [
        "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
        "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
      ],
      [
        "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
        "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
      ],
      [
        "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
        "0ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
      ],
      [
        "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
        "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
      ],
      [
        "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
        "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
      ],
      [
        "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
        "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
      ],
      [
        "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
        "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
      ],
      [
        "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
        "02de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
      ],
      [
        "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
        "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
      ],
      [
        "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
        "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
      ],
      [
        "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
        "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
      ],
      [
        "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
        "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
      ],
      [
        "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
        "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
      ],
      [
        "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
        "02972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
      ],
      [
        "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
        "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
      ],
      [
        "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
        "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
      ],
      [
        "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
        "0d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
      ],
      [
        "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
        "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
      ],
      [
        "049370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
        "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
      ],
      [
        "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
        "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
      ],
      [
        "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
        "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
      ],
      [
        "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
        "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
      ],
      [
        "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
        "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
      ],
      [
        "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
        "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
      ],
      [
        "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
        "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
      ],
      [
        "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
        "091b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
      ],
      [
        "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
        "0673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
      ],
      [
        "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
        "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
      ],
      [
        "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
        "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
      ],
      [
        "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
        "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
      ],
      [
        "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
        "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
      ],
      [
        "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
        "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
      ],
      [
        "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
        "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
      ],
      [
        "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
        "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
      ],
      [
        "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
        "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
      ],
      [
        "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
        "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
      ],
      [
        "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
        "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
      ],
      [
        "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
        "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
      ],
      [
        "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
        "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
      ],
      [
        "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
        "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
      ],
      [
        "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
        "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
      ],
      [
        "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
        "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
      ],
      [
        "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
        "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
      ],
      [
        "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
        "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
      ],
      [
        "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
        "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
      ],
      [
        "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
        "0a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
      ],
      [
        "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
        "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
      ],
      [
        "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
        "09414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
      ],
      [
        "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
        "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
      ],
      [
        "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
        "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
      ],
      [
        "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
        "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
      ],
      [
        "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
        "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
      ],
      [
        "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
        "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
      ],
      [
        "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
        "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
      ],
      [
        "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
        "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
      ],
      [
        "078c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
        "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
      ],
      [
        "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
        "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
      ],
      [
        "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
        "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
      ],
      [
        "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
        "04f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
      ],
      [
        "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
        "073867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
      ],
      [
        "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
        "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
      ],
      [
        "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
        "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
      ],
      [
        "0336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
        "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
      ],
      [
        "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
        "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
      ],
      [
        "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
        "060660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
      ],
      [
        "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
        "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
      ],
      [
        "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
        "0b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
      ],
      [
        "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
        "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
      ],
      [
        "04e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
        "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
      ],
      [
        "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
        "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
      ],
      [
        "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
        "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
      ],
      [
        "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
        "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
      ],
      [
        "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
        "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
      ],
      [
        "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
        "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
      ],
      [
        "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
        "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
      ],
      [
        "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
        "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
      ],
      [
        "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
        "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
      ],
      [
        "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
        "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
      ],
      [
        "0c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
        "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
      ],
      [
        "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
        "021ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
      ],
      [
        "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
        "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
      ],
      [
        "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
        "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
      ],
      [
        "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
        "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
      ],
      [
        "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
        "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
      ],
      [
        "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
        "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
      ],
      [
        "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
        "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
      ],
      [
        "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
        "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
      ],
      [
        "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
        "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
      ],
      [
        "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
        "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
      ],
      [
        "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
        "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
      ],
      [
        "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
        "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
      ],
      [
        "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
        "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
      ],
      [
        "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
        "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
      ],
      [
        "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
        "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
      ],
      [
        "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
        "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
      ],
      [
        "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
        "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
      ],
      [
        "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
        "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
      ],
      [
        "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
        "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
      ],
      [
        "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
        "0c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
      ],
      [
        "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
        "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
      ],
      [
        "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
        "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
      ],
      [
        "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
        "09731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
      ],
      [
        "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
        "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
      ],
      [
        "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
        "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
      ],
      [
        "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
        "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
      ],
      [
        "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
        "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
      ],
      [
        "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
        "0cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
      ],
      [
        "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
        "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
      ],
      [
        "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
        "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
      ],
      [
        "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
        "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
      ],
      [
        "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
        "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
      ],
      [
        "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
        "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
      ],
      [
        "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
        "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
      ],
      [
        "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
        "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
      ],
      [
        "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
        "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
      ],
      [
        "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
        "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
      ],
      [
        "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
        "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
      ],
      [
        "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
        "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
      ],
      [
        "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
        "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
      ],
      [
        "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
        "0712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
      ],
      [
        "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
        "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
      ],
      [
        "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
        "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
      ],
      [
        "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
        "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
      ],
      [
        "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
        "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
      ]
    ]
  },
  "doubles": {
    "step": 4,
    "points": [
      [
        "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
        "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
      ],
      [
        "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
        "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
      ],
      [
        "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
        "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
      ],
      [
        "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
        "04e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
      ],
      [
        "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
        "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
      ],
      [
        "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
        "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
      ],
      [
        "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
        "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
      ],
      [
        "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
        "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
      ],
      [
        "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
        "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
      ],
      [
        "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
        "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
      ],
      [
        "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
        "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
      ],
      [
        "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
        "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
      ],
      [
        "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
        "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
      ],
      [
        "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
        "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
      ],
      [
        "06f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
        "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
      ],
      [
        "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
        "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
      ],
      [
        "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
        "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
      ],
      [
        "0948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
        "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
      ],
      [
        "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
        "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
      ],
      [
        "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
        "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
      ],
      [
        "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
        "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
      ],
      [
        "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
        "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
      ],
      [
        "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
        "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
      ],
      [
        "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
        "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
      ],
      [
        "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
        "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
      ],
      [
        "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
        "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
      ],
      [
        "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
        "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
      ],
      [
        "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
        "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
      ],
      [
        "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
        "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
      ],
      [
        "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
        "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
      ],
      [
        "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
        "0e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
      ],
      [
        "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
        "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
      ],
      [
        "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
        "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
      ],
      [
        "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
        "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
      ],
      [
        "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
        "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
      ],
      [
        "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
        "067c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
      ],
      [
        "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
        "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
      ],
      [
        "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
        "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
      ],
      [
        "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
        "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
      ],
      [
        "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
        "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
      ],
      [
        "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
        "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
      ],
      [
        "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
        "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
      ],
      [
        "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
        "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
      ],
      [
        "0928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
        "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
      ],
      [
        "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
        "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
      ],
      [
        "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
        "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
      ],
      [
        "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
        "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
      ],
      [
        "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
        "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
      ],
      [
        "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
        "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
      ],
      [
        "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
        "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
      ],
      [
        "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
        "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
      ],
      [
        "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
        "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
      ],
      [
        "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
        "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
      ],
      [
        "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
        "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
      ],
      [
        "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
        "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
      ],
      [
        "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
        "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
      ],
      [
        "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
        "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
      ],
      [
        "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
        "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
      ],
      [
        "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
        "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
      ],
      [
        "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
        "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
      ],
      [
        "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
        "0d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
      ],
      [
        "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
        "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
      ],
      [
        "08ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
        "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
      ],
      [
        "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
        "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
      ],
      [
        "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
        "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
      ]
    ]
  }
};
}],
[/* 121 */ 'bcrypto', '/lib/blake2b-browser.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * blake2b.js - blake2b for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */



module.exports = __browser_require__(122 /* './js/blake2b' */, module);
}],
[/* 122 */ 'bcrypto', '/lib/js/blake2b.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * blake2b.js - BLAKE2b implementation for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on dcposch/blakejs:
 *   Daniel Clemens Posch (CC0)
 *   https://github.com/dcposch/blakejs/blob/master/blake2b.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/BLAKE_(hash_function)
 *   https://tools.ietf.org/html/rfc7693
 */



const assert = __browser_require__(24 /* '../internal/assert' */, module);
const HMAC = __browser_require__(27 /* '../internal/hmac' */, module);

/*
 * Constants
 */

const FINALIZED = 0x80000000;

const IV = new Uint32Array([
  0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85,
  0xfe94f82b, 0x3c6ef372, 0x5f1d36f1, 0xa54ff53a,
  0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c,
  0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19
]);

const SIGMA = new Uint8Array([
  0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e,
  0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e,
  0x1c, 0x14, 0x08, 0x10, 0x12, 0x1e, 0x1a, 0x0c,
  0x02, 0x18, 0x00, 0x04, 0x16, 0x0e, 0x0a, 0x06,
  0x16, 0x10, 0x18, 0x00, 0x0a, 0x04, 0x1e, 0x1a,
  0x14, 0x1c, 0x06, 0x0c, 0x0e, 0x02, 0x12, 0x08,
  0x0e, 0x12, 0x06, 0x02, 0x1a, 0x18, 0x16, 0x1c,
  0x04, 0x0c, 0x0a, 0x14, 0x08, 0x00, 0x1e, 0x10,
  0x12, 0x00, 0x0a, 0x0e, 0x04, 0x08, 0x14, 0x1e,
  0x1c, 0x02, 0x16, 0x18, 0x0c, 0x10, 0x06, 0x1a,
  0x04, 0x18, 0x0c, 0x14, 0x00, 0x16, 0x10, 0x06,
  0x08, 0x1a, 0x0e, 0x0a, 0x1e, 0x1c, 0x02, 0x12,
  0x18, 0x0a, 0x02, 0x1e, 0x1c, 0x1a, 0x08, 0x14,
  0x00, 0x0e, 0x0c, 0x06, 0x12, 0x04, 0x10, 0x16,
  0x1a, 0x16, 0x0e, 0x1c, 0x18, 0x02, 0x06, 0x12,
  0x0a, 0x00, 0x1e, 0x08, 0x10, 0x0c, 0x04, 0x14,
  0x0c, 0x1e, 0x1c, 0x12, 0x16, 0x06, 0x00, 0x10,
  0x18, 0x04, 0x1a, 0x0e, 0x02, 0x08, 0x14, 0x0a,
  0x14, 0x04, 0x10, 0x08, 0x0e, 0x0c, 0x02, 0x0a,
  0x1e, 0x16, 0x12, 0x1c, 0x06, 0x18, 0x1a, 0x00,
  0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e,
  0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e,
  0x1c, 0x14, 0x08, 0x10, 0x12, 0x1e, 0x1a, 0x0c,
  0x02, 0x18, 0x00, 0x04, 0x16, 0x0e, 0x0a, 0x06
]);

/**
 * BLAKE2b
 */

class BLAKE2b {
  constructor() {
    this.state = new Uint32Array(16);
    this.V = new Uint32Array(32);
    this.M = new Uint32Array(32);
    this.block = Buffer.alloc(128);
    this.size = 32;
    this.count = 0;
    this.pos = FINALIZED;
  }

  init(size, key) {
    if (size == null)
      size = 32;

    assert((size >>> 0) === size);
    assert(key == null || (key != null && key._isBuffer === true));

    if (size === 0 || size > 64)
      throw new Error('Bad output length.');

    if (key && key.length > 64)
      throw new Error('Bad key length.');

    const klen = key ? key.length : 0;

    for (let i = 0; i < 16; i++)
      this.state[i] = IV[i];

    this.size = size;
    this.count = 0;
    this.pos = 0;

    this.state[0] ^= 0x01010000 ^ (klen << 8) ^ this.size;

    if (klen > 0) {
      const block = Buffer.alloc(128, 0x00);

      key.copy(block, 0);

      this.update(block);
    }

    return this;
  }

  update(data) {
    assert((data != null && data._isBuffer === true));
    assert(!(this.pos & FINALIZED), 'Context is not initialized.');

    let off = 0;
    let len = data.length;

    if (len > 0) {
      const left = this.pos;
      const fill = 128 - left;

      if (len > fill) {
        this.pos = 0;

        data.copy(this.block, left, off, off + fill);

        this.count += 128;
        this._compress(this.block, 0, false);

        off += fill;
        len -= fill;

        while (len > 128) {
          this.count += 128;
          this._compress(data, off, false);
          off += 128;
          len -= 128;
        }
      }

      data.copy(this.block, this.pos, off, off + len);

      this.pos += len;
    }

    return this;
  }

  final() {
    assert(!(this.pos & FINALIZED), 'Context is not initialized.');

    this.count += this.pos;
    this.block.fill(0, this.pos, 128);
    this._compress(this.block, 0, true);
    this.pos = FINALIZED;

    const out = Buffer.alloc(this.size);

    for (let i = 0; i < this.size; i++)
      out[i] = this.state[i >>> 2] >>> (8 * (i & 3));

    for (let i = 0; i < 16; i++)
      this.state[i] = 0;

    for (let i = 0; i < 32; i++) {
      this.V[i] = 0;
      this.M[i] = 0;
    }

    for (let i = 0; i < 128; i++)
      this.block[i] = 0;

    return out;
  }

  _compress(block, off, last) {
    const {V, M} = this;

    for (let i = 0; i < 16; i++) {
      V[i] = this.state[i];
      V[i + 16] = IV[i];
    }

    // uint128
    V[24] ^= this.count;
    V[25] ^= this.count * (1 / 0x100000000);
    V[26] ^= 0;
    V[27] ^= 0;

    if (last) {
      // last block
      V[28] ^= -1;
      V[29] ^= -1;

      // last node
      V[29] ^= 0;
      V[30] ^= 0;
    }

    for (let i = 0; i < 32; i++) {
      M[i] = readU32(block, off);
      off += 4;
    }

    for (let i = 0; i < 12; i++) {
      G(V, M, 0, 8, 16, 24, SIGMA[i * 16 + 0], SIGMA[i * 16 + 1]);
      G(V, M, 2, 10, 18, 26, SIGMA[i * 16 + 2], SIGMA[i * 16 + 3]);
      G(V, M, 4, 12, 20, 28, SIGMA[i * 16 + 4], SIGMA[i * 16 + 5]);
      G(V, M, 6, 14, 22, 30, SIGMA[i * 16 + 6], SIGMA[i * 16 + 7]);
      G(V, M, 0, 10, 20, 30, SIGMA[i * 16 + 8], SIGMA[i * 16 + 9]);
      G(V, M, 2, 12, 22, 24, SIGMA[i * 16 + 10], SIGMA[i * 16 + 11]);
      G(V, M, 4, 14, 16, 26, SIGMA[i * 16 + 12], SIGMA[i * 16 + 13]);
      G(V, M, 6, 8, 18, 28, SIGMA[i * 16 + 14], SIGMA[i * 16 + 15]);
    }

    for (let i = 0; i < 16; i++)
      this.state[i] ^= V[i] ^ V[i + 16];
  }

  static hash() {
    return new BLAKE2b();
  }

  static hmac(size) {
    return new HMAC(BLAKE2b, 128, [size]);
  }

  static digest(data, size, key) {
    const {ctx} = BLAKE2b;

    ctx.init(size, key);
    ctx.update(data);

    return ctx.final();
  }

  static root(left, right, size, key) {
    if (size == null)
      size = 32;

    assert((left != null && left._isBuffer === true) && left.length === size);
    assert((right != null && right._isBuffer === true) && right.length === size);

    const {ctx} = BLAKE2b;

    ctx.init(size, key);
    ctx.update(left);
    ctx.update(right);

    return ctx.final();
  }

  static multi(x, y, z, size, key) {
    const {ctx} = BLAKE2b;

    ctx.init(size, key);
    ctx.update(x);
    ctx.update(y);

    if (z)
      ctx.update(z);

    return ctx.final();
  }

  static mac(data, key, size) {
    return BLAKE2b.hmac(size).init(key).update(data).final();
  }
}

/*
 * Static
 */

BLAKE2b.native = 0;
BLAKE2b.id = 'BLAKE2B256';
BLAKE2b.size = 32;
BLAKE2b.bits = 256;
BLAKE2b.blockSize = 128;
BLAKE2b.zero = Buffer.alloc(32, 0x00);
BLAKE2b.ctx = new BLAKE2b();

/*
 * Helpers
 */

function sum64i(v, a, b) {
  const o0 = v[a + 0] + v[b + 0];
  const o1 = v[a + 1] + v[b + 1];
  const c = (o0 >= 0x100000000) | 0;

  v[a + 0] = o0;
  v[a + 1] = o1 + c;
}

function sum64w(v, a, b0, b1) {
  const o0 = v[a + 0] + b0;
  const o1 = v[a + 1] + b1;
  const c = (o0 >= 0x100000000) | 0;

  v[a + 0] = o0;
  v[a + 1] = o1 + c;
}

function G(v, m, a, b, c, d, ix, iy) {
  const x0 = m[ix + 0];
  const x1 = m[ix + 1];
  const y0 = m[iy + 0];
  const y1 = m[iy + 1];

  sum64i(v, a, b);
  sum64w(v, a, x0, x1);

  const xor0 = v[d + 0] ^ v[a + 0];
  const xor1 = v[d + 1] ^ v[a + 1];

  v[d + 0] = xor1;
  v[d + 1] = xor0;

  sum64i(v, c, d);

  const xor2 = v[b + 0] ^ v[c + 0];
  const xor3 = v[b + 1] ^ v[c + 1];

  v[b + 0] = (xor2 >>> 24) ^ (xor3 << 8);
  v[b + 1] = (xor3 >>> 24) ^ (xor2 << 8);

  sum64i(v, a, b);
  sum64w(v, a, y0, y1);

  const xor4 = v[d + 0] ^ v[a + 0];
  const xor5 = v[d + 1] ^ v[a + 1];

  v[d + 0] = (xor4 >>> 16) ^ (xor5 << 16);
  v[d + 1] = (xor5 >>> 16) ^ (xor4 << 16);

  sum64i(v, c, d);

  const xor6 = v[b + 0] ^ v[c + 0];
  const xor7 = v[b + 1] ^ v[c + 1];

  v[b + 0] = (xor7 >>> 31) ^ (xor6 << 1);
  v[b + 1] = (xor6 >>> 31) ^ (xor7 << 1);
}

function readU32(data, off) {
  return (data[off++]
        + data[off++] * 0x100
        + data[off++] * 0x10000
        + data[off] * 0x1000000);
}

/*
 * Expose
 */

module.exports = BLAKE2b;
}],
[/* 123 */ 'bns-plus', '/lib/sig0.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * sig0.js - SIG(0) for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 *
 * Parts of this software are based on miekg/dns:
 *   https://github.com/miekg/dns/blob/master/sig0.go
 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const bio = __browser_require__(14 /* 'bufio' */, module);
const constants = __browser_require__(11 /* './constants' */, module);
const dnssec = __browser_require__(99 /* './dnssec' */, module);
const encoding = __browser_require__(80 /* './encoding' */, module);
const util = __browser_require__(79 /* './util' */, module);
const wire = __browser_require__(90 /* './wire' */, module);

const {
  types,
  classes,
  algs,
  algsByVal,
  hashes,
  hashesByVal,
  algHashes
} = constants;

const {
  algToHash,
  hashToHash
} = dnssec;

const {
  readNameBR,
  writeNameBW,
  sizeName,
  toName
} = encoding;

const {
  Record,
  KEYRecord,
  SIGRecord
} = wire;

/*
 * Constants
 */

const DUMMY = Buffer.alloc(0);
const DEFAULT_FUDGE = 300;

/*
 * SIG(0)
 */

const sig0 = exports;

sig0.filename = dnssec.filename;
sig0.privFile = dnssec.privFile;
sig0.pubFile = dnssec.pubFile;

sig0.createPrivate = dnssec.createPrivate;
sig0.createPrivateAsync = dnssec.createPrivateAsync;
sig0.createPublic = dnssec.createPublic;
sig0.encodePrivate = dnssec.encodePrivate;
sig0.decodePrivate = dnssec.decodePrivate;

sig0.readPrivate = dnssec.readPrivate;
sig0.readPrivateAsync = dnssec.readPrivateAsync;
sig0.readPublic = dnssec.readPublic;
sig0.readPublicAsync = dnssec.readPublicAsync;
sig0.writeKeys = dnssec.writeKeys;
sig0.writeKeysAsync = dnssec.writeKeysAsync;
sig0.writePrivate = dnssec.writePrivate;
sig0.writePrivateAsync = dnssec.writePrivateAsync;
sig0.writePublic = dnssec.writePublic;
sig0.writePublicAsync = dnssec.writePublicAsync;

sig0.makeKey = function makeKey(algorithm, priv) {
  const pub = sig0.createPublic(algorithm, priv);
  return sig0.createKey(algorithm, pub);
};

sig0.createKey = function createKey(algorithm, publicKey, prefix) {
  assert((algorithm & 0xff) === algorithm);
  assert((publicKey != null && publicKey._isBuffer === true));

  const rr = new Record();
  const rd = new KEYRecord();

  rr.name = '.';
  rr.class = classes.IN;
  rr.type = types.KEY;
  rr.ttl = 0;
  rr.data = rd;

  rd.flags = 0;
  rd.protocol = 0;
  rd.algorithm = algorithm;

  // https://tools.ietf.org/html/rfc4034#appendix-A.1.1
  // PRIVATEDNS publicKey should be wire encoded and prefixed with algo name
  if (algorithm === sig0.algs.PRIVATEDNS) {
    prefix = toName(prefix);
    const key = bio.write(sizeName(prefix) + publicKey.length);
    writeNameBW(key, prefix);
    key.writeBytes(publicKey);
    publicKey = key.render();
  }

  rd.publicKey = publicKey;

  return rr;
};

sig0.sign = function sign(msg, key, priv, fudge, signer) {
  if (fudge == null)
    fudge = DEFAULT_FUDGE;

  assert((msg != null && msg._isBuffer === true));
  assert(msg.length >= 12);
  assert(key instanceof Record);
  assert(key.type === types.KEY);
  assert((priv != null && priv._isBuffer === true));
  assert((fudge >>> 0) === fudge);
  assert(signer == null || typeof signer === 'function');

  const now = util.now();
  const rr = new Record();
  const rd = new SIGRecord();

  rr.name = '.';
  rr.type = types.SIG;
  rr.class = classes.ANY;
  rr.ttl = 0;
  rr.data = rd;
  rd.typeCovered = 0;
  rd.algorithm = key.data.algorithm;
  rd.labels = 0;
  rd.origTTL = 0;
  rd.expiration = now + fudge;
  rd.inception = now - fudge;
  rd.keyTag = key.data.keyTag();
  rd.signerName = '.';
  rd.signature = DUMMY;

  const pre = removeSIG(msg);
  const data = sigData(pre, rd, 0);

  if (rd.algorithm === algs.PRIVATEDNS) {
    if (!signer)
      throw new Error('Signer not available.');

    rd.signature = signer(priv, data);
  } else {
    rd.signature = dnssec.signData(priv, data, rd.algorithm);
  }

  const arcount = bio.readU16BE(pre, 10);
  const size = rr.getSize();
  const bw = bio.write(pre.length + size);

  bw.copy(pre, 0, 10);
  bw.writeU16BE(arcount + 1);
  bw.copy(pre, 12, pre.length);
  rr.write(bw);

  return bw.render();
};

sig0.verify = function verify(msg, key, verifier) {
  assert((msg != null && msg._isBuffer === true));
  assert(key instanceof Record);
  assert(key.type === types.KEY);
  assert(verifier == null || typeof verifier === 'function');

  const [pos, rr] = findSIG(msg);

  if (pos === -1)
    return false;

  const rd = rr.data;

  if (rd.algorithm !== key.data.algorithm)
    return false;

  if (rd.labels !== 0)
    return false;

  if (rd.origTTL !== 0)
    return false;

  const now = util.now();

  if (now < rd.inception)
    return false;

  if (now > rd.expiration)
    return false;

  if (rd.algorithm !== algs.PRIVATEDNS) {
    if (rd.keyTag !== key.data.keyTag())
      return false;
  }

  if (rd.signerName !== '.')
    return false;

  const pre = msg.slice(0, pos);
  const data = sigData(pre, rd, -1);

  if (rd.algorithm === algs.PRIVATEDNS) {
    if (!verifier)
      throw new Error('Verifier not available.');

    return verifier(rr, key, data);
  }

  return dnssec.verifyData(rr, key, data, rd.algorithm);
};

/*
 * Helpers
 */

function findSIG(msg) {
  assert((msg != null && msg._isBuffer === true));

  try {
    return _findSIG(msg);
  } catch (e) {
    return [-1, null];
  }
}

function _findSIG(msg) {
  const br = bio.read(msg);

  br.readU16BE();
  br.readU16BE();

  const qdcount = br.readU16BE();
  const ancount = br.readU16BE();
  const nscount = br.readU16BE();
  const arcount = br.readU16BE();

  if (arcount === 0)
    return [-1, null];

  for (let i = 0; i < qdcount; i++) {
    if (br.left() === 0)
      return [-1, null];

    readNameBR(br);
    br.seek(4);
  }

  for (let i = 0; i < ancount; i++) {
    if (br.left() === 0)
      return [-1, null];

    readNameBR(br);
    br.seek(8);
    br.seek(br.readU16BE());
  }

  for (let i = 0; i < nscount; i++) {
    if (br.left() === 0)
      return [-1, null];

    readNameBR(br);
    br.seek(8);
    br.seek(br.readU16BE());
  }

  for (let i = 0; i < arcount - 1; i++) {
    if (br.left() === 0)
      return [-1, null];

    readNameBR(br);
    br.seek(8);
    br.seek(br.readU16BE());
  }

  const offset = br.offset;
  const rr = Record.read(br);
  const rd = rr.data;

  if (rr.name !== '.')
    return [-1, null];

  if (rr.type !== types.SIG)
    return [-1, null];

  if (rr.class !== classes.ANY)
    return [-1, null];

  if (rr.ttl !== 0)
    return [-1, null];

  if (rd.typeCovered !== 0)
    return [-1, null];

  return [offset, rr];
}

function removeSIG(msg) {
  assert((msg != null && msg._isBuffer === true));
  assert(msg.length >= 12);

  const [pos] = findSIG(msg);

  if (pos === -1)
    return msg;

  const arcount = bio.readU16BE(msg, 10);
  const buf = Buffer.allocUnsafe(pos);
  msg.copy(buf, 0, 0, pos);
  bio.writeU16BE(buf, arcount - 1, 10);

  return buf;
}

function sigData(msg, rd, offset) {
  assert((msg != null && msg._isBuffer === true));
  assert(msg.length >= 12);
  assert(rd instanceof SIGRecord);
  assert(Number.isSafeInteger(offset));

  const sig = rd.signature;
  const arcount = bio.readU16BE(msg, 10);

  if (arcount + offset < 0)
    throw new Error('Invalid offset.');

  rd.signature = DUMMY;

  let size = 0;
  size += rd.getSize();
  size += msg.length;

  const bw = bio.write(size);

  rd.write(bw);
  bw.copy(msg, 0, 10);
  bw.writeU16BE(arcount + offset);
  bw.copy(msg, 12, msg.length);

  rd.signature = sig;

  return bw.render();
}

/*
 * Expose
 */

sig0.algs = algs;
sig0.algsByVal = algsByVal;
sig0.hashes = hashes;
sig0.hashesByVal = hashesByVal;
sig0.algHashes = algHashes;
sig0.algToHash = algToHash;
sig0.hashToHash = hashToHash;
}],
[/* 124 */ 'bns-plus', '/lib/nsec3.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * nsec3.js - NSEC3 for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 *
 * Parts of this software are based on miekg/dns and golang/go:
 *   https://github.com/miekg/dns/blob/master/nsecx.go
 *
 * Parts of this software are based on solvere:
 *   https://github.com/rolandshoemaker/solvere
 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const base32 = __browser_require__(7 /* 'bs32' */, module);
const constants = __browser_require__(11 /* './constants' */, module);
const crypto = __browser_require__(13 /* './internal/crypto' */, module);
const encoding = __browser_require__(80 /* './encoding' */, module);
const wire = __browser_require__(90 /* './wire' */, module);
const util = __browser_require__(79 /* './util' */, module);

const {
  types,
  nsecHashes,
  nsecHashesByVal
} = constants;

const {
  hasType,
  packName
} = encoding;

const {
  Question,
  Record
} = wire;

/*
 * Constants
 */

const MAX_ITERATIONS = 512;

/*
 * NSEC3
 */

const nsec3 = exports;

nsec3.hashName = function hashName(name, ha, iter, salt) {
  assert(typeof name === 'string');
  assert((ha & 0xff) === ha);
  assert((iter & 0xffff) === iter);
  assert((salt != null && salt._isBuffer === true));

  // DoS vector.
  if (iter > MAX_ITERATIONS)
    return null;

  const nameRaw = packName(name.toLowerCase());
  const saltRaw = salt;

  let hash = null;

  switch (ha) {
    case nsecHashes.SHA1:
      hash = crypto.sha1;
      break;
  }

  if (!hash)
    return null;

  let nameHash = hash.multi(nameRaw, saltRaw);

  for (let i = 0; i < iter; i++)
    nameHash = hash.multi(nameHash, saltRaw);

  return nameHash;
};

nsec3.cover = function cover(rr, name) {
  assert(rr instanceof Record);
  assert(rr.type === types.NSEC3);

  const rd = rr.data;
  const nameHash = nsec3.hashName(name, rd.hash, rd.iterations, rd.salt);

  if (!nameHash)
    return false;

  const owner = rr.name;
  const label = util.split(owner);

  if (label.length < 2)
    return false;

  const owner32 = owner.substring(0, label[1] - 1);
  const ownerZone = owner.substring(label[1]);
  const ownerHash = decodeHex(owner32);

  if (!ownerHash)
    return false;

  if (ownerHash.length !== nameHash.length)
    return false;

  if (!util.isSubdomain(ownerZone, name))
    return false;

  const nextHash = rd.nextDomain;

  if (nextHash.length !== nameHash.length)
    return false;

  if (ownerHash.equals(nextHash))
    return false;

  if (ownerHash.compare(nextHash) > 0) {
    if (nameHash.compare(ownerHash) > 0)
      return true;
    return nameHash.compare(nextHash) < 0;
  }

  if (nameHash.compare(ownerHash) < 0)
    return false;

  return nameHash.compare(nextHash) < 0;
};

nsec3.match = function match(rr, name) {
  assert(rr instanceof Record);
  assert(rr.type === types.NSEC3);

  const rd = rr.data;
  const nameHash = nsec3.hashName(name, rd.hash, rd.iterations, rd.salt);

  if (!nameHash)
    return false;

  const owner = rr.name;
  const label = util.split(owner);

  if (label.length < 2)
    return false;

  const owner32 = owner.substring(0, label[1] - 1);
  const ownerZone = owner.substring(label[1]);
  const ownerHash = decodeHex(owner32);

  if (!ownerHash)
    return false;

  if (ownerHash.length !== nameHash.length)
    return false;

  if (!util.isSubdomain(ownerZone, name))
    return false;

  if (ownerHash.equals(nameHash))
    return true;

  return false;
};

nsec3.findClosestEncloser = function findClosestEncloser(name, nsec) {
  assert(typeof name === 'string');
  assert(Array.isArray(nsec));

  const label = util.split(name);

  let nc = name;

  for (let i = 0; i < label.length; i++) {
    const z = name.substring(label[i]);
    const bm = nsec3.findMatching(z, nsec);

    if (!bm)
      continue;

    if (i !== 0)
      nc = name.substring(label[i - 1]);

    return [z, nc];
  }

  return ['', ''];
};

nsec3.findMatching = function findMatching(name, nsec) {
  assert(typeof name === 'string');
  assert(Array.isArray(nsec));

  for (const rr of nsec) {
    if (nsec3.match(rr, name))
      return rr.data.typeBitmap;
  }

  return null; // NSEC missing coverage
};

nsec3.findCoverer = function findCoverer(name, nsec) {
  assert(typeof name === 'string');
  assert(Array.isArray(nsec));

  for (const rr of nsec) {
    if (nsec3.cover(rr, name)) {
      const rd = rr.data;
      return [rd.typeBitmap, (rd.flags & 1) === 1];
    }
  }

  return [null, false]; // NSEC missing coverage
};

nsec3.verifyNameError = function verifyNameError(qs, nsec) {
  const [ce, nc] = nsec3.findClosestEncloser(qs.name, nsec);

  if (ce === '')
    return false; // NSEC missing coverage

  const [cv] = nsec3.findCoverer(nc, nsec);

  if (!cv)
    return false; // NSEC missing coverage

  return true;
};

nsec3.verifyNoData = function verifyNoData(qs, nsec) {
  assert(qs instanceof Question);
  assert(Array.isArray(nsec));

  const bm = nsec3.findMatching(qs.name, nsec);

  if (!bm) {
    if (qs.type !== types.DS)
      return false; // NSEC missing coverage

    const [ce, nc] = nsec3.findClosestEncloser(qs.name, nsec);

    if (ce === '')
      return false; // NSEC missing coverage

    const [b, optOut] = nsec3.findCoverer(nc, nsec);

    if (!b)
      return false; // NSEC missing coverage

    if (!optOut)
      return false; // NSEC opt out

    return true;
  }

  if (hasType(bm, qs.type))
    return false; // NSEC type exists

  if (hasType(bm, types.CNAME))
    return false; // NSEC type exists

  return true;
};

nsec3.verifyDelegation = function verifyDelegation(delegation, nsec) {
  const bm = nsec3.findMatching(delegation, nsec);

  if (!bm) {
    const [ce, nc] = nsec3.findClosestEncloser(delegation, nsec);

    if (ce === '')
      return false; // NSEC missing coverage

    const [b, optOut] = nsec3.findCoverer(nc, nsec);

    if (!b)
      return false; // NSEC missing coverage

    if (!optOut)
      return false; // NSEC opt out

    return true;
  }

  if (!hasType(bm, types.NS))
    return false; // NSEC NS missing

  if (hasType(bm, types.DS))
    return false; // NSEC bad delegation

  if (hasType(bm, types.SOA))
    return false; // NSEC bad delegation

  return true;
};

/*
 * Helpers
 */

function decodeHex(str) {
  try {
    return base32.decodeHex(str);
  } catch (e) {
    return null;
  }
}

/*
 * Expose
 */

nsec3.hashes = nsecHashes;
nsec3.hashesByVal = nsecHashesByVal;
}],
[/* 125 */ 'bns-plus', '/lib/ownership.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * ownership.js - DNSSEC ownership proofs for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const bio = __browser_require__(14 /* 'bufio' */, module);
const constants = __browser_require__(11 /* './constants' */, module);
const crypto = __browser_require__(13 /* './internal/crypto' */, module);
const dnssec = __browser_require__(99 /* './dnssec' */, module);
const encoding = __browser_require__(80 /* './encoding' */, module);
const util = __browser_require__(79 /* './util' */, module);
const wire = __browser_require__(90 /* './wire' */, module);

const {
  types,
  typeToString,
  algs,
  hashes,
  keyFlags,
  KSK_2017
} = constants;

const {
  readNameBR
} = encoding;

const {
  Record,
  TXTRecord
} = wire;

/*
 * Constants
 */

const rootAnchors = [
  Record.fromString(KSK_2017)
];

/**
 * Ownership
 */

class Ownership {
  constructor() {
    this.Resolver = null;
    this.servers = ['8.8.8.8', '8.8.4.4'];

    this.secure = true;
    this.anchors = rootAnchors.slice();
    this.minBits = 1017;
    this.strongBits = 2041;
    this.maxBits = 4096;
    this.ignore = false;

    this.rootAnchors = rootAnchors;
    this.Proof = Proof;
    this.OwnershipProof = Proof;
    this.Zone = Zone;
  }

  hasPrefix(proof, target, items) {
    return false;
  }

  isData(proof, target, items, extra) {
    return true;
  }

  parseData(proof, target, items, extra) {
    return {
      target,
      items
    };
  }

  addData(proof, items) {
    assert(proof instanceof this.Proof);
    assert(Array.isArray(items));

    if (items.length === 0)
      throw new Error('No items provided.');

    if (proof.zones.length < 2)
      throw new Error('Incomplete proof.');

    const zone = proof.zones[proof.zones.length - 1];

    if (zone.claim.length === 0)
      throw new Error('Zone has no claim records.');

    const rr = new Record();
    const rd = new TXTRecord();

    rr.name = zone.claim[0].name.toLowerCase();
    rr.type = types.TXT;
    rr.class = zone.claim[0].class;
    rr.ttl = zone.claim[0].ttl;
    rr.data = rd;

    for (const txt of items) {
      assert(typeof txt === 'string');
      rd.txt.push(txt);
    }

    const sig = zone.claim.pop();

    zone.claim.push(rr);
    zone.claim.push(sig);

    return rr;
  }

  removeData(proof) {
    assert(proof instanceof this.Proof);

    if (proof.zones.length < 2)
      return false;

    const zone = proof.zones[proof.zones.length - 1];

    if (zone.claim.length === 0)
      return false;

    zone.claim = this.filterSet(proof, zone.claim);

    return true;
  }

  filterSet(proof, rrs) {
    assert(proof instanceof this.Proof);
    assert(Array.isArray(rrs));

    const rrset = [];

    if (rrs.length === 0)
      return rrset;

    const target = rrs[0].name.toLowerCase();

    for (const rr of rrs) {
      assert(rr instanceof Record);

      const rd = rr.data;

      if (rr.type === types.TXT && rd.txt.length > 0) {
        if (this.hasPrefix(proof, target, rd.txt))
          continue;
      }

      rrset.push(rr);
    }

    return rrset;
  }

  filterClaim(proof, rrs) {
    if (!this.ignore)
      return rrs;

    return this.filterSet(proof, rrs);
  }

  getData(proof, extra) {
    assert(proof instanceof this.Proof);

    try {
      return this._getData(proof, extra);
    } catch (e) {
      if (e.code === 'ERR_ASSERTION')
        throw e;
      return null;
    }
  }

  _getData(proof, extra) {
    assert(proof instanceof this.Proof);

    if (proof.zones.length < 2)
      return null;

    const zone = proof.zones[proof.zones.length - 1];

    if (zone.claim.length === 0)
      return null;

    const target = zone.claim[0].name.toLowerCase();

    for (const rr of zone.claim) {
      if (rr.type !== types.TXT)
        continue;

      const rd = rr.data;

      if (rd.txt.length === 0)
        continue;

      if (!this.isData(proof, target, rd.txt, extra))
        continue;

      let result = null;

      try {
        result = this.parseData(proof, target, rd.txt, extra);
      } catch (e) {
        if (e.code === 'ERR_ASSERTION')
          throw e;
      }

      return result;
    }

    return null;
  }

  isSane(proof) {
    assert(proof instanceof this.Proof);

    if (proof.zones.length < 2)
      return false;

    let parent = '';

    for (let i = 0; i < proof.zones.length; i++) {
      const zone = proof.zones[i];
      const isLast = i === proof.zones.length - 1;

      if (!this.checkSanity(zone, parent, isLast))
        return false;

      parent = zone.keys[0].name;
    }

    return true;
  }

  verifyTimes(proof, time) {
    assert(proof instanceof this.Proof);
    assert(Number.isSafeInteger(time) && time >= 0);

    if (proof.zones.length < 2)
      return false;

    const [start, end] = this.getWindow(proof);

    return time >= start && time <= end;
  }

  verifySignatures(proof) {
    assert(proof instanceof this.Proof);

    if (proof.zones.length < 2)
      return false;

    let ds = this.anchors;
    let i = 0;

    for (; i < proof.zones.length - 1; i++) {
      const zone = proof.zones[i];

      if (!this.verifyKeys(zone, ds))
        return false;

      if (!this.verifyRecords(zone.referral, zone.keys))
        return false;

      ds = util.extractSet(zone.referral, '', types.DS);
    }

    const zone = proof.zones[i];

    if (!this.verifyKeys(zone, ds))
      return false;

    const claim = this.filterClaim(proof, zone.claim);

    if (!this.verifyRecords(claim, zone.keys))
      return false;

    return true;
  }

  isWeak(proof) {
    assert(proof instanceof this.Proof);

    if (proof.zones.length < 2)
      return false;

    for (const zone of proof.zones) {
      const ksk = extractKey(zone.keys, zone.keys);

      if (ksk && this.isRSA(ksk.data.algorithm)) {
        const bits = crypto.rsaBits(ksk.data.publicKey);

        if (bits < this.strongBits)
          return true; // Insecure Signature.
      }

      const zsk = extractKey(zone.body, zone.keys);

      if (zsk && this.isRSA(zsk.data.algorithm)) {
        const bits = crypto.rsaBits(zsk.data.publicKey);

        if (bits < this.strongBits)
          return true; // Insecure Signature.
      }
    }

    return false;
  }

  getWindow(proof) {
    assert(proof instanceof this.Proof);

    let start = -1;
    let end = -1;

    for (const rr of proof.records()) {
      assert(rr instanceof Record);

      if (rr.type !== types.RRSIG)
        continue;

      const rd = rr.data;

      if (start === -1 || rd.inception > start)
        start = rd.inception;

      if (end === -1 || rd.expiration < end)
        end = rd.expiration;
    }

    if (start === -1 || end === -1)
      return [0, 0];

    if (start > end)
      return [0, 0];

    return [start, end];
  }

  checkSanity(zone, parent, isLast) {
    assert(zone instanceof Zone);
    assert(typeof parent === 'string');
    assert(typeof isLast === 'boolean');

    if (zone.keys.length === 0)
      return false;

    if (isLast) {
      if (zone.referral.length !== 0)
        return false;

      if (zone.claim.length === 0)
        return false;
    } else {
      if (zone.referral.length === 0)
        return false;

      if (zone.claim.length !== 0)
        return false;
    }

    const zoneName = zone.keys[0].name;
    const zoneLabels = util.countLabels(zoneName);

    if (!this.isChild(parent, zoneName))
      return false;

    let sawKeys = false;

    for (const rr of zone.keys) {
      assert(rr instanceof Record);

      if (!util.equal(rr.name, zoneName))
        return false;

      const rd = rr.data;

      switch (rr.type) {
        case types.RRSIG:
          if (rd.typeCovered !== types.DNSKEY)
            return false;

          if (!this.isValidAlg(rd.algorithm))
            return false;

          if (rd.labels !== zoneLabels)
            return false;

          if (!util.equal(rd.signerName, zoneName))
            return false;

          if (sawKeys)
            return false;

          sawKeys = true;

          break;
        case types.DNSKEY:
          break;
        default:
          return false;
      }
    }

    if (!sawKeys)
      return false;

    if (zone.claim.length > 0) {
      let sawClaim = false;

      for (const rr of zone.claim) {
        assert(rr instanceof Record);

        if (!util.equal(rr.name, zoneName))
          return false;

        const rd = rr.data;

        switch (rr.type) {
          case types.RRSIG:
            if (rd.typeCovered !== types.TXT)
              return false;

            if (!this.isValidAlg(rd.algorithm))
              return false;

            if (rd.labels !== zoneLabels)
              return false;

            if (!util.equal(rd.signerName, zoneName))
              return false;

            if (sawClaim)
              return false;

            sawClaim = true;

            break;
          case types.TXT:
            break;
          default:
            return false;
        }
      }

      if (!sawClaim)
        return false;
    }

    if (zone.referral.length > 0) {
      const dsName = zone.referral[0].name;
      const dsLabels = util.countLabels(dsName);

      if (!this.isChild(zoneName, dsName))
        return false;

      let sawReferral = false;

      for (const rr of zone.referral) {
        assert(rr instanceof Record);

        if (!util.equal(rr.name, dsName))
          return false;

        const rd = rr.data;

        switch (rr.type) {
          case types.RRSIG:
            if (rd.typeCovered !== types.DS)
              return false;

            if (!this.isValidAlg(rd.algorithm))
              return false;

            if (rd.labels !== dsLabels)
              return false;

            if (!util.equal(rd.signerName, zoneName))
              return false;

            if (sawReferral)
              return false;

            sawReferral = true;

            break;
          case types.DS:
            break;
          default:
            return false;
        }
      }

      if (!sawReferral)
        return false;
    }

    return true;
  }

  verifyChain(keys, ds) {
    assert(Array.isArray(keys));
    assert(Array.isArray(ds));

    const [ksk, tag] = getKSK(keys);

    if (!ksk)
      return null;

    const map = new Map();

    map.set(tag, ksk);

    if (this.secure) {
      for (const key of getDowngraded(ksk, keys)) {
        const tag = key.data.keyTag();

        if (!map.has(tag))
          map.set(tag, key);
      }
    }

    for (const rr of ds) {
      assert(rr instanceof Record);
      assert(rr.type === types.DS);

      const rd = rr.data;

      // Never allow SHA1 for DS hashes.
      if (this.secure && rd.digestType === hashes.SHA1)
        continue;

      // Find the DS record with our tag.
      const key = map.get(rd.keyTag);

      if (!key)
        continue;

      // Recreate the DS record from our key.
      const ds = dnssec.createDS(key, rd.digestType);

      if (!ds)
        continue; // Failed to convert KSK (unknown alg).

      if (!ds.data.digest.equals(rd.digest))
        continue; // Mismatching DS.

      if (ds.data.algorithm !== rd.algorithm)
        continue; // Mismatching DS.

      return ksk;
    }

    return null;
  }

  verifyRecords(rrs, keys) {
    assert(Array.isArray(rrs));
    assert(Array.isArray(keys));

    const [sig, rrset] = splitSet(rrs);

    if (!sig)
      return false;

    const key = findKey(keys, sig.data.keyTag);

    if (!key)
      return false; // Missing DNS Key.

    return this.verifySignature(sig, key, rrset);
  }

  verifyKey(key, hardened = false) {
    assert(key instanceof Record);
    assert(key.type === types.DNSKEY);
    assert(typeof hardened === 'boolean');

    const kd = key.data;

    if (!this.isValidAlg(kd.algorithm))
      return false; // Invalid Algorithm.

    if (this.secure && this.isSHA1(kd.algorithm))
      return false; // Insecure Signature.

    if (this.isRSA(kd.algorithm)) {
      const bits = crypto.rsaBits(kd.publicKey);

      if (bits < this.minBits || bits > this.maxBits)
        return false; // Insecure Signature.

      if (hardened && bits < this.strongBits)
        return false; // Insecure Signature.
    }

    return true;
  }

  verifySignature(sig, key, rrset) {
    assert(sig instanceof Record);
    assert(sig.type === types.RRSIG);
    assert(key instanceof Record);
    assert(key.type === types.DNSKEY);
    assert(Array.isArray(rrset));

    if (rrset.length === 0)
      return false;

    if (!this.verifyKey(key))
      return false;

    return dnssec.verify(sig, key, rrset);
  }

  verifyKeys(zone, ds) {
    assert(zone instanceof Zone);

    const ksk = this.verifyChain(zone.keys, ds);

    if (!ksk)
      return false;

    const [sig, rrset] = splitSet(zone.keys);

    if (!sig)
      return false;

    return this.verifySignature(sig, ksk, rrset);
  }

  isValidAlg(algorithm) {
    assert((algorithm & 0xff) === algorithm);

    switch (algorithm) {
      case algs.RSASHA1:
      case algs.RSASHA1NSEC3SHA1:
      case algs.RSASHA256:
      case algs.RSASHA512:
      case algs.ECDSAP256SHA256:
      case algs.ECDSAP384SHA384:
      case algs.ED25519:
      case algs.ED448:
        return true;
      default:
        return false;
    }
  }

  isRSA(algorithm) {
    assert((algorithm & 0xff) === algorithm);

    switch (algorithm) {
      case algs.RSASHA1:
      case algs.RSASHA1NSEC3SHA1:
      case algs.RSASHA256:
      case algs.RSASHA512:
        return true;
      default:
        return false;
    }
  }

  isSHA1(algorithm) {
    assert((algorithm & 0xff) === algorithm);

    switch (algorithm) {
      case algs.RSASHA1:
      case algs.RSASHA1NSEC3SHA1:
        return true;
      default:
        return false;
    }
  }

  isChild(parent, child) {
    assert(typeof parent === 'string');
    assert(typeof child === 'string');

    if (parent === '')
      return child === '.';

    const labels = util.countLabels(parent);

    if (util.countLabels(child) !== labels + 1)
      return false;

    if (!util.isSubdomain(parent, child))
      return false;

    return true;
  }

  async prove(name, estimate = false) {
    assert(typeof name === 'string');
    assert(typeof estimate === 'boolean');

    name = util.fqdn(name);

    if (!encoding.isName(name))
      throw new Error(`Invalid name for proof: ${JSON.stringify(name)}.`);

    const {Resolver} = this;

    if (!Resolver)
      throw new Error('No resolver available.');

    const stub = new Resolver({
      rd: true,
      cd: true,
      edns: true,
      dnssec: true,
      hosts: [
        ['localhost.', '127.0.0.1'],
        ['localhost.', '::1']
      ],
      servers: this.servers
    });

    await stub.open();

    try {
      return await this._prove(stub, name, estimate);
    } finally {
      await stub.close();
    }
  }

  async _prove(stub, name, estimate) {
    assert(stub instanceof this.Resolver);
    assert(typeof name === 'string');
    assert(typeof estimate === 'boolean');

    const labels = util.split(name);

    assert(labels.length > 0);

    const zones = [];
    const target = new Zone();

    let ds = await this._lookup(stub, name, types.DS, []);

    try {
      target.claim = await this._lookup(stub, name, types.TXT, []);
    } catch (e) {
      if (!estimate)
        throw e;
    }

    target.keys = await this._lookup(stub, name, types.DNSKEY, ds);

    zones.push(target);

    for (let i = 1; i <= labels.length; i++) {
      let parent = '.';

      if (i < labels.length)
        parent = util.from(name, labels, i);

      const zone = new Zone();
      zone.referral = ds;

      if (parent === '.')
        ds = this.anchors;
      else
        ds = await this._lookup(stub, parent, types.DS, []);

      zone.keys = await this._lookup(stub, parent, types.DNSKEY, ds);
      zones.push(zone);
    }

    zones.reverse();

    const proof = new this.Proof();
    proof.zones = zones;
    proof.canonical();

    if (estimate)
      return proof;

    if (!this.isSane(proof))
      throw new Error('Proof failed sanity check.');

    if (!this.verifyTimes(proof, util.now()))
      throw new Error('Proof contains expired signature.');

    if (!this.verifySignatures(proof))
      throw new Error('Proof failed signature check.');

    return proof;
  }

  async _lookup(stub, name, type, ds) {
    assert(stub instanceof this.Resolver);
    assert(typeof name === 'string');
    assert((type & 0xffff) === type);
    assert(Array.isArray(ds));

    const res = await stub.lookup(name, type);
    const rrs = [];

    for (const rr of res.answer) {
      if (!util.equal(rr.name, name))
        continue;

      switch (rr.type) {
        case type:
        case types.RRSIG:
          rrs.push(rr);
          break;
      }
    }

    const result = this.filterSignatures(rrs, type, ds);

    if (!util.hasType(result, type)) {
      const sym = typeToString(type);
      throw new Error(`No ${sym} records for ${name}`);
    }

    if (!util.hasType(result, types.RRSIG)) {
      const sym = typeToString(type);
      throw new Error(`No RRSIG(${sym}) records for ${name}`);
    }

    return result;
  }

  filterSignatures(answer, type, ds) {
    assert(Array.isArray(answer));
    assert((type & 0xffff) === type);
    assert(Array.isArray(ds));

    const dsSet = toDSSet(ds);
    const keyMap = toKeyMap(answer);
    const revSet = toRevSet(answer);
    const now = util.now();
    const rrs = [];

    let sig = null;

    for (const rr of answer) {
      assert(rr instanceof Record);

      if (rr.type === types.RRSIG) {
        const rd = rr.data;

        if (rd.typeCovered !== type)
          continue;

        if (!this.isValidAlg(rd.algorithm))
          continue;

        // Ignore old signatures.
        if (!rd.validityPeriod(now))
          continue;

        // Ignore SHA1 if secure.
        if (this.secure && this.isSHA1(rd.algorithm))
          continue;

        if (type === types.DNSKEY) {
          const key = keyMap.get(rd.keyTag);

          // Don't include revocation sigs.
          if (key && (key.data.flags & keyFlags.REVOKE))
            continue;

          // Don't include sigs from revoked keys.
          if (revSet.has(rd.keyTag))
            continue;
        }

        if (sig) {
          const sd = sig.data;

          if (type === types.DNSKEY) {
            // Prefer committed keys no matter what.
            if (!dsSet.has(sd.keyTag) && dsSet.has(rd.keyTag)) {
              sig = rr;
              continue;
            }

            if (dsSet.has(sd.keyTag) && !dsSet.has(rd.keyTag))
              continue;
          }

          // Prefer more secure algorithms.
          if (rd.algorithm < sd.algorithm)
            continue;

          // Prefer larger key sizes.
          if (this.isRSA(rd.algorithm) && this.isRSA(sd.algorithm)) {
            if (rd.signature.length < sd.signature.length)
              continue;
          }
        }

        sig = rr;

        continue;
      }

      rrs.push(rr);
    }

    if (!sig) {
      // Error at a higher level.
      return rrs;
    }

    rrs.push(sig);

    for (const rr of rrs)
      rr.ttl = sig.data.origTTL;

    return rrs;
  }
}

/**
 * Proof
 * @extends {bufio.Struct}
 */

class Proof extends bio.Struct {
  constructor() {
    super();
    this.zones = [];
  }

  getTarget() {
    if (this.zones.length < 2)
      return '.';

    const zone = this.zones[this.zones.length - 1];

    if (zone.claim.length === 0)
      return '.';

    return zone.claim[0].name.toLowerCase();
  }

  *records() {
    for (const zone of this.zones) {
      for (const rr of zone.records())
        yield rr;
    }
  }

  inject(msg) {
    assert(msg instanceof this.constructor);
    this.zones = msg.zones.slice();
    return this;
  }

  deepClone() {
    const msg = new this.constructor();
    return msg.decode(this.encode());
  }

  canonical() {
    for (const zone of this.zones)
      zone.canonical();

    return this;
  }

  getSize(map) {
    let size = 1;

    for (const zone of this.zones)
      size += zone.getSize(map);

    return size;
  }

  write(bw, map) {
    bw.writeU8(this.zones.length);

    for (const zone of this.zones)
      zone.write(bw, map);

    return this;
  }

  read(br) {
    const zoneCount = br.readU8();

    for (let i = 0; i < zoneCount; i++) {
      const zone = Zone.read(br);
      this.zones.push(zone);
    }

    return this;
  }

  toString() {
    let str = '';

    str += `;; DNSSEC OWNERSHIP PROOF: ${this.getTarget().toUpperCase()}\n`;
    str += `;; SIZE: ${this.getSize()}\n`;
    str += '\n';

    for (let i = 0; i < this.zones.length; i++) {
      const zone = this.zones[i];
      str += zone.toString() + '\n';
    }

    return str;
  }

  fromString(str) {
    assert(typeof str === 'string');

    const rrs = wire.fromZone(str);

    if (rrs.length === 0)
      throw new Error('No records found.');

    let zone = new Zone();
    let name = rrs[0].name;
    let state = types.DNSKEY;

    for (const rr of rrs) {
      let type = rr.type;

      if (type === types.RRSIG)
        type = rr.data.typeCovered;

      switch (state) {
        case types.DNSKEY:
          if (type === types.TXT) {
            state = types.TXT;
          } else if (!util.equal(rr.name, name)) {
            name = rr.name;
            state = types.DS;
          }
          break;
        case types.DS:
          if (type === types.DNSKEY) {
            if (zone.keys.length === 0)
              throw new Error('Switching zones without any keys.');

            if (zone.referral.length === 0)
              throw new Error('Switching zones without a referral.');

            this.zones.push(zone);

            zone = new Zone();
            state = types.DNSKEY;
          }
          break;
        case types.TXT:
          break;
        default:
          assert(false);
          break;
      }

      if (!util.equal(rr.name, name))
        throw new Error(`Invalid record name (${rr.name} != ${name}).`);

      if (type !== state) {
        const a = typeToString(type);
        const b = typeToString(state);
        throw new Error(`Invalid record type (${a} != ${b}).`);
      }

      switch (state) {
        case types.DNSKEY:
          zone.keys.push(rr);
          break;
        case types.DS:
          zone.referral.push(rr);
          break;
        case types.TXT:
          zone.claim.push(rr);
          break;
        default:
          assert(false);
          break;
      }
    }

    if (zone.keys.length === 0)
      throw new Error('Final zone has no keys.');

    if (zone.referral.length > 0)
      throw new Error('Final zone has unexpected referrals.');

    this.zones.push(zone);

    return this;
  }

  getJSON() {
    return {
      zones: this.zones.map(zone => zone.toJSON())
    };
  }

  fromJSON(json) {
    assert(json && typeof json === 'object');
    assert(Array.isArray(json.zones));

    for (const zone of json.zones)
      this.zones.push(Zone.fromJSON(zone));

    return this;
  }
}

/**
 * Zone
 * @extends {bufio.Struct}
 */

class Zone extends bio.Struct {
  constructor() {
    super();
    this.keys = [];
    this.referral = [];
    this.claim = [];
  }

  get body() {
    return this.referral.length > 0
      ? this.referral
      : this.claim;
  }

  getTarget() {
    if (this.keys.length === 0)
      return '.';

    return this.keys[0].name.toLowerCase();
  }

  *records() {
    for (const rr of this.keys)
      yield rr;

    for (const rr of this.referral)
      yield rr;

    for (const rr of this.claim)
      yield rr;
  }

  inject(msg) {
    assert(msg instanceof this.constructor);
    this.keys = msg.keys.slice();
    this.referral = msg.referral.slice();
    this.claim = msg.claim.slice();
    return this;
  }

  deepClone() {
    const msg = new this.constructor();
    return msg.decode(this.encode());
  }

  canonical() {
    for (const rr of this.keys)
      rr.canonical();

    for (const rr of this.referral)
      rr.canonical();

    for (const rr of this.claim)
      rr.canonical();

    return this;
  }

  getSize(map) {
    let size = 1;

    for (const rr of this.keys)
      size += rr.getSize(map);

    size += 1;

    for (const rr of this.referral)
      size += rr.getSize(map);

    size += 1;

    for (const rr of this.claim)
      size += rr.getSize(map);

    return size;
  }

  write(bw, map) {
    bw.writeU8(this.keys.length);

    for (const rr of this.keys)
      rr.write(bw, map);

    bw.writeU8(this.referral.length);

    for (const rr of this.referral)
      rr.write(bw, map);

    bw.writeU8(this.claim.length);

    for (const rr of this.claim)
      rr.write(bw, map);

    return this;
  }

  read(br) {
    const rrCount = br.readU8();

    for (let i = 0; i < rrCount; i++) {
      const rr = readRecord(br, types.DNSKEY);
      this.keys.push(rr);
    }

    const dsCount = br.readU8();

    for (let i = 0; i < dsCount; i++) {
      const rr = readRecord(br, types.DS);
      this.referral.push(rr);
    }

    const claimCount = br.readU8();

    for (let i = 0; i < claimCount; i++) {
      const rr = readRecord(br, types.TXT);
      this.claim.push(rr);
    }

    return this;
  }

  toString() {
    let str = '';

    str += ';;\n';
    str += `;; ZONE: ${this.getTarget().toUpperCase()}\n`;
    str += ';;\n';

    str += '; KEYS:\n';

    for (const rr of this.keys)
      str += rr.toString() + '\n';

    str += '\n';

    str += this.claim.length > 0
      ? '; CLAIM:\n'
      : '; REFERRAL:\n';

    for (const rr of this.body)
      str += rr.toString() + '\n';

    return str;
  }

  getJSON() {
    return {
      keys: this.keys.map(rr => rr.toJSON()),
      referral: this.referral.map(rr => rr.toJSON()),
      claim: this.claim.map(rr => rr.toJSON())
    };
  }

  fromJSON(json) {
    assert(json && typeof json === 'object');
    assert(Array.isArray(json.keys));
    assert(Array.isArray(json.referral));

    for (const rr of json.keys)
      this.keys.push(Record.fromJSON(rr));

    for (const rr of json.referral)
      this.referral.push(Record.fromJSON(rr));

    for (const rr of json.claim)
      this.claim.push(Record.fromJSON(rr));

    return this;
  }
}

/*
 * Static
 */

Ownership.rootAnchors = rootAnchors;
Ownership.Proof = Proof;
Ownership.OwnershipProof = Proof;
Ownership.Zone = Zone;

/*
 * Helpers
 */

function isSafeRecord(br, expect) {
  const offset = br.offset;

  let ret = false;

  try {
    ret = _isSafeRecord(br, expect);
  } catch (e) {
    ;
  }

  br.offset = offset;

  return ret;
}

function _isSafeRecord(br, expect) {
  readNameBR(br, false);

  const type = br.readU16BE();

  if (type === types.RRSIG) {
    br.seek(8 + 18);
    readNameBR(br, false);
    return true;
  }

  return type === expect;
}

function readRecord(br, expect) {
  assert(br);
  assert((expect & 0xffff) === expect);

  // We don't allow compression
  // or types we don't expect.
  if (!isSafeRecord(br, expect))
    throw new Error('Record unsafe to read.');

  return Record.read(br);
}

function splitSet(rrs) {
  assert(Array.isArray(rrs));

  const rrset = [];

  let sig = null;

  for (const rr of rrs) {
    assert(rr instanceof Record);

    if (rr.type === types.RRSIG) {
      sig = rr;
      continue;
    }

    rrset.push(rr);
  }

  if (!sig || rrset.length === 0)
    return [null, null];

  return [sig, rrset];
}

function getSig(rrs) {
  assert(Array.isArray(rrs));

  for (const rr of rrs) {
    assert(rr instanceof Record);

    if (rr.type !== types.RRSIG)
      continue;

    return rr;
  }

  return null;
}

function findKey(rrs, tag) {
  assert(Array.isArray(rrs));
  assert((tag & 0xffff) === tag);

  for (const rr of rrs) {
    assert(rr instanceof Record);

    if (rr.type !== types.DNSKEY)
      continue;

    const rd = rr.data;

    if (rd.keyTag() !== tag)
      continue;

    // Explanation: someone could publish
    // a revocation sig. We pay no attention
    // to revocations normally. Why? Because
    // DNSSEC revocation doesn't truly revoke
    // anything. An attacker can still publish
    // old states. However, if someone _does_
    // publish a revocation sig for a DNSKEY
    // rrset, we should probably ignore it,
    // even though revocation keys typically
    // don't have DS records, and this should
    // fail at a higher level anyway.
    if (rd.flags & keyFlags.REVOKE)
      continue;

    return rr;
  }

  return null;
}

function getKSK(rrs) {
  assert(Array.isArray(rrs));

  const sig = getSig(rrs);

  if (!sig)
    return [null, null];

  const tag = sig.data.keyTag;
  const key = findKey(rrs, tag);

  return [key, tag];
}

function getDowngraded(ksk, rrs) {
  assert(ksk instanceof Record);
  assert(ksk.type === types.DNSKEY);
  assert(Array.isArray(rrs));

  const kd = ksk.data;
  const keys = [];

  if (kd.algorithm !== algs.RSASHA256
      && kd.algorithm !== algs.RSASHA512) {
    return keys;
  }

  for (const rr of rrs) {
    assert(rr instanceof Record);

    if (rr.type === types.RRSIG)
      continue;

    if (rr.type !== types.DNSKEY)
      continue;

    const rd = rr.data;

    if (rd.algorithm !== algs.RSASHA1
        && rd.algorithm !== algs.RSASHA1NSEC3SHA1) {
      continue;
    }

    if (rd.flags & keyFlags.REVOKE)
      continue;

    if (!rd.publicKey.equals(kd.publicKey))
      continue;

    keys.push(rr);
  }

  return keys;
}

function extractKey(rrs, keys) {
  assert(Array.isArray(rrs));
  assert(Array.isArray(keys));

  const sig = getSig(rrs);

  if (!sig)
    return null;

  const key = findKey(keys, sig.data.keyTag);

  if (!key)
    return null;

  return key;
}

function toKeyMap(rrs) {
  assert(Array.isArray(rrs));

  const map = new Map();

  for (const rr of rrs) {
    assert(rr instanceof Record);

    if (rr.type !== types.DNSKEY)
      continue;

    const tag = rr.data.keyTag();

    if (!map.has(tag))
      map.set(tag, rr);
  }

  return map;
}

function toRevSet(rrs) {
  assert(Array.isArray(rrs));

  const set = new Set();

  for (const rr of rrs) {
    assert(rr instanceof Record);

    if (rr.type !== types.DNSKEY)
      continue;

    if (!(rr.data.flags & keyFlags.REVOKE))
      continue;

    set.add(rr.data.revTag());
  }

  return set;
}

function toDSSet(rrs) {
  assert(Array.isArray(rrs));

  const set = new Set();

  for (const rr of rrs) {
    assert(rr instanceof Record);

    if (rr.type !== types.DS)
      continue;

    set.add(rr.data.keyTag);
  }

  return set;
}

/*
 * Expose
 */

module.exports = Ownership;
}],
[/* 126 */ 'bns-plus', '/lib/punycode.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * punycode.js - punycode for bns
 * Copyright (c) 2019, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 *
 * Parts of this software are based on bestiejs/punycode.js:
 *   Copyright (c) 2011-2019, Mathias Bynens (MIT License)
 *   https://github.com/bestiejs/punycode.js
 *   https://mths.be/punycode
 *
 * Resources:
 *   https://www.ietf.org/rfc/rfc3492.txt
 *   https://en.wikipedia.org/wiki/Punycode
 *   https://github.com/bestiejs/punycode.js/blob/master/punycode.js
 */



const assert = __browser_require__(2 /* 'bsert' */, module);

/*
 * Constants
 */

const MAX_INT = 2147483647;
const BASE = 36;
const T_MIN = 1;
const T_MAX = 26;
const SKEW = 38;
const DAMP = 700;
const INITIAL_BIAS = 72;
const INITIAL_N = 128;
const BASE_MINUS_T_MIN = BASE - T_MIN;
const DELIMITER = '-';
const PUNYCODE_RX = /^xn--/;
const NONASCII_RX = /[^\0-\x7e]/;
const SEPARATORS_RX = /[\x2e\u3002\uff0e\uff61]/g;

/*
 * Errors
 */

const errors = {
  OVERFLOW: 'Overflow: input needs wider integers to process.',
  NOT_BASIC: 'Illegal input >= 0x80 (not a basic code point).',
  INVALID_INPUT: 'Invalid input.'
};

/*
 * API
 */

function encodeRaw(str) {
  assert(typeof str === 'string');

  const codes = ucs2decode(str);

  let n = INITIAL_N;
  let delta = 0;
  let bias = INITIAL_BIAS;
  let len = 0;
  let output = '';

  for (let i = 0; i < codes.length; i++) {
    const ch = codes[i];

    if (ch >= 0x80)
      continue;

    output += String.fromCharCode(ch);
    len += 1;
  }

  let handled = len;

  if (len > 0)
    output += DELIMITER;

  while (handled < codes.length) {
    let m = MAX_INT;

    for (let i = 0; i < codes.length; i++) {
      const ch = codes[i];

      if (ch >= n && ch < m)
        m = ch;
    }

    const hpo = handled + 1;

    if (m - n > Math.floor((MAX_INT - delta) / hpo))
      throw new RangeError(errors.OVERFLOW);

    delta += (m - n) * hpo;
    n = m;

    for (let i = 0; i < codes.length; i++) {
      const ch = codes[i];

      if (ch < n) {
        delta += 1;
        if (delta > MAX_INT)
          throw new RangeError(errors.OVERFLOW);
      }

      if (ch !== n)
        continue;

      let q = delta;
      let k = BASE;

      for (;;) {
        let t = T_MIN;

        if (k > bias) {
          if (k >= bias + T_MAX)
            t = T_MAX;
          else
            t = k - bias;
        }

        if (q < t)
          break;

        const qmt = q - t;
        const bmt = BASE - t;

        output += basic(t + qmt % bmt, 0);

        q = Math.floor(qmt / bmt);
        k += BASE;
      }

      output += basic(q, 0);

      bias = adapt(delta, hpo, handled === len);
      delta = 0;
      handled += 1;
    }

    delta += 1;
    n += 1;
  }

  return output;
}

function decodeRaw(str) {
  assert(typeof str === 'string');

  let delim = str.lastIndexOf(DELIMITER);

  if (delim < 0)
    delim = 0;

  const codes = [];

  for (let i = 0; i < delim; i++) {
    const ch = str.charCodeAt(i);

    if (ch >= 0x80)
      throw new RangeError(errors.NOT_BASIC);

    codes.push(ch);
  }

  let i = 0;
  let n = INITIAL_N;
  let bias = INITIAL_BIAS;
  let index = delim > 0 ? delim + 1 : 0;

  while (index < str.length) {
    const j = i;

    let w = 1;
    let k = BASE;

    for (;;) {
      if (index >= str.length)
        throw new RangeError(errors.INVALID_INPUT);

      const ch = digit(str, index);

      index += 1;

      if (ch >= BASE || ch > Math.floor((MAX_INT - i) / w))
        throw new RangeError(errors.OVERFLOW);

      i += ch * w;

      let t = T_MIN;

      if (k > bias) {
        if (k >= bias + T_MAX)
          t = T_MAX;
        else
          t = k - bias;
      }

      if (ch < t)
        break;

      const bmt = BASE - t;

      if (w > Math.floor(MAX_INT / bmt))
        throw new RangeError(errors.OVERFLOW);

      w *= bmt;
      k += BASE;
    }

    const out = codes.length + 1;

    bias = adapt(i - j, out, j === 0);

    if (Math.floor(i / out) > MAX_INT - n)
      throw new RangeError(errors.OVERFLOW);

    n += Math.floor(i / out);
    i %= out;

    codes.splice(i, 0, n);
    i += 1;
  }

  return String.fromCodePoint(...codes);
}

function encode(str) {
  assert(typeof str === 'string');

  return map(str, (label) => {
    return NONASCII_RX.test(label)
      ? 'xn--' + encodeRaw(label)
      : label;
  });
}

function decode(str) {
  assert(typeof str === 'string');

  return map(str, (label) => {
    return PUNYCODE_RX.test(label)
      ? decodeRaw(label.substring(4).toLowerCase())
      : label;
  });
}

/*
 * Helpers
 */

function ucs2encode(codes) {
  assert(Array.isArray(codes));

  for (const code of codes)
    assert((code >>> 0) === code);

  return String.fromCodePoint(...codes);
}

function ucs2decode(str) {
  assert(typeof str === 'string');

  const codes = [];

  for (let i = 0; i < str.length; i++) {
    const ch = str.charCodeAt(i);

    if (ch >= 0xd800 && ch <= 0xdbff && i + 1 < str.length) {
      const x = str.charCodeAt(i + 1);

      if ((x & 0xfc00) === 0xdc00) {
        codes.push(((ch & 0x3ff) << 10) + (x & 0x3ff) + 0x10000);
        i += 1;
        continue;
      }
    }

    codes.push(ch);
  }

  return codes;
}

function digit(str, index) {
  assert(typeof str === 'string');
  assert((index >>> 0) === index);
  assert(index < str.length);

  const code = str.charCodeAt(index);

  if (code - 0x30 < 0x0a)
    return code - 0x16;

  if (code - 0x41 < 0x1a)
    return code - 0x41;

  if (code - 0x61 < 0x1a)
    return code - 0x61;

  return BASE;
}

function basic(ch, flag) {
  assert((ch >>> 0) === ch);
  assert((flag >>> 0) === flag);

  ch += 22 + 75 * (ch < 26);
  ch -= ((flag !== 0) << 5);

  return String.fromCharCode(ch);
}

function adapt(delta, points, first) {
  assert((delta >>> 0) === delta);
  assert((points >>> 0) === points);
  assert(typeof first === 'boolean');

  let k = 0;

  delta = first ? Math.floor(delta / DAMP) : delta >> 1;
  delta += Math.floor(delta / points);

  for (; delta > BASE_MINUS_T_MIN * T_MAX >> 1; k += BASE)
    delta = Math.floor(delta / BASE_MINUS_T_MIN);

  return Math.floor(k + (BASE_MINUS_T_MIN + 1) * delta / (delta + SKEW));
}

function map(str, fn) {
  assert(typeof str === 'string');
  assert(typeof fn === 'function');

  const index = str.indexOf('@');

  let result = '';

  if (index !== -1) {
    result = str.substring(0, index + 1);
    str = str.substring(index + 1);
  }

  str = str.replace(SEPARATORS_RX, '.');

  const labels = str.split('.');
  const encoded = [];

  for (const label of labels)
    encoded.push(fn(label));

  return result + encoded.join('.');
}

/*
 * Expose
 */

exports._ucs2encode = ucs2encode;
exports._ucs2decode = ucs2decode;
exports.encodeRaw = encodeRaw;
exports.decodeRaw = decodeRaw;
exports.encode = encode;
exports.decode = decode;
}],
[/* 127 */ 'bns-plus', '/lib/rdns.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * rdns.js - replacement dns node.js module (recursive)
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 */



const API = __browser_require__(1 /* './api' */, module);
const Cache = __browser_require__(109 /* './cache' */, module);
const Hints = __browser_require__(116 /* './hints' */, module);
const RecursiveResolver = __browser_require__(128 /* './resolver/recursive' */, module);

let hints = null;

const cache = new Cache();

function createResolver(options) {
  if (!hints)
    hints = Hints.fromRoot();

  const resolver = new RecursiveResolver(options);

  if (!options.hints)
    resolver.hints = hints.clone();

  if (!options.cache)
    resolver.cache = cache;

  return resolver;
}

module.exports = API.make(createResolver, {
  tcp: true,
  edns: true,
  dnssec: true
});
}],
[/* 128 */ 'bns-plus', '/lib/resolver/recursive.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * recursive.js - recursive dns resolver for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 *
 * Parts of this software are based on solvere:
 *   https://github.com/rolandshoemaker/solvere
 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const IP = __browser_require__(4 /* 'binet' */, module);
const Authority = __browser_require__(96 /* '../authority' */, module);
const Cache = __browser_require__(109 /* '../cache' */, module);
const constants = __browser_require__(11 /* '../constants' */, module);
const DNSResolver = __browser_require__(115 /* './dns' */, module);
const dnssec = __browser_require__(99 /* '../dnssec' */, module);
const encoding = __browser_require__(80 /* '../encoding' */, module);
const Hints = __browser_require__(116 /* '../hints' */, module);
const nsec3 = __browser_require__(124 /* '../nsec3' */, module);
const util = __browser_require__(79 /* '../util' */, module);
const wire = __browser_require__(90 /* '../wire' */, module);
const {DNS_PORT} = constants;

const {
  Message,
  Question,
  Record,
  types,
  typeToString,
  codes
} = wire;

const {
  extractSet,
  filterSet,
  hasAll,
  hasType,
  random,
  randomItem,
  equal,
  isSubdomain
} = util;

/**
 * RecursiveResolver
 * @extends DNSResolver
 */

class RecursiveResolver extends DNSResolver {
  constructor(options) {
    super(options);

    this.rd = false;
    this.cache = new Cache();
    this.hints = new Hints();
    this.maxReferrals = 30;
    this.minimize = false;
    this.ub = null;

    this.initOptions(options);
  }

  initOptions(options) {
    if (options == null)
      return this;

    this.parseOptions(options);

    if (options.cache != null) {
      assert(options.cache instanceof Cache);
      this.cache = options.cache;
    }

    if (options.hints != null) {
      assert(options.hints instanceof Hints);
      this.hints = options.hints;
    }

    if (options.maxReferrals != null) {
      assert((options.maxReferrals >>> 0) === options.maxReferrals);
      this.maxReferrals = options.maxReferrals;
    }

    if (options.cacheSize != null) {
      assert((options.cacheSize >>> 0) === options.cacheSize);
      this.cache.maxSize = options.cacheSize;
    }

    if (options.minimize != null) {
      assert(typeof options.minimize === 'boolean');
      this.minimize = options.minimize;
    }

    return this;
  }

  setStub(host, port, ds) {
    assert(typeof host === 'string');
    assert((port & 0xffff) === port);
    assert(port !== 0);
    assert(ds instanceof Record);
    assert(ds.type === types.DS);

    const ip = IP.normalize(host);

    this.hints.clear();
    this.hints.ns.push('hints.local.');

    if (IP.isIPv4String(ip))
      this.hints.inet4.set('hints.local.', ip);
    else
      this.hints.inet6.set('hints.local.', ip);

    this.hints.anchors.push(ds.clone());
    this.hints.port = port;

    return this;
  }

  getAuthority() {
    return this.hints.getAuthority(this.inet6);
  }

  async ask(qs, auth) {
    const cache = this.cache.hit(qs, auth.zone);

    if (cache) {
      this.log('Cache hit for %s (%s).', qs.name, typeToString(qs.type));
      return [cache, true];
    }

    const res = await this.query(qs, auth.servers);

    return [res, false];
  }

  async findNS(rc, name, type, zone) {
    const qs = new Question(name, type);
    const child = await this.follow(qs, rc.hops);
    const res = child.toAnswer();

    rc.hops = child.hops;

    if (res.code !== codes.NOERROR)
      throw new Error('Authority lookup failed.');

    const addrs = extractSet(res.answer, name, type);

    if (addrs.length === 0)
      throw new Error('No authority address.');

    const auth = new Authority(zone, name);

    for (const addr of addrs)
      auth.add(addr.data.address, DNS_PORT);

    this.log('Picked nameserver for: %s', name);

    return auth;
  }

  async lookupNS(rc, name, zone) {
    rc.hop();

    if (this.inet6) {
      this.log('Looking up IPv6 nameserver for %s...', name);
      try {
        return await this.findNS(rc, name, types.AAAA, zone);
      } catch (e) {
        this.log('IPv6 nameserver lookup failed: %s', e.message);
      }
    }

    this.log('Looking up IPv4 nameserver for %s...', name);

    return this.findNS(rc, name, types.A, zone);
  }

  async lookupDNSKEY(qs, auth, ds) {
    const [res, hit] = await this.ask(qs, auth);

    if (res.answer.length === 0
        || res.code !== codes.NOERROR) {
      return [new Map(), new Set()];
    }

    if (auth.zone === '.') {
      assert(ds.length === 0);
      ds = this.hints.anchors;
    }

    if (ds.length === 0) {
      this.log('Invalid DNSKEY (DS absent).');
      return [null, null];
    }

    // Pick out the valid KSK's.
    const kskMap = dnssec.verifyDS(res, ds, qs.name);

    if (!kskMap) {
      this.log('Invalid KSKs (DS mismatch).');
      return [null, null];
    }

    if (!hit) {
      // Verify all ZSK's with KSK's if we're not cached.
      if (!dnssec.verifyZSK(res, kskMap, qs.name)) {
        this.log('Invalid KSKs (verification failure).');
        return [null, null];
      }

      const eternal = auth.zone === '.';
      this.cache.insert(qs, auth.zone, res, true, eternal);
    }

    const zskMap = new Map();
    const revSet = new Set();

    // Grab all ZSK's from the answer.
    for (const rr of res.answer) {
      if (rr.type !== types.DNSKEY)
        continue;

      const rd = rr.data;

      if (!equal(rr.name, qs.name))
        continue;

      if (!(rd.flags & dnssec.keyFlags.ZONE))
        continue;

      if (rd.flags & dnssec.keyFlags.REVOKE) {
        revSet.add(rd.revTag());
        continue;
      }

      zskMap.set(rd.keyTag(), rr);
    }

    return [zskMap, revSet];
  }

  async checkSignatures(msg, auth, ds) {
    if (!this.dnssec)
      return true;

    const qs = new Question(auth.zone, types.DNSKEY);
    const [zskMap, revSet] = await this.lookupDNSKEY(qs, auth, ds);

    if (!zskMap)
      return false;

    if (zskMap.size === 0) {
      this.log('No ZSKs found.');
      return false;
    }

    if (!dnssec.verifyMessage(msg, zskMap, revSet)) {
      this.log('Invalid RRSIGs.');
      return false;
    }

    this.log('Validated DNSSEC signatures.');

    return true;
  }

  splitAuths(authority, additional) {
    const zones = new Map();
    const nsmap = new Map();

    for (const rr of authority) {
      if (rr.type === types.NS)
        nsmap.set(rr.data.ns.toLowerCase(), rr.name.toLowerCase());
    }

    for (const rr of additional) {
      const zone = nsmap.get(rr.name.toLowerCase());

      if (!zone)
        continue;

      if (this.inet6) {
        if (rr.type !== types.A && rr.type !== types.AAAA)
          continue;
      } else {
        if (rr.type !== types.A)
          continue;
      }

      let items = zones.get(zone);

      if (!items) {
        items = [];
        zones.set(zone, items);
      }

      items.push(rr.data.address);
    }

    return [zones, nsmap];
  }

  async pickAuthority(rc, authority, additional) {
    const [zones, nsmap] = this.splitAuths(authority, additional);

    if (zones.size === 0) {
      if (nsmap.size === 0)
        return null;

      let i = random(nsmap.size);
      let ns, zone;

      for ([ns, zone] of nsmap) {
        if (i === 0)
          break;
        i -= 1;
      }

      this.log('Looking up NS: %s', ns);

      return this.lookupNS(rc, ns, zone);
    }

    const set = [];

    for (const [ns, zone] of nsmap) {
      const items = zones.get(zone);
      if (items && items.length > 0)
        set.push([ns, zone]);
    }

    if (set.length === 0)
      return null;

    const [ns, zone] = randomItem(set);
    const items = zones.get(zone);
    assert(items && items.length > 0);

    const auth = new Authority(zone, ns);

    for (const host of items)
      auth.add(host, DNS_PORT);

    return auth;
  }

  insert(rc) {
    if (!rc.hit) {
      const {qs, auth, res, chain} = rc;
      this.cache.insert(qs, auth.zone, res, chain);
    }
  }

  async handleTrust(rc) {
    assert(rc.chain);

    this.log('Verifying zone change to [%s]', rc.auth.zone);

    if (rc.hit) {
      if (!rc.res.ad) {
        this.log('Trust chain broken due to cache.');
        rc.chain = false;
        rc.ds = [];
        return;
      }
      rc.chain = true;
      return;
    }

    if (!rc.res.isDNSSEC()) {
      this.log('Trust chain broken due to lack of DO flag.');
      rc.chain = false;
      rc.ds = [];
      return;
    }

    this.log('Checking signatures...');

    if (!await this.checkSignatures(rc.res, rc.auth, rc.ds)) {
      this.log('Trust chain broken due to lack of child verification.');
      rc.chain = false;
      rc.ds = [];
    }
  }

  async handleAnswer(rc) {
    const [alias, chased] = isAlias(rc.res.answer, rc.qs);

    if (!alias) {
      this.insert(rc);
      return false;
    }

    if (rc.aliases.has(alias))
      throw new Error('Alias loop.');

    this.insert(rc);

    const auth = this.getAuthority();

    this.log('Found alias to: %s', alias);
    this.log('Alias changing zone: [%s->%s]', rc.auth.zone, auth.zone);

    rc.switchZone(auth);
    rc.follow(alias, chased);
    rc.hop();

    return true;
  }

  async handleAuthority(rc) {
    const {authority, additional} = rc.res;

    const hasNS = hasType(authority, types.NS);

    if (!hasNS) {
      if (rc.chain) {
        const nsec = extractSet(authority, '', types.NSEC3);

        if (!nsec3.verifyNoData(rc.qs, nsec)) {
          this.log('Trust chain broken due to missing NSEC coverage.');
          rc.chain = false;
          rc.ds = [];
        } else {
          this.log('Validated NSEC3 nodata.');
        }
      }

      this.insert(rc);

      return false;
    }

    const auth = await this.pickAuthority(rc, authority, additional);

    if (!auth) {
      this.insert(rc);
      return false;
    }

    const hasNSEC3 = hasType(authority, types.NSEC3);

    if (rc.chain && hasNSEC3) {
      const nsec = extractSet(authority, '', types.NSEC3);

      if (!nsec3.verifyDelegation(auth.zone, nsec)) {
        this.log('Trust chain broken due to bad delegation.');
        rc.chain = false;
        rc.ds = [];
      } else {
        this.log('Validated NSEC3 delegation.');
      }
    }

    this.insert(rc);

    this.log('Switching authority: %s', auth.name);
    this.log('Switching zone: [%s->%s]', rc.auth.zone, auth.zone);

    if (rc.chain) {
      // Grab DS records for the _next_ zone.
      rc.ds = extractSet(authority, auth.zone, types.DS);

      if (rc.ds.length === 0) {
        rc.chain = false;
        this.log('Trust chain broken due to zone change.');
      }
    }

    rc.switchZone(auth);
    rc.hop();

    return true;
  }

  async lookupNext(rc) {
    const [res, hit] = await this.ask(rc.qs, rc.auth);
    rc.res = res;
    rc.hit = hit;
  }

  async next(rc) {
    await this.lookupNext(rc);

    if (rc.chain)
      await this.handleTrust(rc);

    if (rc.chain && rc.res.code === codes.NXDOMAIN) {
      const nsec = extractSet(rc.res.authority, '', types.NSEC3);

      if (!nsec3.verifyNameError(rc.qs, nsec)) {
        this.log('Trust chain broken due to bad NX proof.');
        rc.chain = false;
        rc.ds = [];
      } else {
        this.log('Validated NSEC3 NX proof.');
      }
    }

    if (rc.res.isAnswer())
      return this.handleAnswer(rc);

    if (rc.res.isReferral())
      return this.handleAuthority(rc);

    return false;
  }

  async iterate(rc) {
    this.log('Querying %s (%s).', rc.qs.name, typeToString(rc.qs.type));

    this.log('Switching authority: %s', rc.auth.name);
    this.log('Switching zone: [%s]', rc.auth.zone);

    for (;;) {
      if (!await this.next(rc))
        break;
    }

    assert(rc.hops <= rc.maxReferrals);

    this.log(
      'Traversed zones: %s for %s (%s).',
      rc.zones.join(', '),
      rc.question.name,
      typeToString(rc.question.type)
    );

    if (rc.res.code === codes.NOERROR
        || rc.res.answer.length > 0
        || rc.res.authority.length > 0) {
      if (rc.chased.length > 0)
        rc.res.answer = rc.chased.concat(rc.res.answer);

      if (!rc.hit)
        this.cache.insert(rc.question, rc.ns.zone, rc.res, rc.chain);
    }

    return rc;
  }

  async follow(qs, hops) {
    assert(qs instanceof Question);
    assert(typeof hops === 'number');

    const ns = this.getAuthority();
    const rc = new ResolveContext(qs, ns, hops);

    rc.chain = this.dnssec;
    rc.maxReferrals = this.maxReferrals;

    return this.iterate(rc);
  }

  async resolve(qs) {
    assert(qs instanceof Question);

    if (!util.isName(qs.name))
      throw new Error('Invalid qname.');

    const rc = await this.follow(qs, 0);

    this.log('Finishing resolving %s (%s) (hops=%d).',
      qs.name, typeToString(qs.type), rc.hops);

    this.log('Cache usage: %s/%smb (items=%d).',
      (this.cache.size / 1024 / 1024).toFixed(2),
      (this.cache.maxSize / 1024 / 1024).toFixed(2),
      this.cache.map.size);

    return rc.toAnswer();
  }

  async lookup(name, type) {
    const qs = new Question(name, type);
    return this.resolve(qs);
  }

  async reverse(addr) {
    const name = encoding.reverse(addr);
    return this.lookup(name, types.PTR);
  }
}

/**
 * Resolve Context
 */

class ResolveContext {
  constructor(qs, ns, hops) {
    this.question = qs;
    this.ns = ns;
    this.hops = hops;
    this.qs = qs.clone();
    this.auth = ns;
    this.zones = [];
    this.aliases = new Set();
    this.chased = [];
    this.ds = [];
    this.chain = true;
    this.res = null;
    this.hit = false;
    this.maxReferrals = 30;
    this.switchZone(ns);
  }

  switchZone(auth) {
    this.auth = auth;
    this.zones.push(auth.zone);
    return this;
  }

  follow(alias, chased) {
    this.qs.name = alias;
    this.ds = [];
    this.aliases.add(alias);

    for (const rr of chased)
      this.chased.push(rr);

    return this;
  }

  hop() {
    if (this.hops >= this.maxReferrals)
      throw new Error('Maximum referrals exceeded.');

    this.hops += 1;
    return this;
  }

  toAnswer() {
    const res = new Message();

    res.id = this.res.id;
    res.opcode = this.res.opcode;
    res.code = this.res.code;
    res.qr = true;
    res.ra = true;
    res.ad = this.chain;
    res.question = [this.question];
    res.answer = this.res.answer.slice();
    res.authority = this.res.authority.slice();
    res.additional = this.res.additional.slice();
    res.edns = this.res.edns.clone();
    res.tsig = this.res.tsig;
    res.sig0 = this.res.sig0;
    res.size = this.res.size;
    res.malformed = this.res.malformed;
    res.trailing = this.res.trailing;

    return res;
  }
}

/*
 * Static
 */

RecursiveResolver.version = '0.0.0';
RecursiveResolver.native = 0;

/*
 * Helpers
 */

function collapseChain(name, records) {
  const chased = [];
  const map = new Map();
  const sigs = new Map();

  for (const rr of records) {
    const rd = rr.data;

    if (rr.type === types.CNAME) {
      map.set(rr.name.toLowerCase(), rr);
      continue;
    }

    if (rr.type === types.RRSIG) {
      if (rd.typeCovered === types.CNAME)
        sigs.set(rr.name.toLowerCase(), rr);
      continue;
    }
  }

  let qname = name.toLowerCase();
  let canonical = '';

  for (;;) {
    const cname = map.get(qname);
    const sig = sigs.get(qname);

    if (!cname)
      break;

    canonical = cname.data.target;
    qname = canonical.toLowerCase();

    chased.push(cname);

    if (sig)
      chased.push(sig);
  }

  return [canonical, chased];
}

function isAlias(answer, qs) {
  const rrs = filterSet(answer, types.RRSIG);

  if (rrs.length === 0)
    return ['', null];

  if (rrs.length > 1) {
    if (!hasAll(rrs, types.CNAME)
        || qs.type === types.CNAME) {
      return ['', null];
    }

    const [alias, chased] = collapseChain(qs.name, answer);

    return [alias, chased];
  }

  const rr = rrs[0];
  const rd = rr.data;

  switch (rr.type) {
    case types.CNAME: {
      if (qs.type === types.CNAME
          || !equal(qs.name, rr.name)) {
        return ['', null];
      }

      return [rd.target, answer];
    }

    case types.DNAME: {
      if (qs.type === types.DNAME)
        return ['', null];

      if (!isSubdomain(rr.name, qs.name))
        return ['', null];

      const bottom = qs.name.slice(0, -rr.name.length);
      const alias = bottom + rd.target;

      if (!util.isName(alias))
        throw new Error('Invalid DNAME.');

      return [alias, answer];
    }
  }

  return ['', null];
}

/*
 * Expose
 */

module.exports = RecursiveResolver;
}],
[/* 129 */ 'bns-plus', '/lib/server/recursive.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * recursive.js - recursive dns server for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 */



const DNSServer = __browser_require__(98 /* './dns' */, module);
const RecursiveResolver = __browser_require__(128 /* '../resolver/recursive' */, module);

/**
 * RecursiveServer
 * @extends EventEmitter
 */

class RecursiveServer extends DNSServer {
  constructor(options) {
    super(options);
    this.resolver = new RecursiveResolver(options);
    this.resolver.on('log', (...args) => this.emit('log', ...args));
    this.resolver.on('error', err => this.emit('error', err));
    this.ra = true;
    this.initOptions(options);
  }

  get cache() {
    return this.resolver.cache;
  }

  set cache(value) {
    this.resolver.cache = value;
  }

  get hints() {
    return this.resolver.hints;
  }

  set hints(value) {
    this.resolver.hints = value;
  }
}

/*
 * Expose
 */

module.exports = RecursiveServer;
}],
[/* 130 */ 'bns-plus', '/lib/resolver/root.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * root.js - root dns resolver for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const constants = __browser_require__(11 /* '../constants' */, module);
const DNSResolver = __browser_require__(115 /* './dns' */, module);
const dnssec = __browser_require__(99 /* '../dnssec' */, module);
const Hints = __browser_require__(116 /* '../hints' */, module);
const ROOT_HINTS = __browser_require__(108 /* '../roothints' */, module);
const util = __browser_require__(79 /* '../util' */, module);
const wire = __browser_require__(90 /* '../wire' */, module);

const {
  types,
  codes,
  KSK_ARPA
} = constants;

const {
  hasType,
  extractSet
} = util;

const {
  Question,
  Message,
  Record
} = wire;

/*
 * Constants
 */

const CACHE_TIME = 6 * 60 * 60;

/**
 * RootResolver
 * @extends DNSResolver
 */

class RootResolver extends DNSResolver {
  constructor(options) {
    super(options);

    const hints = getHints(this.inet6);

    this.rd = false;
    this.edns = true;
    this.dnssec = true;
    this.anchors = hints.anchors;
    this.servers = hints.servers;
    this.keyMap = new Map();
    this.lastUpdate = 0;
    this.arpa = null;

    if (options)
      this.initOptions(options);
  }

  initOptions(options) {
    this.parseOptions(options);
    return this;
  }

  referArpa(qs) {
    assert(qs instanceof Question);

    if (!this.arpa)
      this.arpa = buildArpa();

    const msg = Message.decode(this.arpa);
    msg.question.push(qs.clone());
    return msg;
  }

  async lookupKeys(zone, ds) {
    const qs = new Question(zone, types.DNSKEY);
    const res = await this.query(qs, this.servers);

    const keyMap = new Map();

    if (res.answer.length === 0
        || res.code !== codes.NOERROR) {
      return null;
    }

    // Pick out the valid KSK's.
    const kskMap = dnssec.verifyDS(res, ds, qs.name);

    if (!kskMap)
      return null;

    // Verify all ZSK's with KSK's.
    if (!dnssec.verifyZSK(res, kskMap, qs.name))
      return null;

    const revoked = new Set();

    // Grab all ZSK's from the answer.
    for (const rr of res.answer) {
      if (rr.type !== types.DNSKEY)
        continue;

      const rd = rr.data;

      if (!util.equal(rr.name, qs.name))
        continue;

      if (!(rd.flags & dnssec.keyFlags.ZONE))
        continue;

      if (rd.flags & dnssec.keyFlags.REVOKE) {
        revoked.add(rd.revTag());
        continue;
      }

      keyMap.set(rd.keyTag(), rr);
    }

    for (const tag of revoked)
      keyMap.delete(tag);

    return keyMap;
  }

  isStale() {
    return util.now() > this.lastUpdate + CACHE_TIME;
  }

  async refreshKeys() {
    const keyMap = await this.lookupKeys('.', this.anchors);

    if (keyMap) {
      this.keyMap = keyMap;
      this.lastUpdate = util.now();
    }
  }

  async checkSignatures(msg) {
    if (!this.dnssec)
      return true;

    if (msg.code !== codes.NOERROR
        && msg.code !== codes.NXDOMAIN) {
      return false;
    }

    if (this.isStale())
      await this.refreshKeys();

    if (!dnssec.verifyMessage(msg, this.keyMap))
      return false;

    if (msg.code === codes.NXDOMAIN)
      return true;

    if (!hasType(msg.authority, types.NS))
      return false;

    if (hasType(msg.authority, types.DS))
      return true;

    const set = extractSet(msg.authority, '', types.NSEC);

    if (set.length !== 1)
      return false;

    const nsec = set[0].data;

    if (!nsec.hasType(types.NS))
      return false;

    if (nsec.hasType(types.DS))
      return false;

    if (nsec.hasType(types.SOA))
      return false;

    return true;
  }

  async resolve(qs) {
    assert(qs instanceof Question);

    if (!util.isName(qs.name))
      throw new Error('Invalid qname.');

    if (util.countLabels(qs.name) !== 1)
      throw new Error('Invalid qname.');

    // Special case for arpa.
    if (util.equal(qs.name, 'arpa.'))
      return this.referArpa(qs);

    const res = await this.query(qs, this.servers);
    const ad = await this.checkSignatures(res);

    const msg = new Message();
    msg.code = res.code;
    msg.question = [qs.clone()];
    msg.answer = res.answer;
    msg.authority = res.authority;
    msg.additional = res.additional;
    msg.qr = true;
    msg.ad = ad;

    dnssec.stripSignatures(msg);

    return msg;
  }

  async lookup(name) {
    const qs = new Question(name, types.NS);
    return this.resolve(qs);
  }
}

/*
 * Helpers
 */

function getHints(inet6) {
  const hints = new Hints();

  hints.setRoot();

  const auth = hints.getAuthority(inet6);

  return {
    anchors: hints.anchors,
    servers: auth.servers
  };
}

function buildArpa() {
  const rrs = wire.fromZone(ROOT_HINTS);
  const msg = new Message();

  msg.qr = true;
  msg.ad = true;

  for (const rr of rrs) {
    switch (rr.type) {
      case types.NS:
        rr.name = 'arpa.';
        rr.canonical();
        msg.authority.push(rr);
        break;
      case types.A:
      case types.AAAA:
        rr.canonical();
        msg.additional.push(rr);
        break;
    }
  }

  const ds = Record.fromString(KSK_ARPA);

  msg.authority.push(ds);

  return msg.compress();
}

/*
 * Expose
 */

module.exports = RootResolver;
}],
[/* 131 */ 'bns-plus', '/lib/srv.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * srv.js - SRV for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc2782
 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const util = __browser_require__(79 /* './util' */, module);

/*
 * SRV
 */

const srv = exports;

srv.encodeName = function encodeName(name, protocol, service) {
  assert(util.isName(name));
  assert(name.length === 0 || name[0] !== '_');
  assert(util.isName(protocol));
  assert(protocol.length >= 1 && protocol.length <= 62);
  assert(protocol[0] !== '_');
  assert(protocol.indexOf('.') === -1);
  assert(util.isName(service));
  assert(service.length >= 1 && service.length <= 62);
  assert(service[0] !== '_');
  assert(service.indexOf('.') === -1);

  if (name === '.')
    name = '';

  const encoded = util.fqdn(`_${service}._${protocol}.${name}`);

  assert(util.isName(encoded));

  return encoded;
};

srv.decodeName = function decodeName(name) {
  assert(util.isName(name));

  const labels = util.split(name);

  assert(labels.length >= 3);

  const service = util.label(name, labels, 0);
  const protocol = util.label(name, labels, 1);

  assert(service.length >= 2);
  assert(protocol.length >= 2);
  assert(service[0] === '_');
  assert(protocol[0] === '_');

  return {
    name: util.fqdn(util.from(name, labels, 2)),
    protocol: protocol.substring(1).toLowerCase(),
    service: service.substring(1).toLowerCase()
  };
};

srv.isName = function isName(name) {
  assert(util.isName(name));

  try {
    srv.decodeName(name);
    return true;
  } catch (e) {
    return false;
  }
};
}],
[/* 132 */ 'bns-plus', '/lib/server/stub.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * stub.js - stub dns server for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 */



const DNSServer = __browser_require__(98 /* './dns' */, module);
const StubResolver = __browser_require__(114 /* '../resolver/stub' */, module);

/**
 * StubServer
 * @extends EventEmitter
 */

class StubServer extends DNSServer {
  constructor(options) {
    super(options);
    this.resolver = new StubResolver(options);
    this.resolver.on('log', (...args) => this.emit('log', ...args));
    this.resolver.on('error', err => this.emit('error', err));
    this.ra = true;
    this.initOptions(options);
  }

  getServers() {
    return this.resolver.getServers();
  }

  setServers(servers) {
    this.resolver.setServers(servers);
    return this;
  }

  get conf() {
    return this.resolver.conf;
  }

  set conf(value) {
    this.resolver.conf = value;
  }

  get hosts() {
    return this.resolver.hosts;
  }

  set hosts(value) {
    this.resolver.hosts = value;
  }
}

/*
 * Expose
 */

module.exports = StubServer;
}],
[/* 133 */ 'bns-plus', '/lib/tsig.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * tsig.js - TSIG for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 *
 * Parts of this software are based on miekg/dns:
 *   https://github.com/miekg/dns/blob/master/tsig.go
 */



const assert = __browser_require__(2 /* 'bsert' */, module);
const bio = __browser_require__(14 /* 'bufio' */, module);
const constants = __browser_require__(11 /* './constants' */, module);
const crypto = __browser_require__(13 /* './internal/crypto' */, module);
const encoding = __browser_require__(80 /* './encoding' */, module);
const util = __browser_require__(79 /* './util' */, module);
const wire = __browser_require__(90 /* './wire' */, module);

const {
  types,
  classes,
  tsigAlgs
} = constants;

const {
  readNameBR,
  writeNameBW
} = encoding;

const {
  Record,
  TSIGRecord
} = wire;

/*
 * Constants
 */

const DEFAULT_FUDGE = 300;

/*
 * TSIG
 */

const tsig = exports;

tsig.sign = function sign(msg, sig, secret, requestMAC, timersOnly) {
  if (typeof sig === 'string') {
    const alg = sig;
    sig = new Record();
    sig.type = types.TSIG;
    sig.data = new TSIGRecord();
    sig.data.algorithm = alg;
  }

  if (requestMAC == null)
    requestMAC = null;

  if (timersOnly == null)
    timersOnly = false;

  assert((msg != null && msg._isBuffer === true));
  assert(msg.length >= 12);
  assert(sig instanceof Record);
  assert(sig.type === types.TSIG);
  assert((secret != null && secret._isBuffer === true));
  assert(requestMAC === null || (requestMAC != null && requestMAC._isBuffer === true));
  assert(typeof timersOnly === 'boolean');

  const id = bio.readU16BE(msg, 0);
  const rr = new Record();
  const rd = sig.data.clone();

  rr.name = '.';
  rr.type = types.TSIG;
  rr.class = classes.ANY;
  rr.ttl = 0;
  rr.data = rd;

  if (rd.algorithm === '.')
    rd.algorithm = tsigAlgs.SHA256;

  if (rd.timeSigned === 0)
    rd.timeSigned = util.now();

  if (rd.fudge === 0)
    rd.fudge = DEFAULT_FUDGE;

  rd.origID = id;

  const pre = removeTSIG(msg);
  const data = tsigData(pre, rd, requestMAC, timersOnly, 0);
  const hash = tsigHash(rd.algorithm, data, secret);

  if (!hash)
    throw new Error(`Unknown TSIG algorithm: ${rd.algorithm}.`);

  rd.mac = hash;

  const arcount = bio.readU16BE(pre, 10);
  const size = rr.getSize();
  const bw = bio.write(pre.length + size);

  bw.copy(pre, 0, 10);
  bw.writeU16BE(arcount + 1);
  bw.copy(pre, 12, pre.length);
  rr.write(bw);

  return bw.render();
};

tsig.verify = function verify(msg, secret, requestMAC, timersOnly) {
  if (requestMAC == null)
    requestMAC = null;

  if (timersOnly == null)
    timersOnly = false;

  assert((msg != null && msg._isBuffer === true));
  assert((secret != null && secret._isBuffer === true));
  assert(requestMAC === null || (requestMAC != null && requestMAC._isBuffer === true));
  assert(typeof timersOnly === 'boolean');

  const [pos, rr] = findTSIG(msg);

  // No TSIG found.
  if (pos === -1)
    return false;

  const rd = rr.data;
  const inception = rd.timeSigned - rd.fudge;
  const expiration = rd.timeSigned + rd.fudge;
  const now = util.now();

  if (now < inception)
    return false;

  if (now > expiration)
    return false;

  const pre = msg.slice(0, pos);
  const data = tsigData(pre, rd, requestMAC, timersOnly, -1);
  const hash = tsigHash(rd.algorithm, data, secret);

  // Unknown algorithm.
  if (!hash)
    return false;

  // Constant time equals.
  return crypto.safeEqual(rd.mac, hash);
};

/*
 * Helpers
 */

function findTSIG(msg) {
  assert((msg != null && msg._isBuffer === true));

  try {
    return _findTSIG(msg);
  } catch (e) {
    return [-1, null];
  }
}

function _findTSIG(msg) {
  const br = bio.read(msg);

  br.readU16BE();
  br.readU16BE();

  const qdcount = br.readU16BE();
  const ancount = br.readU16BE();
  const nscount = br.readU16BE();
  const arcount = br.readU16BE();

  if (arcount === 0)
    return [-1, null];

  for (let i = 0; i < qdcount; i++) {
    if (br.left() === 0)
      return [-1, null];

    readNameBR(br);
    br.seek(4);
  }

  for (let i = 0; i < ancount; i++) {
    if (br.left() === 0)
      return [-1, null];

    readNameBR(br);
    br.seek(8);
    br.seek(br.readU16BE());
  }

  for (let i = 0; i < nscount; i++) {
    if (br.left() === 0)
      return [-1, null];

    readNameBR(br);
    br.seek(8);
    br.seek(br.readU16BE());
  }

  for (let i = 0; i < arcount - 1; i++) {
    if (br.left() === 0)
      return [-1, null];

    readNameBR(br);
    br.seek(8);
    br.seek(br.readU16BE());
  }

  const offset = br.offset;
  const rr = Record.read(br);

  if (rr.name !== '.')
    return [-1, null];

  if (rr.type !== types.TSIG)
    return [-1, null];

  if (rr.class !== classes.ANY)
    return [-1, null];

  if (rr.ttl !== 0)
    return [-1, null];

  return [offset, rr];
}

function removeTSIG(msg) {
  assert((msg != null && msg._isBuffer === true));
  assert(msg.length >= 12);

  const [pos] = findTSIG(msg);

  if (pos === -1)
    return msg;

  const arcount = bio.readU16BE(msg, 10);
  const buf = Buffer.allocUnsafe(pos);
  msg.copy(buf, 0, 0, pos);
  bio.writeU16BE(buf, arcount - 1, 10);

  return buf;
}

function tsigData(msg, sig, requestMAC, timersOnly, offset) {
  assert((msg != null && msg._isBuffer === true));
  assert(msg.length >= 12);
  assert(sig instanceof TSIGRecord);
  assert(requestMAC === null || (requestMAC != null && requestMAC._isBuffer === true));
  assert(typeof timersOnly === 'boolean');
  assert(Number.isSafeInteger(offset));

  const arcount = bio.readU16BE(msg, 10);

  if (arcount + offset < 0)
    throw new Error('Bad offset.');

  let size = 0;

  if (requestMAC) {
    size += 2;
    size += requestMAC.length;
  }

  size += msg.length;

  if (timersOnly) {
    // Time signed and fudge.
    size += 8;
  } else {
    // Header, minus rdlen.
    size += 9;

    // TSIG minus mac and origID.
    size += sig.getSize();
    size -= 2 + sig.mac.length + 2;
  }

  const bw = bio.write(size);

  if (requestMAC) {
    bw.writeU16BE(requestMAC.length);
    bw.writeBytes(requestMAC);
  }

  bw.writeU16BE(sig.origID);
  bw.copy(msg, 2, 10);
  bw.writeU16BE(arcount + offset);
  bw.copy(msg, 12, msg.length);

  if (timersOnly) {
    bw.writeU16BE((sig.timeSigned / 0x100000000) >>> 0);
    bw.writeU32BE(sig.timeSigned >>> 0);
    bw.writeU16BE(sig.fudge);
  } else {
    const alg = sig.algorithm.toLowerCase();

    bw.writeU8(0);
    bw.writeU16BE(types.TSIG);
    bw.writeU16BE(classes.ANY);
    bw.writeU32BE(0);

    // No rdlen.

    writeNameBW(bw, alg);
    bw.writeU16BE((sig.timeSigned / 0x100000000) >>> 0);
    bw.writeU32BE(sig.timeSigned >>> 0);
    bw.writeU16BE(sig.fudge);

    // No mac or origID.

    bw.writeU16BE(sig.error);
    bw.writeU16BE(sig.other.length);
    bw.writeBytes(sig.other);
  }

  return bw.render();
}

function tsigHash(alg, data, secret) {
  assert(typeof alg === 'string');
  assert((data != null && data._isBuffer === true));
  assert((secret != null && secret._isBuffer === true));

  switch (alg.toLowerCase()) {
    case tsigAlgs.MD5:
      return crypto.md5.mac(data, secret);
    case tsigAlgs.SHA1:
      return crypto.sha1.mac(data, secret);
    case tsigAlgs.SHA256:
      return crypto.sha256.mac(data, secret);
    case tsigAlgs.SHA512:
      return crypto.sha512.mac(data, secret);
  }

  return null;
}

/*
 * Expose
 */

tsig.algs = tsigAlgs;
}],
[/* 134 */ 'bns-plus', '/lib/udns.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * udns.js - replacement dns node.js module (recursive)
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 */



const API = __browser_require__(1 /* './api' */, module);
const Cache = __browser_require__(109 /* './cache' */, module);
const Hints = __browser_require__(116 /* './hints' */, module);
const UnboundResolver = __browser_require__(135 /* './resolver/unbound' */, module);

let hints = null;
let ub = null;

const cache = new Cache();

function createResolver(options) {
  if (!hints)
    hints = Hints.fromRoot();

  const resolver = new UnboundResolver(options);

  if (!ub)
    ub = resolver.ub;

  if (!options.hints)
    resolver.hints = hints.clone();

  if (!options.cache)
    resolver.cache = cache;

  resolver.ub = ub;

  return resolver;
}

const api = API.make(createResolver, {
  tcp: true,
  edns: true,
  dnssec: true
});

api.version = UnboundResolver.version;
api.native = UnboundResolver.native;

module.exports = api;
}],
[/* 135 */ 'bns-plus', '/lib/resolver/unbound-browser.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * unbound.js - unbound dns resolver for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 */



module.exports = __browser_require__(128 /* './recursive' */, module);
}],
[/* 136 */ 'bns-plus', '/lib/server/unbound.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * unbound.js - unbound recursive dns server for bns
 * Copyright (c) 2018, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bns
 */



const DNSServer = __browser_require__(98 /* './dns' */, module);
const UnboundResolver = __browser_require__(135 /* '../resolver/unbound' */, module);

/**
 * UnboundServer
 * @extends EventEmitter
 */

class UnboundServer extends DNSServer {
  constructor(options) {
    super(options);
    this.resolver = new UnboundResolver(options);
    this.resolver.on('log', (...args) => this.emit('log', ...args));
    this.resolver.on('error', err => this.emit('error', err));
    this.ra = true;
    this.initOptions(options);
  }

  get cache() {
    return this.resolver.cache;
  }

  set cache(value) {
    this.resolver.cache = value;
  }

  get hints() {
    return this.resolver.hints;
  }

  set hints(value) {
    this.resolver.hints = value;
  }
}

/*
 * Static
 */

UnboundServer.version = UnboundResolver.version;
UnboundServer.native = UnboundResolver.native;

/*
 * Expose
 */

module.exports = UnboundServer;
}],
[/* 137 */ 'bpkg', '/lib/builtins/timers.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * timers-browserify@2.0.10 - timers module for browserify
 * Copyright (c) 2019, J. Ryan Stinnett
 * https://github.com/jryans/timers-browserify
 *
 * License for timers-browserify@2.0.10:
 *
 * # timers-browserify
 *
 * This project uses the [MIT](http://jryans.mit-license.org/) license:
 *
 * Copyright  2012 J. Ryan Stinnett <jryans@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the Software), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * # lib/node
 *
 * The `lib/node` directory borrows files from joyent/node which uses the
 * following license:
 *
 * Copyright Joyent, Inc. and other Node contributors. All rights reserved.
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the 'Software'), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * License for setimmediate@1.0.5:
 *
 * Copyright (c) 2012 Barnesandnoble.com, llc, Donavon West, and Domenic
 * Denicola
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the 'Software'), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/* global MessageChannel */
/* eslint no-var: "off" */



var timers = exports;
var self = global;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;

/*
 * Globals
 */

var setTimeout = self.setTimeout;
var clearTimeout = self.clearTimeout;
var setInterval = self.setInterval;
var clearInterval = self.clearInterval;
var setImmediate = self.setImmediate;
var clearImmediate = self.clearImmediate;

/*
 * Helpers
 */

function _false() {
  return false;
}

function _this() {
  return this;
}

/*
 * Timeout
 */

function Timeout(set, clear, args) {
  this._id = apply.call(set, self, args);
  this._set = set;
  this._clear = clear;
  this._args = args;
}

Timeout.prototype.hasRef = _false;
Timeout.prototype.ref = _this;
Timeout.prototype.unref = _this;

Timeout.prototype.refresh = function() {
  this._clear.call(self, this._id);
  this._id = apply.call(this._set, self, this._args);
  return this;
};

Timeout.prototype.close = function() {
  this._clear.call(self, this._id);
  return this;
};

/*
 * Immediate
 */

function Immediate(id) {
  this._id = id;
}

Immediate.prototype.hasRef = _false;
Immediate.prototype.ref = _this;
Immediate.prototype.unref = _this;

/*
 * API
 */

timers.setTimeout = function() {
  var args = slice.call(arguments, 0);
  return new Timeout(setTimeout, clearTimeout, args);
};

timers.clearTimeout = function(timeout) {
  if (timeout instanceof Timeout)
    timeout.close();
};

timers.setInterval = function() {
  var args = slice.call(arguments, 0);
  return new Timeout(setInterval, clearInterval, args);
};

timers.clearInterval = timers.clearTimeout;

timers.setImmediate = function() {
  return new Immediate(apply.call(setImmediate, self, arguments));
};

timers.clearImmediate = function(immediate) {
  if (immediate instanceof Immediate)
    clearImmediate.call(self, immediate._id);
};

/*
 * setImmediate
 */

;(function() {
  if (self.setImmediate)
    return;

  var nextHandle = 1; // Spec says greater than zero
  var tasksByHandle = {};
  var currentlyRunningATask = false;
  var doc = self.document;
  var registerImmediate;

  function _setImmediate(callback) {
    // Callback can either be a function or a string
    if (typeof callback !== 'function')
      callback = new Function(String(callback));

    // Copy function arguments
    var args = new Array(arguments.length - 1);
    for (var i = 0; i < args.length; i++)
      args[i] = arguments[i + 1];

    // Store and register the task
    var task = { callback: callback, args: args };
    tasksByHandle[nextHandle] = task;
    registerImmediate(nextHandle);
    return nextHandle++;
  }

  function _clearImmediate(handle) {
    delete tasksByHandle[handle];
  }

  function run(task) {
    var callback = task.callback;
    var args = task.args;
    switch (args.length) {
      case 0:
        callback();
        break;
      case 1:
        callback(args[0]);
        break;
      case 2:
        callback(args[0], args[1]);
        break;
      case 3:
        callback(args[0], args[1], args[2]);
        break;
      default:
        callback.apply(undefined, args);
        break;
    }
  }

  function runIfPresent(handle) {
    if (currentlyRunningATask) {
      setTimeout(runIfPresent, 0, handle);
    } else {
      var task = tasksByHandle[handle];
      if (task) {
        currentlyRunningATask = true;
        try {
          run(task);
        } finally {
          _clearImmediate(handle);
          currentlyRunningATask = false;
        }
      }
    }
  }

  function canUsePostMessage() {
    if (self.postMessage && !self.importScripts) {
      var postMessageIsAsynchronous = true;
      var oldOnMessage = self.onmessage;
      self.onmessage = function() {
        postMessageIsAsynchronous = false;
      };
      self.postMessage('', '*');
      self.onmessage = oldOnMessage;
      return postMessageIsAsynchronous;
    }
    return false;
  }

  function installPostMessageImplementation() {
    var messagePrefix = 'setImmediate$' + Math.random() + '$';

    var onGlobalMessage = function(event) {
      if (event.source === self
          && typeof event.data === 'string'
          && event.data.indexOf(messagePrefix) === 0) {
        runIfPresent(event.data.slice(messagePrefix.length));
      }
    };

    if (self.addEventListener)
      self.addEventListener('message', onGlobalMessage, false);
    else
      self.attachEvent('onmessage', onGlobalMessage);

    registerImmediate = function(handle) {
      self.postMessage(messagePrefix + handle, '*');
    };
  }

  function installMessageChannelImplementation() {
    var channel = new MessageChannel();

    channel.port1.onmessage = function(event) {
      var handle = event.data;
      runIfPresent(handle);
    };

    registerImmediate = function(handle) {
      channel.port2.postMessage(handle);
    };
  }

  function installReadyStateChangeImplementation() {
    var html = doc.documentElement;

    registerImmediate = function(handle) {
      var script = doc.createElement('script');

      script.onreadystatechange = function () {
        runIfPresent(handle);
        script.onreadystatechange = null;
        html.removeChild(script);
        script = null;
      };

      html.appendChild(script);
    };
  }

  function installSetTimeoutImplementation() {
    registerImmediate = function(handle) {
      setTimeout(runIfPresent, 0, handle);
    };
  }

  if (canUsePostMessage()) {
    // For non-IE10 modern browsers
    installPostMessageImplementation();
  } else if (self.MessageChannel) {
    // For web workers, where supported
    installMessageChannelImplementation();
  } else if (doc && 'onreadystatechange' in doc.createElement('script')) {
    // For IE 68
    installReadyStateChangeImplementation();
  } else {
    // For older browsers
    installSetTimeoutImplementation();
  }

  setImmediate = _setImmediate;
  clearImmediate = _clearImmediate;
})();
}],
[/* 138 */ 'bpkg', '/lib/builtins/process.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * process.js - node process for javascript
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/bpkg
 *
 * Parts of this software are based on defunctzombie/node-process:
 *   Copyright (c) 2013, Roman Shtylman <shtylman@gmail.com>
 *   https://github.com/defunctzombie/node-process
 *
 * (The MIT License)
 *
 * Copyright (c) 2013 Roman Shtylman <shtylman@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/* global BigInt */
/* eslint no-var: "off" */



var process = exports;
var self = global;
var setTimeout = self.setTimeout;
var clearTimeout = self.clearTimeout;
var boot = Number(new Date());
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

/*
 * Helpers
 */

function _array() {
  return [];
}

function _boolean() {
  return false;
}

function _noop() {}

function _number() {
  return 0;
}

function _string() {
  return '';
}

function _this() {
  return this;
}

/*
 * Timers
 */

function cleanUpNextTick() {
  if (!draining || !currentQueue)
    return;

  draining = false;

  if (currentQueue.length > 0)
    queue = currentQueue.concat(queue);
  else
    queueIndex = -1;

  if (queue.length > 0)
    drainQueue();
}

function drainQueue() {
  if (draining)
    return;

  var timeout = setTimeout.call(self, cleanUpNextTick, 0);
  var len = queue.length;

  draining = true;

  while (len > 0) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue)
        currentQueue[queueIndex].run();
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;

  clearTimeout.call(self, timeout);
}

/*
 * Item
 */

function Item(func, array) {
  this.func = func;
  this.array = array;
}

Item.prototype.run = function() {
  this.func.apply(null, this.array);
};

/*
 * Process
 */

process.allowedNodeEnvironmentFlags =
  typeof Set === 'function' ? new Set() : undefined;
process.arch = 'javascript';
process.argv = ['/usr/bin/node'];
process.argv0 = 'node';
process.browser = true;
process.channel = undefined;
process.config = {};
process.connected = undefined;
process.debugPort = 9229;
process.env = { __proto__: null };
process.env.PATH = '/usr/bin';
process.env.HOME = '/';
process.execArgv = [];
process.execPath = '/usr/bin/node';
process.exitCode = undefined;
process.mainModule = null;
process.noDeprecation = false;
process.pid = 1;
process.platform = 'browser';
process.ppid = 1;
process.release = { name: 'browser' };
process.report = {};
process.stdin = null;
process.stdout = null;
process.stderr = null;
process.throwDeprecation = false;
process.title = 'browser';
process.traceDeprecation = false;
process.version = 'v0.0.0';
process.versions = { node: '0.0.0' };

/*
 * Events
 */

process._events = { __proto__: null };
process._eventsCount = 0;
process._maxListeners = 0;

process.addListener = _this;
process.emit = _boolean;
process.eventNames = _array;
process.getMaxListeners = _number;
process.listenerCount = _number;
process.listeners = _array;
process.off = _this;
process.on = _this;
process.once = _this;
process.prependListener = _this;
process.prependOnceListener = _this;
process.removeAllListeners = _this;
process.removeListener = _this;
process.setMaxListeners = _this;
process.rawListeners = _array;

/*
 * Methods
 */

process.abort = function() {
  throw new Error('Process aborted.');
};

process.binding = function(name) {
  throw new Error('process.binding is not supported.');
};

process.chdir = function(directory) {
  throw new Error('process.chdir is not supported.');
};

process.cpuUsage = function(previousValue) {
  return { user: 0, system: 0 };
};

process.cwd = function() {
  return '/';
};

process.dlopen = function(module, filename, flags) {
  throw new Error('process.dlopen is not supported.');
};

process.emitWarning = function(warning, options) {
  var text = 'Warning: ' + warning;

  if (console.warn)
    console.warn(text);
  else if (console.error)
    console.error(text);
  else
    console.log(text);
};

process.exit = function(code) {
  if (code == null)
    code = process.exitCode;

  code >>>= 0;

  throw new Error('Exit code: ' + code + '.');
};

process.getegid = _number;
process.geteuid = _number;
process.getgid = _number;
process.getgroups = _array;
process.getuid = _number;
process.hasUncaughtExceptionCaptureCallback = _boolean;

process.hrtime = function(time) {
  var now = Number(new Date()) - boot;
  var mod, sec, ms, ns;

  if (now < 0) {
    boot = Number(new Date());
    now = 0;
  }

  if (time) {
    sec = time[0];
    ns = time[1];
    ms = sec * 1000 + Math.floor(ns / 1000000);

    now -= ms;

    if (!isFinite(now))
      now = 0;

    if (now < 0)
      now = 0;
  }

  mod = now % 1000;
  sec = (now - mod) / 1000;
  ns = mod * 1000000;

  return [sec, ns];
};

process.hrtime.bigint = function() {
  if (typeof BigInt !== 'function')
    throw new Error('BigInt is unsupported.');

  var now = Number(new Date()) - boot;

  if (now < 0) {
    boot = Number(new Date());
    now = 0;
  }

  return BigInt(now) * BigInt(1000000);
};

process.initgroups = _noop;
process.kill = _noop;

process.memoryUsage = function() {
  return {
    rss: 0,
    heapTotal: 0,
    heapUsed: 0,
    external: 0
  };
};

process.nextTick = function(callback) {
  if (typeof callback !== 'function')
    throw new TypeError('Callback must be a function');

  var args = new Array(arguments.length - 1);
  var i;

  if (arguments.length > 1) {
    for (i = 1; i < arguments.length; i++)
      args[i - 1] = arguments[i];
  }

  queue.push(new Item(callback, args));

  if (queue.length === 1 && !draining)
    setTimeout.call(self, drainQueue, 0);
};

process.report.getReport = _string;
process.report.setOptions = _noop;
process.report.triggerReport = _string;

process.send = undefined;
process.setegid = _noop;
process.seteuid = _noop;
process.setgid = _noop;
process.setgroups = _noop;
process.setuid = _noop;
process.setUncaughtExceptionCaptureCallback = _noop;
process.umask = _number;

process.uptime = function() {
  var now = Number(new Date()) - boot;

  if (now < 0) {
    boot = Number(new Date());
    now = 0;
  }

  return now / 1000;
};
}],
[/* 139 */ 'bpkg', '/lib/builtins/buffer.js', function(exports, require, module, __filename, __dirname, __meta) {
/*!
 * buffer@5.2.1 - Node.js Buffer API, for the browser
 * Copyright (c) 2019, Feross Aboukhadijeh (MIT)
 * https://github.com/feross/buffer
 *
 * License for buffer@5.2.1:
 *
 * The MIT License (MIT)
 *
 * Copyright (c) Feross Aboukhadijeh, and other contributors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * License for base64-js@1.3.0:
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * License for ieee754@1.1.12:
 *
 * Copyright (c) 2008, Fair Oaks Labs, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * * Neither the name of Fair Oaks Labs, Inc. nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

var __node_modules__ = [
[/* 0 */ 'buffer', '/index.js', function(exports, module, __filename, __dirname, __meta) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */


var base64 = __node_require__(1 /* 'base64-js' */)
var ieee754 = __node_require__(2 /* 'ieee754' */)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if ((obj != null && obj._isBuffer === true)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!(a != null && a._isBuffer === true) || !(b != null && b._isBuffer === true)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!(buf != null && buf._isBuffer === true)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if ((string != null && string._isBuffer === true)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!(b != null && b._isBuffer === true)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!(target != null && target._isBuffer === true)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if ((val != null && val._isBuffer === true)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)

  var first = this[offset]
  var last = this[offset + 7]

  var lo = first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24

  var hi = this[++offset] +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    last * 2 ** 24

  return BigInt(lo) + (BigInt(hi) << BigInt(32))
})

Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)

  var first = this[offset]
  var last = this[offset + 7]

  var hi = first * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  var lo = this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last

  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
})

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)

  var first = this[offset]
  var last = this[offset + 7]

  var val = this[offset + 4] +
    this[offset + 5] * 2 ** 8 +
    this[offset + 6] * 2 ** 16 +
    (last << 24) // Overflow

  return (BigInt(val) << BigInt(32)) +
    BigInt(first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24)
})

Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)

  var first = this[offset]
  var last = this[offset + 7]

  var val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  return (BigInt(val) << BigInt(32)) +
    BigInt(this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last)
})

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!(buf != null && buf._isBuffer === true)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIntBI (buf, value, offset, ext, max, min) {
  if (!(buf != null && buf._isBuffer === true)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

function wrtBigUInt64LE (buf, value, offset, noAssert, min, max) {
  offset = offset >>> 0;
  if (!noAssert) checkIntBI(buf, value, offset, 8, max, min)
  var lo = Number(value & BigInt(0xffffffff))
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  var hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  return offset
}

function wrtBigUInt64BE (buf, value, offset, noAssert, min, max) {
  offset = offset >>> 0;
  if (!noAssert) checkIntBI(buf, value, offset, 8, max, min)
  var lo = Number(value & BigInt(0xffffffff))
  buf[offset + 7] = lo
  lo = lo >> 8
  buf[offset + 6] = lo
  lo = lo >> 8
  buf[offset + 5] = lo
  lo = lo >> 8
  buf[offset + 4] = lo
  var hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset + 3] = hi
  hi = hi >> 8
  buf[offset + 2] = hi
  hi = hi >> 8
  buf[offset + 1] = hi
  hi = hi >> 8
  buf[offset] = hi
  return offset + 8
}

Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset, noAssert) {
  return wrtBigUInt64LE(this, value, offset, noAssert, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset, noAssert) {
  return wrtBigUInt64BE(this, value, offset, noAssert, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset, noAssert) {
  return wrtBigUInt64LE(this, value, offset, noAssert, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset, noAssert) {
  return wrtBigUInt64BE(this, value, offset, noAssert, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!(target != null && target._isBuffer === true)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = (val != null && val._isBuffer === true)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Return not function with Error if BigInt not supported
function defineBigIntMethod (fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
}

function BufferBigIntNotDefined () {
  throw new Error('BigInt not supported')
}
}],
[/* 1 */ 'base64-js', '/index.js', function(exports, module, __filename, __dirname, __meta) {

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}
}],
[/* 2 */ 'ieee754', '/index.js', function(exports, module, __filename, __dirname, __meta) {
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}
}]
];

var __node_cache__ = [];

function __node_error__(location) {
  var err = new Error('Cannot find module \'' + location + '\'');
  err.code = 'MODULE_NOT_FOUND';
  throw err;
}

function __node_require__(id) {
  if ((id >>> 0) !== id || id > __node_modules__.length)
    return __node_error__(id);

  while (__node_cache__.length <= id)
    __node_cache__.push(null);

  var cache = __node_cache__[id];

  if (cache)
    return cache.exports;

  var mod = __node_modules__[id];
  var name = mod[0];
  var path = mod[1];
  var func = mod[2];
  var meta;

  var _exports = exports;
  var _module = module;

  if (id !== 0) {
    _exports = {};
    _module = {
      id: '/' + name + path,
      exports: _exports,
      parent: module.parent,
      filename: module.filename,
      loaded: false,
      children: module.children,
      paths: module.paths
    };
  }

  __node_cache__[id] = _module;

  try {
    func.call(_exports, _exports, _module,
              __filename, __dirname, meta);
  } catch (e) {
    __node_cache__[id] = null;
    throw e;
  }

  __node_modules__[id] = null;

  if (id !== 0)
    _module.loaded = true;

  return _module.exports;
}

__node_require__(0);
}]
];

var __browser_cache__ = [];

function __browser_error__(location) {
  var err = new Error('Cannot find module \'' + location + '\'');
  err.code = 'MODULE_NOT_FOUND';
  throw err;
}

function __fake_require__(location) {
  __browser_error__(location);
}

__fake_require__.cache = { __proto__: null };

__fake_require__.extensions = { __proto__: null };

__fake_require__.main = null;

__fake_require__.resolve = __browser_error__;

__fake_require__.resolve.paths = __browser_error__;

function __browser_require__(id, parent) {
  if ((id >>> 0) !== id || id > __browser_modules__.length)
    return __browser_error__(id);

  if (parent != null && !parent.children)
    return __browser_error__(id);

  while (__browser_cache__.length <= id)
    __browser_cache__.push(null);

  var cache = __browser_cache__[id];

  if (cache)
    return cache.exports;

  var mod = __browser_modules__[id];
  var name = mod[0];
  var path = mod[1];
  var func = mod[2];

  var filename = path;
  var dirname = filename.split('/').slice(0, -1).join('/') || '/';
  var meta;

  var _require = __fake_require__;
  var _exports = {};

  var _module = {
    id: '/' + name + path,
    exports: _exports,
    parent: parent,
    filename: filename,
    loaded: false,
    children: [],
    paths: ['/'],
    require: _require
  };

  if (parent)
    parent.children.push(_module);

  if (id === 0)
    _require.main = _module;

  if (id === 0)
    process.mainModule = _module;

  __browser_cache__[id] = _module;

  try {
    func.call(_exports, _exports, _require,
              _module, filename, dirname, meta);
  } catch (e) {
    __browser_cache__[id] = null;
    throw e;
  }

  __browser_modules__[id] = null;

  _module.loaded = true;

  return _module.exports;
}

;(function() {
  var timers = __browser_require__(137, null);

  setTimeout = timers.setTimeout;
  clearTimeout = timers.clearTimeout;
  setInterval = timers.setInterval;
  clearInterval = timers.clearInterval;
  setImmediate = timers.setImmediate;
  clearImmediate = timers.clearImmediate;
})();

process = __browser_require__(138, null);

Buffer = __browser_require__(139, null).Buffer;

return __browser_require__;
})(function() {
  if (typeof window !== 'undefined' && window.Math === Math)
    return window;

  if (typeof self !== 'undefined' && self.Math === Math)
    return self;

  return Function('return this')();
}());

export default __browser_require__(0, null);
